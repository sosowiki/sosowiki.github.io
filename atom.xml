<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SOSOWIKI</title>
  <icon>https://www.gravatar.com/avatar/0add61f863154d82902310b0dd29ec33</icon>
  <subtitle>SOSOWIKI</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://soso.wiki/"/>
  <updated>2024-05-28T08:57:00.739Z</updated>
  <id>http://soso.wiki/</id>
  
  <author>
    <name>SOSOWIKI</name>
    <email>swift@88.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>百融云创面试题</title>
    <link href="http://soso.wiki/%E7%99%BE%E8%9E%8D%E4%BA%91%E5%88%9B%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://soso.wiki/百融云创面试题/</id>
    <published>2024-05-09T12:58:00.000Z</published>
    <updated>2024-05-28T08:57:00.739Z</updated>
    
    <content type="html"><![CDATA[<p>百融云创面试题<br><a id="more"></a></p><p>1.腾讯会议共享屏幕在线编程 <a href="https://leetcode.cn/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/description/" target="_blank" rel="noopener">https://leetcode.cn/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/description/</a><br>2.KVO 原理<br>3.如何调用私有 API？三方库或系统未暴漏的方法<br>4.怎么改一个类的只读属性<br>5.消息机制<br>6.Runloop 流程，用 Runloop 做过什么？卡顿检测，发生卡顿后怎么获取堆栈信息？堆栈信息的原理<br>7.GCD 都用了哪些？网络请求 A 和 B 都回调后，请求 C，如何实现？除了 dispatch_group<br>8.可变数组 NSMutableArray，在头部插入元素，iOS 系统做了什么优化<br>9.Tagged Pointer<br>10.NSString 存储在哪里，引用计数存储哪里？<br>11.dealloc 流程<br>12.避免哈希碰撞的几种方法？<br>13.mach-o 了解吗？存储的方法信息可以无用代码检测？段迁移？<br>14.脚本检测未使用代码原理<br>15.render 渲染流程<br>16.UIView 动画和 CAAnimation 动画有什么联系？<br>17.项目亮点</p><h2 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a>参考答案</h2><h2 id="1-腾讯会议共享屏幕在线编程-https-leetcode-cn-problems-zhan-de-ya-ru-dan-chu-xu-lie-lcof-description"><a href="#1-腾讯会议共享屏幕在线编程-https-leetcode-cn-problems-zhan-de-ya-ru-dan-chu-xu-lie-lcof-description" class="headerlink" title="1.腾讯会议共享屏幕在线编程 https://leetcode.cn/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/description/"></a>1.腾讯会议共享屏幕在线编程 <a href="https://leetcode.cn/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/description/" target="_blank" rel="noopener">https://leetcode.cn/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/description/</a></h2><h2 id="2-KVO-原理工作原理"><a href="#2-KVO-原理工作原理" class="headerlink" title="2.KVO 原理工作原理"></a>2.KVO 原理工作原理</h2><p>KVO 主要依赖于 Objective-C 的动态性和 Runtime 运行时机制。以下是 KVO 的几个核心步骤和原理：</p><h4 id="1-动态子类化"><a href="#1-动态子类化" class="headerlink" title="1. 动态子类化"></a>1. 动态子类化</h4><p>当你第一次给某个对象添加观察者时，Objective-C Runtime 会动态地创建该对象的一个子类。这个子类会重写被观察属性的 setter 方法。</p><p>例如，如果你观察对象 <code>person</code> 的 <code>name</code> 属性：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[person addObserver:<span class="hljs-keyword">self</span> forKeyPath:<span class="hljs-string">@"name"</span> options:<span class="hljs-built_in">NSKeyValueObservingOptionNew</span> context:<span class="hljs-literal">nil</span>];</span><br></pre></td></tr></table></figure><p>Runtime 会创建一个新的类，假设名为 <code>NSKVONotifying_Person</code>，这个类是 <code>Person</code> 类的子类。</p><h4 id="2-重写-setter-方法"><a href="#2-重写-setter-方法" class="headerlink" title="2. 重写 setter 方法"></a>2. 重写 setter 方法</h4><p>在新的子类中，Runtime 会重写被观察属性的 setter 方法。例如，对于 <code>name</code> 属性，其 setter 方法可能如下：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="hljs-keyword">void</span>)setName:(<span class="hljs-built_in">NSString</span> *)name &#123;</span><br><span class="line">    [<span class="hljs-keyword">self</span> willChangeValueForKey:<span class="hljs-string">@"name"</span>];</span><br><span class="line">    [<span class="hljs-keyword">super</span> setName:name];</span><br><span class="line">    [<span class="hljs-keyword">self</span> didChangeValueForKey:<span class="hljs-string">@"name"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>willChangeValueForKey:</code></strong>：通知系统属性即将发生变化。</li><li><strong><code>didChangeValueForKey:</code></strong>：通知系统属性已经发生变化。</li></ul><p>这些方法会触发 KVO 通知机制，向所有观察者发送通知。</p><h4 id="3-注册观察者"><a href="#3-注册观察者" class="headerlink" title="3. 注册观察者"></a>3. 注册观察者</h4><p>当你调用 <code>addObserver:forKeyPath:options:context:</code> 方法时，Runtime 会将观察者注册到一个内部的观察者列表中，这个列表通常是一个哈希表（Hash Table），键是被观察的属性，值是观察者对象。</p><h4 id="4-通知观察者"><a href="#4-通知观察者" class="headerlink" title="4. 通知观察者"></a>4. 通知观察者</h4><p>当属性值发生变化时，重写的 setter 方法会调用 <code>willChangeValueForKey:</code> 和 <code>didChangeValueForKey:</code> 方法，这些方法会触发 KVO 通知机制，向注册的观察者发送通知。观察者会收到 <code>observeValueForKeyPath:ofObject:change:context:</code> 方法的回调。</p><h2 id="3-如何调用私有-API？三方库或系统未暴漏的方法"><a href="#3-如何调用私有-API？三方库或系统未暴漏的方法" class="headerlink" title="3.如何调用私有 API？三方库或系统未暴漏的方法"></a>3.如何调用私有 API？三方库或系统未暴漏的方法</h2><h3 id="1-使用-performSelector-方法"><a href="#1-使用-performSelector-方法" class="headerlink" title="1. 使用 performSelector: 方法"></a>1. 使用 <code>performSelector:</code> 方法</h3><p><code>performSelector:</code> 方法可以动态调用对象的方法，即使这些方法在编译时不可见。</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SEL privateSelector = <span class="hljs-built_in">NSSelectorFromString</span>(<span class="hljs-string">@"privateMethod"</span>);</span><br><span class="line"><span class="hljs-keyword">if</span> ([object respondsToSelector:privateSelector]) &#123;</span><br><span class="line">    [object performSelector:privateSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-使用-Runtime-动态调用"><a href="#2-使用-Runtime-动态调用" class="headerlink" title="2. 使用 Runtime 动态调用"></a>2. 使用 Runtime 动态调用</h3><p>Objective-C 的 Runtime 库提供了一些函数，可以用来动态调用方法。</p><h4 id="示例代码：调用私有方法"><a href="#示例代码：调用私有方法" class="headerlink" title="示例代码：调用私有方法"></a>示例代码：调用私有方法</h4><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">SEL privateSelector = <span class="hljs-built_in">NSSelectorFromString</span>(<span class="hljs-string">@"privateMethod"</span>);</span><br><span class="line"><span class="hljs-keyword">if</span> ([object respondsToSelector:privateSelector]) &#123;</span><br><span class="line">    IMP imp = [object methodForSelector:privateSelector];</span><br><span class="line">    <span class="hljs-keyword">void</span> (*func)(<span class="hljs-keyword">id</span>, SEL) = (<span class="hljs-keyword">void</span> *)imp;</span><br><span class="line">    func(object, privateSelector);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="示例代码：访问私有属性"><a href="#示例代码：访问私有属性" class="headerlink" title="示例代码：访问私有属性"></a>示例代码：访问私有属性</h4><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">Ivar ivar = class_getInstanceVariable([object <span class="hljs-keyword">class</span>], <span class="hljs-string">"_privateProperty"</span>);</span><br><span class="line"><span class="hljs-keyword">id</span> privateValue = object_getIvar(object, ivar);</span><br></pre></td></tr></table></figure><h3 id="3-使用-dlsym-函数"><a href="#3-使用-dlsym-函数" class="headerlink" title="3. 使用 dlsym 函数"></a>3. 使用 <code>dlsym</code> 函数</h3><p>如果你知道私有 API 的符号名称，可以使用 <code>dlsym</code> 函数来获取函数指针，并调用它。</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">void</span> *handle = dlopen(<span class="hljs-literal">NULL</span>, RTLD_LAZY);</span><br><span class="line"><span class="hljs-keyword">if</span> (handle) &#123;</span><br><span class="line">    <span class="hljs-keyword">void</span> (*privateFunction)(<span class="hljs-keyword">void</span>) = dlsym(handle, <span class="hljs-string">"privateFunctionName"</span>);</span><br><span class="line">    <span class="hljs-keyword">if</span> (privateFunction) &#123;</span><br><span class="line">        privateFunction();</span><br><span class="line">    &#125;</span><br><span class="line">    dlclose(handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-怎么改一个类的只读属性"><a href="#4-怎么改一个类的只读属性" class="headerlink" title="4.怎么改一个类的只读属性"></a>4.怎么改一个类的只读属性</h2><h3 id="方法一：通过-KVC-Key-Value-Coding"><a href="#方法一：通过-KVC-Key-Value-Coding" class="headerlink" title="方法一：通过 KVC (Key-Value Coding)"></a>方法一：通过 KVC (Key-Value Coding)</h3><p>Key-Value Coding (KVC) 是一种间接访问对象属性的方法。即使属性是只读的，也可以通过 KVC 修改它的值。</p><p>示例：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">MyClass</span> : <span class="hljs-title">NSObject</span></span></span><br><span class="line"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>, <span class="hljs-keyword">readonly</span>) <span class="hljs-built_in">NSString</span> *readonlyProperty;</span><br><span class="line"><span class="hljs-keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">NSString</span> *_readonlyProperty;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="hljs-keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="hljs-keyword">self</span> = [<span class="hljs-keyword">super</span> init];</span><br><span class="line">    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>) &#123;</span><br><span class="line">        _readonlyProperty = <span class="hljs-string">@"Initial Value"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 修改只读属性</span></span><br><span class="line">MyClass *myObject = [[MyClass alloc] init];</span><br><span class="line"><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"Before: %@"</span>, myObject.readonlyProperty);</span><br><span class="line"></span><br><span class="line">[myObject setValue:<span class="hljs-string">@"New Value"</span> forKey:<span class="hljs-string">@"readonlyProperty"</span>];</span><br><span class="line"><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"After: %@"</span>, myObject.readonlyProperty);</span><br></pre></td></tr></table></figure><h3 id="方法二：使用运行时函数"><a href="#方法二：使用运行时函数" class="headerlink" title="方法二：使用运行时函数"></a>方法二：使用运行时函数</h3><p>在 Objective-C 中，可以使用运行时函数来修改属性的值。</p><p>示例：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">MyClass</span> : <span class="hljs-title">NSObject</span></span></span><br><span class="line"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>, <span class="hljs-keyword">readonly</span>) <span class="hljs-built_in">NSString</span> *readonlyProperty;</span><br><span class="line"><span class="hljs-keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">NSString</span> *_readonlyProperty;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="hljs-keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="hljs-keyword">self</span> = [<span class="hljs-keyword">super</span> init];</span><br><span class="line">    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>) &#123;</span><br><span class="line">        _readonlyProperty = <span class="hljs-string">@"Initial Value"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 修改只读属性</span></span><br><span class="line">MyClass *myObject = [[MyClass alloc] init];</span><br><span class="line"><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"Before: %@"</span>, myObject.readonlyProperty);</span><br><span class="line"></span><br><span class="line">Ivar ivar = class_getInstanceVariable([MyClass <span class="hljs-keyword">class</span>], <span class="hljs-string">"_readonlyProperty"</span>);</span><br><span class="line">object_setIvar(myObject, ivar, <span class="hljs-string">@"New Value"</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"After: %@"</span>, myObject.readonlyProperty);</span><br></pre></td></tr></table></figure><h3 id="方法三：子类化和重写-Getter-方法"><a href="#方法三：子类化和重写-Getter-方法" class="headerlink" title="方法三：子类化和重写 Getter 方法"></a>方法三：子类化和重写 Getter 方法</h3><p>通过创建一个子类并重写只读属性的 getter 方法，可以控制属性的值。</p><p>示例：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">MyClass</span> : <span class="hljs-title">NSObject</span></span></span><br><span class="line"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>, <span class="hljs-keyword">readonly</span>) <span class="hljs-built_in">NSString</span> *readonlyProperty;</span><br><span class="line"><span class="hljs-keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">NSString</span> *_readonlyProperty;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="hljs-keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="hljs-keyword">self</span> = [<span class="hljs-keyword">super</span> init];</span><br><span class="line">    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>) &#123;</span><br><span class="line">        _readonlyProperty = <span class="hljs-string">@"Initial Value"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">MyClassSubclass</span> : <span class="hljs-title">MyClass</span></span></span><br><span class="line"><span class="hljs-keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">MyClassSubclass</span> </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">NSString</span> *_customValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="hljs-built_in">NSString</span> *)readonlyProperty &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> _customValue ? _customValue : [<span class="hljs-keyword">super</span> readonlyProperty];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="hljs-keyword">void</span>)setCustomValue:(<span class="hljs-built_in">NSString</span> *)value &#123;</span><br><span class="line">    _customValue = value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 修改只读属性</span></span><br><span class="line">MyClassSubclass *myObject = [[MyClassSubclass alloc] init];</span><br><span class="line"><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"Before: %@"</span>, myObject.readonlyProperty);</span><br><span class="line"></span><br><span class="line">[myObject setCustomValue:<span class="hljs-string">@"New Value"</span>];</span><br><span class="line"><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"After: %@"</span>, myObject.readonlyProperty);</span><br></pre></td></tr></table></figure><h2 id="5-消息机制"><a href="#5-消息机制" class="headerlink" title="5.消息机制"></a>5.消息机制</h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><ul><li><strong>消息（Message）</strong>：在 Objective-C 中，方法调用被称为“发送消息”。发送消息的语法是 <code>[receiver message]</code>。</li><li><strong>接收者（Receiver）</strong>：接收并处理消息的对象。</li><li><strong>选择器（Selector）</strong>：表示方法名称的一个数据类型，类型为 <code>SEL</code>。选择器是方法的唯一标识符。</li></ul><h3 id="2-消息发送流程"><a href="#2-消息发送流程" class="headerlink" title="2. 消息发送流程"></a>2. 消息发送流程</h3><p>当向一个对象发送消息时，Objective-C 的运行时系统会进行一系列步骤来查找并调用相应的方法。以下是消息发送的基本流程：</p><ol><li><strong>消息发送</strong>：当代码中调用 <code>[object message]</code> 时，编译器将其转换为 <code>objc_msgSend</code> 函数调用。</li><li><strong>查找方法</strong>：<code>objc_msgSend</code> 函数会根据消息的选择器（<code>SEL</code>）在对象的类及其父类的方法列表中查找对应的方法实现。</li><li><strong>调用方法</strong>：找到方法实现后，<code>objc_msgSend</code> 函数会调用该方法。如果没有找到方法实现，则会触发消息转发机制（Message Forwarding）。</li></ol><h3 id="3-objc-msgSend-函数"><a href="#3-objc-msgSend-函数" class="headerlink" title="3. objc_msgSend 函数"></a>3. <code>objc_msgSend</code> 函数</h3><p><code>objc_msgSend</code> 是 Objective-C 运行时系统的核心函数之一，负责消息的分发。其原型如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void objc_msgSend(id self, SEL _cmd, ...);</span><br></pre></td></tr></table></figure><ul><li><strong><code>self</code></strong>：消息的接收者。</li><li><strong><code>_cmd</code></strong>：消息的选择器。</li><li><strong>可变参数</strong>：方法的参数。</li></ul><h3 id="4-消息转发机制"><a href="#4-消息转发机制" class="headerlink" title="4. 消息转发机制"></a>4. 消息转发机制</h3><p>当 <code>objc_msgSend</code> 无法在类的方法列表中找到与选择器匹配的方法时，会触发消息转发机制。消息转发机制包括以下几个步骤：</p><h4 id="4-1-动态方法解析"><a href="#4-1-动态方法解析" class="headerlink" title="4.1 动态方法解析"></a>4.1 动态方法解析</h4><p>首先，运行时系统会尝试动态方法解析，通过调用类的 <code>+resolveInstanceMethod:</code> 或 <code>+resolveClassMethod:</code> 方法来添加方法实现。如果方法实现被动态添加，消息发送会重新开始。</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="hljs-built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (sel == <span class="hljs-keyword">@selector</span>(myMethod)) &#123;</span><br><span class="line">        class_addMethod([<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>], sel, (IMP)myMethodIMP, <span class="hljs-string">"v@:"</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-快速转发"><a href="#4-2-快速转发" class="headerlink" title="4.2 快速转发"></a>4.2 快速转发</h4><p>如果动态方法解析未能添加方法实现，运行时系统会调用 <code>-forwardingTargetForSelector:</code> 方法。这个方法允许将消息转发给另一个对象。</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="hljs-keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (aSelector == <span class="hljs-keyword">@selector</span>(myMethod)) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> someOtherObject;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-常规转发"><a href="#4-3-常规转发" class="headerlink" title="4.3 常规转发"></a>4.3 常规转发</h4><p>如果快速转发也未能处理消息，运行时系统会调用 <code>-methodSignatureForSelector:</code> 和 <code>-forwardInvocation:</code> 方法。首先，通过 <code>-methodSignatureForSelector:</code> 获取方法签名，然后通过 <code>-forwardInvocation:</code> 进行消息转发。</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="hljs-built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (aSelector == <span class="hljs-keyword">@selector</span>(myMethod)) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> [<span class="hljs-built_in">NSMethodSignature</span> signatureWithObjCTypes:<span class="hljs-string">"v@:"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">super</span> methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="hljs-keyword">void</span>)forwardInvocation:(<span class="hljs-built_in">NSInvocation</span> *)anInvocation &#123;</span><br><span class="line">    SEL sel = [anInvocation selector];</span><br><span class="line">    <span class="hljs-keyword">if</span> ([someOtherObject respondsToSelector:sel]) &#123;</span><br><span class="line">        [anInvocation invokeWithTarget:someOtherObject];</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        [<span class="hljs-keyword">super</span> forwardInvocation:anInvocation];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-消息缓存"><a href="#5-消息缓存" class="headerlink" title="5. 消息缓存"></a>5. 消息缓存</h3><p>为了提高消息发送的性能，Objective-C 运行时系统使用方法缓存（Method Caching）。当一个方法第一次被调用时，其实现会被缓存起来，下次调用相同的方法时，可以直接从缓存中获取，而不需要重新查找。</p><h2 id="6-Runloop-流程，用-Runloop-做过什么？卡顿检测，发生卡顿后怎么获取堆栈信息？堆栈信息的原理"><a href="#6-Runloop-流程，用-Runloop-做过什么？卡顿检测，发生卡顿后怎么获取堆栈信息？堆栈信息的原理" class="headerlink" title="6.Runloop 流程，用 Runloop 做过什么？卡顿检测，发生卡顿后怎么获取堆栈信息？堆栈信息的原理"></a>6.Runloop 流程，用 Runloop 做过什么？卡顿检测，发生卡顿后怎么获取堆栈信息？堆栈信息的原理</h2><h3 id="Runloop-基本概念"><a href="#Runloop-基本概念" class="headerlink" title="Runloop 基本概念"></a>Runloop 基本概念</h3><p>RunLoop 是一个事件处理循环，用来调度和处理任务。它可以在没有任务时使线程进入休眠状态，从而节省资源；有任务时则立即唤醒线程处理任务。RunLoop 实质上是一个对象，这个对象管理着其需要处理的事件和消息，并提供一个入口函数来执行这个事件处理循环。</p><h3 id="Runloop-的基本流程"><a href="#Runloop-的基本流程" class="headerlink" title="Runloop 的基本流程"></a>Runloop 的基本流程</h3><p>RunLoop 的基本流程可以概括为以下几个步骤：</p><ol><li><strong>进入循环</strong>：调用 <code>CFRunLoopRun</code> 或者 <code>-[NSRunLoop run]</code> 方法。</li><li><strong>通知观察者</strong>：通知即将进入 RunLoop 事件处理循环。</li><li><strong>检查 Timer</strong>：检查是否有定时器（Timer）需要处理。</li><li><strong>处理输入源</strong>：处理输入源（Input Source），比如用户触摸事件，UI事件等。</li><li><strong>通知观察者</strong>：通知即将进入休眠。</li><li><strong>休眠</strong>：如果没有事件需要处理，线程进入休眠状态，等待事件发生。</li><li><strong>唤醒</strong>：收到外部事件（如 Timer 到时间、输入源事件）唤醒线程。</li><li><strong>通知观察者</strong>：通知即将处理事件。</li><li><strong>处理事件</strong>：处理 Timer 或输入源事件。</li><li><strong>通知观察者</strong>：通知事件已处理完成。</li><li><strong>重复或退出</strong>：重复上述步骤，或根据特定条件退出循环。</li></ol><h3 id="RunLoop-在-iOS-中的应用"><a href="#RunLoop-在-iOS-中的应用" class="headerlink" title="RunLoop 在 iOS 中的应用"></a>RunLoop 在 iOS 中的应用</h3><h4 id="1-保持线程活跃"><a href="#1-保持线程活跃" class="headerlink" title="1. 保持线程活跃"></a>1. <strong>保持线程活跃</strong></h4><p>RunLoop 的一个典型应用是保持线程活跃。默认情况下，子线程在任务完成后会立即退出。通过 RunLoop，可以让子线程在没有任务时处于休眠状态，但不会退出，等待新的任务到来。</p><p>示例代码：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="hljs-keyword">void</span>)startThread &#123;</span><br><span class="line">    <span class="hljs-built_in">NSThread</span> *thread = [[<span class="hljs-built_in">NSThread</span> alloc] initWithTarget:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(threadEntryPoint) object:<span class="hljs-literal">nil</span>];</span><br><span class="line">    [thread start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="hljs-keyword">void</span>)threadEntryPoint &#123;</span><br><span class="line">    <span class="hljs-keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        [[<span class="hljs-built_in">NSThread</span> currentThread] setName:<span class="hljs-string">@"MyThread"</span>];</span><br><span class="line">        <span class="hljs-built_in">NSRunLoop</span> *runLoop = [<span class="hljs-built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line">        [runLoop addPort:[<span class="hljs-built_in">NSMachPort</span> port] forMode:<span class="hljs-built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">        [runLoop run]; <span class="hljs-comment">// 进入 RunLoop</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-处理定时任务"><a href="#2-处理定时任务" class="headerlink" title="2. 处理定时任务"></a>2. <strong>处理定时任务</strong></h4><p>RunLoop 可以用来处理定时任务，比如定时器。通过将 <code>NSTimer</code> 添加到 RunLoop，可以在指定的时间间隔触发任务。</p><p>示例代码：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="hljs-keyword">void</span>)scheduleTimer &#123;</span><br><span class="line">    <span class="hljs-built_in">NSTimer</span> *timer = [<span class="hljs-built_in">NSTimer</span> timerWithTimeInterval:<span class="hljs-number">1.0</span> target:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(timerFired:) userInfo:<span class="hljs-literal">nil</span> repeats:<span class="hljs-literal">YES</span>];</span><br><span class="line">    [[<span class="hljs-built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="hljs-built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="hljs-keyword">void</span>)timerFired:(<span class="hljs-built_in">NSTimer</span> *)timer &#123;</span><br><span class="line">    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"Timer fired!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-处理网络请求"><a href="#3-处理网络请求" class="headerlink" title="3. 处理网络请求"></a>3. <strong>处理网络请求</strong></h4><p>在处理网络请求时，可以使用 RunLoop 来保持线程活跃，等待网络请求完成。<code>NSURLConnection</code> 和 <code>NSURLSession</code> 都使用 RunLoop 来处理网络事件。</p><h4 id="4-处理输入源事件"><a href="#4-处理输入源事件" class="headerlink" title="4. 处理输入源事件"></a>4. <strong>处理输入源事件</strong></h4><p>RunLoop 可以用来处理输入源事件，比如用户触摸事件、UI事件等。</p><h2 id="7-GCD-都用了哪些？网络请求-A-和-B-都回调后，请求-C，如何实现？除了-dispatch-group"><a href="#7-GCD-都用了哪些？网络请求-A-和-B-都回调后，请求-C，如何实现？除了-dispatch-group" class="headerlink" title="7.GCD 都用了哪些？网络请求 A 和 B 都回调后，请求 C，如何实现？除了 dispatch_group"></a>7.GCD 都用了哪些？网络请求 A 和 B 都回调后，请求 C，如何实现？除了 dispatch_group</h2><p>Grand Central Dispatch (GCD) 是苹果公司推出的一种用于并发编程的技术，旨在优化多核设备上的代码执行。GCD 提供了一种简单易用的 API 来管理并发任务，并且能够自动利用系统资源进行优化。以下是一些常见的 GCD 使用场景：</p><h3 id="1-异步任务"><a href="#1-异步任务" class="headerlink" title="1. 异步任务"></a>1. <strong>异步任务</strong></h3><p>GCD 的一个主要用途就是在后台执行耗时任务，从而避免阻塞主线程，提高应用的响应速度。</p><p>示例代码：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>), ^&#123;</span><br><span class="line">    <span class="hljs-comment">// 执行耗时任务</span></span><br><span class="line">    <span class="hljs-built_in">NSData</span> *data = [<span class="hljs-keyword">self</span> fetchDataFromServer];</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// 回到主线程更新 UI</span></span><br><span class="line">    <span class="hljs-built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [<span class="hljs-keyword">self</span> updateUIWithData:data];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="2-并行任务"><a href="#2-并行任务" class="headerlink" title="2. 并行任务"></a>2. <strong>并行任务</strong></h3><p>GCD 可以轻松地创建并行任务，从而充分利用多核处理器的计算能力。</p><p>示例代码：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>);</span><br><span class="line"><span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    [<span class="hljs-keyword">self</span> performTask1];</span><br><span class="line">&#125;);</span><br><span class="line"><span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    [<span class="hljs-keyword">self</span> performTask2];</span><br><span class="line">&#125;);</span><br><span class="line"><span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    [<span class="hljs-keyword">self</span> performTask3];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="3-同步任务"><a href="#3-同步任务" class="headerlink" title="3. 同步任务"></a>3. <strong>同步任务</strong></h3><p>尽管异步任务更常见，有时也需要同步任务来确保任务按顺序执行。</p><p>示例代码：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">dispatch_sync</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>), ^&#123;</span><br><span class="line">    [<span class="hljs-keyword">self</span> performSynchronousTask];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="4-延迟执行"><a href="#4-延迟执行" class="headerlink" title="4. 延迟执行"></a>4. <strong>延迟执行</strong></h3><p>GCD 提供了简洁的 API 来延迟执行任务。</p><p>示例代码：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dispatch_time_t delay = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="hljs-number">5.0</span> * <span class="hljs-built_in">NSEC_PER_SEC</span>));</span><br><span class="line">dispatch_after(delay, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    [<span class="hljs-keyword">self</span> performDelayedTask];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="5-一次性代码"><a href="#5-一次性代码" class="headerlink" title="5. 一次性代码"></a>5. <strong>一次性代码</strong></h3><p>有时我们需要确保某段代码只执行一次，这时候可以使用 <code>dispatch_once</code>。</p><p>示例代码：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-built_in">dispatch_once_t</span> onceToken;</span><br><span class="line"><span class="hljs-built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">    [<span class="hljs-keyword">self</span> initializeOnce];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="6-调度组"><a href="#6-调度组" class="headerlink" title="6. 调度组"></a>6. <strong>调度组</strong></h3><p>调度组可以用来监控一组任务的完成状态，通常用于需要等待多项任务全部完成后才能继续下一步操作的场景。</p><p>示例代码：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line"><span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>);</span><br><span class="line"></span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">    [<span class="hljs-keyword">self</span> performTask1];</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">    [<span class="hljs-keyword">self</span> performTask2];</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">    [<span class="hljs-keyword">self</span> performTask3];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    [<span class="hljs-keyword">self</span> allTasksCompleted];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="7-信号量"><a href="#7-信号量" class="headerlink" title="7. 信号量"></a>7. <strong>信号量</strong></h3><p>信号量可以用来控制并发访问资源的数量，适用于需要限制并发任务数量的场景。</p><p>示例代码：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="hljs-number">2</span>); <span class="hljs-comment">// 允许同时执行两个并发任务</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;</span><br><span class="line">    <span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>), ^&#123;</span><br><span class="line">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment">// 执行任务</span></span><br><span class="line">        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"Task %d started"</span>, i);</span><br><span class="line">        sleep(<span class="hljs-number">2</span>); <span class="hljs-comment">// 模拟耗时任务</span></span><br><span class="line">        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"Task %d completed"</span>, i);</span><br><span class="line">        </span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-Barrier-Block"><a href="#8-Barrier-Block" class="headerlink" title="8. Barrier Block"></a>8. <strong>Barrier Block</strong></h3><p>Barrier Block 用于在并发队列中插入一个障碍，确保在障碍前提交的所有任务执行完成后，才执行障碍后的任务。</p><p>示例代码：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="hljs-string">"com.example.myqueue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    [<span class="hljs-keyword">self</span> performReadTask1];</span><br><span class="line">&#125;);</span><br><span class="line"><span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    [<span class="hljs-keyword">self</span> performReadTask2];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">    [<span class="hljs-keyword">self</span> performWriteTask];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    [<span class="hljs-keyword">self</span> performReadTask3];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="9-Dispatch-Source"><a href="#9-Dispatch-Source" class="headerlink" title="9. Dispatch Source"></a>9. <strong>Dispatch Source</strong></h3><p>Dispatch Source 是一种非常强大的工具，可以用来处理各种系统事件，如文件变化、定时器、信号等。</p><p>示例代码（定时器）：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, dispatch_get_main_queue());</span><br><span class="line">dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, <span class="hljs-number">1.0</span> * <span class="hljs-built_in">NSEC_PER_SEC</span>, <span class="hljs-number">0.1</span> * <span class="hljs-built_in">NSEC_PER_SEC</span>);</span><br><span class="line">dispatch_source_set_event_handler(timer, ^&#123;</span><br><span class="line">    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"Timer fired"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_resume(timer);</span><br></pre></td></tr></table></figure><h3 id="10-Dispatch-Work-Item"><a href="#10-Dispatch-Work-Item" class="headerlink" title="10. Dispatch Work Item"></a>10. <strong>Dispatch Work Item</strong></h3><p>使用 <code>dispatch_block_t</code> 创建可取消的工作项。</p><p>示例代码：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>);</span><br><span class="line">dispatch_block_t workItem = dispatch_block_create(<span class="hljs-number">0</span>, ^&#123;</span><br><span class="line">    <span class="hljs-comment">// 执行任务</span></span><br><span class="line">    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"Work item executed"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">dispatch_async</span>(queue, workItem);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 取消工作项</span></span><br><span class="line">dispatch_block_cancel(workItem);</span><br></pre></td></tr></table></figure><p>在 iOS 开发中，有时候需要等待多个网络请求完成后再进行进一步操作，比如发起新的网络请求。为了实现这种需求，可以使用多种方法，包括 GCD（Grand Central Dispatch）、<code>NSOperationQueue</code> 和第三方库如 <code>PromiseKit</code> 或 <code>Combine</code>。</p><h3 id="方法一：使用-GCD-Grand-Central-Dispatch"><a href="#方法一：使用-GCD-Grand-Central-Dispatch" class="headerlink" title="方法一：使用 GCD (Grand Central Dispatch)"></a>方法一：使用 GCD (Grand Central Dispatch)</h3><p>GCD 提供了一种简单的方法来同步多个异步任务。可以使用 <code>dispatch_group</code> 来实现等待多个任务完成后执行下一步操作。</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 开始请求A</span></span><br><span class="line">dispatch_group_enter(group);</span><br><span class="line">[<span class="hljs-keyword">self</span> performRequestAWithCompletion:^(<span class="hljs-keyword">id</span> response, <span class="hljs-built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="hljs-comment">// 处理请求A的响应</span></span><br><span class="line">    dispatch_group_leave(group);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 开始请求B</span></span><br><span class="line">dispatch_group_enter(group);</span><br><span class="line">[<span class="hljs-keyword">self</span> performRequestBWithCompletion:^(<span class="hljs-keyword">id</span> response, <span class="hljs-built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="hljs-comment">// 处理请求B的响应</span></span><br><span class="line">    dispatch_group_leave(group);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 当请求A和请求B都完成后，执行请求C</span></span><br><span class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    [<span class="hljs-keyword">self</span> performRequestCWithCompletion:^(<span class="hljs-keyword">id</span> response, <span class="hljs-built_in">NSError</span> *error) &#123;</span><br><span class="line">        <span class="hljs-comment">// 处理请求C的响应</span></span><br><span class="line">    &#125;];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="方法二：使用-NSOperationQueue"><a href="#方法二：使用-NSOperationQueue" class="headerlink" title="方法二：使用 NSOperationQueue"></a>方法二：使用 <code>NSOperationQueue</code></h3><p><code>NSOperationQueue</code> 提供了一种更为面向对象的方法来管理异步任务的依赖关系。</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">NSOperationQueue</span> *queue = [[<span class="hljs-built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">queue.maxConcurrentOperationCount = <span class="hljs-number">2</span>; <span class="hljs-comment">// 设置最大并发数</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">NSBlockOperation</span> *operationA = [<span class="hljs-built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">    [<span class="hljs-keyword">self</span> performRequestAWithCompletion:^(<span class="hljs-keyword">id</span> response, <span class="hljs-built_in">NSError</span> *error) &#123;</span><br><span class="line">        <span class="hljs-comment">// 处理请求A的响应</span></span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">NSBlockOperation</span> *operationB = [<span class="hljs-built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">    [<span class="hljs-keyword">self</span> performRequestBWithCompletion:^(<span class="hljs-keyword">id</span> response, <span class="hljs-built_in">NSError</span> *error) &#123;</span><br><span class="line">        <span class="hljs-comment">// 处理请求B的响应</span></span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">NSBlockOperation</span> *operationC = [<span class="hljs-built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">    [<span class="hljs-keyword">self</span> performRequestCWithCompletion:^(<span class="hljs-keyword">id</span> response, <span class="hljs-built_in">NSError</span> *error) &#123;</span><br><span class="line">        <span class="hljs-comment">// 处理请求C的响应</span></span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 设置依赖关系</span></span><br><span class="line">[operationC addDependency:operationA];</span><br><span class="line">[operationC addDependency:operationB];</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 将操作添加到队列</span></span><br><span class="line">[queue addOperation:operationA];</span><br><span class="line">[queue addOperation:operationB];</span><br><span class="line">[queue addOperation:operationC];</span><br></pre></td></tr></table></figure><h3 id="方法三：使用第三方库-PromiseKit"><a href="#方法三：使用第三方库-PromiseKit" class="headerlink" title="方法三：使用第三方库 PromiseKit"></a>方法三：使用第三方库 PromiseKit</h3><p><code>PromiseKit</code> 提供了一种现代的、链式的方式来处理异步操作。</p><p>首先，确保你已经安装了 <code>PromiseKit</code>。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod &apos;PromiseKit&apos;, &apos;~&gt; 6.0&apos;</span><br></pre></td></tr></table></figure><p>然后，你可以使用类似以下的代码来实现：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;PromiseKit/PromiseKit.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">- (AnyPromise *)performRequestA &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> [AnyPromise promiseWithResolverBlock:^(PMKResolver resolve) &#123;</span><br><span class="line">        [<span class="hljs-keyword">self</span> performRequestAWithCompletion:^(<span class="hljs-keyword">id</span> response, <span class="hljs-built_in">NSError</span> *error) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (error) &#123;</span><br><span class="line">                resolve(error);</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                resolve(response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (AnyPromise *)performRequestB &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> [AnyPromise promiseWithResolverBlock:^(PMKResolver resolve) &#123;</span><br><span class="line">        [<span class="hljs-keyword">self</span> performRequestBWithCompletion:^(<span class="hljs-keyword">id</span> response, <span class="hljs-built_in">NSError</span> *error) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (error) &#123;</span><br><span class="line">                resolve(error);</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                resolve(response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (AnyPromise *)performRequestC &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> [AnyPromise promiseWithResolverBlock:^(PMKResolver resolve) &#123;</span><br><span class="line">        [<span class="hljs-keyword">self</span> performRequestCWithCompletion:^(<span class="hljs-keyword">id</span> response, <span class="hljs-built_in">NSError</span> *error) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (error) &#123;</span><br><span class="line">                resolve(error);</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                resolve(response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="hljs-keyword">void</span>)makeRequests &#123;</span><br><span class="line">    [When(@[[<span class="hljs-keyword">self</span> performRequestA], [<span class="hljs-keyword">self</span> performRequestB]]) then:^<span class="hljs-keyword">id</span>(<span class="hljs-keyword">id</span> results) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> [<span class="hljs-keyword">self</span> performRequestC];</span><br><span class="line">    &#125;].catch(^(<span class="hljs-built_in">NSError</span> *error) &#123;</span><br><span class="line">        <span class="hljs-comment">// 处理错误</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法四：使用-Combine（适用于-iOS-13-及以上）"><a href="#方法四：使用-Combine（适用于-iOS-13-及以上）" class="headerlink" title="方法四：使用 Combine（适用于 iOS 13 及以上）"></a>方法四：使用 Combine（适用于 iOS 13 及以上）</h3><p>如果你在使用 iOS 13 及以上版本，可以使用 Combine 框架来处理异步任务。</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">import Combine</span><br><span class="line"></span><br><span class="line">func performRequestA() -&gt; Future&lt;Data, Error&gt; &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> Future &#123; promise <span class="hljs-keyword">in</span></span><br><span class="line">        <span class="hljs-comment">// 模拟网络请求A</span></span><br><span class="line">        <span class="hljs-keyword">self</span>.performRequestA &#123; (data, error) <span class="hljs-keyword">in</span></span><br><span class="line">            <span class="hljs-keyword">if</span> let error = error &#123;</span><br><span class="line">                promise(.failure(error))</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                promise(.success(data))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func performRequestB() -&gt; Future&lt;Data, Error&gt; &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> Future &#123; promise <span class="hljs-keyword">in</span></span><br><span class="line">        <span class="hljs-comment">// 模拟网络请求B</span></span><br><span class="line">        <span class="hljs-keyword">self</span>.performRequestB &#123; (data, error) <span class="hljs-keyword">in</span></span><br><span class="line">            <span class="hljs-keyword">if</span> let error = error &#123;</span><br><span class="line">                promise(.failure(error))</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                promise(.success(data))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func performRequestC() -&gt; Future&lt;Data, Error&gt; &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> Future &#123; promise <span class="hljs-keyword">in</span></span><br><span class="line">        <span class="hljs-comment">// 模拟网络请求C</span></span><br><span class="line">        <span class="hljs-keyword">self</span>.performRequestC &#123; (data, error) <span class="hljs-keyword">in</span></span><br><span class="line">            <span class="hljs-keyword">if</span> let error = error &#123;</span><br><span class="line">                promise(.failure(error))</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                promise(.success(data))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let cancellable = Publishers.Zip(performRequestA(), performRequestB())</span><br><span class="line">    .flatMap &#123; _ <span class="hljs-keyword">in</span></span><br><span class="line">        <span class="hljs-keyword">return</span> performRequestC()</span><br><span class="line">    &#125;</span><br><span class="line">    .sink(receiveCompletion: &#123; completion <span class="hljs-keyword">in</span></span><br><span class="line">        <span class="hljs-keyword">switch</span> completion &#123;</span><br><span class="line">        <span class="hljs-keyword">case</span> .failure(let error):</span><br><span class="line">            print(<span class="hljs-string">"Error: \(error)"</span>)</span><br><span class="line">        <span class="hljs-keyword">case</span> .finished:</span><br><span class="line">            print(<span class="hljs-string">"All requests finished successfully"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, receiveValue: &#123; data <span class="hljs-keyword">in</span></span><br><span class="line">        print(<span class="hljs-string">"Received data: \(data)"</span>)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>GCD</strong>: 适用于需要轻量级并发管理的场景。</li><li><strong>NSOperationQueue</strong>: 提供了更为面向对象的并发管理方式，适用于复杂任务依赖关系的场景。</li><li><strong>PromiseKit</strong>: 提供了一种现代的链式异步处理方式，代码更为简洁。</li><li><strong>Combine</strong>: 适用于 iOS 13 及以上版本，提供了响应式编程的方式来处理异步任务。</li></ul><p>选择哪种方法取决于你的项目需求和个人偏好。希望这些示例能够帮助你实现网络请求 A 和 B 都回调后再请求 C 的需求。</p><h2 id="8-可变数组-NSMutableArray，在头部插入元素，iOS-系统做了什么优化"><a href="#8-可变数组-NSMutableArray，在头部插入元素，iOS-系统做了什么优化" class="headerlink" title="8.可变数组 NSMutableArray，在头部插入元素，iOS 系统做了什么优化"></a>8.可变数组 NSMutableArray，在头部插入元素，iOS 系统做了什么优化</h2><p>在 iOS 系统中，<code>NSMutableArray</code> 是一个动态数组，它在插入和删除元素时会进行一些优化，但具体的优化细节是由底层实现决定的，这些实现细节通常是私有的，Apple 并未公开详细的内部实现。不过，我们可以推测和总结一些常见的优化策略，这些策略可能会在 <code>NSMutableArray</code> 中使用。</p><h3 id="1-内存预分配和扩展"><a href="#1-内存预分配和扩展" class="headerlink" title="1. 内存预分配和扩展"></a>1. 内存预分配和扩展</h3><p><code>NSMutableArray</code> 会预先分配内存来容纳多个元素，以减少频繁的内存分配操作。当数组需要扩展容量时，它可能会一次性分配比当前需求更多的内存空间，以备将来使用。这种策略可以减少内存分配和释放的频率，提高性能。</p><h3 id="2-元素移动优化"><a href="#2-元素移动优化" class="headerlink" title="2. 元素移动优化"></a>2. 元素移动优化</h3><p>在数组头部插入元素时，所有现有元素都需要向后移动一个位置。为了减少内存拷贝的开销，系统可能会使用高效的内存拷贝函数（如 <code>memmove</code>）来移动元素。<code>memmove</code> 函数在处理重叠内存区域时比 <code>memcpy</code> 更安全和高效。</p><h3 id="3-数据结构优化"><a href="#3-数据结构优化" class="headerlink" title="3. 数据结构优化"></a>3. 数据结构优化</h3><p>尽管 <code>NSMutableArray</code> 主要使用动态数组来实现，但底层可能会结合使用其他数据结构（如链表）来优化特定操作的性能。例如，为了优化头部插入操作，系统可能会在特定情况下使用双向链表或者其他更适合插入操作的结构。</p><h3 id="4-缓存局部性"><a href="#4-缓存局部性" class="headerlink" title="4. 缓存局部性"></a>4. 缓存局部性</h3><p><code>NSMutableArray</code> 可能会利用缓存局部性来提高性能。通过将相邻的元素存储在接近的内存地址上，可以提高缓存命中率，从而提高内存访问速度。</p><h3 id="5-并发处理优化"><a href="#5-并发处理优化" class="headerlink" title="5. 并发处理优化"></a>5. 并发处理优化</h3><p>虽然 <code>NSMutableArray</code> 本身不是线程安全的，但在一些多线程环境中，系统可能会使用锁、原子操作或者其他并发控制机制来优化并发访问的性能。</p><p>总的来说，虽然我们无法确切知道 <code>NSMutableArray</code> 的内部优化细节，但可以推测它会采用一些常见的优化策略来提升性能。了解这些优化策略有助于我们在开发过程中做出更好的性能优化决策。</p><h2 id="9-Tagged-Pointer"><a href="#9-Tagged-Pointer" class="headerlink" title="9.Tagged Pointer"></a>9.Tagged Pointer</h2><h3 id="Tagged-Pointer-的基本原理"><a href="#Tagged-Pointer-的基本原理" class="headerlink" title="Tagged Pointer 的基本原理"></a>Tagged Pointer 的基本原理</h3><p><code>Tagged Pointer</code> 的基本原理是利用指针的高位位元来存储数据，而不是使用这些位元来存储内存地址。具体来说：</p><ul><li>在 64 位系统中，指针有 64 位，其中通常只有低 48 位用于存储内存地址，高 16 位未被使用。</li><li><code>Tagged Pointer</code> 技术利用这些未使用的高位位元来存储数据。</li></ul><h3 id="如何识别-Tagged-Pointer"><a href="#如何识别-Tagged-Pointer" class="headerlink" title="如何识别 Tagged Pointer"></a>如何识别 Tagged Pointer</h3><p>在 Objective-C 中，<code>Tagged Pointer</code> 使用最高位（最高位为 1）来标识是否是 <code>Tagged Pointer</code>。例如：</p><ul><li><code>0x8000000000000000</code>：最高位为 1，表示这是一个 <code>Tagged Pointer</code>。</li><li><code>0x0000000000000000</code>：最高位为 0，表示这是一个普通的指针。</li></ul><h3 id="Tagged-Pointer-的数据存储"><a href="#Tagged-Pointer-的数据存储" class="headerlink" title="Tagged Pointer 的数据存储"></a>Tagged Pointer 的数据存储</h3><p><code>Tagged Pointer</code> 可以存储多种类型的数据，包括：</p><ul><li><strong>小整数</strong>：直接在指针中存储整数值。</li><li><strong>小浮点数</strong>：直接在指针中存储浮点数值。</li><li><strong>小字符串</strong>：直接在指针中存储字符串数据。</li></ul><h2 id="10-NSString-存储在哪里，引用计数存储哪里？"><a href="#10-NSString-存储在哪里，引用计数存储哪里？" class="headerlink" title="10.NSString 存储在哪里，引用计数存储哪里？"></a>10.NSString 存储在哪里，引用计数存储哪里？</h2><h3 id="1-常量字符串"><a href="#1-常量字符串" class="headerlink" title="1. 常量字符串"></a>1. 常量字符串</h3><p>常量字符串是指在代码中直接使用的字符串字面量，例如：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">NSString</span> *str = <span class="hljs-string">@"Hello, World!"</span>;</span><br></pre></td></tr></table></figure><p>这些字符串字面量通常会被存储在程序的只读数据段（Read-Only Data Segment）中。这意味着它们在编译时已经确定，并且在程序运行时不会被修改。它们的内存分配通常是由编译器在编译时完成的。</p><h3 id="2-动态字符串"><a href="#2-动态字符串" class="headerlink" title="2. 动态字符串"></a>2. 动态字符串</h3><p>动态字符串是指在程序运行时生成或拼接的字符串，例如：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">NSString</span> *str1 = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@"Hello, %@"</span>, <span class="hljs-string">@"World"</span>];</span><br><span class="line"><span class="hljs-built_in">NSString</span> *str2 = [str1 mutableCopy];</span><br></pre></td></tr></table></figure><p>这些字符串是在程序运行时动态分配内存的。它们通常存储在堆（Heap）中，并由 <code>NSString</code> 和 <code>NSMutableString</code> 的内部实现来管理。</p><h3 id="3-内存管理"><a href="#3-内存管理" class="headerlink" title="3. 内存管理"></a>3. 内存管理</h3><p>在 Objective-C 中，内存管理主要通过引用计数（Reference Counting）来完成。<code>NSString</code> 对象也遵循这一规则：</p><ul><li><strong>ARC（Automatic Reference Counting）</strong>: 在使用 ARC 的情况下，编译器会自动插入内存管理代码，负责增加和减少引用计数。</li><li><strong>手动内存管理（MRC）</strong>: 在不使用 ARC 的情况下，开发者需要手动管理内存，通过 <code>retain</code>、<code>release</code> 和 <code>autorelease</code> 方法来管理引用计数。</li></ul><h3 id="4-内部实现"><a href="#4-内部实现" class="headerlink" title="4. 内部实现"></a>4. 内部实现</h3><p><code>NSString</code> 是一个抽象类，其具体实现有多个子类，这些子类优化了不同类型的字符串存储和操作。常见的子类包括：</p><ul><li><strong><code>__NSCFConstantString</code></strong>: 用于存储常量字符串。</li><li><strong><code>__NSCFString</code></strong>: 一般用于动态创建的不可变字符串。</li><li><strong><code>NSMutableString</code></strong>: 用于可变字符串。</li></ul><p>在实际运行时，<code>NSString</code> 对象的具体存储位置和方式可能会因为优化而有所不同。例如，短字符串可能会被存储在栈上，以提高性能。</p><h3 id="5-字符串缓存"><a href="#5-字符串缓存" class="headerlink" title="5. 字符串缓存"></a>5. 字符串缓存</h3><p>为了提高性能，<code>NSString</code> 类可能会使用一些内部缓存机制。例如，常量字符串可能会被缓存，以避免重复分配内存。这种优化在底层是由 <code>Core Foundation</code> 框架实现的。</p><h3 id="6-Foundation-框架与-Core-Foundation"><a href="#6-Foundation-框架与-Core-Foundation" class="headerlink" title="6. Foundation 框架与 Core Foundation"></a>6. Foundation 框架与 Core Foundation</h3><p><code>NSString</code> 是 Foundation 框架的一部分，但其底层实现依赖于 Core Foundation 中的 <code>CFString</code>。<code>CFString</code> 提供了字符串操作的底层实现，而 <code>NSString</code> 则是在其基础上提供了面向对象的接口。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>常量字符串</strong>: 存储在程序的只读数据段中。</li><li><strong>动态字符串</strong>: 在程序运行时存储在堆中。</li><li><strong>内存管理</strong>: 通过引用计数管理，无论是 ARC 还是 MRC。</li><li><strong>内部实现</strong>: 由多个子类优化不同类型的字符串，底层依赖于 Core Foundation 的 <code>CFString</code>。</li></ul><h2 id="11-dealloc-流程"><a href="#11-dealloc-流程" class="headerlink" title="11.dealloc 流程"></a>11.dealloc 流程</h2><h2 id="12-避免哈希碰撞的几种方法？"><a href="#12-避免哈希碰撞的几种方法？" class="headerlink" title="12.避免哈希碰撞的几种方法？"></a>12.避免哈希碰撞的几种方法？</h2><h3 id="1-更好的哈希函数"><a href="#1-更好的哈希函数" class="headerlink" title="1. 更好的哈希函数"></a>1. 更好的哈希函数</h3><p>选择一个更好的哈希函数可以极大地减少哈希碰撞的可能性。一个好的哈希函数应具有以下特性：</p><ul><li><strong>均匀性</strong>：能够将输入数据均匀地分布到哈希表的各个位置。</li><li><strong>确定性</strong>：相同的输入总是产生相同的哈希值。</li><li><strong>高效性</strong>：计算哈希值的时间复杂度应尽可能低。</li></ul><p>常见的哈希函数包括：</p><ul><li><strong>MD5</strong></li><li><strong>SHA-1</strong></li><li><strong>SHA-256</strong></li></ul><p>在某些特定场景下，自定义的哈希函数也可能是一个有效的选择。</p><h3 id="2-增大哈希表的大小"><a href="#2-增大哈希表的大小" class="headerlink" title="2. 增大哈希表的大小"></a>2. 增大哈希表的大小</h3><p>通过增大哈希表的大小，可以减少哈希碰撞的概率。哈希表的大小通常是一个素数，这样可以更均匀地分布哈希值。</p><h3 id="3-链地址法（Separate-Chaining）"><a href="#3-链地址法（Separate-Chaining）" class="headerlink" title="3. 链地址法（Separate Chaining）"></a>3. 链地址法（Separate Chaining）</h3><p>链地址法是处理哈希碰撞的一种常见方法。每个哈希表的槽（bucket）都包含一个链表（或其他数据结构），用于存储具有相同哈希值的多个元素。</p><h3 id="4-开放定址法（Open-Addressing）"><a href="#4-开放定址法（Open-Addressing）" class="headerlink" title="4. 开放定址法（Open Addressing）"></a>4. 开放定址法（Open Addressing）</h3><p>开放定址法通过在发生碰撞时寻找下一个空闲槽来存储元素。常见的开放定址法包括线性探测、二次探测和双重散列。</p><h4 id="线性探测"><a href="#线性探测" class="headerlink" title="线性探测"></a>线性探测</h4><p>线性探测在发生碰撞时，按固定步长（通常为 1）依次探测下一个槽，直到找到空闲槽为止。</p><h4 id="二次探测"><a href="#二次探测" class="headerlink" title="二次探测"></a>二次探测</h4><p>二次探测在发生碰撞时，按二次方序列探测下一个槽。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index = (index + i^2) % self.size</span><br></pre></td></tr></table></figure><h4 id="双重散列"><a href="#双重散列" class="headerlink" title="双重散列"></a>双重散列</h4><p>双重散列使用两个不同的哈希函数来计算探测序列。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index = (hash1(key) + i * hash2(key)) % self.size</span><br></pre></td></tr></table></figure><h3 id="5-再哈希法（Rehashing）"><a href="#5-再哈希法（Rehashing）" class="headerlink" title="5. 再哈希法（Rehashing）"></a>5. 再哈希法（Rehashing）</h3><p>再哈希法在发生碰撞时，使用另一个哈希函数重新计算哈希值，直到找到空闲槽为止。</p><h3 id="6-动态调整哈希表大小"><a href="#6-动态调整哈希表大小" class="headerlink" title="6. 动态调整哈希表大小"></a>6. 动态调整哈希表大小</h3><p>在哈希表负载因子（Load Factor）达到一定阈值时，动态调整哈希表的大小。负载因子是已存储元素数量与哈希表大小的比值。当负载因子过高时，增大哈希表的大小并重新哈希所有元素。</p><h2 id="13-mach-o-了解吗？存储的方法信息可以无用代码检测？段迁移？"><a href="#13-mach-o-了解吗？存储的方法信息可以无用代码检测？段迁移？" class="headerlink" title="13.mach-o 了解吗？存储的方法信息可以无用代码检测？段迁移？"></a>13.mach-o 了解吗？存储的方法信息可以无用代码检测？段迁移？</h2><p>Mach-O（Mach Object 文件格式）是 macOS 和 iOS 操作系统上使用的一种文件格式，用于可执行文件、目标代码、动态库、内核转储等。Mach-O 格式提供了一种灵活且强大的方式来描述程序的结构，支持多种架构（如 x86_64、arm64）和多种类型的文件（如可执行文件、动态库）。以下是关于 Mach-O 文件格式的详细介绍：</p><h3 id="Mach-O-文件的基本结构"><a href="#Mach-O-文件的基本结构" class="headerlink" title="Mach-O 文件的基本结构"></a>Mach-O 文件的基本结构</h3><p>Mach-O 文件由多个部分组成，每个部分都有特定的用途和结构。主要部分包括：</p><ol><li><strong>Header（头部）</strong>：包含文件的基本信息，如文件类型、CPU 架构、加载命令数量等。</li><li><strong>Load Commands（加载命令）</strong>：描述文件的各个部分如何加载到内存中。这些命令包括段的描述、动态库的引用、符号表的位置等。</li><li><strong>Segments（段）</strong>：包含实际的代码和数据。每个段包含多个 section（节），每个节存储特定类型的数据，如代码节、数据节、符号表等。</li><li><strong>Sections（节）</strong>：段的子部分，存储不同类型的数据，如可执行代码、只读数据、可写数据等。</li></ol><h3 id="详细结构"><a href="#详细结构" class="headerlink" title="详细结构"></a>详细结构</h3><h4 id="1-Header（头部）"><a href="#1-Header（头部）" class="headerlink" title="1. Header（头部）"></a>1. Header（头部）</h4><p>头部是 Mach-O 文件的开始部分，包含文件的基本信息。头部的结构定义如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct mach_header &#123;</span><br><span class="line">    uint32_t magic;          // 魔数，标识文件格式</span><br><span class="line">    cpu_type_t cputype;      // CPU 类型</span><br><span class="line">    cpu_subtype_t cpusubtype;// CPU 子类型</span><br><span class="line">    uint32_t filetype;       // 文件类型（如可执行文件、动态库）</span><br><span class="line">    uint32_t ncmds;          // 加载命令的数量</span><br><span class="line">    uint32_t sizeofcmds;     // 所有加载命令的总大小</span><br><span class="line">    uint32_t flags;          // 标志位</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-Load-Commands（加载命令）"><a href="#2-Load-Commands（加载命令）" class="headerlink" title="2. Load Commands（加载命令）"></a>2. Load Commands（加载命令）</h4><p>加载命令描述文件的各个部分如何加载到内存中。常见的加载命令包括：</p><ul><li><strong>LC_SEGMENT</strong>：描述一个段。</li><li><strong>LC_SYMTAB</strong>：描述符号表的位置。</li><li><strong>LC_DYSYMTAB</strong>：描述动态符号表的位置。</li><li><strong>LC_LOAD_DYLIB</strong>：描述需要加载的动态库。</li></ul><p>每个加载命令的基本结构如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct load_command &#123;</span><br><span class="line">    uint32_t cmd;      // 加载命令的类型</span><br><span class="line">    uint32_t cmdsize;  // 加载命令的大小</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3-Segments（段）"><a href="#3-Segments（段）" class="headerlink" title="3. Segments（段）"></a>3. Segments（段）</h4><p>段是 Mach-O 文件中的主要数据部分，每个段包含多个节。常见的段包括：</p><ul><li><strong>__TEXT</strong>：包含可执行代码和只读数据。</li><li><strong>__DATA</strong>：包含可写数据。</li><li><strong>__LINKEDIT</strong>：包含符号表和其他链接信息。</li></ul><p>段的基本结构如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct segment_command &#123;</span><br><span class="line">    uint32_t cmd;            // LC_SEGMENT</span><br><span class="line">    uint32_t cmdsize;        // 加载命令的大小</span><br><span class="line">    char segname[16];        // 段的名称</span><br><span class="line">    uint32_t vmaddr;         // 段在虚拟内存中的地址</span><br><span class="line">    uint32_t vmsize;         // 段的大小</span><br><span class="line">    uint32_t fileoff;        // 段在文件中的偏移</span><br><span class="line">    uint32_t filesize;       // 段在文件中的大小</span><br><span class="line">    vm_prot_t maxprot;       // 段的最大保护</span><br><span class="line">    vm_prot_t initprot;      // 段的初始保护</span><br><span class="line">    uint32_t nsects;         // 段中节的数量</span><br><span class="line">    uint32_t flags;          // 段的标志</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="4-Sections（节）"><a href="#4-Sections（节）" class="headerlink" title="4. Sections（节）"></a>4. Sections（节）</h4><p>节是段的子部分，存储具体类型的数据。每个节的基本结构如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct section &#123;</span><br><span class="line">    char sectname[16];       // 节的名称</span><br><span class="line">    char segname[16];        // 段的名称</span><br><span class="line">    uint32_t addr;           // 节在虚拟内存中的地址</span><br><span class="line">    uint32_t size;           // 节的大小</span><br><span class="line">    uint32_t offset;         // 节在文件中的偏移</span><br><span class="line">    uint32_t align;          // 节的对齐</span><br><span class="line">    uint32_t reloff;         // 重定位表的偏移</span><br><span class="line">    uint32_t nreloc;         // 重定位表的数量</span><br><span class="line">    uint32_t flags;          // 节的标志</span><br><span class="line">    uint32_t reserved1;      // 保留字段</span><br><span class="line">    uint32_t reserved2;      // 保留字段</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Mach-O-文件类型"><a href="#Mach-O-文件类型" class="headerlink" title="Mach-O 文件类型"></a>Mach-O 文件类型</h3><p>Mach-O 文件有多种类型，主要包括：</p><ul><li><strong>MH_EXECUTE</strong>：可执行文件。</li><li><strong>MH_DYLIB</strong>：动态库。</li><li><strong>MH_BUNDLE</strong>：可加载的代码包。</li><li><strong>MH_OBJECT</strong>：目标文件。</li><li><strong>MH_DYLINKER</strong>：动态链接器。</li></ul><h3 id="使用工具查看-Mach-O-文件"><a href="#使用工具查看-Mach-O-文件" class="headerlink" title="使用工具查看 Mach-O 文件"></a>使用工具查看 Mach-O 文件</h3><p>macOS 提供了一些工具来查看和分析 Mach-O 文件：</p><ul><li><p>otool</p><p>：用于显示 Mach-O 文件的头部、段、节、符号表等信息。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">otool -hV MyApp.app/MyApp  # 显示头部信息</span><br><span class="line">otool -L MyApp.app/MyApp   # 显示动态库依赖</span><br><span class="line">otool -tV MyApp.app/MyApp  # 显示反汇编代码</span><br></pre></td></tr></table></figure></li><li><p>nm</p><p>：用于显示 Mach-O 文件中的符号表。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nm MyApp.app/MyApp</span><br></pre></td></tr></table></figure></li><li><p>dyldinfo</p><p>：用于显示动态链接相关信息。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dyldinfo -all MyApp.app/MyApp</span><br></pre></td></tr></table></figure></li></ul><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>Mach-O 是 macOS 和 iOS 上使用的一种复杂而灵活的文件格式，用于描述可执行文件、动态库等。它通过头部、加载命令、段和节组织数据，支持多种文件类型和 CPU 架构。理解 Mach-O 文件格式有助于进行底层调试、性能优化和安全分析。macOS 提供了一些工具，如 <code>otool</code> 和 <code>nm</code>，可以用来查看和分析 Mach-O 文件的结构和内容。</p><h2 id="14-脚本检测未使用代码原理"><a href="#14-脚本检测未使用代码原理" class="headerlink" title="14.脚本检测未使用代码原理"></a>14.脚本检测未使用代码原理</h2><h2 id="15-Render-渲染流程"><a href="#15-Render-渲染流程" class="headerlink" title="15.Render 渲染流程"></a>15.Render 渲染流程</h2><p>iOS 渲染流程是一个复杂且高效的过程，它负责将应用的界面呈现到屏幕上。理解这个流程有助于优化应用的性能和用户体验。以下是 iOS 渲染流程的概要：</p><h3 id="1-应用层（Application-Layer）"><a href="#1-应用层（Application-Layer）" class="headerlink" title="1. 应用层（Application Layer）"></a>1. 应用层（Application Layer）</h3><p>应用层是 iOS 应用的最上层，包括应用的逻辑、UI 视图控制器（UIViewController）、视图（UIView）等。开发者主要在这一层进行开发。</p><h3 id="2-Core-Animation"><a href="#2-Core-Animation" class="headerlink" title="2. Core Animation"></a>2. Core Animation</h3><p>Core Animation 是 iOS 渲染的核心技术，它负责管理和执行所有的动画和视图层次结构（Layer Tree）。Core Animation 使用双缓冲技术来确保动画的流畅性。主要包括以下几个组成部分：</p><ul><li><strong>Layer Tree</strong>: 由 <code>CALayer</code> 对象组成的层次结构，每个 <code>UIView</code> 对应一个 <code>CALayer</code>。</li><li><strong>Display Tree</strong>: 由 Core Animation 生成的用于实际显示内容的树。</li><li><strong>Render Tree</strong>: 用于渲染的最终树，由 Core Animation 发送给渲染服务器（Render Server）。</li></ul><h3 id="3-渲染服务器（Render-Server）"><a href="#3-渲染服务器（Render-Server）" class="headerlink" title="3. 渲染服务器（Render Server）"></a>3. 渲染服务器（Render Server）</h3><p>渲染服务器是一个独立的进程，负责接收来自 Core Animation 的 Render Tree，并将其转换为 GPU 可以理解的指令。渲染服务器会将这些指令发送给 GPU 进行实际的渲染。</p><h3 id="4-GPU-渲染"><a href="#4-GPU-渲染" class="headerlink" title="4. GPU 渲染"></a>4. GPU 渲染</h3><p>GPU（图形处理单元）接收到渲染指令后，会执行以下操作：</p><ol><li><strong>顶点着色（Vertex Shading）</strong>: 处理顶点数据，包括位置、颜色、纹理等信息。</li><li><strong>图元组装（Primitive Assembly）</strong>: 将顶点连接成图元（如三角形）。</li><li><strong>光栅化（Rasterization）</strong>: 将图元转换为片元（Pixel）。</li><li><strong>片元着色（Fragment Shading）</strong>: 计算每个片元的颜色和其他属性。</li><li><strong>帧缓存操作（Frame Buffer Operations）</strong>: 将最终的片元数据写入帧缓存（Frame Buffer）。</li></ol><h3 id="5-显示层（Display-Layer）"><a href="#5-显示层（Display-Layer）" class="headerlink" title="5. 显示层（Display Layer）"></a>5. 显示层（Display Layer）</h3><p>最终的帧缓存数据会被传递到显示层，由显示层将其显示在屏幕上。iOS 使用 VSync（垂直同步）信号来协调显示更新，以确保屏幕刷新和渲染同步，避免画面撕裂。</p><h3 id="渲染流程的详细步骤"><a href="#渲染流程的详细步骤" class="headerlink" title="渲染流程的详细步骤"></a>渲染流程的详细步骤</h3><ol><li><strong>视图更新（View Update）</strong>:<ul><li>应用程序修改视图或图层属性（如位置、大小、颜色等）。</li><li><code>UIView</code> 的属性变化会触发 <code>CALayer</code> 的相应变化。</li></ul></li><li><strong>布局和显示（Layout and Display）</strong>:<ul><li><code>UIView</code> 布局系统会重新计算视图的布局。</li><li><code>CALayer</code> 会根据视图的变化更新自己的属性。</li></ul></li><li><strong>Core Animation 动画处理（Core Animation Animation Handling）</strong>:<ul><li>Core Animation 会将动画应用到相关的 <code>CALayer</code> 上。</li><li>根据动画时间轴生成 Display Tree。</li></ul></li><li><strong>Render Tree 生成（Render Tree Generation）</strong>:<ul><li>Core Animation 从 Display Tree 生成 Render Tree。</li><li>Render Tree 包含了所有需要渲染的信息。</li></ul></li><li><strong>Render Server 渲染（Render Server Rendering）</strong>:<ul><li>Core Animation 将 Render Tree 发送给渲染服务器。</li><li>渲染服务器将 Render Tree 转换为 GPU 指令。</li></ul></li><li><strong>GPU 渲染（GPU Rendering）</strong>:<ul><li>GPU 执行顶点着色、图元组装、光栅化、片元着色和帧缓存操作。</li><li>渲染结果存储在帧缓存中。</li></ul></li><li><strong>显示更新（Display Update）</strong>:<ul><li>帧缓存内容通过显示层显示在屏幕上。</li><li>VSync 信号确保显示更新和屏幕刷新同步。</li></ul></li></ol><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p>理解 iOS 渲染流程有助于优化应用性能，以下是一些常见的优化策略：</p><ol><li><strong>减少布局计算和视图层次结构的复杂度</strong>。</li><li><strong>使用合适的图层类型（如 <code>CAShapeLayer</code>、<code>CATextLayer</code>）</strong>。</li><li><strong>避免频繁的视图更新和动画</strong>。</li><li><strong>使用异步绘制技术（如 <code>drawRect:</code> 方法）</strong>。</li><li><strong>避免不必要的离屏渲染（Offscreen Rendering）</strong>。</li></ol><p>通过这些优化策略，可以减少 CPU 和 GPU 的负担，提高应用的流畅性和响应速度。</p><h2 id="16-UIView-动画和-CAAnimation-动画有什么联系？"><a href="#16-UIView-动画和-CAAnimation-动画有什么联系？" class="headerlink" title="16.UIView 动画和 CAAnimation 动画有什么联系？"></a>16.UIView 动画和 CAAnimation 动画有什么联系？</h2><p>虽然 <code>UIView</code> 动画和 <code>CAAnimation</code> 动画在使用上有区别，但它们的底层机制是有联系的。<code>UIView</code> 动画实际上是对 <code>CAAnimation</code> 的封装和简化。当你使用 <code>UIView</code> 动画时，UIKit 会在内部创建相应的 <code>CAAnimation</code> 对象，并将其添加到视图的 <code>CALayer</code> 上。</p><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">UIView</span>.animate(withDuration: <span class="hljs-number">1.0</span>, animations: &#123;</span><br><span class="line">    myView.alpha = <span class="hljs-number">0.0</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面的代码等价于：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let animation = <span class="hljs-built_in">CABasicAnimation</span>(keyPath: <span class="hljs-string">"opacity"</span>)</span><br><span class="line">animation.fromValue = <span class="hljs-number">1.0</span></span><br><span class="line">animation.toValue = <span class="hljs-number">0.0</span></span><br><span class="line">animation.duration = <span class="hljs-number">1.0</span></span><br><span class="line">myView.layer.add(animation, forKey: <span class="hljs-string">"opacityAnimation"</span>)</span><br><span class="line">myView.layer.opacity = <span class="hljs-number">0.0</span></span><br></pre></td></tr></table></figure><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p><code>UIView</code> 动画是对 <code>CAAnimation</code> 的封装，提供了更高层次的接口，使得简单动画的实现更加便捷，而 <code>CAAnimation</code> 提供了更强大的功能和更精细的控制，适合复杂的动画需求。在实际开发中，可以根据具体的动画需求选择合适的动画方式。</p><h2 id="17-项目亮点"><a href="#17-项目亮点" class="headerlink" title="17.项目亮点"></a>17.项目亮点</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;百融云创面试题&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="百融云创" scheme="http://soso.wiki/tags/%E7%99%BE%E8%9E%8D%E4%BA%91%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title>OC语法</title>
    <link href="http://soso.wiki/OC%E8%AF%AD%E6%B3%95/"/>
    <id>http://soso.wiki/OC语法/</id>
    <published>2024-05-08T06:21:00.000Z</published>
    <updated>2024-05-08T06:24:06.674Z</updated>
    
    <content type="html"><![CDATA[<p>OC语法<br><a id="more"></a></p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>一个NSObject对象占用多少内存<br>系统分配了16个字节给NSObject对象（malloc_size）<br>但NSObject对象内部只使用了8个字节的空间（class_getInstanceSize）</p><p>对象的isa指针指向哪里<br>instance对象isa指向class对象<br>调用对象方法时，通过isa指针找到类对象，找到对象方法实现进行调用<br>class对象isa指向meta-class对象<br>调用类方法时，通过isa指针找到元类对象，找到类方法的视线进行调用<br>meta-class对象isa指向基类的meta-class对象</p><p>OC的类信息存放在哪里<br>对象方法、属性、成员变量、协议信息，存放在class对象<br>类方法存放在meta-class对象<br>成员变量的具体值，存放在instance对象</p><h2 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h2><p>iOS用什么方式实现一个对象的KVO（KVO的本质是什么）<br>利用runtime动态生成一个子类，并且让instance对象的isa指向该子类<br>当修改instance对象的属性时，会调用Foundation的<code>_NSSetXXXValueAndNotify</code>函数<br>willChangeValueForKey:<br>父类原来的set方法<br>didChangeValueForKey:<br>内部会触发Observer的监听方法（observeValueForKeyPath:ofObject:change:context）</p><p>如何手动触发KVO<br>手动调用willSetValueForKey:和didChangeValueForKey:</p><p>直接修改成员变量的值会触发KVO吗<br>不会</p><p>通过KVC修改属性会触发KVO吗<br>会</p><p>KVC的赋值和取值过程？<br>赋值  先调用setA  isA _age</p><h2 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h2><p>Category的实现原理<br>Category编译后的底层结构是struct category_t 里面存放分类的对象方法、类方法、属性、协议信息<br>在程序运行时，runtime会将Category的数据，合并到类信息中（类对象、元类对象中）</p><p>Category和Class Extension的区别是什么<br>Class Extension在编译时数据就在类信息中<br>Category是在运行时，将数据合并到类信息中</p><p>Categroy中有load方法吗？load方法是什么时候调用的？load方法能继承吗？<br>有load方法<br>load是在程序启动的时候，加载类、分类的时候调用<br>load方法可以继承，但一般不会主动去调用load方法，都是让系统自动调用</p><p>load、initialize方法的区别？在Category中的调用顺序，出现继承时他们之间的调用过程？</p><p>Category能否添加成员变量？如果可以，如何给Category添加成员变量？<br>不能直接给Category添加成员变量，但可以通过runtime实现Category有成员变量的效果</p><h2 id="Objective-C的本质"><a href="#Objective-C的本质" class="headerlink" title="Objective-C的本质"></a>Objective-C的本质</h2><p>OC的本质<br>底层都是C/C++代码，编译成了汇编语言、机器语言<br>OC的面向对象是通过C/C++的结构体实现的</p><p>将OC代码转换成C/C++代码<br>xcrun  -sdk  iphoneos  clang  -arch  arm64  -rewrite-objc  OC源文件  -o  输出的CPP文件</p><p>一个OC对象在内存中的布局<br>struct NSObject_IMPL {<br>    Class isa;<br>}</p><p>Class 即 objc_class<br>class、meta-class对象的本质结构都是struct objc_class</p><p>创建一个实例对象，至少需要多少内存<br>class_getInstanceSize([NSObject class]);</p><p>创建一个实例对象，实际上分配了多少内存<br>malloc_size(obj);</p><h2 id="常见LLDB指令"><a href="#常见LLDB指令" class="headerlink" title="常见LLDB指令"></a>常见LLDB指令</h2><p>p 打印<br>po 打印对象</p><p>读取内存<br>memory read/数据格式字节数  内存地址<br>x/数量格式字节数 内存地址</p><p>修改内存中的值<br>memory write</p><p>OC对象的分类<br>instance对象（实例对象）、class对象（类对象）、meta-class对象（元类对象）</p><p>class对象在内存中存储的信息主要包括<br>isa指针<br>superclass指针<br>属性、对象方法、协议、成员变量</p><p>meta-class对象在内存中存储的信息<br>isa指针<br>superclass指针<br>类方法</p><p>object_getClass([NSObject class]); 获取元类对象<br>class_isMetaClass([NSObject class]); 查看Class是否是元类对象</p><p>instance的isa指向class<br>class的isa指向meta-class<br>meta-class的isa指向基类的meta-class</p><p>class的superclass指向父类的class<br>如果没有父类，superclass指针为nil</p><p>meta-class的superclass指向父类的meta-class<br>基类的meta-class的superclass指向基类的class</p><p>isa指针<br>isa通过&amp; ISA_MASK （位运算），得到真实地址<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class &#123;</span><br><span class="line">Class isa;</span><br><span class="line">Class superClass;</span><br><span class="line">cache_t cache; // 方法缓存</span><br><span class="line">class_data_bits_t bits; // 用于获取具体的类信息</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bits &amp; FAST_DATA_MASK得到class_rw_t</span><br><span class="line">class_rw_t &#123;</span><br><span class="line">uint32_t flags;</span><br><span class="line">uint32_t version;</span><br><span class="line">const class_ro_t *ro;</span><br><span class="line">method_list_t *methods; // 方法列表</span><br><span class="line">property_list_t *properties; // 属性列表</span><br><span class="line">const protocol_list_t *protocols; // 协议列表</span><br><span class="line">Class firstSubClass;</span><br><span class="line">Class nextSiblingClass;</span><br><span class="line">char *demangledName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class_ro_t &#123;</span><br><span class="line">uint32_t flags;</span><br><span class="line">uint32_t instanceStart;</span><br><span class="line">uint32_t instanceSize;</span><br><span class="line">const char *name; // 类名</span><br><span class="line">method_list_t *baseMethodList;</span><br><span class="line">protocol_list_t *baseProtocols;</span><br><span class="line">const ivar_list_t *ivars; // 成员变量列表</span><br><span class="line">const uint8_t *weakIvarLayout;</span><br><span class="line">property_list_t *baseProperties;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>KVC<br>setValue:forKey:原理<br>按照<code>setKey: _setKey:</code>顺序查找方法，找到方法调用<br>没找到方法，查看accessInstanceVariablesDirectly方法的返回值<br>NO-&gt;调用setValue:forUndefinedKey: 并抛出异常NSUnknownKeyException<br>YES-&gt;按照<code>_key _isKey key isKey</code>顺序查找成员变量，找到后直接赋值，找不到报错</p><p>valueForKey:原理<br>按照<code>getKey、key、isKey、_key</code>顺序查找方法，找到方法调用<br>没找到方法，查看accessInstanceVariablesDirectly方法的返回值<br>NO-&gt;调用valueForUndefinedKey: 并抛出异常NSUnknownKeyException<br>YES-&gt;按照<code>_key、_isKey、key、isKey</code>顺序查找成员变量，找到后直接取值</p><p>Caregory的底层结构<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct category_t &#123;</span><br><span class="line">const char *name;</span><br><span class="line">classref cls;</span><br><span class="line">struct method_list_t *instanceMethods;</span><br><span class="line">struct method_list_t *classMethods;</span><br><span class="line">struct protocol_list_t *protocols;</span><br><span class="line">struct property_list_t *instanceProperties;</span><br><span class="line">struct property_list_t *_classProperties;</span><br><span class="line"></span><br><span class="line">method_list_t *methodForMeta(bool isMeta) &#123;</span><br><span class="line">if (isMeta) return classMethods;</span><br><span class="line">else return instanceMethods;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">property_list_t *propertiesForMeta(bool isMeta, struct header_info *hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Category的加载处理过程<br>1.通过Runtime加载某个类的所有Category数据<br>2.把所有Category的方法、属性、协议数据，合并到一个大数组里，后面参与编译的Category数据，会在数组的前面<br>3.将合并后的分类数据（方法、属性、协议），插入到类原来数据的前面</p><p>+load方法<br>+load方法会在runtime加载类、分类时调用<br>每个类、分类的+load方法，在程序运行过程中只调用一次</p><p>调用顺序：<br>1.先调用类的+load，按照编译先后顺序调用（先编译，先调用），调用子类的+load之前会先调用父类的+load<br>2.再调用分类的+load，按照编译先后顺序调用（先编译，先调用）<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1._objc_Init</span><br><span class="line">2.load_images</span><br><span class="line">3.prepare_load_methods</span><br><span class="line">schedule_class_load</span><br><span class="line">add_class_to_loadable_list</span><br><span class="line">add_category_to_loadable_list</span><br><span class="line">4.call_load_methods</span><br><span class="line">call_class_loads</span><br><span class="line">call_category_loads</span><br><span class="line">(*load_method)(cls, SEL_load)</span><br></pre></td></tr></table></figure></p><p>+load方法时根据方法地址直接调用，并不是经过objc_msgSend函数调用</p><p>+initialize方法<br>+initialize方法会在类第一次接收到消息时调用</p><p>调用顺序<br>先调用父类的+initialize，再调用子类的+initialize<br>先初始化父类，在初始化子类，每个类只会初始化一次<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend</span><br><span class="line">class_getInstanceMethod</span><br><span class="line">lookUpImpOrNil</span><br><span class="line">lookUpImpOrForword</span><br><span class="line">_class_initialize</span><br><span class="line">callInitialize</span><br><span class="line">objc_msgSend(cls, SEL_initialize)</span><br></pre></td></tr></table></figure></p><p>+initialize和+load区别<br>+initialize是通过objc_msgSend进行调用<br>如果子类没有实现+initialize，会调用父类的+initialize（所以父类的+initialize可能会被调用多次）<br>如果分类实现了+initialize，就会覆盖类本身的+initialize调用</p><p>如何给分类添加成员变量？<br>因为分类的底层结构限制，不能添加成员变量到分类，可以通过关联对象间接实现</p><p>添加关联对象<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void objc_setAssociatedObject(id object, const void * key,</span><br><span class="line">                                id value, objc_AssociationPolicy policy)</span><br></pre></td></tr></table></figure></p><p>获得关联对象<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id objc_getAssociatedObject(id object, const void * key)</span><br></pre></td></tr></table></figure></p><p>移除所有的关联对象<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void objc_removeAssociatedObjects(id object)</span><br></pre></td></tr></table></figure></p><p>关联对象的原理<br>关联对象并不是存储在关联对象本身内存中<br>关联对象存储在全局统一的一个AssociationsManager中<br>设置关联对象为nil，就相当于移除关联对象</p><p>block的本质<br>block本质上是一个OC对象，内部有个isa指针<br>block是封装了函数调用以及函数调用环境的OC对象</p><p>block的变量捕获<br>局部变量 auto 捕获到block内部  访问方式：值传递<br>局部变量 static 捕获到block内部 访问方式：指针传递<br>全局变量 不捕获 访问方式：直接访问</p><p>auto变量的捕获</p><p>block的类型<br>block有3种类型，可以通过调用class方法或者isa指针查看具体类型，最终都是继承自NSBlock类型<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__NSGlobalBlock__ (_NSConcreteGlobalBlock)  数据区域 .data区</span><br><span class="line">__NSStackBlock__ (_NSConcreteStackBlock)  栈区</span><br><span class="line">__NSMallocBlock__ (_NSConcreteMallocBlock) 堆区</span><br></pre></td></tr></table></figure></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__NSGlobalBlock__  没有访问auto变量</span><br><span class="line">__NSStackBlock__ 访问了auto变量</span><br><span class="line">__NSMallocBlock__  __NSStackBlock__调用了copy</span><br></pre></td></tr></table></figure><p>调用copy后的结果<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_NSConcreteStackBlock  程序的数据区域 复制效果：什么也不做</span><br><span class="line">_NSConcreteStackBlock  栈  复制效果：从栈复制到堆</span><br><span class="line">_NSConcreteMallocBlock 堆  复制效果：引用计数增加</span><br></pre></td></tr></table></figure></p><p>block的copy<br>在ARC下，编辑器会在下列情况自动将栈上的block拷贝到堆上：<br>1.block作为函数返回值时<br>2.将block赋值给强指针时<br>3.block作为Cocoa API中方法名含有usingBlock的方法参数时<br>4.block作为GCD API的方法参数时</p><p>MRC下block的建议写法：<br>@property(copy, nonatomic) void (^block)(void);</p><p>ARC下block的建议写法：<br>@property(strong, nonatomic) void (^block)(void);<br>@property(copy, nonatomic) void (^block)(void);</p><p>对象类型的auto变量<br>当block内部访问了对象类型的auto变量时<br>如果block在栈上，将不会对auto变量产生强引用</p><p>如果block被拷贝到堆上<br>会调用block内部的copy函数<br>copy函数内部会调用<code>_Block_object_assign</code>函数<br><code>_Block_object_assign</code>函数会根据auto变量的修饰符做出相应操作，形成强引用或弱引用</p><p>如果block从堆上移除<br>会调用block内部的dispose函数<br>dispose函数内部会调用<code>_Block_object_dispose</code>函数<br><code>_Block_object_dispose</code>函数会自动释放引用的auto变量（release）</p><p><code>__block</code>修饰符<br>可以解决block内部无法修改auto变量值的问题<br>不能修饰全局变量、静态变量<br>编译器会把<code>__block</code>包装成一个对象</p><p>当block在栈上时，并不会对<code>__block</code>变量产生强引用</p><p>当block被copy到堆时<br>会调用block内部的copy函数<br>copy函数内部会调用<code>_Block_object_assign</code>函数<br><code>_Block_object_assign</code>函数会对<code>__block</code>变量形成强引用（retain）</p><p>当block从堆中移除时<br>会调用block内部的dispose函数<br>dispose函数内部会调用<code>_Block_object_dispose</code>函数<br><code>_Block_object_dispose</code>函数会自动释放引用的<code>__block</code>变量（release）</p><p><code>__block</code>的<code>__forwarding</code>指针</p><p>对象类型的auto变量、__block变量<br>当block在栈上时，对它们都不会产生强引用</p><p>解决循环引用问题 - ARC<br>用<code>__weak</code>、<code>__unsafe_unretained</code>解决<br>用<code>__block</code>解决（必须要调用block）</p><p>解决循环引用问题 - MRC<br>用<code>__unsafe_unretained</code>解决<br>用<code>__block</code>解决(ARC时会retain，MRC时不会retain)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;OC语法&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="底层原理" scheme="http://soso.wiki/categories/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="底层原理" scheme="http://soso.wiki/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
      <category term="OC语法" scheme="http://soso.wiki/tags/OC%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>自如面试题</title>
    <link href="http://soso.wiki/%E8%87%AA%E5%A6%82%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://soso.wiki/自如面试题/</id>
    <published>2023-04-04T11:43:14.000Z</published>
    <updated>2024-04-29T11:40:04.920Z</updated>
    
    <content type="html"><![CDATA[<p>自如面试题<br><a id="more"></a></p><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><p>1.你觉得自己有什么优势？</p><p>2.线程和进程的区别？</p><p>3.线程间是怎么通信的？CPU是怎么处理线程的</p><p>4.同步串行队列会不会开线程？异步串行队列会不会开线程？</p><p>5.GCD项目里有哪些地方用了</p><p>6.怎么保证网络传输的安全？MD5的加密规则，MD5可以破解吗？AES/RSA，RSA有长度限制吗？</p><p>7.什么是死锁</p><p>8.做过哪些优化，什么是离屏渲染？</p><p>9.网络有没有优化过</p><p>10.发一个网络请求经过了哪些步骤？有没有统计发起网络请求和接收网络请求的时长</p><p>11.三次握手和四次挥手</p><p>12.冷启动和热启动怎么区分？冷启动是指关机后首次打开App，热启动是指打开过App杀死后再打开。</p><p>13.什么是平衡二叉树？</p><p>14.合并多个有序链表</p><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><p>1.介绍印象深刻的项目，遇到的问题，怎么解决的</p><p>2.webView 白屏除了证书问题还有什么情况可能会导致。</p><p>3.说一下对 Flutter 的了解。</p><p>4.多个 widget 之间怎么相互传值，正向反向。</p><p>5.说一下对 iOS 的理解。</p><p>6.Runtime 是怎么实现动态化的，其他语言也写一套汇编的逻辑能实现动态化吗？</p><p>7.RunLoop 应用，卡顿检测，runloop 的 activity 之前切换时长多少你觉得是卡顿？runloop 和内存之前的相关知识，autoreleasepool</p><p>8.内存管理</p><p>9.编译后的结构添加不了成员变量了，如果想添加，有没有办法实现？一个类的成员变量在内存中是怎么存储的？怎么读取一个成员变量？有什么要注意的？给 NSNumber 赋值一个 NSString，正确使用 NSString 时会不会有什么问题。</p><p>10.组件化，路由模式，如果一个类被修改了，他的映射关系怎么及时维护？</p><p>11.说一下你了解的设计模式，说一下工厂模式</p><p>12.讲一个你比较熟悉的框架</p><p>13.项目开发流程。有哪些地方可以提高效率</p><p>14.项目是怎么架构的</p><p>15.反转字符串，第一次反转一个  第二次反转两个  最后不够的全拿过来。</p><h3 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h3><p>1.介绍项目</p><p>2.Flutter 开发遇到的问题</p><p>3.Vue 开发遇到的问题  赋值需要用set方法的原因</p><p>4.学习一门新知识的途径</p><p>5.有没有看过一些源码</p><p>6.从框架中你觉得有什么点印象深刻，从框架中有没有什么点应用到项目里</p><p>7.规划  考虑新公司看中哪些方面，</p><p>8.手里有没有offer  offer上的入职时间</p><p>其他<br>问项目中遇到过啥问题，怎么解决的。平时怎么学习相关知识的<br>说说项目中的亮点，你在开发中担任的角色，你负责的模块</p><h2 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a>参考答案</h2><h3 id="一面-1"><a href="#一面-1" class="headerlink" title="一面"></a>一面</h3><p>1.你觉得自己有什么优势？</p><p>2.线程和进程的区别？</p><p>3.线程间是怎么通信的？CPU是怎么处理线程的</p><p>4.同步串行队列会不会开线程？异步串行队列会不会开线程？</p><p>5.GCD项目里有哪些地方用了</p><p>6.怎么保证网络传输的安全？MD5的加密规则，MD5可以破解吗？AES/RSA，RSA有长度限制吗？</p><p>7.什么是死锁</p><p>8.做过哪些优化，什么是离屏渲染？</p><p>9.网络有没有优化过</p><p>10.发一个网络请求经过了哪些步骤？有没有统计发起网络请求和接收网络请求的时长</p><p>11.三次握手和四次挥手</p><p>12.冷启动和热启动怎么区分？冷启动是指关机后首次打开App，热启动是指打开过App杀死后再打开。</p><p>13.什么是平衡二叉树？</p><p>14.合并多个有序链表</p><h3 id="二面-1"><a href="#二面-1" class="headerlink" title="二面"></a>二面</h3><p>1.介绍印象深刻的项目，遇到的问题，怎么解决的</p><p>2.webView 白屏除了证书问题还有什么情况可能会导致。</p><p>3.说一下对 Flutter 的了解。</p><p>4.多个 widget 之间怎么相互传值，正向反向。</p><p>5.说一下对 iOS 的理解。</p><p>6.Runtime 是怎么实现动态化的，其他语言也写一套汇编的逻辑能实现动态化吗？</p><p>7.RunLoop 应用，卡顿检测，runloop 的 activity 之前切换时长多少你觉得是卡顿？runloop 和内存之前的相关知识，autoreleasepool</p><p>8.内存管理</p><p>9.编译后的结构添加不了成员变量了，如果想添加，有没有办法实现？一个类的成员变量在内存中是怎么存储的？怎么读取一个成员变量？有什么要注意的？给 NSNumber 赋值一个 NSString，正确使用 NSString 时会不会有什么问题。</p><p>10.组件化，路由模式，如果一个类被修改了，他的映射关系怎么及时维护？</p><p>11.说一下你了解的设计模式，说一下工厂模式</p><p>12.讲一个你比较熟悉的框架</p><p>13.项目开发流程。有哪些地方可以提高效率</p><p>14.项目是怎么架构的</p><p>15.反转字符串，第一次反转一个  第二次反转两个  最后不够的全拿过来。</p><h3 id="三面-1"><a href="#三面-1" class="headerlink" title="三面"></a>三面</h3><p>1.介绍项目</p><p>2.Flutter 开发遇到的问题</p><p>3.Vue 开发遇到的问题  赋值需要用set方法的原因</p><p>4.学习一门新知识的途径</p><p>5.有没有看过一些源码</p><p>6.从框架中你觉得有什么点印象深刻，从框架中有没有什么点应用到项目里</p><p>7.规划  考虑新公司看中哪些方面，</p><p>8.手里有没有offer  offer上的入职时间</p><p>其他<br>问项目中遇到过啥问题，怎么解决的。平时怎么学习相关知识的<br>说说项目中的亮点，你在开发中担任的角色，你负责的模块</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自如面试题&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="自如" scheme="http://soso.wiki/tags/%E8%87%AA%E5%A6%82/"/>
    
  </entry>
  
  <entry>
    <title>百度知道面试题</title>
    <link href="http://soso.wiki/%E7%99%BE%E5%BA%A6%E7%9F%A5%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://soso.wiki/百度知道面试题/</id>
    <published>2023-04-04T10:30:00.000Z</published>
    <updated>2024-04-28T08:38:00.943Z</updated>
    
    <content type="html"><![CDATA[<p>百度知道面试题<br><a id="more"></a></p><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><p>1.属性关键字，在 ARC、MRC下分别用什么关键字，copy 修饰 NSString，可变字符串用什么修饰？block 用什么修饰？能不能用 strong 修饰？assign 能修饰对象吗？unsafe_unretain 有什么作用？</p><p>2.block，有几种 block，<code>__weak</code> <code>__block</code>，<code>__block</code> 修改局部变量的值原理，只把局部变量变成结构体就可以了吗？</p><p>3.多线程都用过哪些？NSOperation 了解吗？GCD 怎么开一个线程</p><p>4.什么是死锁，举例说明为什么会死锁</p><p>5.内存都有哪些区域？哪些是在栈上，哪些是在堆上？局部变量存在哪里？</p><p>6.+load 父类、子类调用顺序？分类的 +load 会调用吗？项目里有用到 +load 吗？initialize</p><p>7.Category 实现了本类的同名方法，有没有办法来调用本类的方法？</p><p>8.单链表是否有环</p><p>9.两个链表是否相交（怎么判断是否相交？怎么找交点）</p><p>10.两个字符串的最长相同子串的长度</p><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><p>1.较难定位的 Crash 怎么定位？怎么判断是 OOM 导致的 Crash 还是其他导致的 Crach？</p><p>2.Jenkins+Fastlane 实现 CI，自动化的流程除了打包还能做什么？</p><p>3.Flutter 和原生开发你觉得有什么差异</p><p>4.HTTPDNS，使用和不使用有什么区别？有什么好处？</p><p>5.通知是同步的还是异步的，异步的通知什么时候会发出去，通知的原理，通知如何存储，多次添加通知，多次移除通知会有问题吗？</p><p>6.屏幕显示的流程，CPU/GPU，离屏渲染是什么？光栅化的过程</p><p>7.安装包大小优化做了哪些？段迁移了解吗？</p><p>8.App 启动系统做了哪些事情，怎么优化启动速度</p><p>9.tableView 滑动流畅性优化</p><p>10.从点击屏幕到响应事件的流程</p><p>11.UIView 和 CALayer 的关系，为什么要这么设计</p><p>12.autoreleasePool 的原理，设计成双向链表有什么好处</p><p>13.最有成就感的项目，组件化的好处</p><p>14.如果 Code Review，你会关注哪些东西？</p><p>15.相对其他团队成员的优势</p><p>16.分享会怎么做，如果听众有 PM/测试，会怎么分享</p><p>17.团队里有成员不是特别优秀，怎么把控进度</p><p>18.了解百度的技术职级吗？你觉得自己是T几？</p><h3 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h3><p>经理 项目中遇到的有挑战的问题</p><h3 id="四面"><a href="#四面" class="headerlink" title="四面"></a>四面</h3><p>HR</p><h3 id="五面"><a href="#五面" class="headerlink" title="五面"></a>五面</h3><p>1.通过什么途径学的包括 Vue 的其他知识？为什么会有前端的需求？</p><p>2.IM 的气泡，点九图有没有使用类库，有没有兼容性问题，项目适配的最低系统版本是多少？</p><p>3.IM 文本高度计算，图文混排怎么计算高度，高度计算有没有遇到什么问题</p><p>4.整个 IM 页面的布局，最复杂的 cell 布局</p><p>5.收到新消息的处理，怎么处理能够不滚动到页面底部</p><p>6.大量图片列表滑动到指定位置，怎么避免出现内存导致的问题，为什么没有落地</p><p>7.组件化，什么能拆成组件，你认为组件化做的足够好吗？更好的组件化怎么去做？</p><p>8.你认为 iOS 和其他端有什么不一样，有什么经验可以共用？</p><p>9.未来规划</p><h3 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a>参考答案</h3><h3 id="一面-1"><a href="#一面-1" class="headerlink" title="一面"></a>一面</h3><p>1.属性关键字，在 ARC、MRC下分别用什么关键字，copy 修饰 NSString，可变字符串用什么修饰？block 用什么修饰？能不能用 strong 修饰？assign 能修饰对象吗？unsafe_unretain 有什么作用？</p><p>2.block，有几种 block，<code>__weak</code> <code>__block</code>，<code>__block</code> 修改局部变量的值原理，只把局部变量变成结构体就可以了吗？</p><p>3.多线程都用过哪些？NSOperation 了解吗？GCD 怎么开一个线程</p><h4 id="4-什么是死锁，举例说明为什么会死锁"><a href="#4-什么是死锁，举例说明为什么会死锁" class="headerlink" title="4.什么是死锁，举例说明为什么会死锁"></a>4.什么是死锁，举例说明为什么会死锁</h4><blockquote><p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</p></blockquote><p>四个必要条件</p><ul><li><p>互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。</p></li><li><p>请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</p></li><li><p>不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</p></li><li><p>环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。</p></li></ul><p>举例：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="hljs-keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="hljs-keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="hljs-built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"1"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dispatch_sync 同步，阻塞当前线程，即阻塞主线程。block 又在等主线程里的 viewDidLoad 执行完，从而形成了主线程等待主线程，造成死锁。</p><p>参考链接：<a href="https://baike.baidu.com/item/%E6%AD%BB%E9%94%81" target="_blank" rel="noopener">百度百科-死锁</a></p><h4 id="5-内存都有哪些区域？哪些是在栈上，哪些是在堆上？局部变量存在哪里？"><a href="#5-内存都有哪些区域？哪些是在栈上，哪些是在堆上？局部变量存在哪里？" class="headerlink" title="5.内存都有哪些区域？哪些是在栈上，哪些是在堆上？局部变量存在哪里？"></a>5.内存都有哪些区域？哪些是在栈上，哪些是在堆上？局部变量存在哪里？</h4><ul><li>代码段</li><li>数据段</li><li>栈</li><li>堆</li><li>内核区</li></ul><p>栈区：局部变量和实参</p><p>堆区：OC 中使用 new 方法创建的对象</p><h4 id="6-load-父类、子类调用顺序？分类的-load-会调用吗？项目里有用到-load-吗？initialize"><a href="#6-load-父类、子类调用顺序？分类的-load-会调用吗？项目里有用到-load-吗？initialize" class="headerlink" title="6.+load 父类、子类调用顺序？分类的 +load 会调用吗？项目里有用到 +load 吗？initialize"></a>6.+load 父类、子类调用顺序？分类的 +load 会调用吗？项目里有用到 +load 吗？initialize</h4><p>先调用父类，后调用子类，再调用分类。</p><p>+load 调用顺序</p><p>1.先调用类的 +load</p><ul><li>按照编译先后顺序调用（先编译，先调用）</li><li>调用子类的 +load 之前会先调用父类的 +load</li></ul><p>2.再调用分类的 +load</p><ul><li>按照编译先后顺序调用（先编译，先调用）</li></ul><p>+initialize方法会在类第一次接收到消息时调用。+initialize 调用顺序：</p><ul><li>先调用父类的+initialize，再调用子类的+initialize</li><li>(先初始化父类，再初始化子类，每个类只会初始化1次)</li></ul><h4 id="7-Category-实现了本类的同名方法，有没有办法来调用本类的方法？"><a href="#7-Category-实现了本类的同名方法，有没有办法来调用本类的方法？" class="headerlink" title="7.Category 实现了本类的同名方法，有没有办法来调用本类的方法？"></a>7.Category 实现了本类的同名方法，有没有办法来调用本类的方法？</h4><p>Category 实现了本类的同名方法，会调用 Category 的同名方法。</p><h4 id="8-单链表是否有环"><a href="#8-单链表是否有环" class="headerlink" title="8.单链表是否有环"></a>8.单链表是否有环</h4><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasCycle</span>(<span class="hljs-params"> head </span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">let</span> slow = head;</span><br><span class="line">    <span class="hljs-keyword">let</span> fast = head;</span><br><span class="line">    <span class="hljs-keyword">while</span> (fast.next &amp;&amp; fast.next.next) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        <span class="hljs-keyword">if</span> (slow == fast) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-两个链表是否相交（怎么判断是否相交？怎么找交点）"><a href="#9-两个链表是否相交（怎么判断是否相交？怎么找交点）" class="headerlink" title="9.两个链表是否相交（怎么判断是否相交？怎么找交点）"></a>9.两个链表是否相交（怎么判断是否相交？怎么找交点）</h4><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">FindFirstCommonNode</span>(<span class="hljs-params">pHead1, pHead2</span>)</span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> mySet = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();</span><br><span class="line">    <span class="hljs-keyword">let</span> p1 = pHead1;</span><br><span class="line">    <span class="hljs-keyword">while</span> (p1) &#123;</span><br><span class="line">        mySet.add(p1);</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">let</span> p2 = pHead2;</span><br><span class="line">    <span class="hljs-keyword">while</span> (p2) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (mySet.has(p2)) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> p2;</span><br><span class="line">        &#125;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-两个字符串的最长相同子串的长度"><a href="#10-两个字符串的最长相同子串的长度" class="headerlink" title="10.两个字符串的最长相同子串的长度"></a>10.两个字符串的最长相同子串的长度</h4><p>题目链接：<a href="https://www.nowcoder.com/practice/f33f5adc55f444baa0e0ca87ad8a6aac?tpId=188&amp;&amp;tqId=38644&amp;rp=1&amp;ru=/ta/job-code-high-week&amp;qru=/ta/job-code-high-week/question-ranking" target="_blank" rel="noopener">NC127 最长公共子串</a></p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">LCS</span>(<span class="hljs-params"> str1 ,  str2 </span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (str1.length &gt; str2.length) &#123;</span><br><span class="line">        [str1, str2] = [str2, str1];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">let</span> res = <span class="hljs-string">""</span>;</span><br><span class="line">    <span class="hljs-keyword">let</span> len = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; str1.length; i++) &#123;</span><br><span class="line">        <span class="hljs-keyword">let</span> temp = str1.slice(i-len,i+<span class="hljs-number">1</span>);</span><br><span class="line">        <span class="hljs-keyword">if</span> (str2.indexOf(temp) !== <span class="hljs-number">-1</span>) &#123;</span><br><span class="line">            res = temp;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二面-1"><a href="#二面-1" class="headerlink" title="二面"></a>二面</h3><p>1.较难定位的 Crash 怎么定位？怎么判断是 OOM 导致的 Crash 还是其他导致的 Crach？</p><p>2.Jenkins+Fastlane 实现 CI，自动化的流程除了打包还能做什么？</p><p>3.Flutter 和原生开发你觉得有什么差异</p><p>4.HTTPDNS，使用和不使用有什么区别？有什么好处？</p><p>5.通知是同步的还是异步的，异步的通知什么时候会发出去，通知的原理，通知如何存储，多次添加通知，多次移除通知会有问题吗？</p><p>参考链接：<a href="https://blog.csdn.net/ZCMUCZX/article/details/78631447" target="_blank" rel="noopener">iOS-通知中心原理</a></p><p>6.屏幕显示的流程，CPU/GPU，离屏渲染是什么？光栅化的过程</p><p>7.安装包大小优化做了哪些？段迁移了解吗？</p><p>8.App 启动系统做了哪些事情，怎么优化启动速度</p><p>9.tableView 滑动流畅性优化</p><p>10.从点击屏幕到响应事件的流程</p><p>11.UIView 和 CALayer 的关系，为什么要这么设计</p><p>12.autoreleasePool 的原理，设计成双向链表有什么好处</p><p>13.最有成就感的项目，组件化的好处</p><p>14.如果 Code Review，你会关注哪些东西？</p><p>15.相对其他团队成员的优势</p><p>16.分享会怎么做，如果听众有 PM/测试，会怎么分享</p><p>17.团队里有成员不是特别优秀，怎么把控进度</p><p>18.了解百度的技术职级吗？你觉得自己是T几？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;百度知道面试题&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="百度" scheme="http://soso.wiki/tags/%E7%99%BE%E5%BA%A6/"/>
    
      <category term="百度知道" scheme="http://soso.wiki/tags/%E7%99%BE%E5%BA%A6%E7%9F%A5%E9%81%93/"/>
    
  </entry>
  
  <entry>
    <title>美团面试题</title>
    <link href="http://soso.wiki/2021-07-12-%E7%BE%8E%E5%9B%A2%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://soso.wiki/2021-07-12-美团面试题/</id>
    <published>2021-07-12T14:46:00.000Z</published>
    <updated>2024-04-26T08:34:44.313Z</updated>
    
    <content type="html"><![CDATA[<p>美团面试题<br><a id="more"></a></p><p>1.Runtime</p><p>2.Runloop</p><p>3.内存管理</p><p>4.组件化</p><p>5.Flutter</p><p>6.前端</p><p>7.iOS 引用计数和 GC 的区别</p><p>参考链接：<a href="https://www.jianshu.com/p/30efb565d42b" target="_blank" rel="noopener">简书-垃圾回收和自动引用计数</a></p><p>8.算法（二叉树最大深度）</p><p>LeetCode 题目链接：<a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">二叉树的最大深度</a></p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> max = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> maxDepth = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> max(maxDepth(root.left), maxDepth(root.right)) + <span class="hljs-number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;美团面试题&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="美团" scheme="http://soso.wiki/tags/%E7%BE%8E%E5%9B%A2/"/>
    
  </entry>
  
  <entry>
    <title>墨迹天气面试题</title>
    <link href="http://soso.wiki/%E5%A2%A8%E8%BF%B9%E5%A4%A9%E6%B0%94%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://soso.wiki/墨迹天气面试题/</id>
    <published>2021-06-24T06:33:00.000Z</published>
    <updated>2024-04-26T08:33:28.381Z</updated>
    
    <content type="html"><![CDATA[<p>墨迹天气面试题<br><a id="more"></a></p><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><p>1.Swift 与 OC 方法调用的区别</p><p>2.方法查找的过程，Runtime 消息机制，怎么避免无法识别的方法选择器的闪退？</p><p>3.Runtime 的应用</p><p>4.Category 和本类的同名方法执行哪个</p><p>5.线上卡顿怎么监测，监测原理 Runloop</p><p>6.做过哪些优化</p><p>7.多线程用的多吗？线程同步有哪些方案？锁的效率从高到低说一下</p><p>8.打印结果</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="hljs-keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="hljs-keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="hljs-built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"0"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"1"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), ^&#123;</span><br><span class="line">        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"2"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-built_in">dispatch_sync</span>(dispatch_get_global_queue(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), ^&#123;</span><br><span class="line">        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"3"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"4"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>9.Flutter 遇到过什么问题，图片列表滑动把不在屏幕上显示的内容干掉(复用)会有什么问题吗，优化方案</p><p>10.个人规划</p><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><p>1.Flutter 的状态管理</p><p>2.Flutter 布局，Expanded 和 Flex 布局的区别</p><p>3.InheritedWidget 用过吗？stream 用过吗？</p><p>4.Flutter 动画</p><p>5.webView 与 H5 交互，为什么没有考虑注册的方式，加载一个 H5 页面经历了哪些步骤？</p><p>6.HTTPS 增加了哪些流程？DNS 的过程</p><p>7.长链接，了解 webSocket 吗</p><p>8.直播推流的过程</p><p>9.内存管理，类的属性 p.name = @”zhangsan”; 和方法里的变量 NSString *name = @”zhangsan”; 分别存在哪里？</p><p>10.交换方法</p><p>11.Category 的本质</p><p>12.多线程，线程同步都有哪些方法，值为1的信号量和互斥锁有什么区别</p><p>13.算法：一个 int 数组，查找第 K 个大的数。</p><h3 id="二面-1"><a href="#二面-1" class="headerlink" title="二面"></a>二面</h3><p>1.介绍项目亮点</p><p>2.数据和链表区别</p><p>3.方法查找过程</p><p>4.frame bounds 区别，UIView、CALayer，动画</p><p>5.block  __block</p><p>6.内存优化  查找内存泄露</p><p>7.锁 自旋锁使用场景   互斥锁和信号量区别</p><p>8.方法交换是怎么交换的，注意点</p><p>9.链表是否有环</p><p>10.flutter 的状态管理</p><p>11.命令式编程与响应式编程</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;墨迹天气面试题&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="墨迹天气" scheme="http://soso.wiki/tags/%E5%A2%A8%E8%BF%B9%E5%A4%A9%E6%B0%94/"/>
    
  </entry>
  
  <entry>
    <title>人人车面试题</title>
    <link href="http://soso.wiki/%E4%BA%BA%E4%BA%BA%E8%BD%A6%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://soso.wiki/人人车面试题/</id>
    <published>2021-06-15T10:00:00.000Z</published>
    <updated>2023-04-04T13:21:43.572Z</updated>
    
    <content type="html"><![CDATA[<p>人人车面试题<br><a id="more"></a></p><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><p>1.了解哪些设计模式</p><p>2.MVVM 解决什么问题</p><p>3.性能优化</p><p>4.内存管理的理解</p><p>autoreleasePool 的结构，一个 autoreleasePoolPage 的大小</p><p>5.weak 的原理</p><p>6.class 的结构，cache 的结构，bucket_t 的结构，方法查找的顺序，是逐个遍历吗？</p><p>7.关联对象存在哪里</p><p>8.Category 的加载流程</p><p>9.Runtime 的应用，动态方法解析里返回 YES，但是并没有添加方法，会怎么样？</p><p>10.三次握手与四次挥手，四次挥手后会立马断开连接吗</p><p>11.Swift 解包方式</p><p>12.Swift 中计算属性和存储属性的区别</p><p>13.Swift 类和结构体的区别，使用属性的写法上的区别</p><p>14.数组和链表的区别</p><p>15.快速排序，快排时间复杂度</p><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><p>介绍项目</p><p>1.webView 与 H5 交互，拦截协议 url 有长度限制，有安全问题，可能会被抓包，JSBridge</p><p>2.埋点</p><ul><li><p>埋点保存/删除数据的时机</p></li><li><p>内存里的最大容量，收到内存警告</p></li><li><p>上报网络请求发送失败后的处理，埋点的补偿机制</p></li></ul><p>3.支付</p><p>4.页面 A push B  A willDisappear didDisappear B willAppear didAppear 的执行顺序</p><p>5.Person 类继承自 NSObject 类，没有实现 age 方法。两个实例 p1,p2，怎么让 p1 响应 age 方法，p2 不响应 age 方法。</p><p>6.消息发送机制和消息转发。</p><p>7.KVO 的实现原理</p><p>8.多个分类实现了同一个方法，查找顺序</p><p>9.Swift 的 String 为什么设计成值类型？</p><p>安全，copy，快速</p><p>10.设计 LRU 最近最少使用</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;人人车面试题&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="58" scheme="http://soso.wiki/tags/58/"/>
    
      <category term="人人车" scheme="http://soso.wiki/tags/%E4%BA%BA%E4%BA%BA%E8%BD%A6/"/>
    
  </entry>
  
  <entry>
    <title>快狗打车面试题</title>
    <link href="http://soso.wiki/%E5%BF%AB%E7%8B%97%E6%89%93%E8%BD%A6%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://soso.wiki/快狗打车面试题/</id>
    <published>2021-06-15T04:00:00.000Z</published>
    <updated>2023-04-02T00:18:40.677Z</updated>
    
    <content type="html"><![CDATA[<p>快狗打车面试题<br><a id="more"></a></p><p>1.dart 语法 <code>..</code> 是什么意思</p><p>2.怎么封装一个 Flutter 组件来让原生调用</p><p>3.用的网络请求库是哪个？Flutter 怎么抓包</p><p>4.state 的生命周期</p><p>5.buildContext 是接口、协议还是什么？</p><p>6.Widget 是什么</p><p>7.父子 widget 之间怎么传值，父 widget 怎么管理子 widget 的状态，怎么局部刷新？</p><p>8.同步可以使用 try catch 来捕获异常，带 Future 的异步方法的异常怎么捕获</p><p>9.单链表反转有几种方法，你觉得你的方法是最优的吗？</p><p>10.快速排序，轴点能不能用中间的一个数，怎么优化快排</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;快狗打车面试题&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="58" scheme="http://soso.wiki/tags/58/"/>
    
      <category term="快狗打车" scheme="http://soso.wiki/tags/%E5%BF%AB%E7%8B%97%E6%89%93%E8%BD%A6/"/>
    
  </entry>
  
  <entry>
    <title>货拉拉面试题</title>
    <link href="http://soso.wiki/%E8%B4%A7%E6%8B%89%E6%8B%89%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://soso.wiki/货拉拉面试题/</id>
    <published>2021-06-11T03:40:00.000Z</published>
    <updated>2023-04-02T00:17:41.758Z</updated>
    
    <content type="html"><![CDATA[<p>货拉拉面试题<br><a id="more"></a></p><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><p>1.Vue 用过哪些指令</p><p>2.v-model 有没有遇到过什么问题？数组里的对象赋值后 UI 未更新，需要使用 set 方法的原因是什么？</p><p>3.Vue 双向绑定是怎么实现的</p><p>4.说一下你对 Flutter 的理解，使用过哪些 Widget</p><p>5.Flutter 除了拆分组件还有什么方法能够使代码结构更清晰</p><p>6.Flutter 有没有跟原生交互的部分，有没有涉及双引擎/单引擎的问题</p><p>7.Masonry 和 SnapKit 的选择</p><p>8.做过哪些优化</p><p>9.说一下装饰模式</p><p>10.对 MVVM 的理解，什么情况下会选择 MVVM</p><p>11.多线程的几种实现方法如何选择，除了使用 dispatch_semaphore，还有什么更好用的方法来解决网络请求依赖，嵌套地狱的问题</p><p>12.Git 的使用，项目里有哪些分支</p><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><p>1.介绍最熟悉的项目，遇到的问题</p><p>2.项目架构</p><p>3.启动耗时，启动过程，启动优化</p><p>4.安装包大小优化，优化后的安装包大小有多大</p><p>5.图片加载优化</p><p>6.性能优化，内存、CPU 峰值多少，使用哪些工具分析性能</p><p>7.项目稳定性 crash率，有哪些闪退的问题</p><p>8.对象的内存结构</p><p>9.了解哪些设计模式</p><p>10.7层/5层网络模型，TCP/UDP 区别，TCP 的连接过程</p><p>11.Vue 的生命周期</p><p>12.介绍一个熟悉的排序算法</p><p>13.设计一个下载文件的需求（可能是多个文件，可能用到线程池；边下载边读取）</p><h3 id="三面（HR）"><a href="#三面（HR）" class="headerlink" title="三面（HR）"></a>三面（HR）</h3><p>1.主要的工作，遇到的挑战，最有成就感的事情，举个例子</p><p>2.管理的做的好的地方，有待改进的地方</p><p>3.其他家的机会到哪个阶段了，各个公司的比较</p><p>4.对货拉拉的意向高吗，对货拉拉的了解</p><p>5.选择一家公司比较看重哪些</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;货拉拉面试题&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="货拉拉" scheme="http://soso.wiki/tags/%E8%B4%A7%E6%8B%89%E6%8B%89/"/>
    
  </entry>
  
  <entry>
    <title>搜狐面试题</title>
    <link href="http://soso.wiki/%E6%90%9C%E7%8B%90%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://soso.wiki/搜狐面试题/</id>
    <published>2021-06-10T10:00:00.000Z</published>
    <updated>2023-04-02T00:22:13.476Z</updated>
    
    <content type="html"><![CDATA[<p>搜狐面试题<br><a id="more"></a></p><p>1.介绍一个印象深刻的项目，遇到过什么问题，怎么解决的。</p><p>组件化为什么没有用一个通用的字典来接收页面参数，这样不是更通用？</p><p>webView 交互协议怎么制定的？H5 从原生拿返回值怎么实现的？</p><p>2.做过哪些优化</p><p>3.你觉得你最擅长哪方面？比如 UI、架构啥的</p><p>4.微博详情页（内容、转发、评论）让你来做，你会怎么实现？从外层到内层用什么控件，具体实现。</p><p>5.算法题</p><p>有一个产品发布了多个版本，它遵循以下规则：假如某个版本崩溃了，则后面的所有版本都会崩溃。</p><p>举个例子：一个产品假如有5个版本，其中第1-3版本都是正常的，但是第4个版本崩溃了，那么第5个版本（最新版本）一定也崩溃，第4个版本被称为第一个崩溃版本。</p><p>现在已知一个产品有n个版本，而且有一个检查算法func isBadVersion(version:Int) -&gt; Bool 可以判断一个版本是否崩溃，假设这个产品的最新版本崩溃了，求第一个崩溃的版本。</p><p>思路：本质上是有重复数字的升序数组的二分查找</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">search</span>(<span class="hljs-params"> nums ,  target </span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> start = <span class="hljs-number">0</span></span><br><span class="line">    <span class="hljs-keyword">if</span>(!nums.length) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;</span><br><span class="line">    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="hljs-keyword">let</span> mid = <span class="hljs-built_in">Math</span>.floor((left + right) / <span class="hljs-number">2</span>);</span><br><span class="line">        <span class="hljs-keyword">if</span>(target == nums[mid]) &#123;</span><br><span class="line">            <span class="hljs-keyword">while</span>(mid != <span class="hljs-number">0</span> &amp;&amp; nums[mid - <span class="hljs-number">1</span>] == nums[mid]) mid--; <span class="hljs-comment">// 找到第一个数</span></span><br><span class="line">            <span class="hljs-keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(target &lt; nums[mid]) &#123;</span><br><span class="line">            right = mid - <span class="hljs-number">1</span>;</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="hljs-number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.想实现一个图片，删除后撤销删除，你会用什么数据结构来怎么实现？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;搜狐面试题&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="搜狐" scheme="http://soso.wiki/tags/%E6%90%9C%E7%8B%90/"/>
    
      <category term="狐友" scheme="http://soso.wiki/tags/%E7%8B%90%E5%8F%8B/"/>
    
  </entry>
  
  <entry>
    <title>达达面试题</title>
    <link href="http://soso.wiki/%E8%BE%BE%E8%BE%BE%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://soso.wiki/达达面试题/</id>
    <published>2021-06-08T12:40:00.000Z</published>
    <updated>2023-04-02T00:14:07.059Z</updated>
    
    <content type="html"><![CDATA[<p>达达面试题<br><a id="more"></a></p><h4 id="1-深拷贝、浅拷贝区别。数组里放对象，copy-数组，是深拷贝还是浅拷贝？数组里对象的指针是一样的吗？"><a href="#1-深拷贝、浅拷贝区别。数组里放对象，copy-数组，是深拷贝还是浅拷贝？数组里对象的指针是一样的吗？" class="headerlink" title="1.深拷贝、浅拷贝区别。数组里放对象，copy 数组，是深拷贝还是浅拷贝？数组里对象的指针是一样的吗？"></a>1.深拷贝、浅拷贝区别。数组里放对象，copy 数组，是深拷贝还是浅拷贝？数组里对象的指针是一样的吗？</h4><ul><li><p>浅拷贝：指针拷贝，不会创建一个新的对象。对指向对象的指针拷贝，产生一个新的指向对象的指针。两个指针指向同一个对象。对象的引用计数+1；</p></li><li><p>深拷贝：内容拷贝，会创建一个新的对象。深拷贝就是拷贝地址中的内容。</p></li></ul><p>深拷贝和浅拷贝的本质是内存地址是否相同。</p><p>copy 可变数组是深拷贝。copy 不可变数组是浅拷贝。数组里对象的指针是一样的。</p><table><thead><tr><th></th><th>copy</th><th>mutableCopy</th></tr></thead><tbody><tr><td>NSString</td><td>NSString 浅拷贝</td><td>NSMutableString 深拷贝</td></tr><tr><td>NSMutableString</td><td>NSString 深拷贝</td><td>NSMutableString 深拷贝</td></tr><tr><td>NSArray</td><td>NSArray 浅拷贝</td><td>NSMutableArray 深拷贝</td></tr><tr><td>NSMutableArray</td><td>NSArray 深拷贝</td><td>NSMutableArray 深拷贝</td></tr><tr><td>NSDictionary</td><td>NSDictionary 浅拷贝</td><td>NSMutableDictionary 深拷贝</td></tr><tr><td>NSMutableDictionary</td><td>NSDictionary 深拷贝</td><td>NSMutableDictionary 深拷贝</td></tr></tbody></table><h4 id="2-布局使用-Masony-还是-Xib"><a href="#2-布局使用-Masony-还是-Xib" class="headerlink" title="2.布局使用 Masony 还是 Xib"></a>2.布局使用 Masony 还是 Xib</h4><h4 id="3-StatefulWidget、StatelessWidget-区别"><a href="#3-StatefulWidget、StatelessWidget-区别" class="headerlink" title="3.StatefulWidget、StatelessWidget 区别"></a>3.StatefulWidget、StatelessWidget 区别</h4><ul><li>Widget 是部分界面的不可变的描述信息。</li><li>StatelessWidget 和 StatefulWidget 没有本质区别，他们的所有属性都是不可变的。它们都没法更新，除非用一个新的 Widget 去替换它们。</li><li>StatefulWidget 拥有一个可变的 State。</li></ul><p>StatefulWidget 和 StatelessWidget 的区别在于可变的 State。本质区别是能否自我重新构建（self rebuild）。</p><p><img src="/images/flutter/StatelessWidget和StatefulWidget区别.jpeg" alt="StatelessWidget和StatefulWidget区别"></p><p>参考链接：<a href="https://www.jianshu.com/p/d56e9c758b26" target="_blank" rel="noopener">简书-StatelessWidget和StatefulWidget的区别</a></p><h4 id="4-UITableView、UICollectionView-的调用流程区别"><a href="#4-UITableView、UICollectionView-的调用流程区别" class="headerlink" title="4.UITableView、UICollectionView 的调用流程区别"></a>4.UITableView、UICollectionView 的调用流程区别</h4><h4 id="5-常用的-pod-命令"><a href="#5-常用的-pod-命令" class="headerlink" title="5.常用的 pod 命令"></a>5.常用的 pod 命令</h4><p><code>pod init</code>: 创建 Podfile 文件。</p><p><code>pod install</code>：会根据 podfile.lock 文件中指定的 pod 依赖库的版本去拉去项目的 pod 依赖库。</p><p><code>pod install --no-repo-update</code>: 协作开发时使用此命令可以根据 podfile.lock 文件限制第三方库的版本。</p><p><code>pod update</code>：这个命令会检查 podfile.lock 文件中的 pod 依赖库的版本，并进行更新，会重新生成一个 podfile.lock 文件。</p><p><code>pod repo add NAME URL[branch]</code> ：添加 pod 源。</p><p><code>pod search</code>：搜索可以使用的 pod 依赖库。</p><p><code>pod list</code>：列出所有项目依赖仓库中的 pod 依赖库。</p><p><code>pod repo</code>：用来管理 pod 依赖仓库的地址。</p><p><code>pod spec</code>：管理 pod 规范。</p><p><code>pod env</code>：来打印出 pod 的环境，一般是 podfile 文件中的内容。</p><p><code>pod cache</code>：管理 cocoapod 的缓存：可以用来清空内存，也可以用来查看每个 pod 库的缓存。</p><p><strong>制作私有库使用</strong></p><p><code>pod lib create [仓库名]</code>：在本地创建一个基于 pod 模板的 git 仓库。</p><p><code>pod lib lint</code>：pod 本地库验证，验证 .podspec 文件是否有错。</p><p><code>pod repo add NAME URL[branch]</code>：添加自己的 pod 仓库。</p><p><code>pod spec lint</code>：pod 远程库验证。</p><p><code>pod repo add xxx https://gitxxxx</code> ：放置 spec 文件的 git 仓库地址，给自己添加私有仓库。</p><p><code>pod repo push 索引库名 podspec文件名</code>：命令执行会先将 pod 索引添加到本地的索引库，然后会自动推送到远程的索引库。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Commands:</span><br><span class="line">    + cache         Manipulate the CocoaPods cache</span><br><span class="line">    + deintegrate   Deintegrate CocoaPods from your project</span><br><span class="line">    + env           Display pod environment</span><br><span class="line">    + init          Generate a Podfile for the current directory</span><br><span class="line">    + install       Install project dependencies according to versions from a</span><br><span class="line">                    Podfile.lock</span><br><span class="line">    + ipc           Inter-process communication</span><br><span class="line">    + lib           Develop pods</span><br><span class="line">    + list          List pods</span><br><span class="line">    + outdated      Show outdated project dependencies</span><br><span class="line">    + plugins       Show available CocoaPods plugins</span><br><span class="line">    + repo          Manage spec-repositories</span><br><span class="line">    + search        Search for pods</span><br><span class="line">    + setup         Setup the CocoaPods environment</span><br><span class="line">    + spec          Manage pod specs</span><br><span class="line">    + trunk         Interact with the CocoaPods API (e.g. publishing new specs)</span><br><span class="line">    + try           Try a Pod!</span><br><span class="line">    + update        Update outdated project dependencies and create new</span><br><span class="line">                    Podfile.lock</span><br></pre></td></tr></table></figure><h4 id="6-图文混排有没有做过，有没有内存、性能问题"><a href="#6-图文混排有没有做过，有没有内存、性能问题" class="headerlink" title="6.图文混排有没有做过，有没有内存、性能问题"></a>6.图文混排有没有做过，有没有内存、性能问题</h4><p>参考链接：<a href="https://www.jianshu.com/p/73d098d638cf" target="_blank" rel="noopener">简书-iOS开发之富文本(图文混排)</a></p><h4 id="7-写过哪些脚本，有没有写过函数，按顺序执行的函数。"><a href="#7-写过哪些脚本，有没有写过函数，按顺序执行的函数。" class="headerlink" title="7.写过哪些脚本，有没有写过函数，按顺序执行的函数。"></a>7.写过哪些脚本，有没有写过函数，按顺序执行的函数。</h4><p>bugly、Fastlane、切换 SDK 配置文件</p><p>参考链接：<a href="https://www.runoob.com/linux/linux-shell.html" target="_blank" rel="noopener">菜鸟教程- Shell 教程</a></p><h4 id="8-闪退捕获，Flutter-错误捕获"><a href="#8-闪退捕获，Flutter-错误捕获" class="headerlink" title="8.闪退捕获，Flutter 错误捕获"></a>8.闪退捕获，Flutter 错误捕获</h4><figure class="highlight dart hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">void</span> main() &#123;</span><br><span class="line">     <span class="hljs-comment">// Flutter framework 异常捕获</span></span><br><span class="line">     FlutterError.onError = (FlutterErrorDetails details) &#123;</span><br><span class="line">       <span class="hljs-built_in">bool</span> isDebugMode = <span class="hljs-keyword">false</span>;</span><br><span class="line">       <span class="hljs-keyword">assert</span>(() &#123;</span><br><span class="line">         isDebugMode = <span class="hljs-keyword">true</span>;</span><br><span class="line">         <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">       &#125;());</span><br><span class="line">       <span class="hljs-keyword">if</span> (isDebugMode) &#123;</span><br><span class="line">         FlutterError.dumpErrorToConsole(details);</span><br><span class="line">       &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">         <span class="hljs-comment">//profile,release两个模式下下捕捉异常信息</span></span><br><span class="line">         reportFrameworkError(details);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">     <span class="hljs-comment">// 其他类型异常</span></span><br><span class="line">     runZoned(</span><br><span class="line">       () =&gt; runAutoSizeApp(MyApp(), width: <span class="hljs-number">375</span>, height: <span class="hljs-number">667</span>),</span><br><span class="line">       onError: (<span class="hljs-keyword">dynamic</span> ex, StackTrace stack) &#123;</span><br><span class="line">         reportError(ex, stack);</span><br><span class="line">       &#125;,</span><br><span class="line">     );</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>参考链接：<a href="https://www.jianshu.com/p/854d7e7eb2cf" target="_blank" rel="noopener">Flutter异常捕捉原理和异常上报</a></p><h4 id="9-埋点是怎么做的？页面上的某一个-view-的停留时长怎么统计？"><a href="#9-埋点是怎么做的？页面上的某一个-view-的停留时长怎么统计？" class="headerlink" title="9.埋点是怎么做的？页面上的某一个 view 的停留时长怎么统计？"></a>9.埋点是怎么做的？页面上的某一个 view 的停留时长怎么统计？</h4><h4 id="10-性能优化、图片加载优化、安装包大小优化做了啥，没用到的代码或图片有写脚本来检查吗？"><a href="#10-性能优化、图片加载优化、安装包大小优化做了啥，没用到的代码或图片有写脚本来检查吗？" class="headerlink" title="10.性能优化、图片加载优化、安装包大小优化做了啥，没用到的代码或图片有写脚本来检查吗？"></a>10.性能优化、图片加载优化、安装包大小优化做了啥，没用到的代码或图片有写脚本来检查吗？</h4><ul><li><p>未使用的代码可以用 AppCode 来检测。</p></li><li><p>未使用的图片可以用 <a href="https://github.com/tinymind/LSUnusedResources" target="_blank" rel="noopener">LSUnusedResources</a> 来检测。</p></li></ul><h4 id="12-界面渲染流程、UIView-渲染流程，有没有做过异步绘制？"><a href="#12-界面渲染流程、UIView-渲染流程，有没有做过异步绘制？" class="headerlink" title="12.界面渲染流程、UIView 渲染流程，有没有做过异步绘制？"></a>12.界面渲染流程、UIView 渲染流程，有没有做过异步绘制？</h4><p><img src="/images/ios/UIView的绘制原理.png" alt="UIView的绘制原理"></p><p><img src="/images/ios/系统绘制流程.png" alt="系统绘制流程"></p><p><img src="/images/ios/异步绘制时序图.png" alt="异步绘制时序图"></p><h4 id="13-解决遇到的线程问题描述一下，在子线程刷新-UI-会怎么样？"><a href="#13-解决遇到的线程问题描述一下，在子线程刷新-UI-会怎么样？" class="headerlink" title="13.解决遇到的线程问题描述一下，在子线程刷新 UI 会怎么样？"></a>13.解决遇到的线程问题描述一下，在子线程刷新 UI 会怎么样？</h4><h4 id="14-有没有做过组件模块化？"><a href="#14-有没有做过组件模块化？" class="headerlink" title="14.有没有做过组件模块化？"></a>14.有没有做过组件模块化？</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;达达面试题&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="京东" scheme="http://soso.wiki/tags/%E4%BA%AC%E4%B8%9C/"/>
    
      <category term="达达" scheme="http://soso.wiki/tags/%E8%BE%BE%E8%BE%BE/"/>
    
      <category term="京东到家" scheme="http://soso.wiki/tags/%E4%BA%AC%E4%B8%9C%E5%88%B0%E5%AE%B6/"/>
    
  </entry>
  
  <entry>
    <title>一点资讯面试题</title>
    <link href="http://soso.wiki/%E4%B8%80%E7%82%B9%E8%B5%84%E8%AE%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://soso.wiki/一点资讯面试题/</id>
    <published>2021-06-08T04:00:00.000Z</published>
    <updated>2023-04-02T00:24:00.480Z</updated>
    
    <content type="html"><![CDATA[<p>一点资讯面试题<br><a id="more"></a></p><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><p>1.Flutter 与原生怎么交互</p><p>2.Flutter 跳转原生页面，原生跳转 Flutter 页面怎么实现？</p><p>3.Widget、StatefulWidget、StatelessWidget 区别</p><p>4.Flutter 的三棵树（Widget 树等）</p><p>5.setState 实现源码看过吗？内部实现原理</p><p>6.KVO 实现原理</p><p>7.Runtime 流程，怎么避免方法找不到的闪退</p><p>8.数组插入空安全怎么实现的？交换方法写在哪里？为什么不写在 initialize 里？</p><p>9.两个分类里同名方法执行哪个？</p><p>10.isa 指针的指向，isa 的结构</p><p>11.<code>__block</code> 的原理，全局变量需要捕获吗？</p><p>12.闪退率，Flutter 的闪退怎么监控？</p><p>13.做过哪些优化？FPS 优化，启动优化，安装包大小优化</p><p>14.做过哪些组件？</p><p>15.字符串反转</p><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><p>1.autoreleasepool 什么时候释放</p><p>2.deviceId 怎么确保唯一性</p><p>3.微信 Mac 端登录为什么要做成扫描二维码的方式？怎么实现的？</p><p>4.个人优缺点，未来规划，看机会原因</p><p>5.怎么学习一门新技术</p><h3 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h3><p>1.介绍项目，项目 DAU</p><p>2.心跳包是自己实现的吗？心跳包停掉有没有遇到过？</p><p>3.有没有 offer，觉得一点的优势跟不足，其他一些私人问题</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一点资讯面试题&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="一点资讯" scheme="http://soso.wiki/tags/%E4%B8%80%E7%82%B9%E8%B5%84%E8%AE%AF/"/>
    
  </entry>
  
  <entry>
    <title>恒天财富面试题</title>
    <link href="http://soso.wiki/%E6%81%92%E5%A4%A9%E8%B4%A2%E5%AF%8C%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://soso.wiki/恒天财富面试题/</id>
    <published>2021-06-04T15:50:00.000Z</published>
    <updated>2023-04-02T00:17:28.609Z</updated>
    
    <content type="html"><![CDATA[<p>恒天财富面试题<br><a id="more"></a></p><h4 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h4><p>1.KVO 的实现原理</p><p>2.Category 的底层结构，Category 能添加成员变量吗？为什么？</p><p>3.load 和 initialize 的区别？initialize 的调用顺序？</p><p>4.Block 为什么用 copy？Block 的类型？Block 的结构</p><p>5.Runtime 的消息流程</p><p>6.说说你了解的 Runloop</p><p>7.项目亮点</p><p>8.怎么实现 webView 秒开 H5</p><p>9.项目优化</p><h4 id="二面（前端负责人）"><a href="#二面（前端负责人）" class="headerlink" title="二面（前端负责人）"></a>二面（前端负责人）</h4><p>1.打开一个 App，首页关掉网络后还可以显示一些内容，怎么实现的，有落地吗？</p><p>2.webView 跟 H5 交互方式？是 url scheme 吗？Bridge 用了吗</p><p>3.从加载 H5 到界面显示出来这段时间的白屏发生了什么？</p><p>4.打开一个示例 App，webView 加载 H5 秒开？离线包了解吗？行业解决方案</p><p>5.Vue 的生命周期</p><p>6.v-if 的作用</p><p>7.父子组件怎么传值？</p><p>8.知道 vuex 吗？</p><h4 id="三面（后端负责人）"><a href="#三面（后端负责人）" class="headerlink" title="三面（后端负责人）"></a>三面（后端负责人）</h4><p>1.介绍项目模块，项目分工</p><p>2.安卓 App 提示更新，更新一半退出再进来，从头下载了。断点续传怎么做？</p><p>3.查看药店首页，白屏 loading 时间长怎么优化？</p><p>4.webView 白屏怎么优化？</p><p>5.做过哪些具体的优化</p><p>6.除了埋点还有什么方式排查问题？不能复现的问题怎么查？</p><p>四面（部门负责人）</p><p>HR</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;恒天财富面试题&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="恒天财富" scheme="http://soso.wiki/tags/%E6%81%92%E5%A4%A9%E8%B4%A2%E5%AF%8C/"/>
    
  </entry>
  
  <entry>
    <title>首汽租车面试题</title>
    <link href="http://soso.wiki/%E9%A6%96%E6%B1%BD%E7%A7%9F%E8%BD%A6%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://soso.wiki/首汽租车面试题/</id>
    <published>2021-06-04T03:49:00.000Z</published>
    <updated>2023-04-02T00:22:02.892Z</updated>
    
    <content type="html"><![CDATA[<p>首汽租车面试题<br><a id="more"></a></p><p>1.什么是野指针？什么情况下会野指针？</p><p>2.打印结果：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="hljs-keyword">void</span>)testWeak &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">id</span> obj1 = <span class="hljs-string">@"12131"</span>;</span><br><span class="line">    __<span class="hljs-keyword">weak</span> <span class="hljs-keyword">id</span> obj2 = obj1;</span><br><span class="line">    <span class="hljs-keyword">id</span> obj3 = [<span class="hljs-built_in">NSObject</span> new];</span><br><span class="line">    __<span class="hljs-keyword">weak</span> <span class="hljs-keyword">id</span> obj4 = [[<span class="hljs-built_in">NSObject</span> alloc] init];</span><br><span class="line">    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"obj1:%@ obj2:%@ obj3:%@ obj4:%@"</span>,obj1,obj2,obj3,obj4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.子类怎么重写父类的属性？问题简化怎么重写一个类的属性？只重写set方法可以吗？</p><p>4.了解哪些设计模式？单例有哪些不好的地方？</p><p>5.说一下响应者链</p><p>6.Masonry 链式调用的实现，实现一个控制器，属性的链式调用（手写）</p><p>7.打印结果：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="hljs-keyword">void</span>)testGCD &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="hljs-string">"testqueue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"1"</span>);</span><br><span class="line">        <span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"2"</span>);</span><br><span class="line">            <span class="hljs-built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">                <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"3"</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"4"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"5"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>8.项目亮点或难点</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首汽租车面试题&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="首汽租车" scheme="http://soso.wiki/tags/%E9%A6%96%E6%B1%BD%E7%A7%9F%E8%BD%A6/"/>
    
      <category term="首汽" scheme="http://soso.wiki/tags/%E9%A6%96%E6%B1%BD/"/>
    
  </entry>
  
  <entry>
    <title>豆瓣面试题</title>
    <link href="http://soso.wiki/%E8%B1%86%E7%93%A3%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://soso.wiki/豆瓣面试题/</id>
    <published>2021-05-26T05:39:00.000Z</published>
    <updated>2023-04-02T00:15:55.065Z</updated>
    
    <content type="html"><![CDATA[<p>豆瓣面试题<br><a id="more"></a></p><h4 id="1-是在大学里学的-iOS-吗？怎么学的-iOS？"><a href="#1-是在大学里学的-iOS-吗？怎么学的-iOS？" class="headerlink" title="1.是在大学里学的 iOS 吗？怎么学的 iOS？"></a>1.是在大学里学的 iOS 吗？怎么学的 iOS？</h4><h4 id="2-判断2个单链表是否交叉-实现代码-如果有交叉找出交叉点。"><a href="#2-判断2个单链表是否交叉-实现代码-如果有交叉找出交叉点。" class="headerlink" title="2.判断2个单链表是否交叉,实现代码,如果有交叉找出交叉点。"></a>2.判断2个单链表是否交叉,实现代码,如果有交叉找出交叉点。</h4><p><strong>方法一：哈希表法</strong></p><p>遍历链表 A 并将每个结点的地址/引用存储在哈希表中。然后检查链表 B 中的每一个结点 bi是否在哈希表中。若在，则 bi为相交结点。</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> getIntersectionNode = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">headA, headB</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> mySet = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();</span><br><span class="line">    <span class="hljs-keyword">let</span> curr = headA;</span><br><span class="line">    <span class="hljs-keyword">while</span> (curr != <span class="hljs-literal">null</span>) &#123;</span><br><span class="line">        mySet.add(curr);</span><br><span class="line">        curr = curr.next;</span><br><span class="line">    &#125;</span><br><span class="line">    curr = headB;</span><br><span class="line">    <span class="hljs-keyword">while</span> (curr != <span class="hljs-literal">null</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (mySet.has(curr)) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> curr;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>方法二：双指针法</strong></p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> getIntersectionNode = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">headA, headB</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (headA == <span class="hljs-literal">null</span> || headB == <span class="hljs-literal">null</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">let</span> pA = headA, pB = headB;</span><br><span class="line">    <span class="hljs-keyword">while</span> (pA != pB) &#123;</span><br><span class="line">        pA = pA == <span class="hljs-literal">null</span> ? headB : pA.next;</span><br><span class="line">        pB = pB == <span class="hljs-literal">null</span> ? headA : pB.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> pA;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3-说一下-property-属性修饰符，block-为什么用-copy-？weak-的实现原理？atomic-怎么保证安全？怎么解决读写安全？"><a href="#3-说一下-property-属性修饰符，block-为什么用-copy-？weak-的实现原理？atomic-怎么保证安全？怎么解决读写安全？" class="headerlink" title="3.说一下 @property 属性修饰符，block 为什么用 copy ？weak 的实现原理？atomic 怎么保证安全？怎么解决读写安全？"></a>3.说一下 @property 属性修饰符，block 为什么用 copy ？weak 的实现原理？atomic 怎么保证安全？怎么解决读写安全？</h4><p>@property 什么都不写</p><p>基本数据类型默认修饰符是 atomic, readWrite, assign</p><p>对象类型默认修饰符是 atomic, readWrite, strong</p><p><strong>block 为什么用 copy？</strong></p><p>如果是全局静态 block 的话，它直到程序结束的时候，才会被被释放。但是我们实际操作中基本上不会使用到不访问外部变量的 block。</p><p>如果是保存在栈中的 block，它会随着函数调用结束被销毁。从而导致我们在执行一个包含 block 的函数之后，就无法再访问这个 block。因为（函数结束，函数栈就销毁了，存在函数里面的 block 也就没有了），我们再使用 block 时，就会产生空指针异常。</p><p>如果是堆中的 block，也就是 copy 修饰的 block。他的生命周期就是随着对象的销毁而结束的。只要对象不销毁，我们就可以调用的到在堆中的 block。</p><p>这就是为什么我们要用 copy 来修饰 block。因为不用 copy 修饰的访问外部变量的 block，只在他所在的函数被调用的那一瞬间可以使用。之后就消失了。</p><p><strong>weak 的实现原理</strong></p><p>参考链接：<a href="http://www.cocoachina.com/articles/18962" target="_blank" rel="noopener">iOS 底层解析weak的实现原理</a></p><p><strong>atomic 怎么保证安全？</strong></p><p>属性声明为atomic时，在该属性在调用getter和setter方法时，会加上同步锁，即在属性在调用getter和setter方法时，保证同一时刻只能有一个线程调用属性的读/写方法。保证了读和写的过程是可靠的。但并不能保证数据一定是可靠的。</p><p><strong>怎么解决读写安全？</strong></p><ul><li>dispatch_barrier_async</li><li>pthread_rwlock：读写锁</li></ul><h4 id="4-OSSPinLock-为什么不用了？"><a href="#4-OSSPinLock-为什么不用了？" class="headerlink" title="4.OSSPinLock 为什么不用了？"></a>4.OSSPinLock 为什么不用了？</h4><p>系统维护了 5 个不同的线程优先级/QoS: background，utility，default，user-initiated，user-interactive。高优先级线程始终会在低优先级线程前执行，一个线程不会受到比它更低优先级线程的干扰。这种线程调度算法会产生潜在的优先级反转问题，从而破坏了 spin lock。</p><p>具体来说，如果一个低优先级的线程获得锁并访问共享资源，这时一个高优先级的线程也尝试获得这个锁，它会处于 spin lock 的忙等状态从而占用大量 CPU。此时低优先级线程无法与高优先级线程争夺 CPU 时间，从而导致任务迟迟完不成、无法释放 lock。这并不只是理论上的问题，libobjc 已经遇到了很多次这个问题了，于是苹果的工程师停用了 OSSpinLock。</p><p>参考链接：<a href="https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/" target="_blank" rel="noopener">不再安全的 OSSpinLock</a></p><h4 id="5-同时请求两张图片，之后合成一张图"><a href="#5-同时请求两张图片，之后合成一张图" class="headerlink" title="5.同时请求两张图片，之后合成一张图"></a>5.同时请求两张图片，之后合成一张图</h4><ul><li>dispatch_group 配合 dispatch_semaphore</li><li>dispatch_group dispatch_enter dispatch_leave</li><li>dispatch_barrier</li></ul><p>还有其他的方式吗？只使用 dispatch_semphore 和 dispatch_async 怎么实现？</p><h4 id="6-Runloop-有哪些使用场景？"><a href="#6-Runloop-有哪些使用场景？" class="headerlink" title="6.Runloop 有哪些使用场景？"></a>6.Runloop 有哪些使用场景？</h4><ul><li>控制线程生命周期，实现常驻线程。</li><li><p>TableView 延迟加载图片。滑动时不调用赋值图片的方法，等滑动完毕切换到 NSDefaultRunLoopMode 时才调用。</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="hljs-keyword">self</span>.img performSelector:<span class="hljs-keyword">@selector</span>(setImage:) withObject:image afterDelay:<span class="hljs-number">0</span> inModes:[<span class="hljs-built_in">NSDefaultRunLoopMode</span>]];</span><br></pre></td></tr></table></figure></li><li><p>解决 NSTimer 在滑动时停止的问题。</p></li><li>监测 RunLoop 的状态监测应用卡顿。</li></ul><h4 id="7-子线程怎么销毁？换一种问法，常驻线程怎么销毁？NSPort-的生命周期怎么控制？"><a href="#7-子线程怎么销毁？换一种问法，常驻线程怎么销毁？NSPort-的生命周期怎么控制？" class="headerlink" title="7.子线程怎么销毁？换一种问法，常驻线程怎么销毁？NSPort 的生命周期怎么控制？"></a>7.子线程怎么销毁？换一种问法，常驻线程怎么销毁？NSPort 的生命周期怎么控制？</h4><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="hljs-keyword">void</span>)_stopThread &#123;</span><br><span class="line">    <span class="hljs-keyword">self</span>.isRun = <span class="hljs-literal">NO</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 停止当前线程的Runloop</span></span><br><span class="line">    <span class="hljs-built_in">CFRunLoopStop</span>(<span class="hljs-built_in">CFRunLoopGetCurrent</span>());</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">self</span>.innerThread = <span class="hljs-literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考链接：<a href="https://juejin.cn/post/6868551023439544333" target="_blank" rel="noopener">iOS RunLoop 常驻线程简化实现</a></p><h4 id="8-说一下响应者链。有三个视图-A、B、C-依次被添加到-self-view-上，frame-相同，复写-C-的-pointInSide-方法缩小范围，点击-C-的边缘-C-会响应吗？C-不响应的话，B-会响应吗？"><a href="#8-说一下响应者链。有三个视图-A、B、C-依次被添加到-self-view-上，frame-相同，复写-C-的-pointInSide-方法缩小范围，点击-C-的边缘-C-会响应吗？C-不响应的话，B-会响应吗？" class="headerlink" title="8.说一下响应者链。有三个视图 A、B、C 依次被添加到 self.view 上，frame 相同，复写 C 的 pointInSide 方法缩小范围，点击 C 的边缘 C 会响应吗？C 不响应的话，B 会响应吗？"></a>8.说一下响应者链。有三个视图 A、B、C 依次被添加到 self.view 上，frame 相同，复写 C 的 pointInSide 方法缩小范围，点击 C 的边缘 C 会响应吗？C 不响应的话，B 会响应吗？</h4><p>点击 C 的边缘 C 不会响应，B 会响应。</p><h4 id="9-组件是怎么拆分的？组件化是怎么传值的？组件的注册是写在哪里的？写在-load-会不会有性能问题？怎么解决？"><a href="#9-组件是怎么拆分的？组件化是怎么传值的？组件的注册是写在哪里的？写在-load-会不会有性能问题？怎么解决？" class="headerlink" title="9.组件是怎么拆分的？组件化是怎么传值的？组件的注册是写在哪里的？写在 +load 会不会有性能问题？怎么解决？"></a>9.组件是怎么拆分的？组件化是怎么传值的？组件的注册是写在哪里的？写在 +load 会不会有性能问题？怎么解决？</h4><p>参考链接：<a href="https://zhuanlan.zhihu.com/p/22565656" target="_blank" rel="noopener">iOS组件化方案</a></p><h4 id="10-了解-HTTPDNS-吗？询问的操作是谁去问？本层-gt-上层-gt-上上层"><a href="#10-了解-HTTPDNS-吗？询问的操作是谁去问？本层-gt-上层-gt-上上层" class="headerlink" title="10.了解 HTTPDNS 吗？询问的操作是谁去问？本层-&gt;上层-&gt;上上层"></a>10.了解 HTTPDNS 吗？询问的操作是谁去问？本层-&gt;上层-&gt;上上层</h4><ul><li>使用HTTP（HTTPS）协议绕过运营商的 Local DNS，避免域名劫持，也更准确地判断客户端地区和运营商，得到更精准的解析结果；</li><li>HTTPDNS 能够直接得到客户端的出口网关 IP，从而更准确地判断客户端地区和运营商，得到更精准的解析结果；</li></ul><p>参考链接：<a href="https://help.aliyun.com/product/30100.html?spm=a2c4g.11186623.6.540.1ea63eabsBELsu" target="_blank" rel="noopener">HTTPDNS</a></p><h4 id="11-性能优化，tableView-怎么缓存行高？高度存在哪儿？key-是什么？横竖屏怎么缓存行高？一个页面大概率不会横屏，缓存横竖屏两份行高是不是有些浪费，怎么去处理行高？tableView-怎么控制缓存数量，比如最大1000条数据的缓存量。"><a href="#11-性能优化，tableView-怎么缓存行高？高度存在哪儿？key-是什么？横竖屏怎么缓存行高？一个页面大概率不会横屏，缓存横竖屏两份行高是不是有些浪费，怎么去处理行高？tableView-怎么控制缓存数量，比如最大1000条数据的缓存量。" class="headerlink" title="11.性能优化，tableView 怎么缓存行高？高度存在哪儿？key 是什么？横竖屏怎么缓存行高？一个页面大概率不会横屏，缓存横竖屏两份行高是不是有些浪费，怎么去处理行高？tableView 怎么控制缓存数量，比如最大1000条数据的缓存量。"></a>11.性能优化，tableView 怎么缓存行高？高度存在哪儿？key 是什么？横竖屏怎么缓存行高？一个页面大概率不会横屏，缓存横竖屏两份行高是不是有些浪费，怎么去处理行高？tableView 怎么控制缓存数量，比如最大1000条数据的缓存量。</h4><p>提前计算好cell的高度,缓存在相应的数据源模型中。cellHeight</p><h4 id="12-加载大图，地图这种大图怎么加载优化？系统-API-的原理是什么？"><a href="#12-加载大图，地图这种大图怎么加载优化？系统-API-的原理是什么？" class="headerlink" title="12.加载大图，地图这种大图怎么加载优化？系统 API 的原理是什么？"></a>12.加载大图，地图这种大图怎么加载优化？系统 API 的原理是什么？</h4><ul><li>分片比例裁剪方式。参考苹果给出的 <a href="https://developer.apple.com/library/ios/samplecode/LargeImageDownsizing/" target="_blank" rel="noopener">demo</a>,利用 CGImageCreateWithImageInRect 截取原图对应位置的内容,再通过 CGContextDrawImage 渲染到指定位置;</li><li>利用 CATiledLayer 层级的API,自动进行绘制;</li></ul><p>参考链接：<a href="https://www.jianshu.com/p/2d9e58d67d87" target="_blank" rel="noopener">iOS 大图显示解决办法</a></p><h4 id="13-项目怎么分工的？你负责什么？有没有什么值得说的点？H5-与原生交互有什么经验分享吗？怎么给-webView-加载的页面发的网络请求统一加上-header？"><a href="#13-项目怎么分工的？你负责什么？有没有什么值得说的点？H5-与原生交互有什么经验分享吗？怎么给-webView-加载的页面发的网络请求统一加上-header？" class="headerlink" title="13.项目怎么分工的？你负责什么？有没有什么值得说的点？H5 与原生交互有什么经验分享吗？怎么给 webView 加载的页面发的网络请求统一加上 header？"></a>13.项目怎么分工的？你负责什么？有没有什么值得说的点？H5 与原生交互有什么经验分享吗？怎么给 webView 加载的页面发的网络请求统一加上 header？</h4><h4 id="14-AFN-早期版本为什么要使用常驻线程？怎么统一设置-header？"><a href="#14-AFN-早期版本为什么要使用常驻线程？怎么统一设置-header？" class="headerlink" title="14.AFN 早期版本为什么要使用常驻线程？怎么统一设置 header？"></a>14.AFN 早期版本为什么要使用常驻线程？怎么统一设置 header？</h4><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[requestSerializer setValue:value forHTTPHeaderField:httpHeaderField];</span><br></pre></td></tr></table></figure><h4 id="15-RN-和-Flutter-的底层实现有什么区别？"><a href="#15-RN-和-Flutter-的底层实现有什么区别？" class="headerlink" title="15.RN 和 Flutter 的底层实现有什么区别？"></a>15.RN 和 Flutter 的底层实现有什么区别？</h4><p>在 Android 和 iOS 上，默认情况下 Flutter 和 React Native 都需要一个原生平台的 Activity / ViewController 支持，且在原生层面属于一个“单页面应用”，而它们之间最大的不同点其实在于 UI 构建 ：</p><ul><li>React Native ：</li></ul><p>React Native 是一套 UI 框架，默认情况下 React Native 会在 Activity 下加载  JS 文件，然后运行在  JavaScriptCore 中解析 Bundle 文件布局，最终堆叠出一系列的原生控件进行渲染。</p><p>简单来说就是 <strong>通过写 JS 代码配置页面布局，然后 React Native 最终会解析渲染成原生控件</strong>，如 <code>&lt;View&gt;</code> 标签对应 ViewGroup/UIView ，<code>&lt;ScrollView&gt;</code> 标签对应 ScrollView/UIScrollView ，<code>&lt;Image&gt;</code> 标签对应 ImageView/UIImageView 等。</p><ul><li>Flutter ：</li></ul><p>如果说 React Native 是为开发者做了平台兼容，那 Flutter 则更像是为开发者屏蔽平台的概念。</p><p>Flutter 中绝大部分的 Widget 都与平台无关， 开发者基于 Framework 开发 App ，而 Framework 运行在 Engine 之上，由 Engine 进行适配和跨平台支持。这个跨平台的支持过程，其实就是将 <strong>Flutter UI 中的 Widget “数据化” ，然后通过 Engine 上的 Skia 直接绘制到屏幕上 。</strong></p><p>参考链接：<a href="https://www.jianshu.com/p/85a77bb8d926" target="_blank" rel="noopener">Flutter 与 React Native 的对比分析</a></p><h4 id="16-平时怎么学习-iOS？上家公司的离职原因，未来规划，有没有要问我的？"><a href="#16-平时怎么学习-iOS？上家公司的离职原因，未来规划，有没有要问我的？" class="headerlink" title="16.平时怎么学习 iOS？上家公司的离职原因，未来规划，有没有要问我的？"></a>16.平时怎么学习 iOS？上家公司的离职原因，未来规划，有没有要问我的？</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;豆瓣面试题&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="豆瓣" scheme="http://soso.wiki/tags/%E8%B1%86%E7%93%A3/"/>
    
  </entry>
  
  <entry>
    <title>必要商城面试题</title>
    <link href="http://soso.wiki/%E5%BF%85%E8%A6%81%E5%95%86%E5%9F%8E%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://soso.wiki/必要商城面试题/</id>
    <published>2021-05-20T07:38:00.000Z</published>
    <updated>2023-04-02T00:12:33.436Z</updated>
    
    <content type="html"><![CDATA[<p>必要商城面试题<br><a id="more"></a></p><h4 id="1-项目搭建都做了哪些？"><a href="#1-项目搭建都做了哪些？" class="headerlink" title="1.项目搭建都做了哪些？"></a>1.项目搭建都做了哪些？</h4><h4 id="2-有没有做过解耦？"><a href="#2-有没有做过解耦？" class="headerlink" title="2.有没有做过解耦？"></a>2.有没有做过解耦？</h4><p>参考链接：<a href="https://blog.csdn.net/zramals/article/details/81389256" target="_blank" rel="noopener">iOS组件化（四）-代码解耦合</a></p><p><a href="https://blog.csdn.net/zramals/category_9277261.html" target="_blank" rel="noopener">iOS组件化从零开始</a></p><h4 id="3-路由怎么实现传值的？"><a href="#3-路由怎么实现传值的？" class="headerlink" title="3.路由怎么实现传值的？"></a>3.路由怎么实现传值的？</h4><p>参考链接：<a href="https://blog.csdn.net/zramals/article/details/81457669" target="_blank" rel="noopener">iOS组件化（五）-组件间调用</a></p><h4 id="4-项目优化？"><a href="#4-项目优化？" class="headerlink" title="4.项目优化？"></a>4.项目优化？</h4><ul><li><p>安装包大小优化</p></li><li><p>性能优化</p></li><li><p>启动优化</p></li><li><p>防崩溃</p></li></ul><h4 id="5-防崩溃处理？"><a href="#5-防崩溃处理？" class="headerlink" title="5.防崩溃处理？"></a>5.防崩溃处理？</h4><p>runtime 交换方法</p><h4 id="6-cell-加载图片的优化？"><a href="#6-cell-加载图片的优化？" class="headerlink" title="6.cell 加载图片的优化？"></a>6.cell 加载图片的优化？</h4><h4 id="7-项目难点？"><a href="#7-项目难点？" class="headerlink" title="7.项目难点？"></a>7.项目难点？</h4><h4 id="8-数据传递除了加密以外，怎么保证数据安全？"><a href="#8-数据传递除了加密以外，怎么保证数据安全？" class="headerlink" title="8.数据传递除了加密以外，怎么保证数据安全？"></a>8.数据传递除了加密以外，怎么保证数据安全？</h4><ul><li><p>使用数字证书锁定来保证不被中间人拦截，将服务器返回的数据和我的本地证书进行对比，确保是从服务器返回回来的。</p></li><li><p>使用 https 协议请求网页，post 来请求网页数据，保证用户的账号密码不被被人获取到。</p></li><li>使用苹果自己的 SSKeyChain 钥匙串，将用户的账号密码保存在钥匙串中。</li></ul><p>参考链接：<a href="https://www.jianshu.com/p/cf7279a75cff" target="_blank" rel="noopener">iOS开发，让数据更安全的几个加密方式</a></p><h4 id="9-原生与-H5-的交互？WKWebView-和-UIWebView-的区别？"><a href="#9-原生与-H5-的交互？WKWebView-和-UIWebView-的区别？" class="headerlink" title="9.原生与 H5 的交互？WKWebView 和 UIWebView 的区别？"></a>9.原生与 H5 的交互？WKWebView 和 UIWebView 的区别？</h4><h4 id="10-Cocopods-怎么管理自己的第三方库？"><a href="#10-Cocopods-怎么管理自己的第三方库？" class="headerlink" title="10.Cocopods 怎么管理自己的第三方库？"></a>10.Cocopods 怎么管理自己的第三方库？</h4><h4 id="11-除了-MVC-有没有了解过别的设计模式？"><a href="#11-除了-MVC-有没有了解过别的设计模式？" class="headerlink" title="11.除了 MVC 有没有了解过别的设计模式？"></a>11.除了 MVC 有没有了解过别的设计模式？</h4><h4 id="12-方法交换原理？"><a href="#12-方法交换原理？" class="headerlink" title="12.方法交换原理？"></a>12.方法交换原理？</h4><p>方法交换，交换的是方法的实现。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;必要商城面试题&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="必要商城" scheme="http://soso.wiki/tags/%E5%BF%85%E8%A6%81%E5%95%86%E5%9F%8E/"/>
    
  </entry>
  
  <entry>
    <title>猿辅导面试题</title>
    <link href="http://soso.wiki/%E7%8C%BF%E8%BE%85%E5%AF%BC%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://soso.wiki/猿辅导面试题/</id>
    <published>2021-05-19T11:00:00.000Z</published>
    <updated>2023-04-02T00:24:10.812Z</updated>
    
    <content type="html"><![CDATA[<p>猿辅导面试题<br><a id="more"></a></p><h4 id="1-加入-nil-会闪退吗"><a href="#1-加入-nil-会闪退吗" class="headerlink" title="1.@[]; 加入 nil 会闪退吗"></a>1.@[]; 加入 nil 会闪退吗</h4><p>会闪退，报错：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-[__NSPlaceholderArray initWithObjects:count:]: attempt to insert <span class="hljs-literal">nil</span> object from objects[<span class="hljs-number">4</span>]</span><br></pre></td></tr></table></figure><h4 id="2-array-i-会不会走-objectAtIndex"><a href="#2-array-i-会不会走-objectAtIndex" class="headerlink" title="2.array[i] 会不会走 objectAtIndex"></a>2.array[i] 会不会走 objectAtIndex</h4><p>会走。</p><p>array[i] 如果数组越界，会崩溃报错：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[__NSArrayI objectAtIndexedSubscript:]: index <span class="hljs-number">6</span> beyond bounds [<span class="hljs-number">0</span> .. <span class="hljs-number">4</span>]<span class="hljs-string">'</span></span><br></pre></td></tr></table></figure><h4 id="3-信号量-3-个网络接口返回执行-4"><a href="#3-信号量-3-个网络接口返回执行-4" class="headerlink" title="3.信号量 3 个网络接口返回执行 4"></a>3.信号量 3 个网络接口返回执行 4</h4><p>有些时候，我们需要阻塞发送请求的线程，比如在多个请求回调后统一操作的需求，而这些请求之间并没有顺序关系，且这些接口都会另开线程进行网络请求的。一般地，这种多线程完成后进行统一操作的需求都会使用队列组(dispatch_group_t)来完成，但是由于是异步请求，没等其异步回调之后，请求的线程就结束了，为此，就需要使用信号量来阻塞住发请求的线程。实现代码如下：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">dispatch_async</span>(queue, <span class="hljs-number">0</span>), ^&#123;</span><br><span class="line">    dispatch_semaphore_t sema = dispatch_semaphore_create(<span class="hljs-number">0</span>);</span><br><span class="line">    [网络请求:^&#123;</span><br><span class="line">        <span class="hljs-comment">//请求回调</span></span><br><span class="line">        dispatch_semaphore_signal(sema);  </span><br><span class="line">    &#125;];</span><br><span class="line">    dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样，请求的线程就可以等到回调结束后再结束了，再配合队列组就能完成上述的需求。这种技巧可用于以下场景：</p><ul><li>多个请求结束后统一操作</li><li>多个请求顺序执行</li></ul><h4 id="4-hook-delelgate-方法"><a href="#4-hook-delelgate-方法" class="headerlink" title="4.hook delelgate 方法"></a>4.hook delelgate 方法</h4><p>参考链接：<a href="https://blog.csdn.net/alpaca12/article/details/77914907" target="_blank" rel="noopener">iOS hook delegate</a></p><h4 id="5-交换方法传入参数-为什么需要先-addMethod"><a href="#5-交换方法传入参数-为什么需要先-addMethod" class="headerlink" title="5.交换方法传入参数 为什么需要先 addMethod"></a>5.交换方法传入参数 为什么需要先 addMethod</h4><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="hljs-keyword">void</span>)exchangeInstanceMethodWithSelfClass:(Class)selfClass</span><br><span class="line">                           originalSelector:(SEL)originalSelector</span><br><span class="line">                           swizzledSelector:(SEL)swizzledSelector &#123;</span><br><span class="line">    </span><br><span class="line">    Method originalMethod = class_getInstanceMethod(selfClass, originalSelector);</span><br><span class="line">    Method swizzledMethod = class_getInstanceMethod(selfClass, swizzledSelector);</span><br><span class="line">    <span class="hljs-built_in">BOOL</span> didAddMethod = class_addMethod(selfClass,</span><br><span class="line">                                        originalSelector,</span><br><span class="line">                                        method_getImplementation(swizzledMethod),</span><br><span class="line">                                        method_getTypeEncoding(swizzledMethod));</span><br><span class="line">    <span class="hljs-keyword">if</span> (didAddMethod) &#123;</span><br><span class="line">        class_replaceMethod(selfClass,</span><br><span class="line">                            swizzledSelector,</span><br><span class="line">                            method_getImplementation(originalMethod),</span><br><span class="line">                            method_getTypeEncoding(originalMethod));</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>防止影响父类的方法。</p><ul><li><p><code>init</code> 方法并不是 <code>Person</code> 类本身的实例（对象）方法，而是父类 <code>NSObject</code> 的方法。由于 <code>Person</code> 本身没有该方法，所以 <code>class_getInstanceMethod</code> 获取到的方法是通过 <code>Person</code> 的 <code>superclass</code> 指针从 <code>NSObject</code> 类中获取到了 <code>init</code> 这个方法。</p></li><li><p><code>method_exchangeImplementations</code> 操作将 <code>NSObject</code> 的 <code>init</code> 方法的实现与 <code>Person</code> 类的 <code>yxc_init</code> 方法的实现进行互换了，这时候调用 <code>init</code> 方法实际上是调用了 <code>yxc_init</code> 方法。</p></li><li><p>创建一个 <code>Person</code> 对象时，调用 <code>init</code> 方法，运行时会去查找 <code>yxc_init</code> 的实现，因为 <code>yxc_init</code> 方法是 <code>Person</code> 自身的方法，所以查找到了直接调用。（消息发送机制）</p></li><li><p>而创建一个 <code>NSObject</code> 对象时，调用 <code>init</code> 方法，运行时去查找 <code>yxc_init</code> 方法的时候，<code>NSObject</code> 是没有这个方法，这个方法存在于 <code>Person</code> 类中，所以查找完毕，还是找不到这个方法，就抛异常了。</p></li><li><p>正确的 hook 做法是，先将 init 方法添加到 Person 类中，如果这个类当前有这个方法（而不是父类），则不添加，直接 exchange，否则添加了 init 方法，然后再将 yxc_init 方法的实现设置成 init 方法的实现。</p></li></ul><p>参考链接：<a href="https://www.jianshu.com/p/d6d5bb9d97f5" target="_blank" rel="noopener">iOS Runtime 黑魔法方法交换(Method swizzling)</a></p><h4 id="6-关联对象有几种策略，如何实现-weak"><a href="#6-关联对象有几种策略，如何实现-weak" class="headerlink" title="6.关联对象有几种策略，如何实现 weak"></a>6.关联对象有几种策略，如何实现 weak</h4><p>在关联对象释放的时候，调用<code>objc_setAssociatedObject(object, key, nil, OBJC_ASSOCIATION_ASSIGN)</code>这样就把宿主对象的该 key 的关联对象清除了，外部读这个 key 的关联对象就是 nil</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">void</span> objc_setWeakAssociatedObject(<span class="hljs-keyword">id</span> _Nonnull object, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> * _Nonnull key, <span class="hljs-keyword">id</span> _Nullable value);</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">void</span> objc_setWeakAssociatedObject(<span class="hljs-keyword">id</span> _Nonnull object, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> * _Nonnull key, <span class="hljs-keyword">id</span> _Nullable value) &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (value) &#123;</span><br><span class="line">        <span class="hljs-comment">//__weak typeof(object) weakObj = object;</span></span><br><span class="line">        [value hc_doSthWhenDeallocWithBlock:^(<span class="hljs-built_in">NSObject</span> *__<span class="hljs-keyword">unsafe_unretained</span>  _Nonnull target) &#123;</span><br><span class="line">            objc_setAssociatedObject(object, key, <span class="hljs-literal">nil</span>, OBJC_ASSOCIATION_ASSIGN); <span class="hljs-comment">// clear association</span></span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    objc_setAssociatedObject(object, key, value, OBJC_ASSOCIATION_ASSIGN); <span class="hljs-comment">// call system imp</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考链接：<a href="https://www.jianshu.com/p/9dc4ea925a3d" target="_blank" rel="noopener">OC-AssociatedObject原理及weak关联对象的实现</a></p><h4 id="7-响应者链-button-超出父视图一半能否响应点击事件"><a href="#7-响应者链-button-超出父视图一半能否响应点击事件" class="headerlink" title="7.响应者链 button 超出父视图一半能否响应点击事件"></a>7.响应者链 button 超出父视图一半能否响应点击事件</h4><p>超出父视图的部分不能响应，在父视图内的部分可以响应。</p><p>如何扩大按钮的点击范围？</p><p>可以重写 button 的 pointInside: 方法</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="hljs-built_in">BOOL</span>)pointInside:(<span class="hljs-built_in">CGPoint</span>)point withEvent:(<span class="hljs-built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="hljs-comment">// 当前btn的大小</span></span><br><span class="line">    <span class="hljs-built_in">CGRect</span> btnBounds = <span class="hljs-keyword">self</span>.bounds;</span><br><span class="line">    <span class="hljs-comment">// 扩大按钮的点击范围，改为负值</span></span><br><span class="line">    btnBounds = <span class="hljs-built_in">CGRectInset</span>(btnBounds, <span class="hljs-number">-15</span>, <span class="hljs-number">-15</span>);</span><br><span class="line">    <span class="hljs-comment">// 若点击的点在新的bounds里，就返回YES</span></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-built_in">CGRectContainsPoint</span>(btnBounds, point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-离屏渲染，为什么会触发"><a href="#8-离屏渲染，为什么会触发" class="headerlink" title="8.离屏渲染，为什么会触发"></a>8.离屏渲染，为什么会触发</h4><p>参考链接：<a href="https://zhuanlan.zhihu.com/p/72653360" target="_blank" rel="noopener">知乎-关于iOS离屏渲染的深入研究</a></p><p><a href="https://www.jianshu.com/p/a72692125718" target="_blank" rel="noopener">简书-iOS离屏渲染产生的原因</a></p><h4 id="9-判断当前任务在哪个-queue-中"><a href="#9-判断当前任务在哪个-queue-中" class="headerlink" title="9.判断当前任务在哪个 queue 中"></a>9.判断当前任务在哪个 queue 中</h4><p><code>dispatch_queue_get_label</code></p><p>参考链接：<a href="https://blog.csdn.net/tongwei117/article/details/82757492" target="_blank" rel="noopener">判断代码在哪个队列中运行</a></p><h4 id="10-SDWebImage-内存缓存怎么实现的"><a href="#10-SDWebImage-内存缓存怎么实现的" class="headerlink" title="10.SDWebImage 内存缓存怎么实现的"></a>10.SDWebImage 内存缓存怎么实现的</h4><p>参考链接：<a href="https://www.jianshu.com/p/fc8e8994dde7" target="_blank" rel="noopener">iOS-SDWebImage缓存机制</a></p><h4 id="11-json-转-model，Runtime-能否获取到自定义属性的类型"><a href="#11-json-转-model，Runtime-能否获取到自定义属性的类型" class="headerlink" title="11.json 转 model，Runtime 能否获取到自定义属性的类型"></a>11.json 转 model，Runtime 能否获取到自定义属性的类型</h4><p><code>class_copyPropertyList</code>可以获取到属性列表</p><p><code>property_getName</code>可以获取到属性名</p><p><code>property_getAttributes</code>可以获取到成员类型</p><h4 id="12-tableView-快速滑动-卡顿发生可能原因"><a href="#12-tableView-快速滑动-卡顿发生可能原因" class="headerlink" title="12.tableView 快速滑动 卡顿发生可能原因"></a>12.tableView 快速滑动 卡顿发生可能原因</h4><p>1.提前计算并缓存好高度，因为 heightForRow 最频繁的调用。</p><p>- (UITableViewCell<em>)tableView:(UITableView</em>)tableView cellForRowAtIndexPath:(NSIndexPath*)indexPath;</p><p>2.异步绘制，遇到复杂界面，性能瓶颈时，可能是突破口。</p><p>3.滑动时按需加载，这个在大量图片展示，网络加载时，很管用。（SDWebImage 已经实现异步加载）。</p><p>4.重用 cells。</p><p>5.如果 cell 内显示得内容来自 web，使用异步加载，缓存结果请求。当 cell 中的部分 View 是非常独立的，并且不便于重用的，而且“体积”非常小，在内存可控的前提下，我们完全可以将这些 view 缓存起来。当然也是缓存在模型中。</p><p>6.少用或不用透明图层，使用不透明视图。对于不透明的 View，设置 opaque 为 YES，这样在绘制该 View 时，就不需要考虑被 View 覆盖的其他内容（尽量设置 Cell 的 view 为 opaque，避免 GPU 对 Cell 下面的内容也进行绘制）</p><p>7.减少 subViews。分析 Cell 结构，尽可能的将 相同内容的抽取到一种样式 Cell 中，前面已经提到了 Cell 的重用机制，这样就能保证 UITbaleView 要显示多少内容，真正创建出的 Cell 可能只比屏幕显示的 Cell 多一点。虽然 Cell 的’体积’可能会大点，但是因为 Cell 的数量不会很多，完全可以接受的</p><p>8.少用 addView 给 cell 动态添加 view，可以初始化的时候就添加，然后通过 hide 控制是否显示。</p><h4 id="13-括号算法"><a href="#13-括号算法" class="headerlink" title="13.括号算法"></a>13.括号算法</h4><p>LeetCode 题目链接：<a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">括号生成</a></p><h4 id="14-CocoaPods-缓存存在哪里，pod-install-执行"><a href="#14-CocoaPods-缓存存在哪里，pod-install-执行" class="headerlink" title="14.CocoaPods 缓存存在哪里，pod install 执行"></a>14.CocoaPods 缓存存在哪里，pod install 执行</h4><p>~/Library/Caches/Cocoapods</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;猿辅导面试题&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="猿辅导" scheme="http://soso.wiki/tags/%E7%8C%BF%E8%BE%85%E5%AF%BC/"/>
    
  </entry>
  
  <entry>
    <title>链表算法题</title>
    <link href="http://soso.wiki/%E9%93%BE%E8%A1%A8%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    <id>http://soso.wiki/链表算法题/</id>
    <published>2021-04-28T05:04:00.000Z</published>
    <updated>2023-04-02T00:19:42.306Z</updated>
    
    <content type="html"><![CDATA[<p>链表算法题（ JavaScript 实现）<br><a id="more"></a></p><h4 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h4><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ReverseList</span>(<span class="hljs-params">pHead</span>)</span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> prev = <span class="hljs-literal">null</span>;</span><br><span class="line">    <span class="hljs-keyword">let</span> curr = pHead;</span><br><span class="line">    <span class="hljs-keyword">while</span> (curr) &#123;</span><br><span class="line">        <span class="hljs-keyword">const</span> next = curr.next;</span><br><span class="line">        curr.next = prev;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h4><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> swapPairs = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> dummyNode = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);</span><br><span class="line">    dummyNode.next = head;</span><br><span class="line">    <span class="hljs-keyword">let</span> temp = dummyNode;</span><br><span class="line">    <span class="hljs-keyword">while</span> (temp.next != <span class="hljs-literal">null</span> &amp;&amp; temp.next.next != <span class="hljs-literal">null</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">let</span> head1 = temp.next;</span><br><span class="line">        <span class="hljs-keyword">let</span> head2 = temp.next.next;</span><br><span class="line">        temp.next = head2;</span><br><span class="line">        head1.next = head2.next;</span><br><span class="line">        head2.next = head1;</span><br><span class="line">        temp = head1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> dummyNode.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="判断链表中是否有环"><a href="#判断链表中是否有环" class="headerlink" title="判断链表中是否有环"></a>判断链表中是否有环</h4><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasCycle</span>(<span class="hljs-params"> head </span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">let</span> slow = head;</span><br><span class="line">    <span class="hljs-keyword">let</span> fast = head;</span><br><span class="line">    <span class="hljs-keyword">while</span> (fast.next &amp;&amp; fast.next.next) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        <span class="hljs-keyword">if</span> (slow == fast) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="环的入口结点"><a href="#环的入口结点" class="headerlink" title="环的入口结点"></a>环的入口结点</h4><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">detectCycle</span>(<span class="hljs-params"> head </span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (!head) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;</span><br><span class="line">    <span class="hljs-keyword">let</span> slow = head, fast = head;</span><br><span class="line">    <span class="hljs-keyword">while</span>(fast.next &amp;&amp; fast.next.next) &#123;</span><br><span class="line">        fast = fast.next.next</span><br><span class="line">        slow = slow.next</span><br><span class="line">        <span class="hljs-keyword">if</span> (slow == fast) &#123;</span><br><span class="line">            <span class="hljs-keyword">var</span> a = head;</span><br><span class="line">            <span class="hljs-keyword">while</span> (slow != a) &#123;</span><br><span class="line">                a = a.next</span><br><span class="line">                slow = slow.next</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="链表中倒数第-k-个结点"><a href="#链表中倒数第-k-个结点" class="headerlink" title="链表中倒数第 k 个结点"></a>链表中倒数第 k 个结点</h4><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">FindKthToTail</span>(<span class="hljs-params"> pHead ,  k </span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> length = getLength(pHead);</span><br><span class="line">    <span class="hljs-keyword">if</span> (length &lt; k) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">let</span> i = length - k;</span><br><span class="line">    <span class="hljs-keyword">let</span> p = pHead;</span><br><span class="line">    <span class="hljs-keyword">while</span> (i &gt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">        p = p.next;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> getLength = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> pHead </span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> p = pHead;</span><br><span class="line">    <span class="hljs-keyword">let</span> length = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span>) &#123;</span><br><span class="line">        p = p.next;</span><br><span class="line">        length++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除链表的倒数第-n-个节点"><a href="#删除链表的倒数第-n-个节点" class="headerlink" title="删除链表的倒数第 n 个节点"></a>删除链表的倒数第 n 个节点</h4><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeNthFromEnd</span>(<span class="hljs-params"> head ,  n </span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> length = getLength(head);</span><br><span class="line">    <span class="hljs-keyword">if</span> (length &lt; n) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">let</span> i = length - n;</span><br><span class="line">    <span class="hljs-keyword">let</span> dummy = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    <span class="hljs-keyword">let</span> p = dummy;</span><br><span class="line">    <span class="hljs-keyword">while</span> (i &gt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">        p = p.next;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    p.next = p.next.next;</span><br><span class="line">    <span class="hljs-keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> getLength = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> head </span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> length = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">let</span> p = head;</span><br><span class="line">    <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span>) &#123;</span><br><span class="line">        p = p.next;</span><br><span class="line">        length ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除有序链表中重复的元素"><a href="#删除有序链表中重复的元素" class="headerlink" title="删除有序链表中重复的元素"></a>删除有序链表中重复的元素</h4><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deleteDuplicates</span>(<span class="hljs-params"> head </span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> p = head;</span><br><span class="line">    <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span> &amp;&amp; p.next != <span class="hljs-literal">null</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (p.val == p.next.val) &#123;</span><br><span class="line">            p.next = p.next.next;</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="交叉链表找交点"><a href="#交叉链表找交点" class="headerlink" title="交叉链表找交点"></a>交叉链表找交点</h4><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">FindFirstCommonNode</span>(<span class="hljs-params">pHead1, pHead2</span>)</span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (pHead1 == <span class="hljs-literal">null</span> || pHead2 == <span class="hljs-literal">null</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">let</span> p1 = pHead1, p2 = pHead2;</span><br><span class="line">    <span class="hljs-keyword">while</span> (p1 != p2) &#123;</span><br><span class="line">        p1 = p1 == <span class="hljs-literal">null</span> ? pHead2 : p1.next;</span><br><span class="line">        p2 = p2 == <span class="hljs-literal">null</span> ? pHead1 : p2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h4><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mergeTwoLists</span>(<span class="hljs-params"> l1 ,  l2 </span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> newHead = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">-1</span>);</span><br><span class="line">    <span class="hljs-keyword">let</span> p = newHead;</span><br><span class="line">    <span class="hljs-keyword">while</span>(l1 != <span class="hljs-literal">null</span> &amp;&amp; l2 != <span class="hljs-literal">null</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">            p.next = l1;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            p.next = l2;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span> (l1 != <span class="hljs-literal">null</span>) &#123;</span><br><span class="line">        p.next = l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span> (l2 != <span class="hljs-literal">null</span>) &#123;</span><br><span class="line">        p.next = l2;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="hljs-keyword">return</span> newHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链表算法题（ JavaScript 实现）&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="算法" scheme="http://soso.wiki/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="链表" scheme="http://soso.wiki/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>核桃编程面试题</title>
    <link href="http://soso.wiki/%E6%A0%B8%E6%A1%83%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://soso.wiki/核桃编程面试题/</id>
    <published>2021-04-28T05:00:00.000Z</published>
    <updated>2023-04-02T00:17:15.297Z</updated>
    
    <content type="html"><![CDATA[<p>核桃编程面试题<br><a id="more"></a></p><p>1.消息发送和消息转发的过程</p><p>2.KVO 的原理</p><p>3.能不能动态添加成员变量</p><p>4.分类为啥不能添加成员变量</p><p>5.说一下 HTTPS 和 TCP、UDP</p><p>6.说一下项目亮点</p><p>7.方法交换注意什么</p><p>8.链表反转</p><p>9.NSNumber 怎么进行优化的，数据存储哪里</p><p>10.GCD 和 NSOperation 各自的优点</p><p>11.Runtime 的应用</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;核桃编程面试题&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="核桃编程" scheme="http://soso.wiki/tags/%E6%A0%B8%E6%A1%83%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>字节跳动面试题</title>
    <link href="http://soso.wiki/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://soso.wiki/字节跳动面试题/</id>
    <published>2021-04-25T11:00:00.000Z</published>
    <updated>2023-04-02T00:24:26.418Z</updated>
    
    <content type="html"><![CDATA[<p>字节跳动面试题<br><a id="more"></a></p><h4 id="1-retain-strong-区别"><a href="#1-retain-strong-区别" class="headerlink" title="1.retain  strong 区别"></a>1.retain  strong 区别</h4><p>在声明 block 时，retain 相当于 assign，strong 相当于 copy，block一般使用 copy</p><h4 id="2-NSClassFromString-原理"><a href="#2-NSClassFromString-原理" class="headerlink" title="2.NSClassFromString 原理"></a>2.NSClassFromString 原理</h4><h5 id="反射方法"><a href="#反射方法" class="headerlink" title="反射方法"></a>反射方法</h5><p>系统<code>Foundation</code>框架为我们提供了一些方法反射的 API，我们可以通过这些 API 执行将字符串转为<code>SEL</code>等操作。由于<code>OC</code>语言的动态性，这些操作都是发生在运行时的。</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// SEL和字符串转换</span></span><br><span class="line">FOUNDATION_EXPORT <span class="hljs-built_in">NSString</span> *<span class="hljs-built_in">NSStringFromSelector</span>(SEL aSelector);</span><br><span class="line">FOUNDATION_EXPORT SEL <span class="hljs-built_in">NSSelectorFromString</span>(<span class="hljs-built_in">NSString</span> *aSelectorName);</span><br><span class="line"><span class="hljs-comment">// Class和字符串转换</span></span><br><span class="line">FOUNDATION_EXPORT <span class="hljs-built_in">NSString</span> *<span class="hljs-built_in">NSStringFromClass</span>(Class aClass);</span><br><span class="line">FOUNDATION_EXPORT Class __<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">NSClassFromString</span>(<span class="hljs-built_in">NSString</span> *aClassName);</span><br><span class="line"><span class="hljs-comment">// Protocol和字符串转换</span></span><br><span class="line">FOUNDATION_EXPORT <span class="hljs-built_in">NSString</span> *<span class="hljs-built_in">NSStringFromProtocol</span>(Protocol *proto) <span class="hljs-built_in">NS_AVAILABLE</span>(<span class="hljs-number">10</span>_5, <span class="hljs-number">2</span>_0);</span><br><span class="line">FOUNDATION_EXPORT Protocol * __<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">NSProtocolFromString</span>(<span class="hljs-built_in">NSString</span> *namestr) <span class="hljs-built_in">NS_AVAILABLE</span>(<span class="hljs-number">10</span>_5, <span class="hljs-number">2</span>_0);</span><br></pre></td></tr></table></figure><h5 id="常用判断方法"><a href="#常用判断方法" class="headerlink" title="常用判断方法"></a>常用判断方法</h5><p>在<code>NSObject</code>类中为我们提供了一些基础方法，用来做一些判断操作，这些方法都是发生在运行时动态判断的。</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 当前对象是否这个类或其子类的实例</span></span><br><span class="line">- (<span class="hljs-built_in">BOOL</span>)isKindOfClass:(Class)aClass;</span><br><span class="line"><span class="hljs-comment">// 当前对象是否是这个类的实例</span></span><br><span class="line">- (<span class="hljs-built_in">BOOL</span>)isMemberOfClass:(Class)aClass;</span><br><span class="line"><span class="hljs-comment">// 当前对象是否遵守这个协议</span></span><br><span class="line">- (<span class="hljs-built_in">BOOL</span>)conformsToProtocol:(Protocol *)aProtocol;</span><br><span class="line"><span class="hljs-comment">// 当前对象是否实现这个方法</span></span><br><span class="line">- (<span class="hljs-built_in">BOOL</span>)respondsToSelector:(SEL)aSelector;</span><br></pre></td></tr></table></figure><p>参考链接：<a href="https://www.jianshu.com/p/5bbde2480680" target="_blank" rel="noopener">iOS反射机制</a></p><h4 id="3-http协议版本"><a href="#3-http协议版本" class="headerlink" title="3.http协议版本"></a>3.http协议版本</h4><p><strong>1、HTTP 0.9 ：</strong><br>（1）只接受GET一种请求方法，没有在通信中指定版本号，且不支持请求头；</p><p>（2）此外该版本也不支持POST方法，因此客户端无法向服务器传递太多信息；</p><p><strong>2、HTTP 1.0：</strong><br>（1）支持POST、GET、HEAD三种方法；</p><p>（2）规定浏览器与服务器之间只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求；</p><p><strong>3、HTTP 1.1：</strong><br>（1）新增了五种请求方法：PUT、DELETE、CONNECT、TRACE、OPTIONS；</p><p>（2）HTTP 1.1 在Request消息头里头多了一个Host域，便于一台WEB服务器上可以在同一个IP地址和端口号上使用不同的主机名来创建多个虚拟WEB站点；</p><p>（3）长连接</p><p>（4）缓存策略不同</p><p>（5）在HTTP/1.1中新增了24个状态响应码：<br>100-199 用于指定客户端应相应的某些动作。<br>200-299 用于表示请求成功。<br>300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。<br>400-499 用于指出客户端的错误。<br>500-599 用于支持服务器错误。</p><p><strong>4、HTTP 2.0</strong></p><p>二进制传输：http 1.x 的解析是基于文本，http2的解析是基于二进制；</p><p>多路复用</p><p>header压缩</p><p>服务端推送</p><h4 id="4-http-code-206-401"><a href="#4-http-code-206-401" class="headerlink" title="4.http code 206  401"></a>4.http code 206  401</h4><p>206 Partial Content</p><p>最后一条会话返回了HTTP/206 “Partial Content”响应.这种响应是在客户端表明自己只需要目标URL上的部分资源的时候返回的.这种情况经常发生在客户端继续请求一个未完成的下载的时候(通常是当客户端加载一个体积较大的嵌入文件,比如视频或PDF文件),或者是客户端尝试实现带宽遏流的时候。</p><p>你可以通过<strong>Range</strong>请求头辨认出一个部分内容请求.该请求头表明了客户端需要请求资源的哪一部分。</p><p>401错误原因：用户没有访问权限，需要进行身份认证。</p><h5 id="http-常见的错误码"><a href="#http-常见的错误码" class="headerlink" title="http 常见的错误码"></a>http 常见的错误码</h5><p>2XX 成功</p><p>· 200 OK，表示从客户端发来的请求在服务器端被正确处理</p><p>· 204 No content，表示请求成功，但响应报文不含实体的主体部分</p><p>· 206 Partial Content，进行范围请求</p><p>3XX 重定向</p><p>· 301 moved permanently，永久性重定向，表示资源已被分配了新的 URL</p><p>· 302 found，临时性重定向，表示资源临时被分配了新的 URL</p><p>· 303 see other，表示资源存在着另一个 URL，应使用 GET 方法丁香获取资源</p><p>· 304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况</p><p>· 307 temporary redirect，临时重定向，和302含义相同</p><p>4XX 客户端错误</p><p>· 400 bad request，请求报文存在语法错误</p><p>· 401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息</p><p>· 403 forbidden，表示对请求资源的访问被服务器拒绝</p><p>· 404 not found，表示在服务器上没有找到请求的资源</p><p>5XX 服务器错误</p><p>· 500 internal sever error，表示服务器端在执行请求时发生了错误</p><p>· 503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求</p><h4 id="5-为什么三次握手，四次挥手"><a href="#5-为什么三次握手，四次挥手" class="headerlink" title="5.为什么三次握手，四次挥手"></a>5.为什么三次握手，四次挥手</h4><h4 id="6-dispatch-async-queue-block-会不会开线程"><a href="#6-dispatch-async-queue-block-会不会开线程" class="headerlink" title="6.dispatch_async(queue,block);会不会开线程"></a>6.dispatch_async(queue,block);会不会开线程</h4><p>除了主队列，其他队列都开线程。</p><h4 id="7-二叉树中和为某一值的路径"><a href="#7-二叉树中和为某一值的路径" class="headerlink" title="7.二叉树中和为某一值的路径"></a>7.二叉树中和为某一值的路径</h4><p>LeetCode题目链接：<a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/" target="_blank" rel="noopener">剑指 Offer 34. 二叉树中和为某一值的路径</a></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;(); </span><br><span class="line">    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="hljs-keyword">int</span> sum) &#123;</span><br><span class="line">        recur(root, sum);</span><br><span class="line">        <span class="hljs-keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">recur</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> tar)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;</span><br><span class="line">        path.add(root.val);</span><br><span class="line">        tar -= root.val;</span><br><span class="line">        <span class="hljs-keyword">if</span>(tar == <span class="hljs-number">0</span> &amp;&amp; root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>)</span><br><span class="line">            res.add(<span class="hljs-keyword">new</span> LinkedList(path));</span><br><span class="line">        recur(root.left, tar);</span><br><span class="line">        recur(root.right, tar);</span><br><span class="line">        path.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-Runtime"><a href="#8-Runtime" class="headerlink" title="8.Runtime"></a>8.Runtime</h4><h4 id="9-UIView-绘制过程"><a href="#9-UIView-绘制过程" class="headerlink" title="9.UIView 绘制过程"></a>9.UIView 绘制过程</h4><p><strong>UIView的绘制原理</strong></p><p><img src="/images/ios/UIView的绘制原理.png" alt="UIView的绘制原理"></p><p>当我们调用 UIView 的 setNeedsDisplay 方法以后,实际上并没有立刻发生当前视图的绘制工作,而是在之后的某一时机才会进行当前视图的绘制 。为什么没有立刻发生当前视图的绘制工作？（因为到当前 runloop 将要结束的时候,才会开始介入到UI视图的绘制流程中）</p><ul><li>当调用 UIView 的 setNeedsDisplay 后</li><li>系统会立刻调用 view 的 layer 的同名方法 [view.layer setNeedsDisplay] ,之后相当于在 layer 上面打上了一个脏标记</li><li>然后再当前 runloop 将要结束的时候,才会调用 CALayer 的 display 函数方法，然后才进入到当前视图的真正绘制工作的流程当中</li><li>CALayer 的 display 方法,在内部会首先判断 layer 的 delegate 是否响应 displayLayer 这个方法</li><li>若不响应,则系统开始绘制流程</li><li>若响应,则开始异步绘制</li></ul><p><strong>系统绘制流程</strong></p><p><img src="/images/ios/系统绘制流程.png" alt="系统绘制流程"></p><ul><li>首先 CALayer 内部会创建一个 CGContextRef ,在 drawRect 方法中,可以通过上下文堆栈当中的取出这个 context，拿到的就是当前控件或者说视图的上下文或者说是 backing store</li><li>然后 layer 会判断它是否有代理，若没有,则调用 CALayer 的 drawInContext。</li><li>若有则调用代理方法,然后做当前视图的绘制工作（这一步发生在系统内部当中）,再在合适的时机,基于 drawRect 回调方法,</li><li>drawRect 默认操作是什么都不做,而之所以有这个接口,就是为了让我们在系统绘制之上,可以做些自定义的绘制工作。</li><li>最后再由 CALayer 上传对应的 backing store 给 GPU,这里的 backing store 我们可以理解为位图。</li></ul><p><strong>异步绘制流程</strong></p><p><img src="/images/ios/异步绘制时序图.png" alt="异步绘制时序图"></p><ul><li>左侧是主队列，右侧是全局并发队列</li><li>假如在某一时机调用了 setNeedsDiaplay 方法后</li><li>在当前 runloop 将要结束的时候,会有系统调用视图所对应 layer 的 display 方法</li><li>如果代理实现了 displayLayer 方法,会调用这个代理的 displayLayer 这个方法</li><li>然后通过子线程的切换,我们会在子线程中去做位图的绘制，此时主线程可以去做些其他的工作</li><li>然后再回到主队列中,提交这个位图,设置给 CALayer 的 contents 属性</li></ul><p><strong>子线程的绘制</strong></p><ol><li>通过 CGBitmapContextCreat 方法,来创建一个位图的上下文</li><li>通过 CoreGraphic 的相关 API,可以做当前 UI 控件的一些绘制工作</li><li>之后通过 CGBitmapContextCreatImage 方法,根据所绘制的上下文,生成一张 CGImage 图片</li><li>最后回到主队列中，将该 <strong>CGImage</strong> 图片设置为 <strong>CALayer</strong> 的 <strong>contents</strong></li></ol><p>参考链接：<a href="https://blog.csdn.net/ochenmengo/article/details/104769773/" target="_blank" rel="noopener">UI绘制原理&amp;系统/异步绘制流程</a></p><p><a href="https://www.jianshu.com/p/1afd22268abc" target="_blank" rel="noopener">UIView的绘制原理及优化</a></p><h4 id="10-autoreleasepool"><a href="#10-autoreleasepool" class="headerlink" title="10.autoreleasepool"></a>10.autoreleasepool</h4><ul><li>子线程使用了 autorelease 后，如果当前线程没有 AutorelesepoolPage 的话，代码执行顺序为 autorelease -&gt; autoreleaseFast -&gt; autoreleaseNoPage。在 autoreleaseNoPage 方法中，会创建一个 hotPage ，然后调用page-&gt;add(obj) 。也就是说即使这个线程没有 AutorelesepoolPage ，使用了 autorelease 对象时也会 new 一个 AutoreleasepoolPage 出来管理 autorelese 对象。</li><li>子线程的 autoreleasepool 是在线程销毁的时候释放的。</li></ul><h4 id="11-VC生命周期，viewWillDisappear-和-viewDidDisappear-之间会不会调用view-的-layout"><a href="#11-VC生命周期，viewWillDisappear-和-viewDidDisappear-之间会不会调用view-的-layout" class="headerlink" title="11.VC生命周期，viewWillDisappear 和 viewDidDisappear 之间会不会调用view 的 layout"></a>11.VC生命周期，viewWillDisappear 和 viewDidDisappear 之间会不会调用view 的 layout</h4><p>push 会调用，pop 不会调用</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-number">1</span> push <span class="hljs-number">2</span></span><br><span class="line"><span class="hljs-number">2</span>-[<span class="hljs-number">2</span> loadView]</span><br><span class="line"><span class="hljs-number">2</span>-[<span class="hljs-number">2</span> viewDidLoad]</span><br><span class="line"><span class="hljs-number">1</span>-[<span class="hljs-number">1</span> viewWillDisappear:]</span><br><span class="line"><span class="hljs-number">2</span>-[<span class="hljs-number">2</span> viewWillAppear:]</span><br><span class="line"><span class="hljs-number">2</span>-[<span class="hljs-number">2</span> viewWillLayoutSubviews]</span><br><span class="line"><span class="hljs-number">2</span>-[<span class="hljs-number">2</span> viewDidLayoutSubviews]</span><br><span class="line"><span class="hljs-number">1</span>-[<span class="hljs-number">1</span> viewWillLayoutSubviews]</span><br><span class="line"><span class="hljs-number">1</span>-[<span class="hljs-number">1</span> viewDidLayoutSubviews]</span><br><span class="line"><span class="hljs-number">1</span>-[<span class="hljs-number">1</span> viewDidDisappear:]</span><br><span class="line"><span class="hljs-number">2</span>-[<span class="hljs-number">2</span> viewDidAppear:]</span><br></pre></td></tr></table></figure><h4 id="12-autorelease-调用-release-会立即销毁吗"><a href="#12-autorelease-调用-release-会立即销毁吗" class="headerlink" title="12.autorelease 调用 release 会立即销毁吗"></a>12.autorelease 调用 release 会立即销毁吗</h4><h4 id="13-GCD能不能取消任务"><a href="#13-GCD能不能取消任务" class="headerlink" title="13.GCD能不能取消任务"></a>13.GCD能不能取消任务</h4><ul><li><p>dispatch_block_cancel</p></li><li><p>定义外部变量，用于标记block是否需要取消</p></li></ul><p>参考链接：<a href="https://www.jianshu.com/p/c45f099c7fd4" target="_blank" rel="noopener">如何取消GCD任务</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;字节跳动面试题&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="字节跳动" scheme="http://soso.wiki/tags/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8/"/>
    
  </entry>
  
</feed>
