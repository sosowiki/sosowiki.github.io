<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SOSOWIKI</title>
  <icon>https://www.gravatar.com/avatar/0add61f863154d82902310b0dd29ec33</icon>
  <subtitle>SOSOWIKI</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://soso.wiki/"/>
  <updated>2025-04-09T12:25:55.933Z</updated>
  <id>http://soso.wiki/</id>
  
  <author>
    <name>SOSOWIKI</name>
    <email>swift@88.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>转转</title>
    <link href="http://soso.wiki/2024-09-03-%E8%BD%AC%E8%BD%AC/"/>
    <id>http://soso.wiki/2024-09-03-转转/</id>
    <published>2024-09-03T07:00:00.000Z</published>
    <updated>2025-04-09T12:25:55.933Z</updated>
    
    <content type="html"><![CDATA[<p>转转<br><a id="more"></a></p><p>一面：</p><p>1.活动页组件化，JSON 结构，跳转区分 Scheme 和 HTTP 是谁来处理的？</p><p>2.加载速度优化</p><p>3.检测无用代码是检测的 mach-o 的无用类还是方法？</p><p>4.多个请求完成后通知除了 GCD 还有什么方法？</p><p>5.webView 和原生的交互，设计一个监听原生页面声明周期，通知 H5，（有些需要监听，有些不需要监听）</p><p>6.webView 加载速度优化，项目里用到的</p><p>7.组件化怎么划分的模块，分层</p><p>8.内存管理，项目里常见的循环引用，为什么用 NSProxy，和 NSObject 区别</p><p>二面：</p><p>1.介绍项目亮点</p><p>2.设计原生与 Flutter/H5 交互  上中下三层</p><p>3.iOS 和 H5 交互方法，优缺点</p><p>4.具体规划，目前待遇，offer，期望薪资</p><h1 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a>参考答案</h1><p>一面：</p><p>1.活动页组件化，JSON 结构，跳转区分 Scheme 和 HTTP 是谁来处理的？</p><p>2.加载速度优化</p><p>3.检测无用代码是检测的 mach-o 的无用类还是方法？</p><p>4.多个请求完成后通知除了 GCD 还有什么方法？</p><p>5.webView 和原生的交互，设计一个监听原生页面声明周期，通知 H5，（有些需要监听，有些不需要监听）</p><p>6.webView 加载速度优化，项目里用到的</p><p>7.组件化怎么划分的模块，分层</p><p>（1）Accessories App附属品</p><p>Watch、Extension、Widget</p><p>（2）Business 业务组件</p><p>文库、网盘、性能监控、付费咨询、Feed、搜索等</p><p>（3）Interface 接口层</p><p>（4）Underlays 服务组件</p><p>搜索工具、Feed通用业务，天气通用数据组件等</p><p>（5）Services 服务组件</p><p>IM、Talos、Performance、UBC、AFX等</p><p>（6）Basics 基础组件</p><p>BDPDevice、Cocoa（BBAFoundation、BBAUIKit、BDPWindow、BDPAppearance、AFX）、Network</p><p>（7）Vendors 三方库</p><p>AFNetworking、SDWebImage、YYModel等</p><p>8.内存管理，项目里常见的循环引用，为什么用 NSProxy，和 NSObject 区别</p><ul><li><code>NSProxy</code> 主要用于代理和消息转发，它提供了一个机制来实现不直接处理方法调用的对象。</li><li><code>NSObject</code> 是所有 Objective-C 对象的基础类，提供了对象管理和通用功能的实现。</li></ul><p>通常情况下，如果你需要实现一种代理模式或远程调用，<code>NSProxy</code> 是合适的选择。如果你在创建一个普通的对象，<code>NSObject</code> 是你通常会继承的类。</p><p>二面：</p><p>1.介绍项目亮点</p><p>2.设计原生与 Flutter/H5 交互  上中下三层</p><p>3.iOS 和 H5 交互方法，优缺点</p><p>4.具体规划，目前待遇，offer，期望薪资</p><h2 id="📘-iOS-面试通关手册（组件化-H5-性能-架构）"><a href="#📘-iOS-面试通关手册（组件化-H5-性能-架构）" class="headerlink" title="📘 iOS 面试通关手册（组件化 / H5 / 性能 / 架构）"></a>📘 iOS 面试通关手册（组件化 / H5 / 性能 / 架构）</h2><hr><h3 id="🧩-一面核心题目详解"><a href="#🧩-一面核心题目详解" class="headerlink" title="🧩 一面核心题目详解"></a>🧩 一面核心题目详解</h3><h4 id="1-活动页组件化，JSON-结构，跳转区分-Scheme-和-HTTP-是谁来处理的？"><a href="#1-活动页组件化，JSON-结构，跳转区分-Scheme-和-HTTP-是谁来处理的？" class="headerlink" title="1. 活动页组件化，JSON 结构，跳转区分 Scheme 和 HTTP 是谁来处理的？"></a>1. 活动页组件化，JSON 结构，跳转区分 Scheme 和 HTTP 是谁来处理的？</h4><p><strong>答案要点：</strong></p><ul><li>JSON 描述跳转目标（如 URL、pageId、params）</li><li><p><code>RouterManager</code>/<code>Navigator</code> 统一解析 URL，决定打开方式：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span> ([url.scheme isEqualToString:<span class="hljs-string">@"http"</span>] || [url.scheme isEqualToString:<span class="hljs-string">@"https"</span>]) &#123;</span><br><span class="line">    <span class="hljs-comment">// 打开 WebView</span></span><br><span class="line">&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ([url.scheme isEqualToString:<span class="hljs-string">@"app"</span>]) &#123;</span><br><span class="line">    <span class="hljs-comment">// 原生跳转</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>分离跳转逻辑与页面结构，便于动态配置与热更新。</p></li></ul><hr><h4 id="2-加载速度优化"><a href="#2-加载速度优化" class="headerlink" title="2. 加载速度优化"></a>2. 加载速度优化</h4><p><strong>优化方式：</strong></p><ul><li>首屏优化：异步加载、骨架屏占位、按需加载</li><li>图片优化：压缩、缓存（SDWebImage）、懒加载</li><li>数据优化：合并请求、接口聚合、GZIP 压缩</li><li>离线缓存：预加载 HTML、JS Bundle、资源包</li><li>网络优化：HTTP2、多路复用、CDN 配置</li></ul><hr><h4 id="3-检测无用代码是检测-Mach-O-的类还是方法？"><a href="#3-检测无用代码是检测-Mach-O-的类还是方法？" class="headerlink" title="3. 检测无用代码是检测 Mach-O 的类还是方法？"></a>3. 检测无用代码是检测 Mach-O 的类还是方法？</h4><p><strong>答法：</strong></p><ul><li>都可以，通过静态分析：<ul><li><code>LinkMap</code> 文件分析未被引用的符号</li><li><code>Clang 插桩</code>、<code>Swift Demangle</code> 查看未调用的方法</li></ul></li><li>Mach-O 是最终产物，反映“未被链接进二进制”的部分</li></ul><hr><h4 id="4-多请求完成通知除了-GCD，还有什么？"><a href="#4-多请求完成通知除了-GCD，还有什么？" class="headerlink" title="4. 多请求完成通知除了 GCD，还有什么？"></a>4. 多请求完成通知除了 GCD，还有什么？</h4><p><strong>方案：</strong></p><ul><li><code>NSOperationQueue + addDependency</code></li><li>Promise/Future：PromiseKit、Combine、RxSwift</li><li>KVO 监听属性变化，触发 UI 更新</li><li>Dispatch Semaphore：手动控制信号</li></ul><hr><h4 id="5-WebView-与原生交互，监听页面生命周期通知-H5"><a href="#5-WebView-与原生交互，监听页面生命周期通知-H5" class="headerlink" title="5. WebView 与原生交互，监听页面生命周期通知 H5"></a>5. WebView 与原生交互，监听页面生命周期通知 H5</h4><p><strong>设计：</strong></p><ul><li><p>原生页面生命周期调用 JS 通知：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[webView evaluateJavaScript:<span class="hljs-string">@"window.onNativeLifeCycle('viewDidAppear')"</span>]</span><br></pre></td></tr></table></figure></li><li><p>JS 注册：</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">window</span>.onNativeLifeCycle = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">state</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (state === <span class="hljs-string">'viewDidAppear'</span>) &#123; <span class="hljs-comment">/* 处理 */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可配置控制哪些生命周期需要同步（如通过 JSBridge 参数指定）</p></li></ul><hr><h4 id="6-WebView-加载速度优化（项目中用到的）"><a href="#6-WebView-加载速度优化（项目中用到的）" class="headerlink" title="6. WebView 加载速度优化（项目中用到的）"></a>6. WebView 加载速度优化（项目中用到的）</h4><p><strong>方法：</strong></p><ul><li>离线资源包（JS/CSS/HTML）打包在本地</li><li>WKWebView 复用池（WebViewPool）减少初始化开销</li><li>设置 cachePolicy，合理使用缓存</li><li>禁用插件（如 JS 插件、自动检测）提高启动速度</li></ul><hr><h4 id="7-组件化怎么划分模块-分层？"><a href="#7-组件化怎么划分模块-分层？" class="headerlink" title="7. 组件化怎么划分模块 / 分层？"></a>7. 组件化怎么划分模块 / 分层？</h4><p><strong>推荐结构：</strong></p><ul><li>Base 层：网络、工具类、日志、配置</li><li>UI 层：通用 UI 组件（按钮、卡片、弹窗）</li><li>Biz 层：独立业务模块（登录、支付、商城）</li><li>Service 层：统一服务（埋点、权限、推送）</li><li>Protocol 层：各模块之间解耦协议</li></ul><p><strong>关键词：</strong> 解耦、高内聚、低耦合、模块隔离、可热更新</p><hr><h4 id="8-内存管理：循环引用、NSProxy-与-NSObject-区别"><a href="#8-内存管理：循环引用、NSProxy-与-NSObject-区别" class="headerlink" title="8. 内存管理：循环引用、NSProxy 与 NSObject 区别"></a>8. 内存管理：循环引用、NSProxy 与 NSObject 区别</h4><p><strong>常见循环引用：</strong></p><ul><li>Timer 持有控制器</li><li>Block 捕获 self</li><li>delegate 强引用</li></ul><p><strong>NSProxy 使用：</strong></p><ul><li>中转代理（如 NSTimer）：<figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">NSTimer</span> *timer = [<span class="hljs-built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="hljs-number">1</span> target:[WeakProxy proxyWithTarget:<span class="hljs-keyword">self</span>] selector:<span class="hljs-keyword">@selector</span>(run) userInfo:<span class="hljs-literal">nil</span> repeats:<span class="hljs-literal">YES</span>];</span><br></pre></td></tr></table></figure></li></ul><p><strong>与 NSObject 区别：</strong></p><ul><li>NSProxy 是消息转发专用，不继承 NSObject，无默认行为</li><li>NSObject 有默认的内存管理 / KVO / 响应链</li></ul><hr><h3 id="🚀-二面核心题目详解"><a href="#🚀-二面核心题目详解" class="headerlink" title="🚀 二面核心题目详解"></a>🚀 二面核心题目详解</h3><h4 id="1-项目亮点介绍"><a href="#1-项目亮点介绍" class="headerlink" title="1. 项目亮点介绍"></a>1. 项目亮点介绍</h4><p><strong>答题建议：</strong></p><ul><li>选一个“有挑战/成果”的模块深入讲：<ul><li>比如：活动页组件化、加载优化、自研 Bridge 桥接方案</li><li>体现技术落地、团队协作、提效效果</li></ul></li></ul><hr><h4 id="2-原生与-Flutter-H5-交互设计（上下三层）"><a href="#2-原生与-Flutter-H5-交互设计（上下三层）" class="headerlink" title="2. 原生与 Flutter/H5 交互设计（上下三层）"></a>2. 原生与 Flutter/H5 交互设计（上下三层）</h4><p><strong>三层架构：</strong></p><ul><li>上层：业务 API（login、pay、share）</li><li>中层：Bridge 协议定义、参数统一封装（JSON）</li><li>底层：Native 实现，JS 调用处理、回调、权限判断等</li></ul><hr><h4 id="3-iOS-与-H5-交互方法及优缺点"><a href="#3-iOS-与-H5-交互方法及优缺点" class="headerlink" title="3. iOS 与 H5 交互方法及优缺点"></a>3. iOS 与 H5 交互方法及优缺点</h4><table><thead><tr><th>方法</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><code>evaluateJavaScript</code></td><td>简单直接</td><td>无回调、不安全</td></tr><tr><td><code>WKScriptMessageHandler</code></td><td>安全规范、结构清晰</td><td>配置繁琐，不适合高频交互</td></tr><tr><td>URL Scheme 拦截</td><td>通用性强</td><td>参数受限、安全差</td></tr></tbody></table><hr><h4 id="4-当前待遇-amp-期望薪资"><a href="#4-当前待遇-amp-期望薪资" class="headerlink" title="4. 当前待遇 &amp; 期望薪资"></a>4. 当前待遇 &amp; 期望薪资</h4><p><strong>建议答法：</strong></p><ul><li>当前总包/薪资范围</li><li>期望平台成长 + 技术深度 +回报匹配</li><li>可接受一定灵活性，但看重发展潜力</li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转转&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="转转" scheme="http://soso.wiki/tags/%E8%BD%AC%E8%BD%AC/"/>
    
  </entry>
  
  <entry>
    <title>京东</title>
    <link href="http://soso.wiki/2024-08-29-%E4%BA%AC%E4%B8%9C/"/>
    <id>http://soso.wiki/2024-08-29-京东/</id>
    <published>2024-08-29T09:30:00.000Z</published>
    <updated>2024-09-11T07:53:08.376Z</updated>
    
    <content type="html"><![CDATA[<p>京东<br><a id="more"></a></p><p>一面：</p><p>1.SDK 体积优化</p><p>2.组件化</p><p>3.端到端监控，具体实现</p><p>4.YYModel 的实现原理，和 MJExtension 区别，为什么比 MJExtension 快？</p><p>5.OOM 怎么排查</p><p>6.Facebook 出的异步渲染框架 AsyncDisplayKit 原理</p><p>7.样式字段很多，怎么和逻辑字段分开下发？</p><p>8.跨端方案，Talos lite</p><p>9.怎么提升代码质量</p><p>10.设计模式：策略模式、中介者模式</p><p>11.打点 cell 50%展现时打点</p><p>打点规范，怎么快速找到某一个页面的所有点击点位</p><p>12.产品上的业务指标</p><p>13.读写安全，除了加锁还有哪些方法</p><p>14.算法：实现一个列表，复用，不卡顿，cell 上是多个文本</p><p>二面：</p><p>1.Flutter 与 iOS 交互方法？</p><p>2.Flutter 的 UI 层在哪儿？RN 是原生控件</p><p>3.组件化的 Router 里的映射表什么时候生成？</p><p>4.JSBridge 原理，前端 JS 有哪些异步方法？前端有哪些存储方法，localstorage有大小限制吗？</p><p>5.iOS 打包流程，命令  Xcode build；Cocoapods 打包出来的第三方库是什么形式的？源码还是二进制？.a和.framework 有什么区别？</p><p>6.接口监控</p><p>7.为什么用到动态库，动态库类型是什么 so？</p><p>8.加载速度优化</p><p>9.SDK 体积优化</p><p>10.RN 的原理，怎么转成了原生控件？了解哪些动态化的方案？Weex、小程序等的区别</p><p>11.了解哪些性能优化，滑动流畅性的指标</p><p>12.深拷贝和浅拷贝的区别</p><p>13.App 启动流程，优化手段，main函数有哪些优化地方</p><p>14.发一个 Post 请求，怎么加快速度？Get 和 Post 请求区别，Get 可以将参数放在请求体吗？</p><p>15.触摸屏幕流程</p><p>16.Swift 中 Class 和 Struct 区别，Struct 可以继承吗？</p><p>17.堆和栈的区别</p><p>18.内存 isa</p><p>19.绘制流程</p><p>20.加载速度优化，各个阶段耗时有统计吗？网络的耗时在哪块儿？</p><p>21.IM 的架构</p><p>22.IM 怎么保证消息的顺序</p><h2 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a>参考答案</h2><p>一面：</p><p>1.SDK体积优化</p><p>2.组件化</p><p>3.端到端监控，具体实现</p><p>4.OOM怎么排查</p><p>5.样式字段很多，怎么和逻辑字段分开下发？</p><p>6.跨端方案，Talos lite</p><p>7.怎么提升代码质量</p><p>8.设计模式：策略模式、中介者模式</p><p>常见的23种设计模式包括：</p><ol><li><strong>创建型模式</strong>：<ul><li>单例模式 (Singleton)</li><li>工厂方法模式 (Factory Method)</li><li>抽象工厂模式 (Abstract Factory)</li><li>建造者模式 (Builder)</li><li>原型模式 (Prototype)</li></ul></li><li><strong>结构型模式</strong>：<ul><li>适配器模式 (Adapter)</li><li>桥接模式 (Bridge)</li><li>组合模式 (Composite)</li><li>装饰器模式 (Decorator)</li><li>外观模式 (Facade)</li><li>享元模式 (Flyweight)</li><li>代理模式 (Proxy)</li></ul></li><li><strong>行为型模式</strong>：<ul><li>责任链模式 (Chain of Responsibility)</li><li>命令模式 (Command)</li><li>解释器模式 (Interpreter)</li><li>迭代器模式 (Iterator)</li><li>中介者模式 (Mediator)</li><li>存储器模式 (Memento)</li><li>观察者模式 (Observer)</li><li>状态模式 (State)</li><li>策略模式 (Strategy)</li><li>模板方法模式 (Template Method)</li><li>访问者模式 (Visitor)</li></ul></li></ol><h4 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a><a href="https://www.runoob.com/design-pattern/mediator-pattern.html" target="_blank" rel="noopener">中介者模式</a></h4><p>中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性，属于行为型模式。</p><p>中介者模式定义了一个中介对象来封装一系列对象之间的交互。中介者使各对象之间不需要显式地相互引用，从而使其耦合松散，且可以独立地改变它们之间的交互。</p><h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a><a href="https://www.runoob.com/design-pattern/strategy-pattern.html" target="_blank" rel="noopener">策略模式</a></h4><p>在策略模式（Strategy Pattern）中一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。</p><p>在策略模式定义了一系列算法或策略，并将每个算法封装在独立的类中，使得它们可以互相替换。通过使用策略模式，可以在运行时根据需要选择不同的算法，而不需要修改客户端代码。</p><p>在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。</p><p>9.打点 cell 50%展现时打点</p><p>可以使用<code>UITableView</code>的<code>scrollViewDidScroll</code>方法来检测<code>cell</code>的可见区域。具体步骤如下：</p><ol><li><strong>设置UITableViewDelegate</strong>: 确保你的视图控制器实现了<code>UITableViewDelegate</code>协议，并设置<code>delegate</code>。</li><li><strong>计算可见区域</strong>: 在<code>scrollViewDidScroll</code>方法中，计算每个<code>cell</code>的可见区域，并检查它是否至少展现了50%。</li><li><strong>打点逻辑</strong>: 根据计算结果进行打点操作，例如记录数据或发送网络请求。</li></ol><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#import <span class="hljs-meta-string">"ViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">ViewController</span> () &lt;<span class="hljs-title">UITableViewDelegate</span>, <span class="hljs-title">UITableViewDataSource</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">weak</span>, <span class="hljs-keyword">nonatomic</span>) <span class="hljs-keyword">IBOutlet</span> <span class="hljs-built_in">UITableView</span> *tableView;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="hljs-keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="hljs-keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="hljs-keyword">self</span>.tableView.delegate = <span class="hljs-keyword">self</span>;</span><br><span class="line">    <span class="hljs-keyword">self</span>.tableView.dataSource = <span class="hljs-keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">#pragma mark - UITableViewDataSource</span></span><br><span class="line"></span><br><span class="line">- (<span class="hljs-built_in">NSInteger</span>)tableView:(<span class="hljs-built_in">UITableView</span> *)tableView numberOfRowsInSection:(<span class="hljs-built_in">NSInteger</span>)section &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>; <span class="hljs-comment">// 示例行数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="hljs-built_in">UITableViewCell</span> *)tableView:(<span class="hljs-built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="hljs-built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">    <span class="hljs-built_in">UITableViewCell</span> *cell = [tableView dequeueReusableCellWithIdentifier:<span class="hljs-string">@"cell"</span> forIndexPath:indexPath];</span><br><span class="line">    cell.textLabel.text = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@"Row %ld"</span>, (<span class="hljs-keyword">long</span>)indexPath.row];</span><br><span class="line">    <span class="hljs-keyword">return</span> cell;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">#pragma mark - UIScrollViewDelegate</span></span><br><span class="line"></span><br><span class="line">- (<span class="hljs-keyword">void</span>)scrollViewDidScroll:(<span class="hljs-built_in">UIScrollView</span> *)scrollView &#123;</span><br><span class="line">    <span class="hljs-built_in">NSArray</span>&lt;<span class="hljs-built_in">UITableViewCell</span> *&gt; *visibleCells = [<span class="hljs-keyword">self</span>.tableView visibleCells];</span><br><span class="line">    <span class="hljs-built_in">CGRect</span> visibleRect;</span><br><span class="line">    visibleRect.origin = <span class="hljs-keyword">self</span>.tableView.contentOffset;</span><br><span class="line">    visibleRect.size = <span class="hljs-keyword">self</span>.tableView.bounds.size;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">UITableViewCell</span> *cell <span class="hljs-keyword">in</span> visibleCells) &#123;</span><br><span class="line">        <span class="hljs-built_in">CGRect</span> cellRect = [<span class="hljs-keyword">self</span>.tableView convertRect:cell.frame toView:<span class="hljs-keyword">self</span>.tableView.superview];</span><br><span class="line">        <span class="hljs-built_in">CGRect</span> intersection = <span class="hljs-built_in">CGRectIntersection</span>(visibleRect, cellRect);</span><br><span class="line">        <span class="hljs-built_in">CGFloat</span> intersectionRatio = intersection.size.height / cellRect.size.height;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> (intersectionRatio &gt;= <span class="hljs-number">0.5</span>) &#123;</span><br><span class="line">            <span class="hljs-built_in">NSIndexPath</span> *indexPath = [<span class="hljs-keyword">self</span>.tableView indexPathForCell:cell];</span><br><span class="line">            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"Cell at %ld is at least 50%% visible."</span>, (<span class="hljs-keyword">long</span>)indexPath.row);</span><br><span class="line">            <span class="hljs-comment">// 打点逻辑，例如记录或发送请求</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul><li><strong>计算可见区域</strong>：使用<code>convertRect:toView:</code>方法将<code>cell</code>的frame转换到<code>superview</code>的坐标系，然后计算交集区域。</li><li><strong>检查比例</strong>：判断交集区域的高度与<code>cell</code>的总高度的比例是否大于或等于50%。</li></ul><p>这个实现将确保在<code>UITableView</code>滚动时，对每个<code>cell</code>进行检查，并在其至少展现50%时执行打点操作。</p><p>打点规范，怎么快速找到某一个页面的所有点击点位</p><p>10.产品上的业务指标</p><p>11.读写安全，除了加锁还有哪些方法</p><p>12.算法：实现一个列表，复用，不卡顿，cell上是多个文本</p><p>二面：</p><p>1.Flutter 与 iOS 交互方法？</p><p>2.Flutter 的 UI 层在哪儿？RN 是原生控件</p><p>3.组件化的 Router 里的映射表什么时候生成？</p><p>4.JSBridge 原理</p><p>5.iOS 打包流程，命令  Xcode build；Cocoapods 打包出来的第三方库是什么形式的？源码还是二进制？.a和.framework 有什么区别？</p><p>CocoaPods 打包出来的第三方库可以是源码形式，也可以是二进制形式，取决于库的发布方式。</p><ol><li><strong>源码形式</strong>：大多数CocoaPods库以源码形式提供。这意味着CocoaPods会将库的源代码下载到你的项目中，并在构建时编译这些代码。</li><li><strong>二进制形式</strong>：一些库提供二进制预编译版本，以减少编译时间和提高构建速度。在这种情况下，CocoaPods会下载预编译的二进制文件，而不是源码。</li></ol><p>你可以在<code>Podspec</code>文件中检查库的具体形式，通常在<code>source</code>字段中定义了库的来源。如果是二进制库，<code>Podspec</code>会指定二进制文件的URL和相关配置。</p><p><code>.a</code>和<code>.framework</code>是iOS开发中常见的两种二进制文件格式，分别代表静态库和动态库。它们的主要区别如下：</p><ol><li><strong><code>.a</code>（静态库）</strong>：<ul><li><strong>打包形式</strong>：静态库是一个归档文件，包含了多个编译好的目标文件（<code>.o</code>文件）。</li><li><strong>链接方式</strong>：在编译时，静态库的代码会被直接链接到应用程序中。每次构建时，库的代码会被复制到最终的可执行文件中。</li><li><strong>更新</strong>：如果静态库的代码有更新，必须重新编译整个应用程序。</li><li><strong>体积</strong>：由于代码被复制到应用程序中，最终的应用包可能会较大。</li></ul></li><li><strong><code>.framework</code>（动态库）</strong>：<ul><li><strong>打包形式</strong>：动态库是一个文件夹（包），包含库的二进制文件以及相关的资源文件（如头文件和配置文件）。它可以包含多个版本和资源。</li><li><strong>链接方式</strong>：动态库在运行时被加载到内存中。应用程序在运行时与库链接，而不是在编译时。这样，多个应用程序可以共享同一个动态库。</li><li><strong>更新</strong>：更新动态库只需替换库文件，不需要重新编译依赖于该库的应用程序。</li><li><strong>体积</strong>：动态库的使用可以减少最终应用程序的体积，因为库的代码和资源在运行时被共享和加载。</li></ul></li></ol><p>简而言之，<code>.a</code>是静态库，编译时直接包含在应用中；<code>.framework</code>是动态库，在运行时动态加载和共享。</p><p>6.接口监控</p><p>7.为什么用到动态库，动态库类型是什么 so？</p><p>8.加载速度优化</p><p>9.SDK 体积优化</p><p>10.RN 的原理，怎么转成了原生控件？了解哪些动态化的方案？Weex、小程序等的区别</p><p>11.了解哪些性能优化，滑动流畅性的指标</p><p>12.深拷贝和浅拷贝的区别</p><p>13.App 启动流程，优化手段，main函数有哪些优化地方</p><p>14.发一个 Post 请求，怎么加快速度？Get 和 Post 请求区别，Get 可以将参数放在请求体吗？</p><p>15.触摸屏幕流程</p><p>16.Swift 中 Class 和 Struct 区别，Struct 可以继承吗？</p><p>17.堆和栈的区别</p><p>18.内存 isa</p><p>19.绘制流程</p><p>20.加载速度优化，各个阶段耗时有统计吗？网络的耗时在哪块儿？</p><p>21.IM 的架构</p><p>22.IM 怎么保证消息的顺序</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;京东&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="京东" scheme="http://soso.wiki/tags/%E4%BA%AC%E4%B8%9C/"/>
    
      <category term="京东搜索" scheme="http://soso.wiki/tags/%E4%BA%AC%E4%B8%9C%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>天眼查</title>
    <link href="http://soso.wiki/2024-08-29-%E5%A4%A9%E7%9C%BC%E6%9F%A5/"/>
    <id>http://soso.wiki/2024-08-29-天眼查/</id>
    <published>2024-08-29T03:00:00.000Z</published>
    <updated>2024-08-29T09:14:55.744Z</updated>
    
    <content type="html"><![CDATA[<p>天眼查<br><a id="more"></a></p><p>1.通用化技术提升迭代效率</p><p>2.降低三方 App 接入成本</p><p>3.SDK 体积优化，为什么用 Masonry 会增加体积</p><p>4.加载速度优化，怎么统计的？多个请求并发怎么处理的？</p><p>5.引用计数，isa 里都有什么？weak 的实现？对象的释放流程</p><p>6.方法交换交换的是什么？</p><p>7.SDWebImage加载url的流程，三级缓存，清除缓存</p><p>7.block 的变量捕获，为什么用<code>__block</code>可以修改局部变量的值</p><p>8.找出代码里有问题的地方，可变数组用 copy 修饰，调用添加元素方法会发生什么？能不能上报、拦截闪退？线程不安全怎么处理？常用的加锁方式，区别？</p><p>9.<a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">删除链表的倒数第 N 个结点</a></p><h2 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a>参考答案</h2><p>1.通用化技术提升迭代效率</p><p>2.降低三方 App 接入成本</p><p>3.SDK 体积优化，为什么用 Masonry 会增加体积</p><p>4.加载速度优化，怎么统计的？多个请求并发怎么处理的？</p><p>5.引用计数，isa 里都有什么？weak 的实现？对象的释放流程，怎么判断是否有弱引用</p><p>isa</p><ul><li><p>nonpointer 0，代表普通的指针，存储着Class、Meta-Class对象的内存地址1，代表优化过，使用位域存储更多的信息</p></li><li><p>has_assoc 是否有设置过关联对象，如果没有，释放时会更快</p></li><li><p>has_cxx_dtor 是否有C++的析构函数（.cxx_destruct），如果没有，释放时会更快</p></li><li><p>shiftcls 存储着Class、Meta-Class对象的内存地址信息</p></li><li><p>magic 用于在调试时分辨对象是否未完成初始化</p></li><li><p>weakly_referenced 是否有被弱引用指向过，如果没有，释放时会更快</p></li><li><p>deallocating 对象是否正在释放</p></li><li><p>extra_rc 里面存储的值是引用计数器减1</p></li><li><p>has_sidetable_rc 引用计数器是否过大无法存储在isa中如果为1，那么引用计数会存储在一个叫SideTable的类的属性中</p></li></ul><p>6.方法交换交换的是什么？</p><p>7.block 的变量捕获，为什么用<code>__block</code>可以修改局部变量的值</p><p>8.找出代码里有问题的地方，可变数组用 copy 修饰，调用添加元素方法会发生什么？能不能上报、拦截闪退？线程不安全怎么处理？常用的加锁方式，区别？</p><p>9.<a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">删除链表的倒数第 N 个结点</a></p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="hljs-comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="hljs-comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="hljs-comment"> * &#125;</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">var</span> removeNthFromEnd = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head, n</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> length = getLength(head);</span><br><span class="line">    <span class="hljs-keyword">let</span> i = length - n;</span><br><span class="line">    <span class="hljs-keyword">let</span> dummyNode = <span class="hljs-keyword">new</span> ListNode();</span><br><span class="line">    dummyNode.next = head;</span><br><span class="line">    <span class="hljs-keyword">let</span> p = dummyNode;</span><br><span class="line">    <span class="hljs-keyword">while</span> (i &gt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">        p = p.next;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    p.next = p.next.next;</span><br><span class="line">    <span class="hljs-keyword">return</span> dummyNode.next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> getLength = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> length = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">let</span> p = head;</span><br><span class="line">    <span class="hljs-keyword">while</span> (p) &#123;</span><br><span class="line">        length++;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;天眼查&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="天眼查" scheme="http://soso.wiki/tags/%E5%A4%A9%E7%9C%BC%E6%9F%A5/"/>
    
  </entry>
  
  <entry>
    <title>二叉树算法题</title>
    <link href="http://soso.wiki/2024-08-29-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    <id>http://soso.wiki/2024-08-29-二叉树算法题/</id>
    <published>2024-08-28T16:06:00.000Z</published>
    <updated>2024-08-28T16:13:54.197Z</updated>
    
    <content type="html"><![CDATA[<p>二叉树算法题（ JavaScript 实现）<br><a id="more"></a></p><h4 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">二叉树的中序遍历</a></h4><p>递归：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> inorderTraversal = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> res = []</span><br><span class="line">    <span class="hljs-keyword">const</span> inorder = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(root.left);</span><br><span class="line">        res.push(root.val);</span><br><span class="line">        inorder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    inorder(root);</span><br><span class="line">    <span class="hljs-keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>迭代：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> inorderTraversal = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">const</span> res = [];</span><br><span class="line">    <span class="hljs-keyword">const</span> stack = [];</span><br><span class="line">    <span class="hljs-keyword">let</span> cur = root;</span><br><span class="line">    <span class="hljs-keyword">while</span> (stack.length || cur) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (cur) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            cur = stack.pop();</span><br><span class="line">            res.push(cur.val);</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">二叉树的层序遍历</a></h4><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> levelOrder = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">const</span> res = [], queue = [];</span><br><span class="line">    queue.push(root);</span><br><span class="line">    <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">while</span> (queue.length) &#123;</span><br><span class="line">        <span class="hljs-keyword">let</span> curLevel = [];</span><br><span class="line">        <span class="hljs-keyword">let</span> length = queue.length;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="hljs-keyword">let</span> node = queue.shift();</span><br><span class="line">            curLevel.push(node.val);</span><br><span class="line">            <span class="hljs-keyword">if</span> (node.left) &#123;</span><br><span class="line">                queue.push(node.left);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="hljs-keyword">if</span> (node.right) &#123;</span><br><span class="line">                queue.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.push(curLevel);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">二叉树的最大深度</a></h4><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> maxDepth = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.max(maxDepth(root.left), maxDepth(root.right)) + <span class="hljs-number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a><a href="https://leetcode.cn/problems/invert-binary-tree/" target="_blank" rel="noopener">翻转二叉树</a></h4><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> invertTree = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">let</span> left = invertTree(root.left);</span><br><span class="line">    <span class="hljs-keyword">let</span> right = invertTree(root.right);</span><br><span class="line">    root.left = right;</span><br><span class="line">    root.right = left;</span><br><span class="line">    <span class="hljs-keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="二叉树的直径"><a href="#二叉树的直径" class="headerlink" title="二叉树的直径"></a><a href="https://leetcode.cn/problems/diameter-of-binary-tree/" target="_blank" rel="noopener">二叉树的直径</a></h4><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> diameterOfBinaryTree = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> ans = <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDepth</span>(<span class="hljs-params">root</span>) </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">let</span> left = getDepth(root.left);</span><br><span class="line">        <span class="hljs-keyword">let</span> right = getDepth(root.right);</span><br><span class="line">        ans = <span class="hljs-built_in">Math</span>.max(ans, left + right + <span class="hljs-number">1</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.max(left, right) + <span class="hljs-number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    getDepth(root);</span><br><span class="line">    <span class="hljs-keyword">return</span> ans - <span class="hljs-number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;二叉树算法题（ JavaScript 实现）&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="算法" scheme="http://soso.wiki/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="http://soso.wiki/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>百川智能</title>
    <link href="http://soso.wiki/%E7%99%BE%E5%B7%9D%E6%99%BA%E8%83%BD/"/>
    <id>http://soso.wiki/百川智能/</id>
    <published>2024-08-28T03:00:00.000Z</published>
    <updated>2024-08-30T05:53:38.036Z</updated>
    
    <content type="html"><![CDATA[<p>百川智能<br><a id="more"></a></p><p>一面：</p><p>1.SDK体积优化</p><p>2.webView白屏</p><p>3.线上闪退处理流程</p><p>4.Runtime、Runloop应用，结合项目；为什么开启runloop</p><p>5.MVC MVVM 项目里具体的用法</p><p>算法：</p><p>1.单链表中是否存在环？如果存在，返回环的起始节点。解释快慢指针原理。</p><p>2.一百盏灯排成一行,从左到右编号1-100,每盏灯都有一根开关,一开始全是灭的,另外有100小孩,第一个把1的倍数的开关拉一下,第二个把凡是2的倍数开关拉一下,这样下去到最后一盏灯,有哪些是亮的？（口述思路）</p><p>二面：</p><p>1.写一个工具方法：用 OC 或 Swift 实现，查找数组的第 k 个大的元素</p><p>要求能在项目里实际使用，可以用三方库。注意边界条件。</p><p>2.卡片动态化，怎么避免因为卡片样式等接需求</p><p>3.IM列表数据过大的问题</p><p>4.删除消息怎么保证多端一致性</p><p>5.怎么解决ViewModel过大的问题，MVVM和MVC的核心区别是双向绑定吗？</p><p>6.为什么选择SSE</p><p>7.离线包</p><p>8.webView cookie 丢失问题</p><p>9.RN长列表性能问题</p><h2 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a>参考答案</h2><p>(GPT)</p><p>1.SDK体积优化</p><p>2.webView白屏</p><p>3.线上闪退处理流程</p><p>4.Runtime、Runloop应用，结合项目</p><p>算法：</p><p>1.单链表中是否存在环？如果存在，返回环的起始节点。解释快慢指针原理。</p><p>2.一百盏灯排成一行,从左到右编号1-100,每盏灯都有一根开关,一开始全是灭的,另外有100小孩,第一个把1的倍数的开关拉一下,第二个把凡是2的倍数开关拉一下,这样下去到最后一盏灯,有哪些是亮的？（口述思路）</p><p>这个问题可以通过分析开关操作的规律来解决。我们来详细探讨一下每盏灯的状态。</p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><ul><li>一开始，每盏灯都是灭的。</li><li>每个小孩操作的是与他们编号相同的倍数的开关。例如，第一个小孩操作的是1、2、3、4、…、100号开关；第二个小孩操作的是2、4、6、8、…、100号开关，依此类推。</li></ul><h3 id="观察灯的状态"><a href="#观察灯的状态" class="headerlink" title="观察灯的状态"></a>观察灯的状态</h3><p>每盏灯的状态取决于被多少个小孩操作。一个灯的状态会在操作次数（开关次数）为奇数时变为亮，为偶数时保持灭。</p><p>我们可以发现：</p><ul><li>如果灯的编号是 ( n )，那么它会被所有 ( n ) 的因子的小孩操作。比如，灯编号为12的灯会被1、2、3、4、6、12号小孩操作。</li><li>因此，每盏灯的状态由它的因子数量决定。如果因子数量是奇数，则灯是亮的。如果因子数量是偶数，则灯是灭的。</li></ul><h3 id="因子数量的分析"><a href="#因子数量的分析" class="headerlink" title="因子数量的分析"></a>因子数量的分析</h3><p>每个正整数 ( n ) 的因子数量通常是偶数，因为因子通常成对出现（比如 ( 1 ) 和 ( n ), ( 2 ) 和 ( n/2 ) 等）。然而，完全平方数（如1, 4, 9, 16, …）的因子数量是奇数，因为一个因子对（如 ( \sqrt{n} )）会被重复计算一次。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul><li>只有完全平方数的因子数量是奇数，因此只有那些灯编号是完全平方数的灯会在最后亮着。</li></ul><h3 id="列出完全平方数"><a href="#列出完全平方数" class="headerlink" title="列出完全平方数"></a>列出完全平方数</h3><ol><li>( 1^2 = 1 )</li><li>( 2^2 = 4 )</li><li>( 3^2 = 9 )</li><li>( 4^2 = 16 )</li><li>( 5^2 = 25 )</li><li>( 6^2 = 36 )</li><li>( 7^2 = 49 )</li><li>( 8^2 = 64 )</li><li>( 9^2 = 81 )</li><li>( 10^2 = 100 )</li></ol><p>所以，最后亮着的灯的编号是：1, 4, 9, 16, 25, 36, 49, 64, 81, 100。</p><p>二面：</p><p>1.写一个工具方法：用 OC 或 Swift 实现，查找数组的第 k 个大的元素</p><p>要求能在项目里实际使用，可以用三方库。注意边界条件。</p><p>2.卡片动态化，怎么避免因为卡片样式等接需求</p><p>3.IM列表数据过大的问题</p><p>4.删除消息怎么保证多端一致性</p><p>5.怎么解决ViewModel过大的问题，MVVM和MVC的核心区别是双向绑定吗？</p><p>6.为什么选择SSE</p><p>相较于其他流式数据传输方式，SSE 的优点包括：</p><ol><li><strong>简单实现</strong>：SSE 使用标准的 HTTP 协议，易于实现和调试，尤其是对于基本的实时推送需求。</li><li><strong>自动重连</strong>：SSE 支持自动重连机制，连接丢失后会自动尝试重新建立连接，确保数据传输的可靠性。</li><li><strong>单向通信</strong>：适用于只需要从服务器到客户端的单向数据流的场景，例如新闻推送或实时更新。</li><li><strong>轻量级</strong>：SSE 不需要额外的握手或复杂的协议栈，相比 WebSocket，SSE 的实现和维护成本较低。</li><li><strong>文本数据</strong>：SSE 以 UTF-8 编码的文本格式传输数据，解析起来较为简单。</li></ol><p>这些优点使 SSE 在需要简单、可靠的实时数据推送时成为一个合适的选择。</p><p>流式数据可以通过多种方式进行传输，具体选择取决于应用场景、性能需求和技术栈。以下是一些常见的流式数据传输方法：</p><h3 id="1-WebSocket"><a href="#1-WebSocket" class="headerlink" title="1. WebSocket"></a>1. <strong>WebSocket</strong></h3><ul><li><strong>描述</strong>：WebSocket 是一种在单个 TCP 连接上进行全双工通信的协议。与 HTTP 不同，它允许在客户端和服务器之间进行双向实时数据交换。</li><li><strong>适用场景</strong>：需要双向实时通信的应用，例如在线游戏、实时聊天、协作工具。</li><li><strong>优点</strong>：低延迟、双向通信、持久连接。</li></ul><h3 id="2-Server-Sent-Events-SSE"><a href="#2-Server-Sent-Events-SSE" class="headerlink" title="2. Server-Sent Events (SSE)"></a>2. <strong>Server-Sent Events (SSE)</strong></h3><ul><li><strong>描述</strong>：SSE 允许服务器通过单向的持久连接向客户端推送实时事件。客户端可以通过 EventSource API 接收这些事件。</li><li><strong>适用场景</strong>：需要从服务器向客户端推送实时数据的应用，例如实时更新的新闻推送、监控系统。</li><li><strong>优点</strong>：简单易用、自动重连、支持文本数据。</li></ul><h3 id="3-HTTP-2"><a href="#3-HTTP-2" class="headerlink" title="3. HTTP/2"></a>3. <strong>HTTP/2</strong></h3><ul><li><strong>描述</strong>：HTTP/2 是 HTTP 协议的升级版，支持多路复用（multiplexing），允许在单个 TCP 连接上并发传输多个请求和响应。</li><li><strong>适用场景</strong>：需要高效和快速加载的网页应用、实时更新的内容。</li><li><strong>优点</strong>：减少延迟、提高传输效率、支持流式数据传输。</li></ul><h3 id="4-gRPC"><a href="#4-gRPC" class="headerlink" title="4. gRPC"></a>4. <strong>gRPC</strong></h3><ul><li><strong>描述</strong>：gRPC 是 Google 开发的开源高性能 RPC 框架，支持双向流式通信。基于 HTTP/2，提供了高效的通信机制。</li><li><strong>适用场景</strong>：微服务架构、需要高效传输和处理大规模数据的系统。</li><li><strong>优点</strong>：强类型、安全、高性能、支持双向流。</li></ul><h3 id="5-MQTT-Message-Queuing-Telemetry-Transport"><a href="#5-MQTT-Message-Queuing-Telemetry-Transport" class="headerlink" title="5. MQTT (Message Queuing Telemetry Transport)"></a>5. <strong>MQTT (Message Queuing Telemetry Transport)</strong></h3><ul><li><strong>描述</strong>：MQTT 是一种轻量级的消息传输协议，设计用于低带宽、不稳定的网络环境。支持发布/订阅模型。</li><li><strong>适用场景</strong>：物联网（IoT）设备通信、低带宽网络中的消息传输。</li><li><strong>优点</strong>：轻量、可靠、适合低带宽和高延迟的环境。</li></ul><h3 id="6-Apache-Kafka"><a href="#6-Apache-Kafka" class="headerlink" title="6. Apache Kafka"></a>6. <strong>Apache Kafka</strong></h3><ul><li><strong>描述</strong>：Apache Kafka 是一个分布式流媒体平台，用于构建实时数据流应用和数据管道。支持高吞吐量的数据传输。</li><li><strong>适用场景</strong>：需要处理大量实时数据的应用、数据管道、日志聚合。</li><li><strong>优点</strong>：高吞吐量、可扩展、持久性、高可靠性。</li></ul><h3 id="7-Redis-Streams"><a href="#7-Redis-Streams" class="headerlink" title="7. Redis Streams"></a>7. <strong>Redis Streams</strong></h3><ul><li><strong>描述</strong>：Redis Streams 是 Redis 的一种数据结构，用于处理流数据。支持持久化、高效的流数据存储和处理。</li><li><strong>适用场景</strong>：需要高效处理流数据的应用，例如实时数据分析、日志处理。</li><li><strong>优点</strong>：高性能、简单易用、支持持久化和数据恢复。</li></ul><h3 id="8-WebRTC"><a href="#8-WebRTC" class="headerlink" title="8. WebRTC"></a>8. <strong>WebRTC</strong></h3><ul><li><strong>描述</strong>：WebRTC 是一种支持浏览器之间直接进行实时通信的技术，支持视频、音频和数据流。</li><li><strong>适用场景</strong>：视频会议、实时数据传输、点对点通信。</li><li><strong>优点</strong>：低延迟、点对点通信、支持多种数据类型。</li></ul><h3 id="9-Chunked-Transfer-Encoding"><a href="#9-Chunked-Transfer-Encoding" class="headerlink" title="9. Chunked Transfer Encoding"></a>9. <strong>Chunked Transfer Encoding</strong></h3><ul><li><strong>描述</strong>：这是 HTTP/1.1 中的一种传输编码方式，允许服务器分块传输数据，客户端可以在接收数据时开始处理。</li><li><strong>适用场景</strong>：需要逐步传输大数据的场景。</li><li><strong>优点</strong>：支持动态生成和传输数据，减少了延迟。</li></ul><h3 id="10-Data-Streams-File-Streams"><a href="#10-Data-Streams-File-Streams" class="headerlink" title="10. Data Streams (File Streams)"></a>10. <strong>Data Streams (File Streams)</strong></h3><ul><li><strong>描述</strong>：通过文件流传输数据，通常用于大文件的逐步传输和处理。</li><li><strong>适用场景</strong>：大文件传输、流式处理数据。</li><li><strong>优点</strong>：支持大数据文件的逐步传输、处理。</li></ul><p>选择合适的流式数据传输方式需要考虑具体的应用需求、数据量、实时性要求、网络条件等因素。每种技术都有其特定的优点和适用场景。</p><p>7.离线包</p><p>8.webView cookie 丢失问题</p><p>iOS WebView 中的 Cookie 丢失通常可以由以下几个原因引起：</p><ol><li><strong>App 重新启动</strong>：WebView 的 Cookie 存储在内存中，当应用被终止或重启时，这些 Cookie 可能会丢失。</li><li><strong>Cookies 设置</strong>：iOS 的 WebView 可能会受到应用的 Cookie 设置或隐私策略的影响，特别是在使用 <code>WKWebView</code> 时，它的 Cookie 存储可能与 <code>UIWebView</code> 不同。</li><li><strong>共享 Cookie</strong>：<code>WKWebView</code> 和 <code>UIWebView</code> 使用不同的 Cookie 存储机制，它们之间的 Cookie 可能无法共享。</li><li><strong>域名问题</strong>：确保设置和读取 Cookie 的域名一致，跨域请求可能导致 Cookie 丢失。</li></ol><h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h3><ol><li><p><strong>使用 <code>WKWebView</code> 的 <code>WKWebsiteDataStore</code></strong>：</p><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> webView = <span class="hljs-type">WKWebView</span>(frame: .zero, configuration: <span class="hljs-type">WKWebViewConfiguration</span>())</span><br><span class="line"><span class="hljs-keyword">let</span> dataStore = <span class="hljs-type">WKWebsiteDataStore</span>.<span class="hljs-keyword">default</span>()</span><br><span class="line">webView.configuration.websiteDataStore = dataStore</span><br></pre></td></tr></table></figure></li><li><p><strong>持久化 Cookie</strong>： 你可以手动持久化和恢复 Cookie。例如，通过 <code>HTTPCookieStorage</code> 保存 Cookie，然后在应用启动时恢复：</p><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// Save cookies</span></span><br><span class="line"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> cookies = <span class="hljs-type">HTTPCookieStorage</span>.shared.cookies &#123;</span><br><span class="line">    <span class="hljs-type">UserDefaults</span>.standard.<span class="hljs-keyword">set</span>(cookies.<span class="hljs-built_in">map</span> &#123; <span class="hljs-type">NSKeyedArchiver</span>.archivedData(withRootObject: \$<span class="hljs-number">0</span>) &#125;, forKey: <span class="hljs-string">"savedCookies"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Load cookies</span></span><br><span class="line"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> cookieData = <span class="hljs-type">UserDefaults</span>.standard.array(forKey: <span class="hljs-string">"savedCookies"</span>) <span class="hljs-keyword">as</span>? [<span class="hljs-type">Data</span>] &#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> cookies = cookieData.compactMap &#123; <span class="hljs-type">NSKeyedUnarchiver</span>.unarchiveObject(with: \$<span class="hljs-number">0</span>) <span class="hljs-keyword">as</span>? <span class="hljs-type">HTTPCookie</span> &#125;</span><br><span class="line">    cookies.forEach &#123; <span class="hljs-type">HTTPCookieStorage</span>.shared.setCookie(\$<span class="hljs-number">0</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>确保 WebView 配置正确</strong>：确保 WebView 使用的是适当的 <code>WKWebViewConfiguration</code>，并且 Cookie 设置没有被隐私设置或其他配置所干扰。</p></li></ol><p>这些方法可以帮助管理和解决 iOS WebView 中的 Cookie 丢失问题。</p><p><a href="https://www.jianshu.com/p/8636ccd3674b" target="_blank" rel="noopener">https://www.jianshu.com/p/8636ccd3674b</a></p><p>9.RN长列表性能问题</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;百川智能&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="百川智能" scheme="http://soso.wiki/tags/%E7%99%BE%E5%B7%9D%E6%99%BA%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>汽车之家</title>
    <link href="http://soso.wiki/%E6%B1%BD%E8%BD%A6%E4%B9%8B%E5%AE%B6/"/>
    <id>http://soso.wiki/汽车之家/</id>
    <published>2024-08-23T06:00:00.000Z</published>
    <updated>2024-08-28T07:40:22.757Z</updated>
    
    <content type="html"><![CDATA[<p>汽车之家<br><a id="more"></a><br>1.动态库和静态库的区别</p><p>2.网络优化</p><p>3.静态分析发现了哪些问题？</p><p>4.加载速度优化</p><p>5.Crash 监测，野指针定位</p><p>.打印结果</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;</span><br><span class="line"> <span class="hljs-keyword">int</span>(^aBlock)(<span class="hljs-keyword">int</span>) = ^(<span class="hljs-keyword">int</span> num) &#123;</span><br><span class="line">     a += num;</span><br><span class="line">     <span class="hljs-keyword">if</span> (a &lt; <span class="hljs-number">5</span>) &#123;</span><br><span class="line">         aBlock(a);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="hljs-keyword">return</span> a++;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"%d"</span>, aBlock(<span class="hljs-number">1</span>));</span><br></pre></td></tr></table></figure><p>aBlock为什么是空？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;汽车之家&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="汽车之家" scheme="http://soso.wiki/tags/%E6%B1%BD%E8%BD%A6%E4%B9%8B%E5%AE%B6/"/>
    
  </entry>
  
  <entry>
    <title>元石</title>
    <link href="http://soso.wiki/%E5%85%83%E7%9F%B3/"/>
    <id>http://soso.wiki/元石/</id>
    <published>2024-08-23T03:00:00.000Z</published>
    <updated>2024-08-28T07:32:32.818Z</updated>
    
    <content type="html"><![CDATA[<p>元石<br><a id="more"></a></p><p>一面：</p><p>项目</p><p>1.SSE 怎么实现逐字打印效果，event来了个卡片，怎么保证顺序？</p><p>2.三方接入成本为什么还需要5人日？toast这种是不是SDK实现好点，担心增加体积可以用subPackage</p><p>3.SDK体积优化</p><p>4.加载速度优化</p><p>5.活动页组件化</p><p>6.卡顿监控，能获取到卡顿的堆栈吗？</p><p>7.组件化能不在+load注册吗？attribute注册了解吗？</p><p>算法：</p><p>1.<a href="https://leetcode.cn/problems/combination-sum/" target="_blank" rel="noopener">39. 组合总和</a></p><p>2.合并两个有序链表</p><p>二面：</p><p>1.通用化技术提升迭代效率，scheme和动态化，设计scheme需要有哪些注意点</p><p>2.白屏率怎么统计？</p><p>3.活动页组件化</p><p>4.RN跟Flutter的对比</p><p>5.SSE实现打字机效果，对SSE的了解，切换前后台，怎么断点续传</p><p>6.算法：反转数  输入int  返回int   边界条件、能运行</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;元石&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="元石" scheme="http://soso.wiki/tags/%E5%85%83%E7%9F%B3/"/>
    
  </entry>
  
  <entry>
    <title>度小满</title>
    <link href="http://soso.wiki/%E5%BA%A6%E5%B0%8F%E6%BB%A1/"/>
    <id>http://soso.wiki/度小满/</id>
    <published>2024-08-20T14:50:00.000Z</published>
    <updated>2024-08-20T14:50:56.034Z</updated>
    
    <content type="html"><![CDATA[<p>度小满<br><a id="more"></a></p><p>一面：</p><p>1.内存管理，内存泄漏，监测方法，解决办法</p><p>2.App启动流程，优化方法，查看每个阶段耗时的方法</p><p>Category和Extension区别，使用场景</p><p>Category可以添加属性吗？</p><p>3.webView和原生交互，怎么提升webView加载速度？H5怎么加载本地的JS和图片资源？</p><p>4.HTTP和HTTPS的区别，HTTPS怎么保证安全？GET和POST区别？请求头里一般有什么？</p><p>5.MVC、MVP、MVVM区别，使用场景</p><p>6.用OC实现一个栈，push  pop  isEmpty方法，栈和队列的区别，使用场景</p><p>7.了解鸿蒙吗</p><p>二面：</p><p>1.了解提升研发效率的方法，跨平台框架？</p><p>2.Flutter和原生交互方法</p><p>3.小程序的实现原理，SN的实现原理</p><p>3.设计图片下载框架，包括内存，缓存，解码等；缓存的技术指标是什么？(命中率) 在缓存即将达到最大容量时，同时有大量写入缓存的操作，怎么优化？</p><p>4.下载限制并发数量，下载断点续传    http请求码是多少</p><p>5.同层渲染怎么实现</p><p>6.webView加载速度优化</p><p>7.线上卡顿监控，卡顿优化</p><p>8.线上内存监控</p><p>9.口述快速排序，快速排序用迭代实现</p><p>10.HTTPS的流程，客户端校验证书的过程，链式验证</p><p>三面：</p><p>1.监控</p><p>2.原生与H5交互，注入和post message怎么选型的？</p><p>3.有没有关注过业务指标，技术手段提升业务指标的情况？收银台支付成功率？</p><p>4.其他：年龄、看机会原因，有没有别的offer</p><h2 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a>参考答案</h2><p>1.内存管理，内存泄漏，卡顿监测方法，解决办法</p><p>2.App启动流程，优化方法，查看每个阶段耗时的方法</p><p>3.webView和原生交互，怎么提升webView加载速度？H5怎么加载本地的JS和图片资源？</p><p>4.HTTP和HTTPS的区别，HTTPS怎么保证安全？GET和POST区别？请求头里一般有什么？</p><p>HTTP（HyperText Transfer Protocol）和HTTPS（HyperText Transfer Protocol Secure）是用于在网络上传输数据的两种协议。它们有以下主要区别：</p><ol><li><strong>安全性</strong>：<ul><li><strong>HTTP</strong>：数据以纯文本形式传输，不加密。因此，数据在传输过程中容易被截获和篡改。</li><li><strong>HTTPS</strong>：在HTTP的基础上增加了SSL/TLS加密层。数据在传输过程中会被加密，提供了数据的保密性和完整性，防止被窃听和篡改。</li></ul></li><li><strong>端口</strong>：<ul><li><strong>HTTP</strong>：默认使用80端口。</li><li><strong>HTTPS</strong>：默认使用443端口。</li></ul></li><li><strong>证书</strong>：<ul><li><strong>HTTP</strong>：不需要证书。</li><li><strong>HTTPS</strong>：需要SSL/TLS证书，用于加密通信和验证服务器身份。证书由受信任的证书颁发机构（CA）签发。</li></ul></li><li><strong>性能</strong>：<ul><li><strong>HTTP</strong>：因为没有加密和解密的过程，速度相对较快。</li><li><strong>HTTPS</strong>：由于需要进行加密和解密操作，性能会有所下降，但现代硬件和优化技术已经极大地减少了这种影响。</li></ul></li></ol><p>GET和POST区别</p><ul><li><strong>GET</strong>：主要用于获取数据，参数在URL中，适合传输较少、非敏感数据，幂等且可缓存。</li><li><strong>POST</strong>：主要用于提交数据，参数在请求体中，适合传输大量、敏感数据，非幂等且通常不缓存。</li></ul><p>以下是一些常见的HTTP请求头字段及其作用：</p><h3 id="1-通用请求头字段"><a href="#1-通用请求头字段" class="headerlink" title="1. 通用请求头字段"></a>1. <strong>通用请求头字段</strong></h3><ul><li><strong>Host</strong>：指定请求的目标主机和端口，例如：<code>Host: www.example.com</code>。这是HTTP/1.1中必须包含的头字段。</li><li><strong>User-Agent</strong>：标识发出请求的客户端软件信息，例如浏览器类型和版本、操作系统等，例如：<code>User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3</code>。</li><li><strong>Accept</strong>：指定客户端能够处理的内容类型，例如：<code>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</code>。</li><li><strong>Accept-Language</strong>：指定客户端首选的语言和地区，例如：<code>Accept-Language: en-US,en;q=0.5</code>。</li><li><strong>Accept-Encoding</strong>：指定客户端支持的内容编码类型，例如：<code>Accept-Encoding: gzip, deflate, br</code>。</li><li><strong>Connection</strong>：控制连接的管理，例如：<code>Connection: keep-alive</code>或<code>Connection: close</code>。</li></ul><h3 id="2-请求头字段（请求特有）"><a href="#2-请求头字段（请求特有）" class="headerlink" title="2. 请求头字段（请求特有）"></a>2. <strong>请求头字段（请求特有）</strong></h3><ul><li><strong>Referer</strong>：指示请求的来源页面的URL，例如：<code>Referer: https://www.example.com/previous-page</code>。</li><li><strong>Cookie</strong>：发送存储在客户端的Cookie数据，例如：<code>Cookie: sessionId=abc123; theme=light</code>。</li><li><strong>Authorization</strong>：用于传递身份验证凭据，例如：<code>Authorization: Bearer token123</code>或<code>Authorization: Basic base64credentials</code>。</li><li><strong>Content-Type</strong>：指定请求体的媒体类型，常用于POST和PUT请求，例如：<code>Content-Type: application/json</code>或<code>Content-Type: application/x-www-form-urlencoded</code>。</li><li><strong>Content-Length</strong>：表示请求体的字节长度，例如：<code>Content-Length: 348</code>。</li><li><strong>Origin</strong>：表明请求的来源，用于跨域请求，例如：<code>Origin: https://www.example.com</code>。</li><li><strong>If-Modified-Since</strong>：用于条件请求，只在指定日期之后资源被修改时才返回，例如：<code>If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT</code>。</li><li><strong>If-None-Match</strong>：用于条件请求，当ETag不匹配时才返回，例如：<code>If-None-Match: &quot;abc123&quot;</code>。</li><li><strong>Range</strong>：请求部分资源内容，例如：<code>Range: bytes=500-999</code>。</li></ul><h3 id="3-自定义请求头字段"><a href="#3-自定义请求头字段" class="headerlink" title="3. 自定义请求头字段"></a>3. <strong>自定义请求头字段</strong></h3><ul><li><strong>X-Requested-With</strong>：通常用于标识Ajax请求，例如：<code>X-Requested-With: XMLHttpRequest</code>。</li><li><strong>X-CSRF-Token</strong>：用于传递CSRF（跨站请求伪造）令牌，以防止CSRF攻击。</li><li><strong>X-Forwarded-For</strong>：记录原始客户端IP地址，常用于代理服务器，例如：<code>X-Forwarded-For: 203.0.113.195</code>。</li></ul><h3 id="4-HTTP-2-特有头字段"><a href="#4-HTTP-2-特有头字段" class="headerlink" title="4. HTTP/2 特有头字段"></a>4. <strong>HTTP/2 特有头字段</strong></h3><ul><li><strong>:method</strong>：表示HTTP方法，例如：<code>:method: GET</code>。</li><li><strong>:scheme</strong>：表示请求的协议（http或https），例如：<code>:scheme: https</code>。</li><li><strong>:path</strong>：表示请求的路径和查询字符串，例如：<code>:path: /index.html</code>。</li><li><strong>:authority</strong>：表示服务器的主机名和端口，类似于HTTP/1.1的Host头字段，例如：<code>:authority: www.example.com</code>。</li></ul><h3 id="示例请求头"><a href="#示例请求头" class="headerlink" title="示例请求头"></a>示例请求头</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET /index.html HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: en-US,en;q=0.5</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Referer: https://www.example.com/previous-page</span><br><span class="line">Cookie: sessionId=abc123; theme=light</span><br><span class="line">Authorization: Bearer token123</span><br></pre></td></tr></table></figure><p>这些请求头字段在客户端和服务器之间传递时，提供了关于请求和客户端环境的丰富信息，使得服务器能够理解和处理请求，并返回适当的响应。</p><p>5.MVC、MVP、MVVM区别，使用场景</p><p>6.用OC实现一个栈，push  pop  isEmpty方法，栈和队列的区别，使用场景</p><p>7.了解鸿蒙吗</p><p>二面：</p><p>1.了解提升研发效率的方法，跨平台框架？</p><p>2.Flutter和原生交互方法</p><p>3.小程序的实现原理，SN的实现原理</p><p>3.设计图片下载框架，包括内存，缓存，解码等；缓存的技术指标是什么？(命中率) 在缓存即将达到最大容量时，同时有大量写入缓存的操作，怎么优化？</p><p>4.下载限制并发数量，下载断点续传    http请求码是多少</p><p>5.同层渲染怎么实现</p><p><a href="https://developers.weixin.qq.com/community/develop/article/doc/000c4e433707c072c1793e56f5c813" target="_blank" rel="noopener">小程序同层渲染原理剖析</a></p><p><a href="https://zhuanlan.zhihu.com/p/498449103" target="_blank" rel="noopener">小程序在同层渲染上的探索</a></p><p>6.webView加载速度优化</p><p>7.线上卡顿监控，卡顿优化</p><p>8.线上内存监控</p><p><a href="https://wetest.qq.com/labs/367" target="_blank" rel="noopener">iOS微信内存监控 </a></p><p>9.口述快速排序，快速排序用迭代实现</p><p>10.HTTPS的流程，客户端校验证书的过程，链式验证</p><p>第一步是检查证书的链式验证。客户端会使用已信任的根证书（Root Certificate Authority）去验证服务器证书的有效性。根证书是权威机构颁发的，被广泛信任的证书，用于证明其它证书的合法性。客户端会检查服务器证书中的颁发者，然后递归地检查颁发者的证书，直到检查到根证书或者找不到信任的根证书为止。</p><p>第二步是检查证书的有效期。客户端会检查证书的有效起始日期和有效截止日期，确保证书在有效期内。如果证书过期，客户端将拒绝连接。</p><p>第三步是检查证书的公钥。客户端会验证服务器证书中的公钥和域名是否匹配。客户端会从证书中提取服务器的公钥，并与服务器进行握手协议，验证证书中的公钥是否与服务器的公钥匹配。如果不匹配，客户端将拒绝连接。</p><p>除了上述基本的校验步骤，客户端还可以进行更加严格的校验，以提高安全性。例如，客户端可以检查证书中是否包含指纹信息（Fingerprint），从而确保证书的完整性和一致性。客户端也可以检查证书中的扩展字段，查看是否存在其他安全相关的信息。</p><p>总结来说，客户端校验证书的过程包括链式验证、有效期验证和公钥匹配验证。通过这些验证步骤，客户端能够确保所连接的服务器是合法且可信赖的，从而保障通信的安全性。</p><p>三面：</p><p>1.监控</p><p>2.原生与H5交互，注入和post message怎么选型的？</p><p>在移动开发中，原生与H5（HTML5）交互是一个常见的需求。为了实现这种交互，通常有两种主要的方法：注入（Injection）和 <code>postMessage</code>。各有优缺点，选择哪种方法取决于具体的应用场景和需求。下面对这两种方法进行详细比较和建议：</p><h3 id="注入（Injection）"><a href="#注入（Injection）" class="headerlink" title="注入（Injection）"></a>注入（Injection）</h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ol><li><strong>灵活性高</strong>：可以直接在H5页面中注入原生代码，灵活性较高。</li><li><strong>强大的控制力</strong>：原生代码可以直接操作H5页面的DOM和JavaScript，控制力强。</li><li><strong>无需特定API支持</strong>：不需要依赖特定的API或者更新H5页面的代码。</li></ol><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ol><li><strong>安全性问题</strong>：注入代码可能会带来安全风险，容易被恶意代码利用。</li><li><strong>维护复杂</strong>：代码维护复杂，尤其是原生代码和H5页面频繁变动时。</li><li><strong>浏览器兼容性</strong>：不同浏览器对注入代码的支持可能有所不同。</li></ol><h3 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage"></a><code>postMessage</code></h3><h4 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h4><ol><li><strong>安全性高</strong>：通过消息传递的方式进行交互，安全性较高，不容易被恶意代码利用。</li><li><strong>标准化</strong>：<code>postMessage</code>是HTML5标准的一部分，具有较好的跨浏览器兼容性。</li><li><strong>易于调试和维护</strong>：消息传递方式使得代码逻辑更加清晰，易于调试和维护。</li></ol><h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><ol><li><strong>性能影响</strong>：在高频率消息传递的情况下，可能会有性能影响。</li><li><strong>依赖API</strong>：需要H5页面和原生代码都支持<code>postMessage</code> API。</li><li><strong>有限的控制力</strong>：相比直接注入代码，控制力稍弱，只能通过消息进行交互。</li></ol><h3 id="如何选择？"><a href="#如何选择？" class="headerlink" title="如何选择？"></a>如何选择？</h3><p>选择哪种方法取决于具体的应用场景和需求：</p><ol><li><strong>安全性优先</strong>：如果安全性是首要考虑因素，建议使用<code>postMessage</code>，因为这种方法更安全，不容易被恶意代码利用。</li><li><strong>高频交互</strong>：如果需要高频率的交互，且对性能要求较高，可以考虑注入方式，但要特别注意代码的安全性和浏览器兼容性。</li><li><strong>跨浏览器兼容</strong>：如果需要在多个浏览器中运行，并且希望代码易于维护和调试，<code>postMessage</code>是更好的选择。</li><li><strong>快速开发</strong>：如果需要快速实现功能，且不考虑长远的维护和安全性问题，注入方式可能会更快捷。</li></ol><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>综合来看，<code>postMessage</code>在大多数情况下是更优的选择，特别是在考虑安全性、标准化和易于维护的情况下。但在某些特定场景下，比如需要高频率的交互或者对H5页面进行强控制时，注入方式也不失为一个可选方案。最终的选择应根据具体的项目需求和开发环境来决定。</p><p>3.有没有关注过业务指标，技术手段提升业务指标的情况？收银台支付成功率？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;度小满&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="度小满" scheme="http://soso.wiki/tags/%E5%BA%A6%E5%B0%8F%E6%BB%A1/"/>
    
  </entry>
  
  <entry>
    <title>瓴岳科技</title>
    <link href="http://soso.wiki/%E7%93%B4%E5%B2%B3%E7%A7%91%E6%8A%80/"/>
    <id>http://soso.wiki/瓴岳科技/</id>
    <published>2024-08-05T03:00:00.000Z</published>
    <updated>2024-08-07T07:39:54.396Z</updated>
    
    <content type="html"><![CDATA[<p>瓴岳科技<br><a id="more"></a></p><p>1.SDK 体积优化</p><p>2.webView 加载速度优化，H5 怎么加载本地 JS/图片资源</p><p>3.线上监控，卡顿、内存</p><p>4.Runloop 有几个 mode？</p><p>5.项目里有用到常驻线程吗？</p><p>6.KVO 原理</p><p>7.IMP、selector、SEL 含义和区别</p><p>8.消息转发机制的优劣，和直接调用相比</p><p>9.点击界面上的一个按钮，发生了什么？</p><p>10.SQLite3 和 Realm 的区别？</p><p>11.Category 和 Extension 的区别</p><p>12.Block 的本质，结构体里有哪些东西？内存管理</p><p>13.为什么要在主线程刷新 UI</p><p>14.Swift 中 Result 类型</p><p>15.二叉树的翻转</p><p><a href="https://leetcode.cn/problems/invert-binary-tree/" target="_blank" rel="noopener">226. 翻转二叉树</a></p><h2 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a>参考答案</h2><p>(GPT)</p><h2 id="1-SDK体积优化"><a href="#1-SDK体积优化" class="headerlink" title="1.SDK体积优化"></a>1.SDK体积优化</h2><p>优化iOS SDK体积对于提升应用性能、减少下载时间以及节省用户设备存储空间都非常重要。以下是一些有效的方法来优化iOS SDK的体积：</p><h3 id="1-移除不必要的架构"><a href="#1-移除不必要的架构" class="headerlink" title="1. 移除不必要的架构"></a>1. 移除不必要的架构</h3><ul><li><p>只保留所需的架构：在构建SDK时，移除不必要的架构，例如x86_64和i386（模拟器架构），只保留arm64（实际设备架构）。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lipo -remove x86_64 YourSDK.framework/YourSDK -o YourSDK.framework/YourSDK</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-减少资源文件"><a href="#2-减少资源文件" class="headerlink" title="2. 减少资源文件"></a>2. 减少资源文件</h3><ul><li><strong>移除未使用的资源</strong>：移除未使用的图片、音频、视频等资源文件。</li><li><strong>压缩资源文件</strong>：使用工具（如ImageOptim）压缩图片文件，使用合适的编码格式压缩音频和视频文件。</li></ul><h3 id="3-使用符号表压缩"><a href="#3-使用符号表压缩" class="headerlink" title="3. 使用符号表压缩"></a>3. 使用符号表压缩</h3><ul><li><p>压缩符号表：通过strip工具压缩符号表以减少二进制文件的体积。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strip -S YourSDK.framework/YourSDK</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-代码优化"><a href="#4-代码优化" class="headerlink" title="4. 代码优化"></a>4. 代码优化</h3><ul><li><strong>移除未使用代码</strong>：通过代码分析工具（如Xcode的静态分析功能）查找并移除未使用的代码。</li><li><strong>模块化</strong>：将SDK拆分成多个模块，只在需要时引入特定模块。</li></ul><h3 id="5-使用Swift-Package-Manager"><a href="#5-使用Swift-Package-Manager" class="headerlink" title="5. 使用Swift Package Manager"></a>5. 使用Swift Package Manager</h3><ul><li><strong>Swift Package Manager (SPM)</strong>：使用SPM来管理和分发SDK，可以显著减少SDK的体积，因为SPM只会下载和编译所需的代码。</li></ul><h3 id="6-动态库-vs-静态库"><a href="#6-动态库-vs-静态库" class="headerlink" title="6. 动态库 vs 静态库"></a>6. 动态库 vs 静态库</h3><ul><li><strong>选择合适的库类型</strong>：在某些情况下，使用动态库（.dylib或.framework）可以减少整体应用的体积，因为它们可以被多个应用共享。</li></ul><h3 id="7-编译优化"><a href="#7-编译优化" class="headerlink" title="7. 编译优化"></a>7. 编译优化</h3><ul><li><p>优化编译设置：在Xcode中，确保在Release配置下选择优化选项（如-Oz）以减少代码体积。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Build Settings -&gt; Optimization Level -&gt; Optimize for Size [-Oz]</span><br></pre></td></tr></table></figure></li></ul><h3 id="8-引用第三方库优化"><a href="#8-引用第三方库优化" class="headerlink" title="8. 引用第三方库优化"></a>8. 引用第三方库优化</h3><ul><li><strong>移除未使用的第三方库</strong>：确保只包含那些在SDK中实际使用的第三方库。</li><li><strong>使用轻量级的第三方库</strong>：选择功能相同但体积更小的第三方库。</li></ul><h3 id="9-符号混淆"><a href="#9-符号混淆" class="headerlink" title="9. 符号混淆"></a>9. 符号混淆</h3><ul><li><strong>符号混淆</strong>：使用符号混淆工具（如llvm-obfuscator）混淆符号表以减少符号表大小和提高代码安全性。</li></ul><p>通过以上方法，您可以显著减少iOS SDK的体积，从而提升用户体验和应用的整体性能。</p><h2 id="2-webView加载速度优化，H5怎么加载本地JS-图片资源"><a href="#2-webView加载速度优化，H5怎么加载本地JS-图片资源" class="headerlink" title="2.webView加载速度优化，H5怎么加载本地JS/图片资源"></a>2.webView加载速度优化，H5怎么加载本地JS/图片资源</h2><p><a href="https://blog.cnbang.net/tech/3477/" target="_blank" rel="noopener">移动 H5 首屏秒开优化方案探讨</a></p><p><a href="https://tech.meituan.com/2017/06/09/webviewperf.html" target="_blank" rel="noopener">WebView性能、体验分析与优化</a></p><h2 id="3-线上监控，卡顿、内存"><a href="#3-线上监控，卡顿、内存" class="headerlink" title="3.线上监控，卡顿、内存"></a>3.线上监控，卡顿、内存</h2><h2 id="4-Runloop有几个mode？"><a href="#4-Runloop有几个mode？" class="headerlink" title="4.Runloop有几个mode？"></a>4.Runloop有几个mode？</h2><p>最常用的模式主要是以下几个：</p><ul><li><code>NSDefaultRunLoopMode</code> / <code>kCFRunLoopDefaultMode</code></li><li><code>UITrackingRunLoopMode</code></li><li><code>NSRunLoopCommonModes</code> / <code>kCFRunLoopCommonModes</code></li></ul><h2 id="5-项目里有用到常驻线程吗？"><a href="#5-项目里有用到常驻线程吗？" class="headerlink" title="5.项目里有用到常驻线程吗？"></a>5.项目里有用到常驻线程吗？</h2><h2 id="6-KVO原理"><a href="#6-KVO原理" class="headerlink" title="6.KVO原理"></a>6.KVO原理</h2><h3 id="KVO-基本概念"><a href="#KVO-基本概念" class="headerlink" title="KVO 基本概念"></a>KVO 基本概念</h3><p>KVO 允许对象观察另一个对象的某个属性，当该属性发生变化时，观察者会收到通知。通常，KVO 的使用分为以下几个步骤：</p><ol><li><strong>注册观察者</strong>：使用 <code>addObserver:forKeyPath:options:context:</code> 方法注册观察者。</li><li><strong>实现回调方法</strong>：实现 <code>observeValueForKeyPath:ofObject:change:context:</code> 方法来处理属性变化。</li><li><strong>移除观察者</strong>：使用 <code>removeObserver:forKeyPath:</code> 方法移除观察者。</li></ol><h3 id="KVO-工作原理"><a href="#KVO-工作原理" class="headerlink" title="KVO 工作原理"></a>KVO 工作原理</h3><p>KVO 的实现主要依赖于 Objective-C 的运行时机制，具体步骤如下：</p><ol><li><strong>动态创建子类</strong><br>当你为某个对象的某个属性注册观察者时，Objective-C 运行时会动态创建该对象的一个子类（通常以 <code>NSKVONotifying_</code> 为前缀），并将该对象的类指针（<code>isa</code> 指针）指向这个新创建的子类。</li><li><strong>重写属性的 setter 方法</strong><br>在这个新创建的子类中，Objective-C 运行时会重写被观察属性的 setter 方法。例如，如果你观察的是 <code>name</code> 属性，KVO 会重写 <code>setName:</code> 方法。</li><li><strong>通知观察者</strong><br>在重写的 setter 方法中，KVO 会插入一些钩子代码，在属性值变更前后调用 <code>willChangeValueForKey:</code> 和 <code>didChangeValueForKey:</code> 方法。这些方法用于通知观察者属性即将改变和已经改变。</li><li><strong>调用观察者的回调方法</strong><br><code>didChangeValueForKey:</code> 方法会触发 KVO 通知机制，最终调用观察者的 <code>observeValueForKeyPath:ofObject:change:context:</code> 方法。</li></ol><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li><strong>移除观察者</strong>：在对象释放之前，一定要移除所有的观察者，否则会导致崩溃。</li><li><strong>线程安全</strong>：KVO 通知是同步的，意味着属性的 setter 方法会在观察者的回调方法完成之后才返回。确保观察者的回调方法是线程安全的非常重要。</li><li><strong>KVO-compliant</strong>：确保属性遵循 KVO 协议，即通过 setter 方法（而不是直接修改实例变量）来改变属性的值。</li><li><strong>自动和手动通知</strong>：默认情况下，KVO 是自动通知的。你也可以通过重写 <code>automaticallyNotifiesObserversForKey:</code> 方法来禁用自动通知，并手动调用 <code>willChangeValueForKey:</code> 和 <code>didChangeValueForKey:</code>。</li></ol><h2 id="7-IMP、selector、SEL含义和区别"><a href="#7-IMP、selector、SEL含义和区别" class="headerlink" title="7.IMP、selector、SEL含义和区别"></a>7.IMP、selector、SEL含义和区别</h2><ol><li><strong>SEL（selector）</strong><ul><li><code>SEL</code> 或 <code>selector</code> 是方法的唯一标识符。</li><li>在编译时，编译器会将方法名称映射为一个 <code>SEL</code> 类型的选择器。</li><li>选择器用于在运行时查找方法的实现。</li></ul></li><li><strong>IMP</strong><ul><li><code>IMP</code> 是一个函数指针，指向方法的实际实现。</li><li>当你发送消息给对象时，运行时系统会根据 <code>SEL</code> 找到对应的 <code>IMP</code>，然后调用它。</li><li>直接调用 <code>IMP</code> 可以略过消息传递机制，提高性能。</li></ul></li></ol><h2 id="8-消息转发机制的优劣，和直接调用相比"><a href="#8-消息转发机制的优劣，和直接调用相比" class="headerlink" title="8.消息转发机制的优劣，和直接调用相比"></a>8.消息转发机制的优劣，和直接调用相比</h2><ol><li><strong>性能</strong><ul><li><strong>直接调用方法</strong>：最快，因为编译器在编译时已经确定了方法的实现。</li><li><strong>消息传递机制</strong>：稍慢，因为需要在运行时查找方法的实现。</li><li><strong>消息转发机制</strong>：最慢，因为涉及多个步骤来处理未知消息。</li></ul></li><li><strong>灵活性</strong><ul><li><strong>直接调用方法</strong>：灵活性最低，因为方法实现是静态绑定的。</li><li><strong>消息传递机制</strong>：灵活性较高，可以在运行时动态查找和调用方法。</li><li><strong>消息转发机制</strong>：灵活性最高，可以在运行时动态处理未知消息，甚至可以将消息转发给其他对象。</li></ul></li><li><strong>使用场景</strong><ul><li><strong>直接调用方法</strong>：适用于性能关键的代码，方法实现是确定的。</li><li><strong>消息传递机制</strong>：适用于需要一些动态特性的代码。</li><li><strong>消息转发机制</strong>：适用于需要高度动态性和灵活性的代码，例如代理模式、消息路由等。</li></ul></li></ol><h2 id="9-点击界面上的一个按钮，发生了什么？"><a href="#9-点击界面上的一个按钮，发生了什么？" class="headerlink" title="9.点击界面上的一个按钮，发生了什么？"></a>9.点击界面上的一个按钮，发生了什么？</h2><h3 id="响应者链（Responder-Chain）"><a href="#响应者链（Responder-Chain）" class="headerlink" title="响应者链（Responder Chain）"></a>响应者链（Responder Chain）</h3><p>响应者链是一个由 <code>UIResponder</code> 对象组成的链条，这些对象可以响应和处理事件。<code>UIView</code>, <code>UIViewController</code>, <code>UIWindow</code>, 以及 <code>UIApplication</code> 都是 <code>UIResponder</code> 的子类。</p><h4 id="事件传递和响应者链"><a href="#事件传递和响应者链" class="headerlink" title="事件传递和响应者链"></a>事件传递和响应者链</h4><ol><li><strong>触摸事件的产生</strong>：当用户点击屏幕时，硬件会捕捉到这个触摸事件，并将其传递给 iOS 系统。</li><li><strong>创建 UIEvent 对象</strong>：iOS 系统会将触摸数据封装成一个 <code>UIEvent</code> 对象。</li><li><strong>事件传递给 UIWindow</strong>：系统会将这个 <code>UIEvent</code> 传递给应用的主 <code>UIWindow</code>。</li><li><strong>找到第一响应者</strong>：<code>UIWindow</code> 会调用 <code>hitTest:withEvent:</code> 方法，从视图层次结构中找出最合适的视图来处理这个触摸事件。这个视图成为第一响应者。</li><li><strong>事件传递给 UIView</strong>：触摸事件会被传递给找到的视图（通常是一个 <code>UIButton</code>），并调用其 <code>touchesBegan:withEvent:</code>, <code>touchesMoved:withEvent:</code>, <code>touchesEnded:withEvent:</code> 方法来处理具体的触摸事件。</li></ol><h3 id="手势识别器的优先级"><a href="#手势识别器的优先级" class="headerlink" title="手势识别器的优先级"></a>手势识别器的优先级</h3><p>手势识别器（Gesture Recognizer）在 iOS 的事件处理机制中具有较高的优先级。具体来说，手势识别器会先接收到触摸事件，并尝试识别是否是自己关心的手势。如果手势识别器识别成功，那么它会处理该事件并阻止事件继续传递给响应者链。</p><h3 id="具体的事件传递顺序"><a href="#具体的事件传递顺序" class="headerlink" title="具体的事件传递顺序"></a>具体的事件传递顺序</h3><ol><li><strong>触摸事件产生</strong>：用户触摸屏幕，触摸事件被硬件捕获并传递给 iOS 系统。</li><li><strong>创建 UIEvent 对象</strong>：iOS 系统将触摸数据封装成一个 <code>UIEvent</code> 对象。</li><li><strong>事件传递给 UIWindow</strong>：系统将此 <code>UIEvent</code> 对象传递给应用的主 <code>UIWindow</code>。</li><li><strong>手势识别器检测</strong>：<code>UIWindow</code> 会先将触摸事件传递给视图层次结构中相关视图的手势识别器。如果有手势识别器检测到手势并识别成功，那么该手势识别器会处理该事件，并阻止事件继续传递。</li><li><strong>事件传递给响应者链</strong>：如果手势识别器没有处理该事件，那么事件将按照响应者链的机制传递。响应者链会从最合适的视图开始处理触摸事件，调用相关的 <code>touchesBegan:withEvent:</code>, <code>touchesMoved:withEvent:</code>, <code>touchesEnded:withEvent:</code> 方法。</li></ol><h2 id="10-SQLite3和Realm的区别？"><a href="#10-SQLite3和Realm的区别？" class="headerlink" title="10.SQLite3和Realm的区别？"></a>10.SQLite3和Realm的区别？</h2><h3 id="1-数据库类型"><a href="#1-数据库类型" class="headerlink" title="1. 数据库类型"></a>1. 数据库类型</h3><ul><li><strong>SQLite3</strong>: SQLite 是一个轻量级的关系型数据库管理系统，遵循 SQL 标准。它使用 SQL 语言进行数据操作，支持复杂的查询和事务处理。</li><li><strong>Realm</strong>: Realm 是一个面向对象的数据库，旨在简化数据存储和查询过程。它不使用 SQL，而是通过对象模型进行数据操作。</li></ul><h3 id="2-数据模型"><a href="#2-数据模型" class="headerlink" title="2. 数据模型"></a>2. 数据模型</h3><ul><li><strong>SQLite3</strong>: 使用关系型数据模型，数据存储在表中，表包含行和列。数据操作通过 SQL 查询语句完成。</li><li><strong>Realm</strong>: 使用面向对象的数据模型，数据存储在对象中。你可以直接通过对象属性进行查询和操作，这使得代码更加直观和简洁。</li></ul><h3 id="3-性能"><a href="#3-性能" class="headerlink" title="3. 性能"></a>3. 性能</h3><ul><li><strong>SQLite3</strong>: 通常在处理非常复杂的查询或需要高度自定义的查询时性能较好。SQLite3 的性能可能会受到 SQL 查询复杂性的影响。</li><li><strong>Realm</strong>: 由于其设计面向移动设备，通常在读写性能上表现优异，尤其是对于常见的、简单的查询操作。Realm 还提供了对多线程的支持，以提高并发性能。</li></ul><h3 id="4-数据迁移"><a href="#4-数据迁移" class="headerlink" title="4. 数据迁移"></a>4. 数据迁移</h3><ul><li><strong>SQLite3</strong>: 数据库迁移通常需要手动编写 SQL 脚本来修改表结构，这可能会比较繁琐。</li><li><strong>Realm</strong>: 提供了内置的数据迁移机制，可以通过代码来定义迁移步骤，这使得数据迁移过程更加方便和安全。</li></ul><h3 id="5-易用性"><a href="#5-易用性" class="headerlink" title="5. 易用性"></a>5. 易用性</h3><ul><li><strong>SQLite3</strong>: 由于使用 SQL 语言，开发者需要了解 SQL 语法和关系型数据库的基本概念。数据模型的改变通常需要手动修改表结构。</li><li><strong>Realm</strong>: 提供了面向对象的 API，使用起来更加直观。开发者不需要学习 SQL，只需操作对象模型即可。</li></ul><h3 id="6-数据同步"><a href="#6-数据同步" class="headerlink" title="6. 数据同步"></a>6. 数据同步</h3><ul><li><strong>SQLite3</strong>: 本身不提供数据同步功能。如果需要在不同设备间同步数据，通常需要额外的服务器支持。</li><li><strong>Realm</strong>: 提供了 Realm Cloud 服务，可以实现数据的实时同步和离线访问，适合需要多设备数据同步的应用。</li></ul><h3 id="7-文件大小和存储方式"><a href="#7-文件大小和存储方式" class="headerlink" title="7. 文件大小和存储方式"></a>7. 文件大小和存储方式</h3><ul><li><strong>SQLite3</strong>: 数据存储在单个文件中，文件大小会随着数据量的增加而增加。SQLite3 支持多种数据类型和存储格式。</li><li><strong>Realm</strong>: 数据也存储在单个文件中，但由于其高效的存储格式和压缩机制，通常文件大小较小。Realm 对于对象模型的存储进行了优化，减少了数据的冗余。</li></ul><h3 id="8-加密和安全性"><a href="#8-加密和安全性" class="headerlink" title="8. 加密和安全性"></a>8. 加密和安全性</h3><ul><li><strong>SQLite3</strong>: 支持加密，但需要使用第三方库（如 SQLCipher）来实现。</li><li><strong>Realm</strong>: 内置支持加密，可以方便地加密整个数据库文件，提高数据安全性。</li></ul><h3 id="9-多平台支持"><a href="#9-多平台支持" class="headerlink" title="9. 多平台支持"></a>9. 多平台支持</h3><ul><li><strong>SQLite3</strong>: 支持几乎所有的平台，包括 iOS、Android、Windows、Linux 等。因为其广泛的支持和成熟度，SQLite 是一个非常可靠的选择。</li><li><strong>Realm</strong>: 也支持多平台，包括 iOS、Android、React Native 等。Realm 提供的 API 在不同平台上保持一致性，便于跨平台开发。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>SQLite3</strong>: 适合需要复杂查询、事务处理和高度自定义的应用，尤其是那些开发者已经熟悉 SQL 语言的情况。</li><li><strong>Realm</strong>: 适合需要高性能、简单易用和面向对象的数据存储解决方案，特别是移动应用开发。</li></ul><h2 id="11-Category和Extension的区别"><a href="#11-Category和Extension的区别" class="headerlink" title="11.Category和Extension的区别"></a>11.Category和Extension的区别</h2><table><thead><tr><th>特性</th><th>Category</th><th>Extension</th></tr></thead><tbody><tr><td>定义和用途</td><td>为现有类添加方法</td><td>在实现文件中添加私有方法和属性</td></tr><tr><td>实例变量</td><td>不能添加</td><td>可以添加</td></tr><tr><td>访问控制</td><td>方法是公开的</td><td>方法和属性是私有的</td></tr><tr><td>编译时机</td><td>动态加载，在运行时添加</td><td>编译时添加，类定义的一部分</td></tr><tr><td>使用场景</td><td>将类的方法划分到多个文件，为系统类添加方法</td><td>在实现文件中定义私有方法和属性，提高封装性</td></tr></tbody></table><h2 id="12-Block的本质，结构体里有哪些东西？内存管理"><a href="#12-Block的本质，结构体里有哪些东西？内存管理" class="headerlink" title="12.Block的本质，结构体里有哪些东西？内存管理"></a>12.Block的本质，结构体里有哪些东西？内存管理</h2><h3 id="Block-的本质"><a href="#Block-的本质" class="headerlink" title="Block 的本质"></a>Block 的本质</h3><p>在底层，<code>Block</code> 是一个封装了函数指针、捕获变量及其他相关信息的结构体。可以通过 Clang 提供的编译器选项 <code>-rewrite-objc</code> 将 Objective-C 代码转换为纯 C++ 代码，来查看 <code>Block</code> 的具体实现。</p><p>例如，以下是一个简单的 <code>Block</code> 声明和使用：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">void</span> (^simpleBlock)(<span class="hljs-keyword">void</span>) = ^&#123;</span><br><span class="line">    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"This is a simple block"</span>);</span><br><span class="line">&#125;;</span><br><span class="line">simpleBlock();</span><br></pre></td></tr></table></figure><p>使用 <code>-rewrite-objc</code> 将其转换为 C++ 代码后，可以看到 <code>Block</code> 的底层实现。</p><h3 id="Block-的结构体"><a href="#Block-的结构体" class="headerlink" title="Block 的结构体"></a>Block 的结构体</h3><p>在底层，<code>Block</code> 是一个结构体，通常包含以下几个部分：</p><ol><li><strong>isa 指针</strong>：指向 <code>Block</code> 的类对象，用于实现 Objective-C 的动态特性。</li><li><strong>flags</strong>：标志位，指示 <code>Block</code> 的一些特性（如是否需要复制、是否包含捕获变量等）。</li><li><strong>reserved</strong>：保留字段，通常用于内存对齐。</li><li><strong>invoke 指针</strong>：指向实际执行 <code>Block</code> 代码的函数指针。</li><li><strong>descriptor 指针</strong>：指向 <code>Block</code> 的描述信息，包括 <code>Block</code> 的大小、拷贝和释放函数等。</li><li><strong>捕获变量</strong>：如果 <code>Block</code> 捕获了外部变量，这些变量会被存储在结构体中。</li></ol><p>具体的结构体定义可能如下所示：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">block_impl</span> &#123;</span></span><br><span class="line">    <span class="hljs-keyword">void</span> *isa;</span><br><span class="line">    <span class="hljs-keyword">int</span> flags;</span><br><span class="line">    <span class="hljs-keyword">int</span> reserved;</span><br><span class="line">    <span class="hljs-keyword">void</span> (*invoke)(<span class="hljs-keyword">void</span> *, ...);</span><br><span class="line">    <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">block_descriptor</span> *<span class="hljs-title">descriptor</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">block_descriptor</span> &#123;</span></span><br><span class="line">    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> reserved;</span><br><span class="line">    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> size;</span><br><span class="line">    <span class="hljs-keyword">void</span> (*copy)(<span class="hljs-keyword">void</span> *dst, <span class="hljs-keyword">void</span> *src);</span><br><span class="line">    <span class="hljs-keyword">void</span> (*dispose)(<span class="hljs-keyword">void</span> *src);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Block-的内存管理"><a href="#Block-的内存管理" class="headerlink" title="Block 的内存管理"></a>Block 的内存管理</h3><p><code>Block</code> 的内存管理涉及到以下几个方面：</p><ol><li><strong>栈上的 Block</strong>：默认情况下，<code>Block</code> 是在栈上分配的。这意味着它的生命周期是有限的，当超出其作用域时，<code>Block</code> 会被销毁。如果试图在作用域外使用该 <code>Block</code>，会导致崩溃。</li><li><strong>堆上的 Block</strong>：为了让 <code>Block</code> 在作用域外仍然有效，可以将其复制到堆上。可以使用 <code>Block_copy</code> 函数或 <code>^</code> 运算符来实现这一点。在 ARC 环境下，直接赋值给 <code>__strong</code> 类型的变量时，<code>Block</code> 会自动复制到堆上。</li><li><strong>捕获变量的内存管理</strong>：<code>Block</code> 可以捕获其作用域中的变量，包括自动变量（局部变量）和静态变量。捕获变量的内存管理取决于变量的类型：<ul><li>对于自动变量，<code>Block</code> 会将其值拷贝到 <code>Block</code> 的结构体中。</li><li>对于对象类型的变量，<code>Block</code> 会对其进行 <code>retain</code> 操作（在 ARC 下），以确保 <code>Block</code> 的生命周期内变量仍然有效。</li></ul></li></ol><h2 id="13-为什么要在主线程刷新UI"><a href="#13-为什么要在主线程刷新UI" class="headerlink" title="13.为什么要在主线程刷新UI"></a>13.为什么要在主线程刷新UI</h2><p>在 iOS 和 macOS 开发中，所有的 UI 更新必须在主线程（也称为主队列）上执行。以下是为什么需要在主线程刷新 UI 的几个原因：</p><h3 id="1-UIKit-和-AppKit-的线程安全性"><a href="#1-UIKit-和-AppKit-的线程安全性" class="headerlink" title="1. UIKit 和 AppKit 的线程安全性"></a>1. UIKit 和 AppKit 的线程安全性</h3><ul><li>单线程设计：<ul><li>UIKit（iOS 的 UI 框架）和 AppKit（macOS 的 UI 框架）是设计为非线程安全的。它们的大多数 API 都假定是在主线程上调用的。</li><li>这是因为 UI 操作通常涉及到大量复杂的内部状态管理和绘图操作，确保所有这些操作在一个单一线程上可以避免并发问题。</li></ul></li></ul><h3 id="2-数据一致性和线程同步"><a href="#2-数据一致性和线程同步" class="headerlink" title="2. 数据一致性和线程同步"></a>2. 数据一致性和线程同步</h3><ul><li>数据一致性：<ul><li>如果多个线程同时操作 UI 组件，可能会导致不一致的 UI 状态。例如，一个线程正在修改视图的属性，而另一个线程正在试图渲染视图，这可能会导致崩溃或未定义行为。</li></ul></li><li>线程同步：<ul><li>多线程操作 UI 需要额外的同步机制来防止并发访问冲突。使用主线程可以简化这种同步需求，使代码更容易维护和理解。</li></ul></li></ul><h3 id="3-事件处理模型"><a href="#3-事件处理模型" class="headerlink" title="3. 事件处理模型"></a>3. 事件处理模型</h3><ul><li>事件循环：<ul><li>iOS 和 macOS 应用程序的主线程运行一个事件循环，处理用户交互、定时器、网络响应等各种事件。UI 更新也是事件循环的一部分。</li><li>通过将所有 UI 操作放在主线程上，确保了事件处理的顺序性和一致性。</li></ul></li></ul><h3 id="4-用户体验"><a href="#4-用户体验" class="headerlink" title="4. 用户体验"></a>4. 用户体验</h3><ul><li>平滑的 UI 动画和响应：<ul><li>在主线程上更新 UI 可以确保动画的平滑性和用户交互的及时响应。如果在后台线程更新 UI，可能会导致动画卡顿或延迟响应，影响用户体验。</li></ul></li><li>避免死锁：<ul><li>主线程上的操作是顺序执行的，这降低了发生死锁的风险。如果尝试在后台线程进行复杂的 UI 操作，可能会导致线程间的资源争用和死锁。</li></ul></li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>在主线程刷新 UI 是为了确保 UIKit 和 AppKit 的线程安全性、保持数据一致性和简化线程同步、遵循事件处理模型以及提供更好的用户体验。通过理解和遵循这些原则，可以避免许多潜在的并发问题和性能瓶颈，从而构建更稳定和高效的应用程序。</p><h2 id="14-Swift中Result类型"><a href="#14-Swift中Result类型" class="headerlink" title="14.Swift中Result类型"></a>14.Swift中Result类型</h2><p>在 Swift 中，<code>Result</code> 类型是一种用于表示操作结果的枚举，能够明确地表达成功和失败的情况。它的引入使得错误处理更加简洁和明确，特别是在异步操作和函数返回值中。</p><h3 id="Result-类型的定义"><a href="#Result-类型的定义" class="headerlink" title="Result 类型的定义"></a><code>Result</code> 类型的定义</h3><p><code>Result</code> 类型是一个泛型枚举，有两个可能的值：</p><ul><li><code>.success(Value)</code>：表示操作成功，并包含成功时的返回值。</li><li><code>.failure(Error)</code>：表示操作失败，并包含失败时的错误。</li></ul><p>以下是 <code>Result</code> 类型的定义：</p><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Result</span>&lt;<span class="hljs-title">Success</span>, <span class="hljs-title">Failure</span>: <span class="hljs-title">Error</span>&gt; </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">case</span> success(<span class="hljs-type">Success</span>)</span><br><span class="line">    <span class="hljs-keyword">case</span> failure(<span class="hljs-type">Failure</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-Result-类型"><a href="#使用-Result-类型" class="headerlink" title="使用 Result 类型"></a>使用 <code>Result</code> 类型</h3><h4 id="定义一个返回-Result-类型的函数"><a href="#定义一个返回-Result-类型的函数" class="headerlink" title="定义一个返回 Result 类型的函数"></a>定义一个返回 <code>Result</code> 类型的函数</h4><p>假设我们有一个函数，用于从服务器获取数据，该函数可以成功返回数据，也可能因为网络错误而失败：</p><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">NetworkError</span>: <span class="hljs-title">Error</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">case</span> badURL</span><br><span class="line">    <span class="hljs-keyword">case</span> requestFailed</span><br><span class="line">    <span class="hljs-keyword">case</span> unknown</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fetchData</span><span class="hljs-params">(from urlString: String, completion: <span class="hljs-params">(Result&lt;Data, NetworkError&gt;)</span></span></span> -&gt; <span class="hljs-type">Void</span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> url = <span class="hljs-type">URL</span>(string: urlString) <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        completion(.failure(.badURL))</span><br><span class="line">        <span class="hljs-keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-type">URLSession</span>.shared.dataTask(with: url) &#123; data, response, error <span class="hljs-keyword">in</span></span><br><span class="line">        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-number">_</span> = error &#123;</span><br><span class="line">            completion(.failure(.requestFailed))</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> data = data &#123;</span><br><span class="line">            completion(.success(data))</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            completion(.failure(.unknown))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.resume()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="调用并处理-Result"><a href="#调用并处理-Result" class="headerlink" title="调用并处理 Result"></a>调用并处理 <code>Result</code></h4><p>调用 <code>fetchData</code> 函数，并处理返回的 <code>Result</code>：</p><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fetchData(from: <span class="hljs-string">"https://example.com"</span>) &#123; result <span class="hljs-keyword">in</span></span><br><span class="line">    <span class="hljs-keyword">switch</span> result &#123;</span><br><span class="line">    <span class="hljs-keyword">case</span> .success(<span class="hljs-keyword">let</span> data):</span><br><span class="line">        <span class="hljs-comment">// 处理成功情况</span></span><br><span class="line">        <span class="hljs-built_in">print</span>(<span class="hljs-string">"Data received: \(data)"</span>)</span><br><span class="line">    <span class="hljs-keyword">case</span> .failure(<span class="hljs-keyword">let</span> error):</span><br><span class="line">        <span class="hljs-comment">// 处理失败情况</span></span><br><span class="line">        <span class="hljs-keyword">switch</span> error &#123;</span><br><span class="line">        <span class="hljs-keyword">case</span> .badURL:</span><br><span class="line">            <span class="hljs-built_in">print</span>(<span class="hljs-string">"Bad URL"</span>)</span><br><span class="line">        <span class="hljs-keyword">case</span> .requestFailed:</span><br><span class="line">            <span class="hljs-built_in">print</span>(<span class="hljs-string">"Request failed"</span>)</span><br><span class="line">        <span class="hljs-keyword">case</span> .unknown:</span><br><span class="line">            <span class="hljs-built_in">print</span>(<span class="hljs-string">"Unknown error"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Result-类型的便利方法"><a href="#Result-类型的便利方法" class="headerlink" title="Result 类型的便利方法"></a><code>Result</code> 类型的便利方法</h3><p>Swift 提供了一些便利方法来处理 <code>Result</code> 类型，包括 <code>map</code>、<code>flatMap</code>、<code>mapError</code> 和 <code>flatMapError</code>。</p><h4 id="map-方法"><a href="#map-方法" class="headerlink" title="map 方法"></a><code>map</code> 方法</h4><p><code>map</code> 方法可以将 <code>Result</code> 中的成功值转换为另一种类型：</p><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">Int</span>, <span class="hljs-type">NetworkError</span>&gt; = .success(<span class="hljs-number">42</span>)</span><br><span class="line"><span class="hljs-keyword">let</span> stringResult = result.<span class="hljs-built_in">map</span> &#123; value <span class="hljs-keyword">in</span></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">"The answer is \(value)"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// stringResult 是 Result&lt;String, NetworkError&gt;.success("The answer is 42")</span></span><br></pre></td></tr></table></figure><h4 id="flatMap-方法"><a href="#flatMap-方法" class="headerlink" title="flatMap 方法"></a><code>flatMap</code> 方法</h4><p><code>flatMap</code> 方法用于将 <code>Result</code> 中的成功值转换为另一个 <code>Result</code>：</p><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">Int</span>, <span class="hljs-type">NetworkError</span>&gt; = .success(<span class="hljs-number">42</span>)</span><br><span class="line"><span class="hljs-keyword">let</span> newResult = result.flatMap &#123; value <span class="hljs-keyword">in</span></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">String</span>, <span class="hljs-type">NetworkError</span>&gt;.success(<span class="hljs-string">"The answer is \(value)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// newResult 是 Result&lt;String, NetworkError&gt;.success("The answer is 42")</span></span><br></pre></td></tr></table></figure><h4 id="mapError-方法"><a href="#mapError-方法" class="headerlink" title="mapError 方法"></a><code>mapError</code> 方法</h4><p><code>mapError</code> 方法用于将 <code>Result</code> 中的错误值转换为另一种错误类型：</p><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">Int</span>, <span class="hljs-type">NetworkError</span>&gt; = .failure(.badURL)</span><br><span class="line"><span class="hljs-keyword">let</span> newResult = result.mapError &#123; error <span class="hljs-keyword">in</span></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-type">MyCustomError</span>.networkError(error)</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// newResult 是 Result&lt;Int, MyCustomError&gt;.failure(.networkError(.badURL))</span></span><br></pre></td></tr></table></figure><h4 id="flatMapError-方法"><a href="#flatMapError-方法" class="headerlink" title="flatMapError 方法"></a><code>flatMapError</code> 方法</h4><p><code>flatMapError</code> 方法用于将 <code>Result</code> 中的错误值转换为另一个 <code>Result</code>：</p><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">Int</span>, <span class="hljs-type">NetworkError</span>&gt; = .failure(.badURL)</span><br><span class="line"><span class="hljs-keyword">let</span> newResult = result.flatMapError &#123; error <span class="hljs-keyword">in</span></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">Int</span>, <span class="hljs-type">MyCustomError</span>&gt;.failure(.networkError(error))</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// newResult 是 Result&lt;Int, MyCustomError&gt;.failure(.networkError(.badURL))</span></span><br></pre></td></tr></table></figure><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p><code>Result</code> 类型在 Swift 中提供了一种优雅的方式来处理可能成功或失败的操作。通过明确地表达成功和失败的情况，<code>Result</code> 类型使得代码更加易读和可维护。借助 <code>map</code>、<code>flatMap</code>、<code>mapError</code> 和 <code>flatMapError</code> 等便利方法，可以更方便地处理 <code>Result</code> 类型的值。使用 <code>Result</code> 类型可以更好地管理错误处理，特别是在异步操作中。</p><h2 id="15-二叉树的翻转"><a href="#15-二叉树的翻转" class="headerlink" title="15.二叉树的翻转"></a>15.二叉树的翻转</h2><p><a href="https://leetcode.cn/problems/invert-binary-tree/" target="_blank" rel="noopener">226. 翻转二叉树</a></p><p>递归：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> invertTree = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">const</span> left = invertTree(root.left);</span><br><span class="line">    <span class="hljs-keyword">const</span> right = invertTree(root.right);</span><br><span class="line">    root.left = right;</span><br><span class="line">    root.right = left;</span><br><span class="line">    <span class="hljs-keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>迭代：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> invertTree = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">let</span> stack = [];</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="hljs-keyword">while</span> (stack.length) &#123;</span><br><span class="line">        <span class="hljs-keyword">let</span> node = stack.pop();</span><br><span class="line">        <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) &#123;</span><br><span class="line">            stack.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) &#123;</span><br><span class="line">            stack.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">let</span> temp = node.left;</span><br><span class="line">        node.left = node.right;</span><br><span class="line">        node.right = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;瓴岳科技&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="瓴岳科技" scheme="http://soso.wiki/tags/%E7%93%B4%E5%B2%B3%E7%A7%91%E6%8A%80/"/>
    
  </entry>
  
  <entry>
    <title>去哪儿网</title>
    <link href="http://soso.wiki/%E5%8E%BB%E5%93%AA%E5%84%BF%E7%BD%91/"/>
    <id>http://soso.wiki/去哪儿网/</id>
    <published>2024-07-31T03:00:00.000Z</published>
    <updated>2024-08-07T07:39:50.610Z</updated>
    
    <content type="html"><![CDATA[<p>去哪儿网<br><a id="more"></a><br>1.项目</p><ul><li><p>降低三方 App 接入成本怎么做的？</p></li><li><p>加载速度优化怎么做的？主要是从业务逻辑纬度处理的？</p></li><li><p>异常监控怎么做的？</p></li><li><p>动态库版式缩放怎么实现的？</p></li></ul><p>2.线上闪退捕获怎么做的？有没有捕获不到的异常，watchdog 能捕获吗？APM 性能监控</p><p>3.RN 是怎么实现的？跨端还了解哪些？Flutter是怎么实现的，为什么说 Flutter 的性能比 RN 好？</p><p>4.H5 和原生通信有哪些方法？</p><p>5.怎么提升 webView 的加载速度，使其接近原生？大的图片、JS 等端上下载后，怎么交给H5使用</p><p>6.小程序是怎么实现的？</p><p>7.前端 JS 的异步是怎么实现的？</p><p>8.项目亮点</p><h2 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a>参考答案</h2><p>(GPT)</p><h2 id="1-项目"><a href="#1-项目" class="headerlink" title="1.项目"></a>1.项目</h2><ul><li><p>降低三方 App 接入成本怎么做的？</p></li><li><p>加载速度优化怎么做的？主要是从业务逻辑纬度处理的？</p></li><li><p>异常监控怎么做的？</p></li><li><p>动态库版式缩放怎么实现的？</p></li></ul><h2 id="2-线上闪退捕获怎么做的？有没有捕获不到的异常，watchdog能捕获吗？APM-性能监控"><a href="#2-线上闪退捕获怎么做的？有没有捕获不到的异常，watchdog能捕获吗？APM-性能监控" class="headerlink" title="2.线上闪退捕获怎么做的？有没有捕获不到的异常，watchdog能捕获吗？APM 性能监控"></a>2.线上闪退捕获怎么做的？有没有捕获不到的异常，watchdog能捕获吗？APM 性能监控</h2><p><a href="https://www.jianshu.com/p/8123fc17fe0e" target="_blank" rel="noopener">移动端监控体系之技术原理剖析</a></p><p><a href="https://www.jianshu.com/p/29051908c74b" target="_blank" rel="noopener">iOS Crash 捕获及堆栈符号化思路剖析</a></p><p><a href="https://zhuanlan.zhihu.com/p/614227556" target="_blank" rel="noopener">知乎-iOS云音乐APM性能监控实践</a></p><h2 id="3-RN-是怎么实现的？跨端还了解哪些？Flutter-是怎么实现的，为什么说-Flutter-的性能比-RN-好？"><a href="#3-RN-是怎么实现的？跨端还了解哪些？Flutter-是怎么实现的，为什么说-Flutter-的性能比-RN-好？" class="headerlink" title="3.RN 是怎么实现的？跨端还了解哪些？Flutter 是怎么实现的，为什么说 Flutter 的性能比 RN 好？"></a>3.RN 是怎么实现的？跨端还了解哪些？Flutter 是怎么实现的，为什么说 Flutter 的性能比 RN 好？</h2><p>React Native 通过 JavaScript 和原生代码之间的桥接，实现了跨平台的移动应用开发。其核心是通过 Bridge 在 JavaScript 和原生线程之间进行通信，使用 React 构建用户界面，并通过 Yoga 引擎处理布局。这样，开发者可以使用熟悉的 JavaScript 和 React 技术栈来构建高性能的移动应用，同时享受原生性能和体验。</p><p>Flutter 通过使用 Dart 语言、Skia 图形引擎和自定义的渲染引擎，实现了跨平台的高性能应用开发。其核心是完全自行绘制界面，不依赖于平台的原生控件，提供了一种一致的开发体验和用户体验。Flutter 的 Widget 系统、渲染树、状态管理和平台通道等机制，使其能够高效地构建复杂的跨平台应用。</p><p>Flutter 和 React Native（RN）是两种流行的跨平台移动应用开发框架，各有其优点和缺点。性能是评估这两种框架的一个重要方面。以下是从多个角度对 Flutter 和 React Native 性能的比较：</p><h3 id="1-启动时间"><a href="#1-启动时间" class="headerlink" title="1. 启动时间"></a>1. <strong>启动时间</strong></h3><ul><li><strong>Flutter</strong>: Flutter 应用的启动时间通常较快，因为 Flutter 使用了 AOT（Ahead-of-Time）编译，将 Dart 代码编译成了原生 ARM 代码。在启动时，无需进行额外的解释或编译步骤。</li><li><strong>React Native</strong>: React Native 应用的启动时间可能稍慢一些，因为它依赖于 JavaScriptCore（iOS）或 Hermes 引擎（Android）来解释和执行 JavaScript 代码。尽管 Hermes 引擎在某些情况下可以减少启动时间，但它仍然需要一些初始化步骤。</li></ul><h3 id="2-UI-渲染性能"><a href="#2-UI-渲染性能" class="headerlink" title="2. UI 渲染性能"></a>2. <strong>UI 渲染性能</strong></h3><ul><li><strong>Flutter</strong>: Flutter 使用 Skia 图形引擎直接绘制到屏幕上，这使得 Flutter 可以提供非常流畅的 UI 渲染性能。Flutter 的渲染是逐帧进行的，通常可以达到 60fps 或 120fps。</li><li><strong>React Native</strong>: React Native 依赖于原生平台的控件和组件进行渲染，通过 Bridge 进行 JavaScript 和原生代码的通信。这种桥接机制可能会导致一定的性能瓶颈，特别是在处理复杂动画和大量 UI 更新时。</li></ul><h3 id="3-动画性能"><a href="#3-动画性能" class="headerlink" title="3. 动画性能"></a>3. <strong>动画性能</strong></h3><ul><li><strong>Flutter</strong>: Flutter 的动画性能通常非常出色，因为动画是在 Flutter 的渲染引擎中直接处理的，没有额外的通信开销。Flutter 提供了丰富的动画库和工具，使开发者可以轻松创建复杂和流畅的动画。</li><li><strong>React Native</strong>: React Native 的动画性能在某些情况下可能不如 Flutter，因为动画需要通过 Bridge 进行通信。虽然 React Native 提供了 Animated API 和 Reanimated 库来优化动画性能，但在处理非常复杂的动画时，可能仍然会遇到性能问题。</li></ul><h3 id="4-内存使用"><a href="#4-内存使用" class="headerlink" title="4. 内存使用"></a>4. <strong>内存使用</strong></h3><ul><li><strong>Flutter</strong>: Flutter 的内存使用通常较为高效，但由于它将整个 UI 树都保持在内存中，内存占用可能会随着应用复杂度的增加而增加。</li><li><strong>React Native</strong>: React Native 的内存使用也比较高效，不过由于 JavaScript 运行时和 Bridge 的存在，可能会引入额外的内存开销。</li></ul><h3 id="5-开发体验"><a href="#5-开发体验" class="headerlink" title="5. 开发体验"></a>5. <strong>开发体验</strong></h3><ul><li><strong>Flutter</strong>: Flutter 提供了热重载（Hot Reload）功能，使开发者可以快速看到代码修改的效果，极大地提高了开发效率。Flutter 的热重载通常速度非常快，体验流畅。</li><li><strong>React Native</strong>: React Native 也提供了热重载和快速刷新（Fast Refresh）功能，不过在某些情况下，热重载的速度可能不如 Flutter 快。</li></ul><h3 id="6-跨平台一致性"><a href="#6-跨平台一致性" class="headerlink" title="6. 跨平台一致性"></a>6. <strong>跨平台一致性</strong></h3><ul><li><strong>Flutter</strong>: 由于 Flutter 使用了自定义的绘图引擎，它在不同平台上的外观和行为非常一致，开发者可以更加精确地控制 UI 的细节。</li><li><strong>React Native</strong>: React Native 使用的是平台原生控件，虽然这意味着它在不同平台上能提供更原生的体验，但也可能导致不同平台之间的外观和行为不一致。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>Flutter</strong> 在 UI 渲染性能、动画性能和跨平台一致性方面通常优于 React Native。其高效的渲染引擎和 AOT 编译使得 Flutter 应用的启动时间和运行性能都非常出色。</li><li><strong>React Native</strong> 在使用原生控件和访问原生平台功能方面有优势，可以提供更原生的用户体验。不过，由于 JavaScript 和原生代码之间的桥接机制，可能会在某些场景下遇到性能瓶颈。</li></ul><p>最终选择哪个框架，取决于具体项目的需求和开发团队的技术栈。如果需要非常高性能、流畅的动画和一致的跨平台体验，Flutter 可能是更好的选择。如果需要更原生的外观和感觉，或者开发团队已经熟悉 JavaScript 和 React 生态系统，React Native 可能更适合。</p><h2 id="4-H5-和原生通信有哪些方法？"><a href="#4-H5-和原生通信有哪些方法？" class="headerlink" title="4.H5 和原生通信有哪些方法？"></a>4.H5 和原生通信有哪些方法？</h2><h3 id="1-通过-URL-Schemes"><a href="#1-通过-URL-Schemes" class="headerlink" title="1. 通过 URL Schemes"></a>1. <strong>通过 URL Schemes</strong></h3><p>URL Schemes 是一种通过特定 URL 格式触发原生代码的方法。</p><h3 id="2-通过-WKScriptMessageHandler"><a href="#2-通过-WKScriptMessageHandler" class="headerlink" title="2. 通过 WKScriptMessageHandler"></a>2. <strong>通过 <code>WKScriptMessageHandler</code></strong></h3><p><code>WKScriptMessageHandler</code> 是 WKWebView 提供的用于接收来自 JavaScript 消息的处理器。</p><h4 id="H5-代码"><a href="#H5-代码" class="headerlink" title="H5 代码"></a>H5 代码</h4><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">window</span>.webkit.messageHandlers.myHandler.postMessage(&#123;<span class="hljs-attr">key</span>: <span class="hljs-string">'value'</span>&#125;);</span><br></pre></td></tr></table></figure><h4 id="iOS-代码"><a href="#iOS-代码" class="headerlink" title="iOS 代码"></a>iOS 代码</h4><p>在 <code>WKWebView</code> 的配置中添加一个脚本消息处理器：</p><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> WebKit</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ViewController</span>: <span class="hljs-title">UIViewController</span>, <span class="hljs-title">WKScriptMessageHandler</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">var</span> webView: <span class="hljs-type">WKWebView</span>!</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">viewDidLoad</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">        <span class="hljs-keyword">super</span>.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-keyword">let</span> config = <span class="hljs-type">WKWebViewConfiguration</span>()</span><br><span class="line">        config.userContentController.add(<span class="hljs-keyword">self</span>, name: <span class="hljs-string">"myHandler"</span>)</span><br><span class="line">        </span><br><span class="line">        webView = <span class="hljs-type">WKWebView</span>(frame: <span class="hljs-keyword">self</span>.view.frame, configuration: config)</span><br><span class="line">        <span class="hljs-keyword">self</span>.view.addSubview(webView)</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> url = <span class="hljs-type">URL</span>(string: <span class="hljs-string">"https://yourwebsite.com"</span>) &#123;</span><br><span class="line">            webView.load(<span class="hljs-type">URLRequest</span>(url: url))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">userContentController</span><span class="hljs-params">(<span class="hljs-number">_</span> userContentController: WKUserContentController, didReceive message: WKScriptMessage)</span></span> &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> message.name == <span class="hljs-string">"myHandler"</span> &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> body = message.body <span class="hljs-keyword">as</span>? [<span class="hljs-type">String</span>: <span class="hljs-type">Any</span>] &#123;</span><br><span class="line">                <span class="hljs-built_in">print</span>(<span class="hljs-string">"Message from H5: \(body)"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-通过-evaluateJavaScript"><a href="#3-通过-evaluateJavaScript" class="headerlink" title="3. 通过 evaluateJavaScript"></a>3. <strong>通过 <code>evaluateJavaScript</code></strong></h3><p>iOS 可以通过 <code>evaluateJavaScript</code> 方法执行 H5 页面上的 JavaScript 代码。</p><h4 id="iOS-代码-1"><a href="#iOS-代码-1" class="headerlink" title="iOS 代码"></a>iOS 代码</h4><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">webView.evaluateJavaScript(<span class="hljs-string">"javascriptFunctionName('argument')"</span>) &#123; (result, error) <span class="hljs-keyword">in</span></span><br><span class="line">    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> error = error &#123;</span><br><span class="line">        <span class="hljs-built_in">print</span>(<span class="hljs-string">"JavaScript evaluation error: \(error)"</span>)</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        <span class="hljs-built_in">print</span>(<span class="hljs-string">"JavaScript evaluation result: \(String(describing: result))"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-通过-WebView-的-loadHTMLString-或-load-方法"><a href="#4-通过-WebView-的-loadHTMLString-或-load-方法" class="headerlink" title="4. 通过 WebView 的 loadHTMLString 或 load 方法"></a>4. <strong>通过 WebView 的 <code>loadHTMLString</code> 或 <code>load</code> 方法</strong></h3><p>你可以通过 <code>loadHTMLString</code> 或 <code>load</code> 方法将 HTML 内容直接加载到 WebView 中，并在 HTML 中嵌入 JavaScript 代码与原生代码进行通信。</p><h2 id="5-怎么提升-webView-的加载速度，使其接近原生？大的图片、js等端上下载后，怎么交给H5使用"><a href="#5-怎么提升-webView-的加载速度，使其接近原生？大的图片、js等端上下载后，怎么交给H5使用" class="headerlink" title="5.怎么提升 webView 的加载速度，使其接近原生？大的图片、js等端上下载后，怎么交给H5使用"></a>5.怎么提升 webView 的加载速度，使其接近原生？大的图片、js等端上下载后，怎么交给H5使用</h2><h3 id="1-预加载（Preloading）"><a href="#1-预加载（Preloading）" class="headerlink" title="1. 预加载（Preloading）"></a>1. 预加载（Preloading）</h3><ul><li><strong>提前加载 WebView</strong>：在用户访问页面之前，提前初始化和加载 WebView。这样用户点击时，内容已经部分或全部加载完毕。</li><li><strong>使用缓存</strong>：利用缓存机制来存储常用资源，减少重复加载。</li></ul><h3 id="2-优化资源"><a href="#2-优化资源" class="headerlink" title="2. 优化资源"></a>2. 优化资源</h3><ul><li><strong>减少请求数量</strong>：合并 CSS、JavaScript 文件，减少 HTTP 请求次数。</li><li><strong>压缩资源</strong>：使用 gzip 或 brotli 压缩 HTML、CSS 和 JavaScript 文件。</li><li><strong>图片优化</strong>：压缩图片，使用适当的图片格式（如 WebP），并考虑使用延迟加载（lazy loading）。</li></ul><h3 id="3-使用-WKWebView"><a href="#3-使用-WKWebView" class="headerlink" title="3. 使用 WKWebView"></a>3. 使用 WKWebView</h3><ul><li><strong>选择 WKWebView</strong>：相比 UIWebView，WKWebView 提供了更好的性能和更低的内存占用。确保你的应用使用的是 WKWebView。</li></ul><h3 id="4-加载策略"><a href="#4-加载策略" class="headerlink" title="4. 加载策略"></a>4. 加载策略</h3><ul><li><strong>懒加载</strong>：对于不在视口内的内容，使用懒加载技术，只在需要时才加载这些资源。</li><li><strong>异步加载</strong>：将 JavaScript 脚本放在页面底部或者使用 <code>defer</code> 和 <code>async</code> 属性异步加载脚本，避免阻塞页面渲染。</li></ul><h3 id="5-优化代码"><a href="#5-优化代码" class="headerlink" title="5. 优化代码"></a>5. 优化代码</h3><ul><li><strong>减少 DOM 操作</strong>：过多或复杂的 DOM 操作会降低渲染速度，优化前端代码，减少不必要的 DOM 操作。</li><li><strong>避免重排（Reflow）和重绘（Repaint）</strong>：尽量减少和优化需要重排和重绘的操作。</li></ul><h3 id="6-使用本地资源"><a href="#6-使用本地资源" class="headerlink" title="6. 使用本地资源"></a>6. 使用本地资源</h3><ul><li><strong>本地化资源</strong>：将常用的 CSS 和 JavaScript 文件内嵌到应用中，避免从远程服务器加载。</li><li><strong>Service Worker</strong>：虽然 iOS 对 Service Worker 的支持不如 Android，但可以利用它在支持的场景下缓存资源，提高加载速度。</li></ul><h3 id="7-网络优化"><a href="#7-网络优化" class="headerlink" title="7. 网络优化"></a>7. 网络优化</h3><ul><li><strong>CDN</strong>：使用内容分发网络（CDN）来加速资源加载。</li><li><strong>HTTP/2</strong>：使用 HTTP/2 协议来降低延迟和提升加载速度。</li></ul><h3 id="8-确保设备性能"><a href="#8-确保设备性能" class="headerlink" title="8. 确保设备性能"></a>8. 确保设备性能</h3><ul><li><strong>内存优化</strong>：确保 WebView 不会消耗过多内存，避免在低内存设备上崩溃或变慢。</li><li><strong>性能监控</strong>：定期监控应用的性能，并根据实际数据进行优化。</li></ul><h3 id="9-使用-SPA-Single-Page-Application"><a href="#9-使用-SPA-Single-Page-Application" class="headerlink" title="9. 使用 SPA (Single Page Application)"></a>9. 使用 SPA (Single Page Application)</h3><ul><li><strong>单页应用</strong>：如果你的应用逻辑允许，考虑将 Web 应用改为单页应用（SPA），减少页面跳转时间，并通过前端路由管理页面状态。</li></ul><h3 id="10-其他优化"><a href="#10-其他优化" class="headerlink" title="10. 其他优化"></a>10. 其他优化</h3><ul><li><strong>Lazy Load</strong>：对图片和其他资源使用懒加载技术。</li><li><strong>减少动画和特效</strong>：过多的动画和特效会增加 CPU 和 GPU 的负担，尽量减少或优化这些效果。</li></ul><p>通过综合以上方法，逐步优化 WebView 的加载速度，可以显著提升用户体验，使其接近原生应用的性能。</p><h3 id="1-预加载并注入资源"><a href="#1-预加载并注入资源" class="headerlink" title="1. 预加载并注入资源"></a>1. 预加载并注入资源</h3><p>在 WKWebView 初始化时，可以预先加载本地下载的资源，并通过 JavaScript 注入到网页中。</p><h4 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h4><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> WebKit</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ViewController</span>: <span class="hljs-title">UIViewController</span>, <span class="hljs-title">WKNavigationDelegate</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">var</span> webView: <span class="hljs-type">WKWebView</span>!</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">viewDidLoad</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">        <span class="hljs-keyword">super</span>.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-keyword">let</span> webConfiguration = <span class="hljs-type">WKWebViewConfiguration</span>()</span><br><span class="line">        webView = <span class="hljs-type">WKWebView</span>(frame: .zero, configuration: webConfiguration)</span><br><span class="line">        webView.navigationDelegate = <span class="hljs-keyword">self</span></span><br><span class="line">        view.addSubview(webView)</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment">// 加载本地 HTML 文件</span></span><br><span class="line">        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> localHTMLUrl = <span class="hljs-type">Bundle</span>.main.url(forResource: <span class="hljs-string">"index"</span>, withExtension: <span class="hljs-string">"html"</span>) &#123;</span><br><span class="line">            webView.loadFileURL(localHTMLUrl, allowingReadAccessTo: localHTMLUrl.deletingLastPathComponent())</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment">// 注入本地 JavaScript 文件</span></span><br><span class="line">        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> localJSUrl = <span class="hljs-type">Bundle</span>.main.url(forResource: <span class="hljs-string">"script"</span>, withExtension: <span class="hljs-string">"js"</span>),</span><br><span class="line">           <span class="hljs-keyword">let</span> localJSContent = <span class="hljs-keyword">try</span>? <span class="hljs-type">String</span>(contentsOf: localJSUrl) &#123;</span><br><span class="line">            <span class="hljs-keyword">let</span> userScript = <span class="hljs-type">WKUserScript</span>(source: localJSContent, injectionTime: .atDocumentStart, forMainFrameOnly: <span class="hljs-literal">true</span>)</span><br><span class="line">            webView.configuration.userContentController.addUserScript(userScript)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-使用自定义-URL-Scheme"><a href="#2-使用自定义-URL-Scheme" class="headerlink" title="2. 使用自定义 URL Scheme"></a>2. 使用自定义 URL Scheme</h3><p>通过自定义 URL Scheme，将本地资源提供给 WebView。</p><h4 id="示例代码：-1"><a href="#示例代码：-1" class="headerlink" title="示例代码："></a>示例代码：</h4><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> WebKit</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ViewController</span>: <span class="hljs-title">UIViewController</span>, <span class="hljs-title">WKNavigationDelegate</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">var</span> webView: <span class="hljs-type">WKWebView</span>!</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">viewDidLoad</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">        <span class="hljs-keyword">super</span>.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-keyword">let</span> webConfiguration = <span class="hljs-type">WKWebViewConfiguration</span>()</span><br><span class="line">        webView = <span class="hljs-type">WKWebView</span>(frame: .zero, configuration: webConfiguration)</span><br><span class="line">        webView.navigationDelegate = <span class="hljs-keyword">self</span></span><br><span class="line">        webView.uiDelegate = <span class="hljs-keyword">self</span></span><br><span class="line">        view.addSubview(webView)</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> localHTMLUrl = <span class="hljs-type">Bundle</span>.main.url(forResource: <span class="hljs-string">"index"</span>, withExtension: <span class="hljs-string">"html"</span>) &#123;</span><br><span class="line">            webView.loadFileURL(localHTMLUrl, allowingReadAccessTo: localHTMLUrl.deletingLastPathComponent())</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-keyword">let</span> schemeHandler = <span class="hljs-type">LocalSchemeHandler</span>()</span><br><span class="line">        webConfiguration.setURLSchemeHandler(schemeHandler, forURLScheme: <span class="hljs-string">"myapp"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> url = <span class="hljs-type">URL</span>(string: <span class="hljs-string">"myapp://localResource/script.js"</span>) &#123;</span><br><span class="line">            webView.load(<span class="hljs-type">URLRequest</span>(url: url))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LocalSchemeHandler</span>: <span class="hljs-title">NSObject</span>, <span class="hljs-title">WKURLSchemeHandler</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">webView</span><span class="hljs-params">(<span class="hljs-number">_</span> webView: WKWebView, start urlSchemeTask: WKURLSchemeTask)</span></span> &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> url = urlSchemeTask.request.url, url.scheme == <span class="hljs-string">"myapp"</span> &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> url.path == <span class="hljs-string">"/localResource/script.js"</span>,</span><br><span class="line">               <span class="hljs-keyword">let</span> filePath = <span class="hljs-type">Bundle</span>.main.path(forResource: <span class="hljs-string">"script"</span>, ofType: <span class="hljs-string">"js"</span>) &#123;</span><br><span class="line">                <span class="hljs-keyword">let</span> data = <span class="hljs-keyword">try</span>? <span class="hljs-type">Data</span>(contentsOf: <span class="hljs-type">URL</span>(fileURLWithPath: filePath))</span><br><span class="line">                <span class="hljs-keyword">let</span> response = <span class="hljs-type">URLResponse</span>(url: url, mimeType: <span class="hljs-string">"application/javascript"</span>, expectedContentLength: data?.<span class="hljs-built_in">count</span> ?? <span class="hljs-number">0</span>, textEncodingName: <span class="hljs-literal">nil</span>)</span><br><span class="line">                urlSchemeTask.didReceive(response)</span><br><span class="line">                <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> data = data &#123;</span><br><span class="line">                    urlSchemeTask.didReceive(data)</span><br><span class="line">                &#125;</span><br><span class="line">                urlSchemeTask.didFinish()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">webView</span><span class="hljs-params">(<span class="hljs-number">_</span> webView: WKWebView, stop urlSchemeTask: WKURLSchemeTask)</span></span> &#123;</span><br><span class="line">        <span class="hljs-comment">// Handle task stopping if needed</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-使用-Base64-编码"><a href="#3-使用-Base64-编码" class="headerlink" title="3. 使用 Base64 编码"></a>3. 使用 Base64 编码</h3><p>将本地资源转换成 Base64 编码，然后通过 JavaScript 将其注入到网页中。</p><h4 id="示例代码：-2"><a href="#示例代码：-2" class="headerlink" title="示例代码："></a>示例代码：</h4><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> WebKit</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ViewController</span>: <span class="hljs-title">UIViewController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">var</span> webView: <span class="hljs-type">WKWebView</span>!</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">viewDidLoad</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">        <span class="hljs-keyword">super</span>.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">        webView = <span class="hljs-type">WKWebView</span>(frame: <span class="hljs-keyword">self</span>.view.frame)</span><br><span class="line">        <span class="hljs-keyword">self</span>.view.addSubview(webView)</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> localHTMLUrl = <span class="hljs-type">Bundle</span>.main.url(forResource: <span class="hljs-string">"index"</span>, withExtension: <span class="hljs-string">"html"</span>) &#123;</span><br><span class="line">            webView.loadFileURL(localHTMLUrl, allowingReadAccessTo: localHTMLUrl.deletingLastPathComponent())</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> imagePath = <span class="hljs-type">Bundle</span>.main.path(forResource: <span class="hljs-string">"image"</span>, ofType: <span class="hljs-string">"png"</span>),</span><br><span class="line">           <span class="hljs-keyword">let</span> imageData = <span class="hljs-keyword">try</span>? <span class="hljs-type">Data</span>(contentsOf: <span class="hljs-type">URL</span>(fileURLWithPath: imagePath)) &#123;</span><br><span class="line">            <span class="hljs-keyword">let</span> base64String = imageData.base64EncodedString()</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">let</span> jsCode = <span class="hljs-string">"""</span></span><br><span class="line"><span class="hljs-string">            var img = document.createElement('img');</span></span><br><span class="line"><span class="hljs-string">            img.src = 'data:image/png;base64,\(base64String)';</span></span><br><span class="line"><span class="hljs-string">            document.body.appendChild(img);</span></span><br><span class="line"><span class="hljs-string">            """</span></span><br><span class="line">            webView.evaluateJavaScript(jsCode, completionHandler: <span class="hljs-literal">nil</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-使用本地服务器"><a href="#4-使用本地服务器" class="headerlink" title="4. 使用本地服务器"></a>4. 使用本地服务器</h3><p>在应用内启动一个本地服务器（如 GCDWebServer），然后通过 HTTP 请求获取本地资源。</p><h4 id="示例代码：-3"><a href="#示例代码：-3" class="headerlink" title="示例代码："></a>示例代码：</h4><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> WebKit</span><br><span class="line"><span class="hljs-keyword">import</span> GCDWebServer</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ViewController</span>: <span class="hljs-title">UIViewController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">var</span> webView: <span class="hljs-type">WKWebView</span>!</span><br><span class="line">    <span class="hljs-keyword">var</span> webServer: <span class="hljs-type">GCDWebServer</span>!</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">viewDidLoad</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">        <span class="hljs-keyword">super</span>.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">        webServer = <span class="hljs-type">GCDWebServer</span>()</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment">// 添加处理器来提供本地资源</span></span><br><span class="line">        webServer.addGETHandler(forBasePath: <span class="hljs-string">"/"</span>, directoryPath: <span class="hljs-type">Bundle</span>.main.resourcePath!, indexFilename: <span class="hljs-literal">nil</span>, cacheAge: <span class="hljs-number">3600</span>, allowRangeRequests: <span class="hljs-literal">true</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment">// 启动本地服务器</span></span><br><span class="line">        webServer.start(withPort: <span class="hljs-number">8080</span>, bonjourName: <span class="hljs-string">"GCD Web Server"</span>)</span><br><span class="line">        </span><br><span class="line">        webView = <span class="hljs-type">WKWebView</span>(frame: <span class="hljs-keyword">self</span>.view.frame)</span><br><span class="line">        <span class="hljs-keyword">self</span>.view.addSubview(webView)</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> url = <span class="hljs-type">URL</span>(string: <span class="hljs-string">"http://localhost:8080/index.html"</span>) &#123;</span><br><span class="line">            webView.load(<span class="hljs-type">URLRequest</span>(url: url))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述方法，可以将本地下载的资源交给 H5 使用，以提升 WebView 的加载速度和用户体验。选择具体方案时，可以根据实际需求、项目复杂度和维护成本进行权衡。</p><h2 id="6-小程序是怎么实现的？"><a href="#6-小程序是怎么实现的？" class="headerlink" title="6.小程序是怎么实现的？"></a>6.小程序是怎么实现的？</h2><h2 id="7-前端-JS-的异步是怎么实现的？"><a href="#7-前端-JS-的异步是怎么实现的？" class="headerlink" title="7.前端 JS 的异步是怎么实现的？"></a>7.前端 JS 的异步是怎么实现的？</h2><p>JavaScript 的异步是通过事件循环（Event Loop）、回调函数、任务队列（Task Queue）和微任务队列（Microtask Queue）等机制共同实现的。下面我们详细讨论这些概念及其工作原理。</p><h3 id="事件循环（Event-Loop）"><a href="#事件循环（Event-Loop）" class="headerlink" title="事件循环（Event Loop）"></a>事件循环（Event Loop）</h3><p>JavaScript 运行时环境（如浏览器或 Node.js）包含一个事件循环，它是处理异步操作的核心。事件循环负责监控调用栈和任务队列，并根据情况将任务队列中的任务推入调用栈执行。</p><h3 id="调用栈（Call-Stack）"><a href="#调用栈（Call-Stack）" class="headerlink" title="调用栈（Call Stack）"></a>调用栈（Call Stack）</h3><p>调用栈用于追踪正在执行的函数，JavaScript 是单线程的，这意味着它一次只能执行一个任务。调用栈记录了函数的调用顺序，并在当前函数执行完毕后，依次返回上一级调用。</p><h3 id="Web-API"><a href="#Web-API" class="headerlink" title="Web API"></a>Web API</h3><p>浏览器提供了一些异步 API，如 <code>setTimeout</code>、<code>setInterval</code>、<code>XMLHttpRequest</code>、<code>fetch</code> 等。当调用这些 API 时，任务会被移交给浏览器处理，而不是立即在调用栈中执行。</p><h3 id="任务队列（Task-Queue）"><a href="#任务队列（Task-Queue）" class="headerlink" title="任务队列（Task Queue）"></a>任务队列（Task Queue）</h3><p>任务队列存储了已完成的异步操作对应的回调函数，这些回调函数等待事件循环将它们推入调用栈执行。任务队列包括宏任务队列（Macro Task Queue）和微任务队列（Microtask Queue）。</p><h4 id="宏任务（Macro-Task）"><a href="#宏任务（Macro-Task）" class="headerlink" title="宏任务（Macro Task）"></a>宏任务（Macro Task）</h4><p>宏任务包括 <code>setTimeout</code>、<code>setInterval</code>、I/O 操作等。这些任务会被添加到宏任务队列中，等待事件循环处理。</p><h4 id="微任务（Microtask）"><a href="#微任务（Microtask）" class="headerlink" title="微任务（Microtask）"></a>微任务（Microtask）</h4><p>微任务包括 <code>Promise</code> 的 <code>.then</code> 回调、<code>MutationObserver</code> 等。微任务会被添加到微任务队列中。微任务队列的优先级高于宏任务队列，这意味着在每次宏任务执行完毕后，事件循环会首先清空微任务队列。</p><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ol><li><strong>主线程执行同步代码</strong>：所有同步代码会被压入调用栈中并执行。</li><li><strong>遇到异步操作</strong>：当遇到异步操作（如 <code>setTimeout</code>、<code>fetch</code> 等），相应的回调函数会被注册并移交给浏览器的 Web API 处理。</li><li><strong>Web API 完成任务</strong>：一旦异步操作完成，回调函数会被放入相应的任务队列中（宏任务或微任务）。</li><li><strong>事件循环检查调用栈</strong>：事件循环不断检查调用栈是否为空。</li><li><strong>处理微任务</strong>：如果调用栈为空，事件循环会优先处理微任务队列中的任务。</li><li><strong>处理宏任务</strong>：如果微任务队列为空，事件循环会处理宏任务队列中的任务。</li></ol><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Start'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Timeout callback'</span>);</span><br><span class="line">&#125;, <span class="hljs-number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Promise callback'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'End'</span>);</span><br></pre></td></tr></table></figure><h3 id="执行顺序解析"><a href="#执行顺序解析" class="headerlink" title="执行顺序解析"></a>执行顺序解析</h3><ol><li><code>console.log(&#39;Start&#39;)</code> 输出 “Start”。</li><li><code>setTimeout</code> 注册一个回调函数，并将其移交给浏览器处理（宏任务）。</li><li><code>Promise.resolve().then</code> 注册一个回调函数，并将其放入微任务队列。</li><li><code>console.log(&#39;End&#39;)</code> 输出 “End”。</li><li>主线程执行完同步代码后，调用栈为空，事件循环首先处理微任务队列。</li><li>微任务队列中的 <code>Promise</code> 回调函数被执行，输出 “Promise callback”。</li><li>微任务队列清空后，事件循环处理宏任务队列中的 <code>setTimeout</code> 回调，输出 “Timeout callback”。</li></ol><p>综上所述，JavaScript 的异步机制通过事件循环、调用栈、任务队列和 Web API 的协同工作，实现了异步操作，使得代码可以在等待长时间操作（如网络请求）时，不阻塞主线程的执行。</p><h2 id="8-项目亮点"><a href="#8-项目亮点" class="headerlink" title="8.项目亮点"></a>8.项目亮点</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;去哪儿网&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="去哪儿网" scheme="http://soso.wiki/tags/%E5%8E%BB%E5%93%AA%E5%84%BF%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>字节跳动</title>
    <link href="http://soso.wiki/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8/"/>
    <id>http://soso.wiki/字节跳动/</id>
    <published>2024-07-30T03:00:00.000Z</published>
    <updated>2024-07-31T08:42:25.478Z</updated>
    
    <content type="html"><![CDATA[<p>字节跳动<br><a id="more"></a></p><p>1.项目选一点来说，技术指标？了解业务指标吗？</p><p>2.KVO原理，应用场景</p><p>3.Runtime、应用，Runtime 交换方法需要注意什么？Runtime 的 hook 和 fish hook 有什么区别？</p><p>4.Runloop、应用、Runloop 来监测卡顿有什么问题？</p><p>5.UIView 和 CALaye r的区别，为什么这么设计？</p><p>6.显式动画和隐式动画的区别</p><p>7.了解的设计原则和设计模式，结合项目</p><p>8.block 的本质</p><p>9.算法：查找字符串的无重复字符子串的最大长度</p><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/" target="_blank" rel="noopener">无重复字符的最长子串-力扣</a></p><h2 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a>参考答案</h2><h2 id="1-项目选一点来说，技术指标？了解业务指标吗？"><a href="#1-项目选一点来说，技术指标？了解业务指标吗？" class="headerlink" title="1.项目选一点来说，技术指标？了解业务指标吗？"></a>1.项目选一点来说，技术指标？了解业务指标吗？</h2><h2 id="2-KVO原理，应用场景"><a href="#2-KVO原理，应用场景" class="headerlink" title="2.KVO原理，应用场景"></a>2.KVO原理，应用场景</h2><ol><li><strong>动态生成子类</strong>：当你观察某个对象的属性时，Objective-C Runtime会动态创建该对象的一个子类，并重写被观察属性的setter方法。</li><li><strong>方法重写</strong>：在重写的setter方法中，KVO机制会插入一些代码，用于通知所有观察者该属性的变化。</li><li><strong>isa指针指向</strong>：原始对象的<code>isa</code>指针会被修改，指向新创建的子类，以确保调用setter方法时实际调用的是重写后的方法。</li><li><strong>通知机制</strong>：属性值变化时，KVO机制会自动通知所有注册的观察者，调用观察者的<code>observeValueForKeyPath:ofObject:change:context:</code>方法。</li></ol><h2 id="3-Runtime、应用，Runtime-交换方法需要注意什么？Runtime的-hook-和-fish-hook-有什么区别？"><a href="#3-Runtime、应用，Runtime-交换方法需要注意什么？Runtime的-hook-和-fish-hook-有什么区别？" class="headerlink" title="3.Runtime、应用，Runtime 交换方法需要注意什么？Runtime的 hook 和 fish hook 有什么区别？"></a>3.Runtime、应用，Runtime 交换方法需要注意什么？Runtime的 hook 和 fish hook 有什么区别？</h2><h3 id="iOS-Runtime-Hook"><a href="#iOS-Runtime-Hook" class="headerlink" title="iOS Runtime Hook"></a>iOS Runtime Hook</h3><h4 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h4><ol><li><strong>Method Swizzling</strong>: 这是最常见的Runtime Hook技术，通过交换方法实现和自定义方法实现，从而改变类的行为。</li><li><strong>动态性强</strong>: 由于Objective-C Runtime的动态特性，可以在运行时对类和方法进行操作。</li><li><strong>灵活性高</strong>: 可以在不修改原始代码的情况下，对应用程序的行为进行修改。</li><li><strong>适用范围广</strong>: 适用于Objective-C编写的类和方法。</li></ol><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>修改系统或第三方库的行为。</li><li>监控方法调用和参数。</li><li>在不破坏原有代码的基础上，添加额外的功能。</li></ul><h3 id="Fishhook"><a href="#Fishhook" class="headerlink" title="Fishhook"></a>Fishhook</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>Fishhook是由Facebook开源的一个库，主要用于在iOS应用中重绑定符号，从而实现对低层次的C函数进行hook。</p><h4 id="主要特点-1"><a href="#主要特点-1" class="headerlink" title="主要特点"></a>主要特点</h4><ol><li><strong>基于符号重绑定</strong>: Fishhook通过修改符号表来重新绑定函数指针，从而实现对函数的替换。</li><li><strong>适用范围</strong>: 主要用于C语言层面的函数，如系统调用和标准库函数。</li><li><strong>低层次</strong>: 适用于低层次的函数拦截，而不是面向对象的Method Swizzling。</li><li><strong>开源库</strong>: Fishhook是一个开源库，可以方便地集成到项目中。</li></ol><h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>替换系统函数实现，如<code>malloc</code>、<code>free</code>、<code>open</code>等。</li><li>监控和修改底层C函数的行为。</li><li>在动态加载的库中对特定函数进行hook。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>iOS Runtime Hook</strong>主要用于Objective-C的方法替换，通过Runtime机制实现，适用于面向对象的环境。</li><li><strong>Fishhook</strong>主要用于C函数的符号重绑定，通过修改符号表实现，适用于底层C函数的拦截和替换。</li></ul><h2 id="4-Runloop、应用、Runloop-来监测卡顿有什么问题？"><a href="#4-Runloop、应用、Runloop-来监测卡顿有什么问题？" class="headerlink" title="4.Runloop、应用、Runloop 来监测卡顿有什么问题？"></a>4.Runloop、应用、Runloop 来监测卡顿有什么问题？</h2><p>使用 RunLoop 来监测卡顿是一个常见的方法，但它也有一些局限性和潜在的问题。以下是一些主要问题：</p><h3 id="1-精度问题"><a href="#1-精度问题" class="headerlink" title="1. 精度问题"></a>1. 精度问题</h3><p>RunLoop 的监测精度有限。RunLoop 的每一次循环都有其自身的周期，如果要监测短暂的卡顿（比如几毫秒），RunLoop 可能无法捕捉到。</p><h3 id="2-影响性能"><a href="#2-影响性能" class="headerlink" title="2. 影响性能"></a>2. 影响性能</h3><p>频繁监测 RunLoop 的状态可能会对应用性能产生影响。尤其在主线程上进行监测时，可能会增加额外的开销，从而影响应用的响应速度。</p><h3 id="3-误报问题"><a href="#3-误报问题" class="headerlink" title="3. 误报问题"></a>3. 误报问题</h3><p>使用 RunLoop 来检测卡顿时，可能会出现误报的情况。例如，后台任务、I/O 操作或者网络请求等可能导致 RunLoop 的阻塞，这些情况未必是真正的 UI 卡顿。</p><h3 id="4-无法检测异步任务"><a href="#4-无法检测异步任务" class="headerlink" title="4. 无法检测异步任务"></a>4. 无法检测异步任务</h3><p>RunLoop 主要监测的是同步任务的执行情况，对于异步任务（如 GCD 的 <code>dispatch_async</code> 或者 <code>NSOperationQueue</code>）的监测能力有限。这可能导致一些卡顿问题被遗漏。</p><h3 id="5-复杂的实现逻辑"><a href="#5-复杂的实现逻辑" class="headerlink" title="5. 复杂的实现逻辑"></a>5. 复杂的实现逻辑</h3><p>为了准确监测卡顿，可能需要实现复杂的逻辑来处理各种边界情况和特例。这不仅增加了代码的复杂性，也增加了维护的难度。</p><h3 id="6-应用场景有限"><a href="#6-应用场景有限" class="headerlink" title="6. 应用场景有限"></a>6. 应用场景有限</h3><p>RunLoop 监测方法主要应用于主线程的 UI 卡顿检测，对于多线程环境下的卡顿监测效果不佳。因此，如果应用中存在大量的多线程操作，单纯依赖 RunLoop 进行监测可能无法全面覆盖。</p><h3 id="典型实现方法"><a href="#典型实现方法" class="headerlink" title="典型实现方法"></a>典型实现方法</h3><p>尽管存在上述问题，RunLoop 仍然是一个常用的卡顿监测工具。以下是一个简单的实现思路：</p><ol><li><strong>观察 RunLoop 的状态</strong>：通过监听 RunLoop 的 <code>kCFRunLoopBeforeSources</code> 和 <code>kCFRunLoopAfterWaiting</code> 等状态，记录 RunLoop 的执行时间。</li><li><strong>计算时间差</strong>：在每次 RunLoop 状态变化时，计算当前时间与上一次状态变化的时间差。如果时间差超过某个阈值（比如 100 毫秒），则认为发生了卡顿。</li><li><strong>记录或上报卡顿</strong>：将卡顿信息记录到日志中，或者上报到服务器进行分析。</li></ol><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">CFRunLoopObserverRef</span> observer;</span><br><span class="line"><span class="hljs-built_in">CFRunLoopObserverContext</span> context = &#123;<span class="hljs-number">0</span>, (__bridge <span class="hljs-keyword">void</span> *)<span class="hljs-keyword">self</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>&#125;;</span><br><span class="line">observer = <span class="hljs-built_in">CFRunLoopObserverCreate</span>(kCFAllocatorDefault,</span><br><span class="line">                                   kCFRunLoopAllActivities,</span><br><span class="line">                                   <span class="hljs-literal">YES</span>,</span><br><span class="line">                                   <span class="hljs-number">0</span>,</span><br><span class="line">                                   &amp;runLoopObserverCallback,</span><br><span class="line">                                   &amp;context);</span><br><span class="line"><span class="hljs-keyword">if</span> (observer) &#123;</span><br><span class="line">    <span class="hljs-built_in">CFRunLoopAddObserver</span>(<span class="hljs-built_in">CFRunLoopGetMain</span>(), observer, kCFRunLoopCommonModes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>runLoopObserverCallback</code> 中可以实现时间差计算和卡顿检测逻辑。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>虽然使用 RunLoop 来监测卡顿存在一些问题，但它仍然是一个有用的工具，尤其是在主线程的 UI 卡顿检测方面。为了提高监测的准确性和覆盖面，可以结合其他监测方法，如定期采样、堆栈追踪等，来更全面地了解应用的性能状况。</p><h2 id="5-UIView-和-CALayer-的区别，为什么这么设计？"><a href="#5-UIView-和-CALayer-的区别，为什么这么设计？" class="headerlink" title="5.UIView 和 CALayer 的区别，为什么这么设计？"></a>5.UIView 和 CALayer 的区别，为什么这么设计？</h2><h3 id="UIView"><a href="#UIView" class="headerlink" title="UIView"></a>UIView</h3><ol><li><p><strong>类型</strong>: <code>UIView</code> 是一个视图类，继承自 <code>UIResponder</code>。</p></li><li><p>功能</p><p>:</p><ul><li><strong>事件处理</strong>: <code>UIView</code> 负责处理用户交互事件，如触摸、手势等。</li><li><strong>视图层次结构</strong>: <code>UIView</code> 管理视图层次结构，可以包含其他视图（子视图）并且可以被其他视图包含（父视图）。</li><li><strong>布局和自动布局</strong>: <code>UIView</code> 支持自动布局（Auto Layout）和布局约束，并且可以响应布局变化。</li><li><strong>动画</strong>: <code>UIView</code> 提供了动画接口，可以对视图进行动画处理。</li><li><strong>渲染</strong>: <code>UIView</code> 本身并不直接进行渲染操作，而是通过其内部的 <code>CALayer</code> 来进行渲染。</li></ul></li></ol><h3 id="CALayer"><a href="#CALayer" class="headerlink" title="CALayer"></a>CALayer</h3><ol><li><strong>类型</strong>: <code>CALayer</code> 是 Core Animation 框架中的一个类，负责管理和渲染内容。</li><li>功能:<ul><li><strong>内容渲染</strong>: <code>CALayer</code> 负责渲染视图的内容，并且可以直接绘制图形、设置背景颜色、边框、阴影等。</li><li><strong>动画</strong>: <code>CALayer</code> 提供了强大的动画功能，支持隐式动画（Implicit Animations）和显式动画（Explicit Animations）。</li><li><strong>图形操作</strong>: <code>CALayer</code> 支持复杂的图形操作，如变换（旋转、缩放、平移）、遮罩（Masking）、滤镜（Filters）等。</li><li><strong>不处理事件</strong>: <code>CALayer</code> 不处理用户交互事件，这是 <code>UIView</code> 的职责。</li><li><strong>不参与自动布局</strong>: <code>CALayer</code> 不参与 <code>UIView</code> 的布局系统，它的布局需要手动设置。</li></ul></li></ol><h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><ul><li><strong>层次结构</strong>: 每个 <code>UIView</code> 都包含一个 <code>CALayer</code> 实例作为其 <code>layer</code> 属性，<code>UIView</code> 通过这个 <code>CALayer</code> 来进行内容的实际渲染。</li><li><strong>委托关系</strong>: <code>UIView</code> 是 <code>CALayer</code> 的委托（delegate），<code>CALayer</code> 的一些操作（如绘制内容）可以委托给 <code>UIView</code> 来处理。</li></ul><h3 id="典型用法"><a href="#典型用法" class="headerlink" title="典型用法"></a>典型用法</h3><ul><li><strong>UIView</strong>:<ul><li>创建和管理界面元素。</li><li>响应用户交互。</li><li>布局和子视图管理。</li></ul></li><li><strong>CALayer</strong>:<ul><li>执行复杂的动画和图形操作。</li><li>提供低级别的绘图和渲染支持。</li><li>作为 <code>UIView</code> 的底层实现，提升渲染性能。</li></ul></li></ul><p>在 iOS 开发中，<code>UIView</code> 和 <code>CALayer</code> 的设计遵循了一系列面向对象设计原则，这些原则确保了代码的灵活性、可维护性和性能。以下是一些关键的设计原则以及它们在 <code>UIView</code> 和 <code>CALayer</code> 中的体现：</p><h3 id="1-单一职责原则（Single-Responsibility-Principle-SRP）"><a href="#1-单一职责原则（Single-Responsibility-Principle-SRP）" class="headerlink" title="1. 单一职责原则（Single Responsibility Principle, SRP）"></a>1. <strong>单一职责原则（Single Responsibility Principle, SRP）</strong></h3><p><strong>定义</strong>: 每个类应该只有一个引起变化的原因，即每个类应该只有一个职责。</p><p><strong>体现</strong>:</p><ul><li><code>UIView</code> 主要负责处理用户交互事件、管理视图层次结构和布局。</li><li><code>CALayer</code> 专注于内容的渲染和动画。</li></ul><p>通过将视图的管理和渲染职责分离，可以让每个类更加专注于自身的功能，简化了类的设计和职责。</p><h3 id="2-开放-封闭原则（Open-Closed-Principle-OCP）"><a href="#2-开放-封闭原则（Open-Closed-Principle-OCP）" class="headerlink" title="2. 开放-封闭原则（Open/Closed Principle, OCP）"></a>2. <strong>开放-封闭原则（Open/Closed Principle, OCP）</strong></h3><p><strong>定义</strong>: 软件实体（类、模块、函数等）应该可以扩展，但不可修改。</p><p><strong>体现</strong>:</p><ul><li><code>UIView</code> 通过其 <code>layer</code> 属性委托渲染任务给 <code>CALayer</code>。如果需要扩展渲染功能，可以通过自定义 <code>CALayer</code> 而不是修改 <code>UIView</code>。</li><li><code>CALayer</code> 的功能可以通过子类化和委托模式来扩展，而不需要修改现有的类。</li></ul><p>这种设计允许在不修改现有代码的情况下，轻松添加新功能。</p><h3 id="3-里氏替换原则（Liskov-Substitution-Principle-LSP）"><a href="#3-里氏替换原则（Liskov-Substitution-Principle-LSP）" class="headerlink" title="3. 里氏替换原则（Liskov Substitution Principle, LSP）"></a>3. <strong>里氏替换原则（Liskov Substitution Principle, LSP）</strong></h3><p><strong>定义</strong>: 子类对象必须能够替换其父类对象，并且不会导致程序行为的改变。</p><p><strong>体现</strong>:</p><ul><li><code>UIView</code> 和 <code>CALayer</code> 都可以被子类化，子类可以替换父类的实例并正常工作。</li><li><code>UIView</code> 的子类可以扩展用户交互和布局功能，而 <code>CALayer</code> 的子类可以扩展渲染和动画功能。</li></ul><h3 id="4-依赖倒置原则（Dependency-Inversion-Principle-DIP）"><a href="#4-依赖倒置原则（Dependency-Inversion-Principle-DIP）" class="headerlink" title="4. 依赖倒置原则（Dependency Inversion Principle, DIP）"></a>4. <strong>依赖倒置原则（Dependency Inversion Principle, DIP）</strong></h3><p><strong>定义</strong>: 高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。</p><p><strong>体现</strong>:</p><ul><li><code>UIView</code> 并不直接依赖低层的渲染实现，而是通过 <code>CALayer</code> 进行抽象。</li><li><code>CALayer</code> 提供了渲染的抽象接口，具体的渲染细节可以通过子类和委托模式来实现。</li></ul><h3 id="5-接口隔离原则（Interface-Segregation-Principle-ISP）"><a href="#5-接口隔离原则（Interface-Segregation-Principle-ISP）" class="headerlink" title="5. 接口隔离原则（Interface Segregation Principle, ISP）"></a>5. <strong>接口隔离原则（Interface Segregation Principle, ISP）</strong></h3><p><strong>定义</strong>: 客户端不应该被强迫依赖它们不使用的方法；一个类对另一个类的依赖应该建立在最小接口上。</p><p><strong>体现</strong>:</p><ul><li><code>UIView</code> 和 <code>CALayer</code> 的接口设计相对独立，<code>UIView</code> 聚焦在用户交互和布局接口上，而 <code>CALayer</code> 聚焦在渲染和动画接口上。</li><li><code>UIView</code> 的用户只需要关心用户交互和布局相关的方法，而不需要了解渲染和动画的细节。</li></ul><h3 id="6-组合优于继承（Composition-over-Inheritance）"><a href="#6-组合优于继承（Composition-over-Inheritance）" class="headerlink" title="6. 组合优于继承（Composition over Inheritance）"></a>6. <strong>组合优于继承（Composition over Inheritance）</strong></h3><p><strong>定义</strong>: 应该优先使用组合而不是继承来达到代码复用和扩展的目的。</p><p><strong>体现</strong>:</p><ul><li><code>UIView</code> 通过组合 <code>CALayer</code> 来实现复杂的功能，而不是通过继承来扩展一个巨大的视图类。</li><li>这种设计允许在 <code>UIView</code> 和 <code>CALayer</code> 之间进行灵活的组合和配置，以适应不同的需求。</li></ul><h3 id="7-性能和效率"><a href="#7-性能和效率" class="headerlink" title="7. 性能和效率"></a>7. <strong>性能和效率</strong></h3><p><strong>定义</strong>: 在设计中考虑性能和效率问题，确保应用程序运行高效。</p><p><strong>体现</strong>:</p><ul><li><code>CALayer</code> 直接与 Core Animation 交互，提供硬件加速的动画和渲染性能。</li><li><code>UIView</code> 通过 <code>CALayer</code> 进行渲染，可以减少视图树的复杂度并提高渲染效率。</li></ul><p>通过遵循这些设计原则，<code>UIView</code> 和 <code>CALayer</code> 实现了职责分离、代码复用、灵活扩展和高效渲染，形成了一个强大且易于维护的视图和动画系统。这种设计不仅提升了开发体验，还提高了应用程序的性能和稳定性。</p><h2 id="6-显式动画和隐式动画的区别"><a href="#6-显式动画和隐式动画的区别" class="headerlink" title="6.显式动画和隐式动画的区别"></a>6.显式动画和隐式动画的区别</h2><p>在 iOS 开发中，动画可以分为显式动画（Explicit Animations）和隐式动画（Implicit Animations）。这两种动画方式在实现、使用场景和控制粒度上有所不同。</p><h3 id="隐式动画（Implicit-Animations）"><a href="#隐式动画（Implicit-Animations）" class="headerlink" title="隐式动画（Implicit Animations）"></a>隐式动画（Implicit Animations）</h3><p>隐式动画是由 Core Animation 框架自动处理的动画效果。它们不需要显式地创建动画对象，系统会自动为你生成动画效果。</p><p><strong>特点</strong>:</p><ol><li><strong>自动触发</strong>: 隐式动画通常在更改 <code>CALayer</code> 的可动画属性时自动触发，如 <code>position</code>、<code>opacity</code>、<code>backgroundColor</code> 等。</li><li><strong>简洁</strong>: 隐式动画不需要显式地声明动画对象，代码更简洁。</li><li><strong>默认持续时间</strong>: 隐式动画有默认的动画持续时间，通常为 0.25 秒。</li><li><strong>可定制</strong>: 可以通过事务（<code>CATransaction</code>）来定制隐式动画的属性，如持续时间、动画曲线等。</li></ol><p><strong>示例</strong>:</p><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ViewController</span>: <span class="hljs-title">UIViewController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">var</span> myLayer: <span class="hljs-type">CALayer</span>!</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">viewDidLoad</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">        <span class="hljs-keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        myLayer = <span class="hljs-type">CALayer</span>()</span><br><span class="line">        myLayer.frame = <span class="hljs-type">CGRect</span>(x: <span class="hljs-number">50</span>, y: <span class="hljs-number">50</span>, width: <span class="hljs-number">100</span>, height: <span class="hljs-number">100</span>)</span><br><span class="line">        myLayer.backgroundColor = <span class="hljs-type">UIColor</span>.blue.cgColor</span><br><span class="line">        view.layer.addSublayer(myLayer)</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">// 使用隐式动画更改属性</span></span><br><span class="line">        <span class="hljs-type">DispatchQueue</span>.main.asyncAfter(deadline: .now() + <span class="hljs-number">1</span>) &#123;</span><br><span class="line">            <span class="hljs-type">CATransaction</span>.begin()</span><br><span class="line">            <span class="hljs-type">CATransaction</span>.setAnimationDuration(<span class="hljs-number">2.0</span>)</span><br><span class="line">            <span class="hljs-keyword">self</span>.myLayer.position = <span class="hljs-type">CGPoint</span>(x: <span class="hljs-number">200</span>, y: <span class="hljs-number">300</span>)</span><br><span class="line">            <span class="hljs-keyword">self</span>.myLayer.backgroundColor = <span class="hljs-type">UIColor</span>.red.cgColor</span><br><span class="line">            <span class="hljs-type">CATransaction</span>.commit()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="显式动画（Explicit-Animations）"><a href="#显式动画（Explicit-Animations）" class="headerlink" title="显式动画（Explicit Animations）"></a>显式动画（Explicit Animations）</h3><p>显式动画是开发者明确创建并添加到图层上的动画对象。它们提供了更高的控制粒度，可以对动画的各个方面进行精细控制。</p><p><strong>特点</strong>:</p><ol><li><strong>明确声明</strong>: 显式动画需要显式地创建动画对象，如 <code>CABasicAnimation</code>、<code>CAKeyframeAnimation</code>、<code>CAAnimationGroup</code> 等。</li><li><strong>精细控制</strong>: 显式动画允许精细控制动画的各个方面，包括起始值、结束值、持续时间、重复次数、动画曲线等。</li><li><strong>复合动画</strong>: 可以组合多个动画，形成复杂的动画效果。</li><li><strong>更多类型</strong>: 提供了多种类型的动画，如基础动画、关键帧动画、路径动画、组动画等。</li></ol><p><strong>示例</strong>:</p><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ViewController</span>: <span class="hljs-title">UIViewController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">var</span> myLayer: <span class="hljs-type">CALayer</span>!</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">viewDidLoad</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">        <span class="hljs-keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        myLayer = <span class="hljs-type">CALayer</span>()</span><br><span class="line">        myLayer.frame = <span class="hljs-type">CGRect</span>(x: <span class="hljs-number">50</span>, y: <span class="hljs-number">50</span>, width: <span class="hljs-number">100</span>, height: <span class="hljs-number">100</span>)</span><br><span class="line">        myLayer.backgroundColor = <span class="hljs-type">UIColor</span>.blue.cgColor</span><br><span class="line">        view.layer.addSublayer(myLayer)</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">// 创建显式动画</span></span><br><span class="line">        <span class="hljs-type">DispatchQueue</span>.main.asyncAfter(deadline: .now() + <span class="hljs-number">1</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">let</span> positionAnimation = <span class="hljs-type">CABasicAnimation</span>(keyPath: <span class="hljs-string">"position"</span>)</span><br><span class="line">            positionAnimation.fromValue = <span class="hljs-keyword">self</span>.myLayer.position</span><br><span class="line">            positionAnimation.toValue = <span class="hljs-type">CGPoint</span>(x: <span class="hljs-number">200</span>, y: <span class="hljs-number">300</span>)</span><br><span class="line">            positionAnimation.duration = <span class="hljs-number">2.0</span></span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">let</span> colorAnimation = <span class="hljs-type">CABasicAnimation</span>(keyPath: <span class="hljs-string">"backgroundColor"</span>)</span><br><span class="line">            colorAnimation.fromValue = <span class="hljs-type">UIColor</span>.blue.cgColor</span><br><span class="line">            colorAnimation.toValue = <span class="hljs-type">UIColor</span>.red.cgColor</span><br><span class="line">            colorAnimation.duration = <span class="hljs-number">2.0</span></span><br><span class="line"></span><br><span class="line">            <span class="hljs-comment">// 添加动画到图层</span></span><br><span class="line">            <span class="hljs-keyword">self</span>.myLayer.add(positionAnimation, forKey: <span class="hljs-string">"positionAnimation"</span>)</span><br><span class="line">            <span class="hljs-keyword">self</span>.myLayer.add(colorAnimation, forKey: <span class="hljs-string">"colorAnimation"</span>)</span><br><span class="line"></span><br><span class="line">            <span class="hljs-comment">// 更新图层属性</span></span><br><span class="line">            <span class="hljs-keyword">self</span>.myLayer.position = <span class="hljs-type">CGPoint</span>(x: <span class="hljs-number">200</span>, y: <span class="hljs-number">300</span>)</span><br><span class="line">            <span class="hljs-keyword">self</span>.myLayer.backgroundColor = <span class="hljs-type">UIColor</span>.red.cgColor</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>隐式动画</strong>:<ul><li>自动触发，代码简洁。</li><li>适用于简单的动画效果。</li><li>可以通过事务（<code>CATransaction</code>）进行有限的定制。</li></ul></li><li><strong>显式动画</strong>:<ul><li>需要显式地创建动画对象。</li><li>提供更高的控制粒度，适用于复杂的动画效果。</li><li>支持多种动画类型和复合动画。</li></ul></li></ul><p>选择使用隐式动画还是显式动画取决于具体的需求和场景。如果需要实现简单的动画效果，隐式动画通常足够且更简洁；如果需要复杂的、多步骤的动画效果，显式动画则提供了更强大的控制能力。</p><h2 id="7-了解的设计原则和设计模式，结合项目"><a href="#7-了解的设计原则和设计模式，结合项目" class="headerlink" title="7.了解的设计原则和设计模式，结合项目"></a>7.了解的设计原则和设计模式，结合项目</h2><h4 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h4><p>单一职责：一个类只负责一件事，UIView和CALayer</p><p>开闭原则：对修改关闭，对扩展开放 Cagrgory</p><p>接口隔离原则：使用多个专门的协议，而不是一个庞大臃肿的协议，协议中的方法尽量少  UITableView</p><p>依赖倒置原则：抽象不应该依赖于具体实现，具体实现可以依赖于抽象</p><p>里氏替换原则：父类可以被子类无缝替换，且原有功能不受任何影响 KVO</p><p>迪米特法则：一个对象应当对其他对象尽可能少的了解，高内聚、低耦合</p><h2 id="8-block的本质"><a href="#8-block的本质" class="headerlink" title="8.block的本质"></a>8.block的本质</h2><h2 id="9-算法：查找字符串的无重复字符子串的最大长度"><a href="#9-算法：查找字符串的无重复字符子串的最大长度" class="headerlink" title="9.算法：查找字符串的无重复字符子串的最大长度"></a>9.算法：查找字符串的无重复字符子串的最大长度</h2><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/" target="_blank" rel="noopener">无重复字符的最长子串-力扣</a></p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * @param &#123;string&#125; s</span></span><br><span class="line"><span class="hljs-comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">var</span> lengthOfLongestSubstring = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> len = s.length;</span><br><span class="line">    <span class="hljs-keyword">let</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();</span><br><span class="line">    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">let</span> maxLenth = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">while</span> (i &lt; len &amp;&amp; j &lt; len) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (!set.has(s[j])) &#123;</span><br><span class="line">            set.add(s[j]);</span><br><span class="line">            j++;</span><br><span class="line">            maxLenth = <span class="hljs-built_in">Math</span>.max(maxLenth, j - i);</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            set.delete(s[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> maxLenth;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;字节跳动&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="字节跳动" scheme="http://soso.wiki/tags/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>淡蓝网</title>
    <link href="http://soso.wiki/%E6%B7%A1%E8%93%9D%E7%BD%91/"/>
    <id>http://soso.wiki/淡蓝网/</id>
    <published>2024-07-29T03:00:00.000Z</published>
    <updated>2024-07-29T07:59:35.221Z</updated>
    
    <content type="html"><![CDATA[<p>淡蓝网<br><a id="more"></a></p><p>1.SDK体积优化，无用代码检测怎么做的？</p><p>2.加载速度优化，怎么发现的多次刷新？</p><p>3.高考项目</p><p>4.循环引用怎么解决？NSTimer 为什么用 weak 不能解决循环引用</p><p>5.Swift 中 weak 和 unowned 的区别？什么场景下用 unowned？或者说 unowned 有什么好处？</p><p>6.什么场景下用分类？Category 能添加属性吗？为什么不能添加成员变量？苹果为什么这么设计？</p><p>7.为什么要设计元类？</p><p>8.SDK中有个类有私有成员变量，怎么改它的值？</p><p>9.数组的方法被 hook 了，怎么让有些数组不生效，使用系统的默认方法</p><h2 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a>参考答案</h2><p>1.SDK体积优化，无用代码检测怎么做的？</p><p>通过使用<strong>otool</strong>工具对编译产生的<strong>Mach-O</strong>文件，结合项目源码进行分析。</p><p><strong>第一步：</strong><br> 找到项目中所有的<code>protocol</code>中的方法&lt;包括系统<code>&lt;UITabaleViewDelegate&gt;</code>的和项目的&gt;</p><p><strong>第二步：</strong><br> 通过<strong>Mach-O</strong>，找到项目中所有被引用的方法</p><p><strong>第三步：</strong><br> 通过<strong>Mach-O</strong>，找到项目中所有的方法</p><p><strong>第四步：</strong><br> 遍历第三步查出的所有方法，如果当前方法不在代理方法集合，也不在引用方法集合中，那么就认为是没有用到的方法。</p><p>参考链接：<a href="https://www.jianshu.com/p/d62db6c082e9" target="_blank" rel="noopener">简书-iOS 脚本查看项目未使用到的方法</a></p><p>2.加载速度优化，怎么发现的多次刷新</p><p>3.高考项目</p><p>4.循环引用怎么解决？NSTimer为什么用weak不能解决循环引用</p><h3 id="解决循环引用的方法"><a href="#解决循环引用的方法" class="headerlink" title="解决循环引用的方法"></a>解决循环引用的方法</h3><h4 id="1-使用-weak-修饰符"><a href="#1-使用-weak-修饰符" class="headerlink" title="1. 使用 weak 修饰符"></a>1. 使用 <code>weak</code> 修饰符</h4><p>在使用闭包时，可以使用<code>weak</code>或<code>unowned</code>关键字来解决循环引用问题。</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__<span class="hljs-keyword">weak</span> <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">self</span>) weakSelf = <span class="hljs-keyword">self</span>;</span><br><span class="line"><span class="hljs-keyword">self</span>.someBlock = ^&#123;</span><br><span class="line">    [weakSelf doSomething];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在Swift中：</p><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">weak</span> <span class="hljs-keyword">var</span> weakSelf = <span class="hljs-keyword">self</span></span><br><span class="line"><span class="hljs-keyword">self</span>.someBlock = &#123; [<span class="hljs-keyword">weak</span> weakSelf] <span class="hljs-keyword">in</span></span><br><span class="line">    weakSelf?.doSomething()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-使用-delegate-和-weak-修饰符"><a href="#2-使用-delegate-和-weak-修饰符" class="headerlink" title="2. 使用 delegate 和 weak 修饰符"></a>2. 使用 <code>delegate</code> 和 <code>weak</code> 修饰符</h4><p>在使用委托模式时，可以将委托声明为<code>weak</code>。</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">weak</span>) <span class="hljs-keyword">id</span>&lt;MyDelegate&gt; delegate;</span><br></pre></td></tr></table></figure><p>在Swift中：</p><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">weak</span> <span class="hljs-keyword">var</span> delegate: <span class="hljs-type">MyDelegate</span>?</span><br></pre></td></tr></table></figure><h4 id="3-使用-block-修饰符"><a href="#3-使用-block-修饰符" class="headerlink" title="3. 使用 __block 修饰符"></a>3. 使用 <code>__block</code> 修饰符</h4><p>在某些情况下，可以使用<code>__block</code>修饰符来解决循环引用问题。</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">self</span>) blockSelf = <span class="hljs-keyword">self</span>;</span><br><span class="line"><span class="hljs-keyword">self</span>.someBlock = ^&#123;</span><br><span class="line">    [blockSelf doSomething];</span><br><span class="line">    blockSelf = <span class="hljs-literal">nil</span>; <span class="hljs-comment">// 解除循环引用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="为什么-NSTimer-使用-weak-不能解决循环引用"><a href="#为什么-NSTimer-使用-weak-不能解决循环引用" class="headerlink" title="为什么 NSTimer 使用 weak 不能解决循环引用"></a>为什么 <code>NSTimer</code> 使用 <code>weak</code> 不能解决循环引用</h3><p><code>NSTimer</code> 是一个常见的导致循环引用的源头，因为它会强引用其目标对象。即使你在目标对象中使用<code>weak</code>修饰符，<code>NSTimer</code>仍然会强引用目标对象，导致循环引用。</p><h4 id="使用-NSTimer-的正确方法"><a href="#使用-NSTimer-的正确方法" class="headerlink" title="使用 NSTimer 的正确方法"></a>使用 <code>NSTimer</code> 的正确方法</h4><ol><li><strong>使用中介对象</strong></li></ol><p>你可以创建一个中介对象，这个对象不会强引用目标对象，从而打破循环引用。</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">TimerProxy</span> : <span class="hljs-title">NSObject</span></span></span><br><span class="line"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">weak</span>) <span class="hljs-keyword">id</span> target;</span><br><span class="line"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">assign</span>) SEL selector;</span><br><span class="line"><span class="hljs-keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">TimerProxy</span></span></span><br><span class="line">- (<span class="hljs-keyword">void</span>)timerDidFire:(<span class="hljs-built_in">NSTimer</span> *)timer &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.target) &#123;</span><br><span class="line">        [<span class="hljs-keyword">self</span>.target performSelector:<span class="hljs-keyword">self</span>.selector withObject:timer];</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        [timer invalidate];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 使用中介对象</span></span><br><span class="line">TimerProxy *proxy = [TimerProxy new];</span><br><span class="line">proxy.target = <span class="hljs-keyword">self</span>;</span><br><span class="line">proxy.selector = <span class="hljs-keyword">@selector</span>(timerDidFire:);</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">NSTimer</span> *timer = [<span class="hljs-built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="hljs-number">1.0</span></span><br><span class="line">                                                  target:proxy</span><br><span class="line">                                                selector:<span class="hljs-keyword">@selector</span>(timerDidFire:)</span><br><span class="line">                                                userInfo:<span class="hljs-literal">nil</span></span><br><span class="line">                                                 repeats:<span class="hljs-literal">YES</span>];</span><br></pre></td></tr></table></figure><ol><li><strong>使用 <code>GCD</code> 定时器</strong></li></ol><p><code>GCD</code> 提供了一种无需手动管理循环引用的定时器。</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue();</span><br><span class="line"><span class="hljs-keyword">self</span>.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, queue);</span><br><span class="line"></span><br><span class="line">dispatch_source_set_timer(<span class="hljs-keyword">self</span>.timer, dispatch_time(DISPATCH_TIME_NOW, <span class="hljs-number">0</span>), <span class="hljs-number">1.0</span> * <span class="hljs-built_in">NSEC_PER_SEC</span>, (<span class="hljs-number">1</span>ull * <span class="hljs-built_in">NSEC_PER_SEC</span>) / <span class="hljs-number">10</span>);</span><br><span class="line"></span><br><span class="line">__<span class="hljs-keyword">weak</span> <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">self</span>) weakSelf = <span class="hljs-keyword">self</span>;</span><br><span class="line">dispatch_source_set_event_handler(<span class="hljs-keyword">self</span>.timer, ^&#123;</span><br><span class="line">    [weakSelf timerDidFire];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_resume(<span class="hljs-keyword">self</span>.timer);</span><br></pre></td></tr></table></figure><p>在Swift中：</p><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> queue = <span class="hljs-type">DispatchQueue</span>.main</span><br><span class="line"><span class="hljs-keyword">let</span> timer = <span class="hljs-type">DispatchSource</span>.makeTimerSource(queue: queue)</span><br><span class="line"></span><br><span class="line">timer.schedule(deadline: .now(), repeating: <span class="hljs-number">1.0</span>)</span><br><span class="line"></span><br><span class="line">timer.setEventHandler &#123; [<span class="hljs-keyword">weak</span> <span class="hljs-keyword">self</span>] <span class="hljs-keyword">in</span></span><br><span class="line">    <span class="hljs-keyword">self</span>?.timerDidFire()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timer.resume()</span><br><span class="line"><span class="hljs-keyword">self</span>.timer = timer</span><br></pre></td></tr></table></figure><p>5.swift中weak和unowned的区别？什么场景下用unowned？或者说unowned有什么好处？</p><p>在Swift中，<code>weak</code> 和 <code>unowned</code> 是两种用于解决强引用循环（retain cycle）问题的引用类型修饰符。虽然它们都可以用来打破循环引用，但它们的行为和使用场景有所不同。</p><h3 id="weak-和-unowned-的区别"><a href="#weak-和-unowned-的区别" class="headerlink" title="weak 和 unowned 的区别"></a><code>weak</code> 和 <code>unowned</code> 的区别</h3><h4 id="weak"><a href="#weak" class="headerlink" title="weak"></a><code>weak</code></h4><ol><li><p><strong>可选类型</strong>：<code>weak</code> 修饰的引用会被自动设置为 <code>nil</code> 当其引用的对象被释放时。因此，<code>weak</code> 引用必须是可选类型（Optional）。</p></li><li><p><strong>自动解除引用</strong>：使用 <code>weak</code> 修饰符可以防止强引用循环，因为当被引用对象被释放时，<code>weak</code> 引用会自动变成 <code>nil</code>。</p></li><li><p>用法</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">class</span> Person &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    <span class="hljs-keyword">weak</span> var spouse: Person?</span><br><span class="line"></span><br><span class="line">    init(name: String) &#123;</span><br><span class="line">        <span class="hljs-keyword">self</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var john: Person? = Person(name: <span class="hljs-string">"John"</span>)</span><br><span class="line">var jane: Person? = Person(name: <span class="hljs-string">"Jane"</span>)</span><br><span class="line"></span><br><span class="line">john?.spouse = jane</span><br><span class="line">jane?.spouse = john</span><br><span class="line"></span><br><span class="line">john = <span class="hljs-literal">nil</span></span><br><span class="line"><span class="hljs-comment">// At this point, jane?.spouse is automatically set to nil</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="unowned"><a href="#unowned" class="headerlink" title="unowned"></a><code>unowned</code></h4><ol><li><p><strong>非可选类型</strong>：<code>unowned</code> 修饰的引用在其引用的对象被释放后不会自动变成 <code>nil</code>，并且它必须是非可选类型（Non-Optional）。</p></li><li><p><strong>无自动解除引用</strong>：使用 <code>unowned</code> 修饰符不会自动变成 <code>nil</code>，如果你尝试访问一个已经被释放的对象，会导致运行时崩溃。</p></li><li><p>用法</p><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span></span><br><span class="line">    <span class="hljs-keyword">var</span> car: <span class="hljs-type">Car</span>?</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">init</span>(name: <span class="hljs-type">String</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">self</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">var</span> model: <span class="hljs-type">String</span></span><br><span class="line">    <span class="hljs-keyword">unowned</span> <span class="hljs-keyword">var</span> owner: <span class="hljs-type">Person</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">init</span>(model: <span class="hljs-type">String</span>, owner: <span class="hljs-type">Person</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">self</span>.model = model</span><br><span class="line">        <span class="hljs-keyword">self</span>.owner = owner</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> john: <span class="hljs-type">Person</span>? = <span class="hljs-type">Person</span>(name: <span class="hljs-string">"John"</span>)</span><br><span class="line"><span class="hljs-keyword">var</span> johnsCar: <span class="hljs-type">Car</span>? = <span class="hljs-type">Car</span>(model: <span class="hljs-string">"Tesla"</span>, owner: john!)</span><br><span class="line"></span><br><span class="line">john?.car = johnsCar</span><br><span class="line"></span><br><span class="line">john = <span class="hljs-literal">nil</span></span><br><span class="line"><span class="hljs-comment">// At this point, accessing johnsCar?.owner will cause a runtime crash because john has been deallocated</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><h4 id="什么时候使用-weak"><a href="#什么时候使用-weak" class="headerlink" title="什么时候使用 weak"></a>什么时候使用 <code>weak</code></h4><ul><li>当引用的对象可能在其生命周期中变为 <code>nil</code> 时。</li><li>常见的场景包括委托（delegates）、UI元素的引用（例如：视图控制器对视图的引用），以及任何你预计会变为 <code>nil</code> 的引用。</li></ul><h4 id="什么时候使用-unowned"><a href="#什么时候使用-unowned" class="headerlink" title="什么时候使用 unowned"></a>什么时候使用 <code>unowned</code></h4><ul><li>当引用的对象在其生命周期中不会变为 <code>nil</code>，并且你确定引用的对象会一直存在直到被引用对象的生命周期结束。</li><li>常见的场景包括：两个对象具有相同的生命周期，或一个对象的生命周期完全包含另一个对象的生命周期。</li><li>例如，闭包对 <code>self</code> 的引用可以使用 <code>unowned</code> 修饰符，因为闭包的生命周期通常与其持有者相同或更短。</li></ul><h3 id="unowned-的好处"><a href="#unowned-的好处" class="headerlink" title="unowned 的好处"></a><code>unowned</code> 的好处</h3><ul><li><strong>性能</strong>：由于 <code>unowned</code> 引用不会自动设置为 <code>nil</code>，它的性能稍微优于 <code>weak</code> 引用，因为不需要额外的nil检查。</li><li><strong>非可选类型</strong>：<code>unowned</code> 引用不需要解包，因为它是非可选类型，这可以简化代码。</li></ul><p>然而，使用 <code>unowned</code> 引用时需要非常小心，因为如果引用的对象被释放后再访问该引用，会导致运行时崩溃。一般来说，除非你非常确定引用的对象在其生命周期中不会变为 <code>nil</code>，否则建议使用 <code>weak</code> 引用。</p><p>6.什么场景下用分类？Category能添加属性吗？为什么不能添加成员变量？苹果为什么这么设计？</p><p>在 Objective-C 中，<code>Category</code> 是用于为现有类添加方法的一种机制，但它不能直接添加成员变量（实例变量）。不过，可以通过一些间接方式为 <code>Category</code> 添加属性。让我们深入探讨一下为什么 <code>Category</code> 不能添加成员变量、苹果为什么设计成这样，以及如何在 <code>Category</code> 中添加属性。</p><h3 id="为什么-Category-不能添加成员变量"><a href="#为什么-Category-不能添加成员变量" class="headerlink" title="为什么 Category 不能添加成员变量"></a>为什么 <code>Category</code> 不能添加成员变量</h3><p><code>Category</code> 主要设计目的是为了扩展已有类的功能，而不是修改类的内部结构。添加成员变量会涉及到修改类的内存布局，这在运行时会带来很多复杂性和潜在的问题。</p><ol><li><strong>内存布局问题</strong>：Objective-C 的内存布局是在编译时确定的，而成员变量会影响对象的内存布局。如果允许在 <code>Category</code> 中添加成员变量，那么就意味着当一个新 <code>Category</code> 被加载时，需要重新计算和调整所有实例的内存布局，这在运行时是非常复杂和低效的。</li><li><strong>二进制兼容性</strong>：允许 <code>Category</code> 添加成员变量会破坏二进制兼容性。假设一个类库在某个版本中添加了一个包含成员变量的 <code>Category</code>，而在早期版本中没有这个 <code>Category</code>，那么在不同版本之间切换时可能会导致崩溃或未定义行为。</li><li><strong>动态加载</strong>：Objective-C 支持动态加载类和 <code>Category</code>。如果 <code>Category</code> 能够添加成员变量，那么动态加载一个新的 <code>Category</code> 时，需要重新分配和调整现有对象的内存，这在设计和实现上是非常困难的。</li></ol><h3 id="苹果为什么这么设计"><a href="#苹果为什么这么设计" class="headerlink" title="苹果为什么这么设计"></a>苹果为什么这么设计</h3><p>苹果设计 <code>Category</code> 的目的是为了提供一种灵活且轻量级的方式来扩展类的功能，而不改变类的基本结构。这样设计的主要原因包括：</p><ol><li><strong>简化实现</strong>：不允许 <code>Category</code> 添加成员变量使得内存管理和对象模型的实现更加简单和可靠。</li><li><strong>动态特性</strong>：Objective-C 是一种动态语言，<code>Category</code> 提供了在运行时扩展类功能的能力，而无需重新编译类文件。这种灵活性是Objective-C的一个重要特性。</li><li><strong>稳定性和兼容性</strong>：通过限制 <code>Category</code> 的能力，可以确保类的内存布局在整个应用程序生命周期内保持稳定，从而提高程序的稳定性和兼容性。</li></ol><h3 id="如何在-Category-中添加属性"><a href="#如何在-Category-中添加属性" class="headerlink" title="如何在 Category 中添加属性"></a>如何在 <code>Category</code> 中添加属性</h3><p>虽然 <code>Category</code> 不能直接添加成员变量，但可以通过关联对象（Associated Objects）来间接实现属性的添加。</p><h4 id="1-使用关联对象"><a href="#1-使用关联对象" class="headerlink" title="1. 使用关联对象"></a>1. 使用关联对象</h4><p>你可以使用 <code>objc_setAssociatedObject</code> 和 <code>objc_getAssociatedObject</code> 函数来为 <code>Category</code> 添加属性。</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">MyClass</span> (<span class="hljs-title">CategoryName</span>)</span></span><br><span class="line"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-keyword">id</span> property;</span><br><span class="line"><span class="hljs-keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">MyClass</span> (<span class="hljs-title">CategoryName</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="hljs-keyword">void</span>)setProperty:(<span class="hljs-keyword">id</span>)value &#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="hljs-keyword">self</span>, <span class="hljs-keyword">@selector</span>(property), value, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="hljs-keyword">id</span>)property &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> objc_getAssociatedObject(<span class="hljs-keyword">self</span>, <span class="hljs-keyword">@selector</span>(property));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">@end</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，我们使用了关联对象来为 <code>Category</code> 添加属性。<code>objc_setAssociatedObject</code> 函数将一个对象与一个键关联起来，而 <code>objc_getAssociatedObject</code> 函数则根据键获取关联的对象。</p><h4 id="2-关联对象策略"><a href="#2-关联对象策略" class="headerlink" title="2. 关联对象策略"></a>2. 关联对象策略</h4><p><code>objc_setAssociatedObject</code> 的第四个参数是一个关联策略，常见的策略包括：</p><ul><li><code>OBJC_ASSOCIATION_ASSIGN</code>：相当于 <code>assign</code> 属性。</li><li><code>OBJC_ASSOCIATION_RETAIN_NONATOMIC</code>：相当于 <code>strong</code> 非原子属性。</li><li><code>OBJC_ASSOCIATION_COPY_NONATOMIC</code>：相当于 <code>copy</code> 非原子属性。</li><li><code>OBJC_ASSOCIATION_RETAIN</code>：相当于 <code>strong</code> 原子属性。</li><li><code>OBJC_ASSOCIATION_COPY</code>：相当于 <code>copy</code> 原子属性。</li></ul><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>虽然 <code>Category</code> 不能直接添加成员变量，但通过关联对象，我们可以间接地为 <code>Category</code> 添加属性。这种设计使得 <code>Category</code> 的实现更加简单和稳定，同时保留了扩展类功能的灵活性。苹果选择不允许 <code>Category</code> 添加成员变量，是为了简化内存管理、提高运行时性能和确保二进制兼容性。</p><p>7.为什么要设计元类？</p><p>8.SDK中有个类有私有成员变量，怎么改它的值？</p><p>9.数组的方法被hook了，怎么让有些数组不生效，使用系统的默认方法</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;淡蓝网&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="淡蓝网" scheme="http://soso.wiki/tags/%E6%B7%A1%E8%93%9D%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>米可世界</title>
    <link href="http://soso.wiki/%E7%B1%B3%E5%8F%AF%E4%B8%96%E7%95%8C/"/>
    <id>http://soso.wiki/米可世界/</id>
    <published>2024-07-26T03:00:00.000Z</published>
    <updated>2024-07-26T09:16:48.251Z</updated>
    
    <content type="html"><![CDATA[<p>米可世界<br><a id="more"></a><br>1.长链的事件分发？例如收到礼物，直播间和个人中心模块都需要知道，数据可能很大，通知不合适</p><p>protocol buffer？</p><p>2.动画用的什么？</p><p>3.长连接</p><p>4.TCP和UDP的区别？</p><p>5.HTTP 为什么要三次握手、四次挥手？</p><p>6.HTTPS 的流程？确认加密算法是在哪一步？</p><p>7.class 和 struct 区别</p><p>8.runtime，+load和+initialize方法的执行顺序</p><p>9.automic和nonatomic，automic是否是线程安全？</p><p>10.Runloop，和对象释放的关系，Runloop在切换mode时会退出吗？</p><p>11.SDK体积优化？脚本用的什么？静态分析发现了哪些问题？</p><p>12.你觉得值得说的负责的项目</p><h2 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a>参考答案</h2><p>1.长链的事件分发？例如收到礼物，直播间和个人中心模块都需要知道，数据可能很大，通知不合适</p><p>长链的事件分发，特别是在处理像收到礼物这样的复杂事件时，需要考虑事件的多点通知、数据大小以及实时性等因素。以下是对这个问题的一些详细解答和建议：</p><h3 id="一、事件分发机制概述"><a href="#一、事件分发机制概述" class="headerlink" title="一、事件分发机制概述"></a>一、事件分发机制概述</h3><p>事件分发机制主要指的是在系统中，当某个事件发生时，如何高效、准确地将该事件的信息传递给所有需要知道的模块或组件。在长链事件分发场景下，这种机制尤为重要，因为它需要确保多个模块（如直播间和个人中心模块）能够实时、准确地接收到事件信息。</p><h3 id="二、长链事件分发的具体实现"><a href="#二、长链事件分发的具体实现" class="headerlink" title="二、长链事件分发的具体实现"></a>二、长链事件分发的具体实现</h3><ol><li><p><strong>事件定义与捕获</strong></p><ul><li><strong>事件定义</strong>：首先，需要明确定义哪些事件需要被捕获并分发。在这个例子中，收到礼物是一个关键事件。</li><li><strong>事件捕获</strong>：当用户在直播间送出礼物时，系统需要能够捕获到这个行为，并生成相应的事件信息。</li></ul></li><li><p><strong>事件信息的封装</strong></p><ul><li>由于数据可能很大，因此在封装事件信息时，需要考虑数据的压缩和精简。例如，可以使用Protobuf协议来序列化数据，以减少数据大小并提高效率。</li><li>同时，也可以考虑只封装关键信息，如礼物类型、数量、送礼者信息等，以减少数据传输量。</li></ul></li><li><p><strong>事件分发的设计与实现</strong></p><ul><li><strong>分发策略</strong>：对于长链事件，可以采用多种分发策略，如发布订阅模式、消息队列等。这些策略可以确保事件信息能够可靠地传递给所有需要的模块。</li><li><strong>异步处理</strong>：为了避免因事件处理而导致的系统阻塞，可以采用异步处理的方式。即当事件发生时，将事件信息放入消息队列中，由专门的消费者线程或进程进行异步处理。</li><li><strong>并发控制</strong>：在并发环境下，需要确保事件分发的正确性和一致性。可以使用锁、事务等机制来控制并发访问和数据一致性。</li></ul></li><li><p><strong>模块间的通信</strong></p><ul><li><strong>API调用</strong>：直播间和个人中心模块可以通过API调用来实现事件信息的接收和处理。这些API可以定义为RESTful接口或WebSocket等实时通信协议。</li><li><strong>消息推送</strong>：对于需要实时性较高的场景，可以使用消息推送服务（如MQTT、WebSocket）来实时将事件信息推送给相关模块。</li></ul></li><li><p><strong>数据校验与错误处理</strong></p><ul><li>在事件分发过程中，需要对接收到的数据进行校验，以确保数据的完整性和正确性。</li><li>如果在分发过程中出现错误或异常情况，需要有相应的错误处理机制来记录日志、报警或进行重试等操作。</li></ul></li></ol><h3 id="三、优化与改进"><a href="#三、优化与改进" class="headerlink" title="三、优化与改进"></a>三、优化与改进</h3><ol><li><strong>性能优化</strong>：通过优化事件捕获、封装、分发和处理的各个环节，来提高系统的整体性能。例如，使用高效的序列化协议、优化消息队列的处理逻辑等。</li><li><strong>可扩展性设计</strong>：在设计事件分发机制时，需要考虑系统的可扩展性。例如，可以通过增加消费者线程或进程的数量、扩展消息队列的容量等方式来提高系统的处理能力。</li><li><strong>安全性考虑</strong>：在事件分发过程中，需要确保数据的安全性和隐私保护。例如，使用加密技术来保护敏感数据的传输和存储安全。</li></ol><p>综上所述，长链的事件分发是一个复杂的过程，需要综合考虑事件的定义与捕获、信息封装、分发策略、模块间通信、数据校验与错误处理等多个方面。通过合理的设计和优化，可以确保事件分发的准确性和实时性，同时提高系统的整体性能和可扩展性。</p><p>2.动画用的什么？</p><p>3.长连接</p><p>4.TCP和UDP的区别？</p><p>TCP（传输控制协议）和UDP（用户数据报协议）是互联网协议族中两个重要的传输层协议。它们在多个方面存在显著差异，以下是对这些区别的详细解析：</p><h3 id="一、连接性"><a href="#一、连接性" class="headerlink" title="一、连接性"></a>一、连接性</h3><ul><li><strong>TCP</strong>：TCP是一种面向连接的协议。在数据传输之前，发送方和接收方需要先进行三次握手，建立连接后才能开始传输数据。这种连接保证了数据的可靠性和顺序性。</li><li><strong>UDP</strong>：UDP则是一种无连接的协议。发送方在发送数据时不需要提前与接收方建立连接，直接发送数据包。这种方式简化了通信过程，但牺牲了数据的可靠性和顺序性。</li></ul><h3 id="二、可靠性"><a href="#二、可靠性" class="headerlink" title="二、可靠性"></a>二、可靠性</h3><ul><li><strong>TCP</strong>：TCP对数据的可靠性要求非常严格。它使用确认和重传机制来确保数据的完整性和正确性。如果接收方没有收到数据或数据损坏，发送方会重新发送数据，直到接收方确认收到为止。</li><li><strong>UDP</strong>：UDP对数据的可靠性要求较低。它不提供确认、重传和流量控制机制。如果数据在传输过程中丢失或损坏，UDP不会进行重传，接收方可能会收到不完整的数据。</li></ul><h3 id="三、速度和效率"><a href="#三、速度和效率" class="headerlink" title="三、速度和效率"></a>三、速度和效率</h3><ul><li><strong>TCP</strong>：由于TCP需要建立连接和使用确认重传机制，因此其速度和效率相对较低。特别是在网络拥塞时，TCP的拥塞控制机制会限制发送速率，进一步降低传输速度。</li><li><strong>UDP</strong>：UDP没有连接建立和确认重传的开销，也不受拥塞控制机制的限制。因此，其数据传输速度通常比TCP更快，尤其适用于对实时性要求较高的应用。</li></ul><h3 id="四、数据包大小"><a href="#四、数据包大小" class="headerlink" title="四、数据包大小"></a>四、数据包大小</h3><ul><li><strong>TCP</strong>：TCP将数据划分为较小的数据包（称为TCP段）进行传输。它没有固定的数据包大小限制，而是根据网络状况动态调整数据包大小。</li><li><strong>UDP</strong>：UDP则允许发送方一次性将多个数据包打包成一个较大的数据报（称为UDP数据报）进行传输。数据报的大小通常由应用层决定，这使得UDP在传输大量数据时更为高效。</li></ul><h3 id="五、适用场景"><a href="#五、适用场景" class="headerlink" title="五、适用场景"></a>五、适用场景</h3><ul><li><strong>TCP</strong>：适用于对数据可靠性要求较高的应用场景，如文件传输、电子邮件、网页浏览等。这些应用需要确保数据的完整性和正确性，因此选择TCP作为传输层协议更为合适。</li><li><strong>UDP</strong>：适用于对数据实时性要求较高的应用场景，如音频和视频流传输、网络游戏、实时通信等。这些应用对数据的完整性和正确性要求相对较低，但对传输速度有较高要求，因此选择UDP作为传输层协议更为合适。</li></ul><p>综上所述，TCP和UDP在连接性、可靠性、速度和效率、数据包大小以及适用场景等方面存在显著差异。在实际应用中，应根据具体需求选择合适的传输层协议以确保数据的安全、稳定和高效传输。</p><p>5.HTTP 为什么要三次握手、四次挥手？</p><p>HTTP之所以在TCP连接建立时需要三次握手，以及TCP连接断开时需要四次挥手，主要是为了确保数据传输的可靠性、确保连接的建立和断开均能够按照既定协议进行。以下是详细的解释：</p><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p><strong>目的</strong>：</p><ol><li><strong>确认双方的接收与发送能力</strong>：通过三次握手，客户端和服务器能够确认彼此的接收和发送功能都是正常的，从而确保数据能够双向、可靠地传输。</li><li><strong>同步初始序列号</strong>：TCP连接中，每个传输的TCP段都会带有一个序列号，用于标识数据的顺序。三次握手过程中，双方会协商并同步各自的初始序列号，以便后续的数据传输能够按照正确的顺序进行。</li><li><strong>防止失效的连接请求</strong>：三次握手可以防止由于网络延迟或信号丢失导致的失效连接请求被服务器误认为是新的连接请求，从而减少资源浪费和潜在的安全风险。</li></ol><p><strong>过程</strong>：</p><ol><li><strong>第一次握手</strong>：客户端发送一个带有SYN（同步）标志的数据包给服务器，表示自己希望建立连接，并附带一个初始序列号（ISN）。</li><li><strong>第二次握手</strong>：服务器收到客户端的SYN包后，会回复一个带有SYN/ACK（同步/确认）标志的数据包给客户端，表示自己已经收到了客户端的连接请求，并且也附带了自己的初始序列号（ISN）以及确认号为客户端的序列号+1，以此确认客户端的发送能力。</li><li><strong>第三次握手</strong>：客户端收到服务器的SYN/ACK包后，会发送一个带有ACK（确认）标志的数据包给服务器，表示自己已经收到了服务器的回复，确认号为服务器的序列号+1，从而完成连接的建立。</li></ol><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><strong>目的</strong>：</p><ol><li><strong>确保数据完整传输</strong>：TCP连接是全双工的，即数据可以同时在两个方向上传输。四次挥手确保了双方都能在完成数据传输后再关闭连接，防止数据丢失。</li><li><strong>释放连接资源</strong>：通过明确的断开连接过程，双方可以及时释放占用的资源，避免无效连接占用系统资源。</li></ol><p><strong>过程</strong>：</p><ol><li><strong>第一次挥手</strong>：客户端发送一个带有FIN（结束）标志的数据包给服务器，表示自己已经发送完所有数据，希望关闭连接。此时客户端进入FIN-WAIT-1状态。</li><li><strong>第二次挥手</strong>：服务器收到客户端的FIN包后，会回复一个带有ACK标志的数据包给客户端，表示自己已经收到了客户端的关闭请求，确认号为客户端的序列号+1。此时服务器进入CLOSE-WAIT状态，等待自己这一方也发送完所有数据后再关闭连接。</li><li><strong>第三次挥手</strong>：服务器发送一个带有FIN标志的数据包给客户端，表示自己也已经发送完所有数据，希望关闭连接。此时服务器进入LAST-ACK状态，等待客户端的确认。</li><li><strong>第四次挥手</strong>：客户端收到服务器的FIN包后，回复一个带有ACK标志的数据包给服务器，表示自己已经收到了服务器的关闭请求，确认号为服务器的序列号+1。此时客户端进入TIME-WAIT状态，等待足够的时间以确保服务器收到自己的ACK包后顺利关闭连接。最后，客户端也从TIME-WAIT状态转换到CLOSED状态，完成连接的断开。</li></ol><p>综上所述，HTTP的三次握手和四次挥手是为了确保数据传输的可靠性和连接的正确建立与断开而设计的机制。这些机制在TCP/IP协议栈中起着至关重要的作用，保证了网络通信的稳定性和高效性。</p><p>6.HTTPS 的流程？确认加密算法是在哪一步？</p><p>7.class 和 struct 区别</p><h3 id="1-类型属性"><a href="#1-类型属性" class="headerlink" title="1. 类型属性"></a>1. 类型属性</h3><ul><li><strong>class</strong>：是引用类型，意味着在堆上分配内存，栈中保存的是其引用（即指向堆上对象的指针）。这允许class对象可以被多个变量引用，且修改一个对象的属性可能会影响到其他引用该对象的变量。</li><li><strong>struct</strong>：是值类型，它在栈上直接分配内存，存储的是其实际的值。因此，每次复制struct变量时，都会创建该变量值的副本，修改一个struct变量的值不会影响其他副本。</li></ul><h3 id="2-成员访问权限"><a href="#2-成员访问权限" class="headerlink" title="2. 成员访问权限"></a>2. 成员访问权限</h3><ul><li><strong>class</strong>：默认情况下，class中的成员（成员变量和成员函数）的访问权限是私有的（private），这意味着它们只能在class内部被访问。不过，可以显式地指定成员的访问权限，如public、protected或private。</li><li><strong>struct</strong>：默认情况下，struct中的成员是公开的（public），这意味着它们可以在struct外部被访问。但同样地，也可以显式地指定成员的访问权限。</li></ul><h3 id="3-构造函数和析构函数"><a href="#3-构造函数和析构函数" class="headerlink" title="3. 构造函数和析构函数"></a>3. 构造函数和析构函数</h3><ul><li><strong>class</strong>：可以定义构造函数来初始化对象的状态，也可以定义析构函数来清理资源。构造函数可以是隐式的或显式的，但析构函数总是显式的。</li><li><strong>struct</strong>：虽然可以定义构造函数，但它们的构造函数有一些限制，如必须初始化所有成员变量。struct不支持定义析构函数。</li></ul><h3 id="4-继承和多态"><a href="#4-继承和多态" class="headerlink" title="4. 继承和多态"></a>4. 继承和多态</h3><ul><li><strong>class</strong>：支持继承和多态。一个class可以继承另一个class的成员（包括方法和属性），并通过重写基类方法来支持多态。</li><li><strong>struct</strong>：不支持继承（除了接口）和多态。在.NET等环境中，虽然struct可以实现接口，但它不能作为基类被其他类型继承</li></ul><p>8.runtime，+load和+initialize方法的执行顺序</p><h3 id="load方法"><a href="#load方法" class="headerlink" title="+load方法"></a>+load方法</h3><ol><li><strong>调用时机</strong>：<ul><li><code>+load</code>方法会在runtime加载类、分类时调用。具体来说，当应用程序启动时，Objective-C runtime会加载所有的类和分类实现，并在此时调用每个类和分类的<code>+load</code>方法。</li><li>需要注意的是，<code>+load</code>方法在程序运行过程中只会被调用一次，且其调用顺序遵循特定的规则。</li></ul></li><li><strong>调用顺序</strong>：<ul><li>首先，调用类的<code>+load</code>方法，按照编译先后顺序调用（先编译的类，其<code>+load</code>方法会先被调用）。</li><li>调用子类的<code>+load</code>之前，会先调用其父类的<code>+load</code>方法。这是为了确保父类被正确加载和初始化后，子类再进行加载。</li><li>然后，调用分类的<code>+load</code>方法，也是按照编译先后顺序调用。但分类的<code>+load</code>方法会在所有类的<code>+load</code>方法之后调用。</li></ul></li><li><strong>调用方式</strong>：<ul><li><code>+load</code>方法是根据方法地址直接调用的，不走objc_msgSend消息发送机制。这意味着<code>+load</code>方法的调用非常高效，但也需要注意不要在其中进行耗时的操作，以免影响程序启动速度。</li></ul></li></ol><h3 id="initialize方法"><a href="#initialize方法" class="headerlink" title="+initialize方法"></a>+initialize方法</h3><ol><li><strong>调用时机</strong>：<ul><li><code>+initialize</code>方法会在类第一次接收到消息（即第一次使用该类时，如创建实例或调用类方法）时调用。每个类只会初始化一次。</li></ul></li><li><strong>调用顺序</strong>：<ul><li>首先，调用父类的<code>+initialize</code>方法（如果子类没有实现自己的<code>+initialize</code>方法，则会调用父类的）。</li><li>然后，调用子类的<code>+initialize</code>方法。这确保了类的初始化过程是从基类开始，逐层向下进行的。</li></ul></li><li><strong>调用方式</strong>：<ul><li>与<code>+load</code>方法不同，<code>+initialize</code>方法是通过objc_msgSend消息发送机制调用的。这意味着它的调用更加灵活，但也可能会受到消息传递机制的影响。</li></ul></li><li><strong>注意事项</strong>：<ul><li>如果子类实现了自己的<code>+initialize</code>方法，那么父类的<code>+initialize</code>方法只有在子类没有调用<code>[super initialize]</code>时才会被跳过。但在实际开发中，通常不需要（也不建议）在子类的<code>+initialize</code>方法中显式调用<code>[super initialize]</code>，因为系统已经保证了这一过程的正确性。</li></ul></li></ol><p>9.automic和nonatomic，automic是否是线程安全？</p><p>在Objective-C中，<code>atomic</code>和<code>nonatomic</code>是属性（property）声明时的两个关键字，它们用于定义属性的线程安全性。然而，关于<code>atomic</code>是否是线程安全的问题，需要更细致地理解这两个关键字的含义以及线程安全的概念。</p><h3 id="atomic"><a href="#atomic" class="headerlink" title="atomic"></a>atomic</h3><ul><li><strong>定义</strong>：<code>atomic</code>属性表示属性的setter和getter方法是线程安全的。这通常是通过在访问属性时添加锁来实现的，以确保在任意给定时刻只有一个线程可以访问属性的值。</li><li><strong>线程安全性</strong>：虽然<code>atomic</code>为setter和getter方法提供了基本的线程保护，但它并不保证整个对象的线程安全。具体来说，<code>atomic</code>只能确保在读取或写入属性值时的原子性，但如果操作涉及到多个步骤或需要访问对象的其他部分，那么<code>atomic</code>并不能提供足够的保护。</li><li><strong>性能影响</strong>：由于<code>atomic</code>属性需要加锁，因此它们通常比<code>nonatomic</code>属性执行得更慢。在某些情况下，这种性能开销可能是不可接受的。</li><li><strong>重要说明</strong>：需要注意的是，即使在iOS开发中，苹果官方也推荐使用<code>nonatomic</code>属性，除非有明确的理由需要线程安全（如使用原子操作来保证数据的一致性）。这是因为<code>atomic</code>属性虽然提供了一定的线程安全性，但它们的性能成本较高，并且在许多情况下，开发者可以通过其他方式（如使用锁或同步机制）来确保线程安全，而不必依赖<code>atomic</code>属性。</li></ul><h3 id="nonatomic"><a href="#nonatomic" class="headerlink" title="nonatomic"></a>nonatomic</h3><ul><li><strong>定义</strong>：<code>nonatomic</code>属性表示属性的setter和getter方法不是线程安全的。这意味着在多个线程同时访问同一属性时，可能会导致数据竞争和不确定的行为。</li><li><strong>性能优势</strong>：由于<code>nonatomic</code>属性不需要加锁，因此它们通常比<code>atomic</code>属性执行得更快。</li><li><strong>使用场景</strong>：<code>nonatomic</code>属性非常适合在不需要线程安全的情况下使用，例如在单线程环境中或当开发者可以通过其他方式（如加锁）来确保线程安全时。</li></ul><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>因此，<code>atomic</code>属性虽然在一定程度上提供了线程安全，但它并不是完全线程安全的，并且性能成本较高。在iOS开发中，建议根据实际需要选择使用<code>atomic</code>或<code>nonatomic</code>属性，并在必要时通过其他同步机制来确保线程安全。</p><p>综上所述，<strong>atomic属性并不等同于线程安全</strong>，而只是为setter和getter方法提供了一定的保护。在复杂的多线程环境中，开发者需要结合其他同步机制来确保整个对象或应用的线程安全。</p><p>10.Runloop，和对象释放的关系，Runloop在切换mode时会退出吗？</p><h3 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h3><ol><li><strong>Runloop</strong>：<ul><li>Runloop是一个事件处理循环，用于监听并处理输入事件（如触摸事件、定时器事件等）和系统事件（如内存警告）。</li><li>每个线程都可以有自己的Runloop，但默认情况下，除了主线程外，其他线程的Runloop不会自动启动。</li></ul></li><li><strong>自动释放池（AutoreleasePool）</strong>：<ul><li>自动释放池是iOS中的一种内存自动回收机制，用于延迟释放加入到池中的对象。</li><li>当对象被添加到自动释放池中时，它并不会立即被释放，而是在自动释放池销毁时（通常是Runloop的休眠或结束时）发送<code>release</code>消息，从而释放对象。</li></ul></li></ol><h3 id="二、Runloop与自动释放池的关系"><a href="#二、Runloop与自动释放池的关系" class="headerlink" title="二、Runloop与自动释放池的关系"></a>二、Runloop与自动释放池的关系</h3><ol><li><strong>自动释放池的创建与销毁</strong>：<ul><li>在主线程中，每次Runloop启动时（如用户交互导致的事件循环开始），系统会自动创建一个新的自动释放池。</li><li>在Runloop休眠或结束前，旧的自动释放池会被销毁，同时创建新的自动释放池以准备下一轮的事件处理。</li><li>在子线程中，如果Runloop被手动启动，同样会在Runloop的循环中创建和销毁自动释放池。不过，如果子线程没有启动Runloop，则需要手动管理自动释放池（例如，在每个任务开始前创建，任务结束后销毁）。</li></ul></li><li><strong>对象释放的时机</strong>：<ul><li>加入到自动释放池中的对象，其释放时机受Runloop控制。具体来说，当Runloop进入休眠状态前或结束运行时，会自动销毁当前的自动释放池，从而释放池中的所有对象。</li><li>这种机制有助于在事件处理过程中有效地管理内存，避免了因对象生命周期管理不当而导致的内存泄漏问题。</li></ul></li></ol><h3 id="三、注意事项"><a href="#三、注意事项" class="headerlink" title="三、注意事项"></a>三、注意事项</h3><ul><li>在使用子线程时，如果需要处理大量数据或执行耗时操作，建议手动启动Runloop，并利用自动释放池来管理内存。这可以避免因长时间占用内存而导致的性能问题。</li><li>需要注意的是，虽然自动释放池可以简化内存管理任务，但在某些情况下（如循环引用）仍然需要开发者手动介入以释放对象。</li></ul><p>综上所述，Runloop与自动释放池在iOS开发中紧密相关。Runloop通过控制自动释放池的创建与销毁来间接管理对象的释放时机，从而帮助开发者有效地管理内存资源。</p><p>Runloop在切换Mode时并不会直接退出，而是会先退出当前Mode的Runloop循环，并重新进入新的Mode下的Runloop循环。</p><p>11.SDK体积优化？脚本用的什么？静态分析发现了哪些问题？</p><p>Xcode静态分析能够发现的问题主要包括以下几个方面：</p><h3 id="1-逻辑缺陷"><a href="#1-逻辑缺陷" class="headerlink" title="1. 逻辑缺陷"></a>1. 逻辑缺陷</h3><ul><li><strong>访问未初始化的变量</strong>：这是常见的逻辑错误之一，尝试访问一个未被赋予初始值的变量，可能导致不确定的结果。</li><li><strong>空指针的解引用</strong>：解引用一个空指针（即指向空地址的指针）会导致程序崩溃。静态分析能够识别出这类潜在的解引用操作。</li></ul><h3 id="2-内存管理缺陷"><a href="#2-内存管理缺陷" class="headerlink" title="2. 内存管理缺陷"></a>2. 内存管理缺陷</h3><ul><li><strong>内存泄漏</strong>：分配的内存没有被及时释放，导致内存占用不断增加，最终可能影响程序的性能和稳定性。Xcode静态分析能够检测出这类内存管理错误。</li><li><strong>对象所有权问题</strong>：对于使用ARC（自动引用计数）管理的对象，静态分析可以检查是否存在潜在的强引用循环等问题，这些问题可能导致对象无法被正确释放。</li></ul><h3 id="3-无用存储缺陷"><a href="#3-无用存储缺陷" class="headerlink" title="3. 无用存储缺陷"></a>3. 无用存储缺陷</h3><ul><li><strong>未使用的变量</strong>：定义了变量但在代码中从未使用过，这不仅浪费了内存资源，还可能是代码冗余或逻辑错误的表现。</li></ul><h3 id="4-API使用缺陷"><a href="#4-API使用缺陷" class="headerlink" title="4. API使用缺陷"></a>4. API使用缺陷</h3><ul><li><strong>不遵循库或框架的使用规则</strong>：在调用API时，如果未按照库或框架的规范进行操作（如传递了错误的参数类型、遗漏了必要的参数等），静态分析能够识别出这类问题。</li></ul><h3 id="5-声明错误"><a href="#5-声明错误" class="headerlink" title="5. 声明错误"></a>5. 声明错误</h3><ul><li><strong>类、方法或变量的声明错误</strong>：包括类型不匹配、拼写错误等，这些都可能导致编译错误或运行时错误。静态分析可以在不执行代码的情况下发现这些错误。</li></ul><p>12.你觉得值得说的负责的项目</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;米可世界&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="米可世界" scheme="http://soso.wiki/tags/%E7%B1%B3%E5%8F%AF%E4%B8%96%E7%95%8C/"/>
    
  </entry>
  
  <entry>
    <title>贝壳</title>
    <link href="http://soso.wiki/%E8%B4%9D%E5%A3%B3/"/>
    <id>http://soso.wiki/贝壳/</id>
    <published>2024-07-25T03:00:00.000Z</published>
    <updated>2024-07-26T09:15:13.813Z</updated>
    
    <content type="html"><![CDATA[<p>贝壳<br><a id="more"></a><br>一面：</p><p>1.SDK体积优化，从多大优化到了多大，为什么减少Masony的使用会减少包大小</p><p>2.加载速度优化，两套网络请求的问题</p><p>3.上传视频需要注意什么？视频很大，分片，内存占用</p><p>4.自动释放池，什么时候会加 autorelease，一个方法里，alloc一个对象，这个对象加了autorelease吗？如果这个方法返回了这个对象呢？自动释放池能嵌套吗？</p><p>5.循环引用，block什么时候循环引用，block用到了_xxx成员变量，会循环引用吗？成员变量会编译成什么  self -&gt; </p><p>6.NSTimer的循环引用，为什么？</p><p>7.多线程：A/B/C并发，请求完成后执行其他任务</p><p>二面：</p><p>1.通用化技术提升迭代效率指的什么？卡片等是什么实现的</p><p>2.多线程：A -&gt; B   C -&gt; D  B依赖A、D依赖C，都完成后执行E</p><p>3.代理和block怎么选型？</p><p>4.页面传值一对多怎么实现？对象加到数组里，这个对象的引用计数增加了吗？weak呢？</p><p>5.SDWebImage原理，解码是在什么时候做的？一张图片加载到界面的过程，大图加载</p><p>6.设计：多个弹窗依次弹出，有优先级</p><p>三面：</p><p>1.iOS中遇到过的不易解决的问题，怎么解决的？</p><p>2.A -&gt; B -&gt; C 用路由的方式反向传值，什么是路由？什么时候注册？参数是什么类型？</p><p>3.autoreleasePool和Runloop的关系</p><p>4.mach-o了解吗？</p><p>参考答案</p><p>一面：</p><p>1.SDK体积优化，从多大优化到了多大，为什么减少Masony的使用会减少包大小</p><p>2.加载速度优化，两套网络请求的问题</p><p>3.上传视频需要注意什么？视频很大，分片，内存占用</p><p>在iOS开发中，网络请求上传视频是一个常见的需求，尤其是当视频文件较大时，更需要注意一系列的技术细节和优化手段以确保上传过程的稳定性、效率和用户体验。以下是一些关键的注意事项和优化手段：</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li><strong>文件大小检测</strong>：<ul><li>在上传前，先检查视频文件的大小，避免上传过大的文件导致内存溢出或上传时间过长。</li></ul></li><li><strong>网络状态检测</strong>：<ul><li>检测用户的网络状态（如Wi-Fi、4G/5G等），根据网络状况调整上传策略，如在网络较差时暂停上传或提示用户。</li></ul></li><li><strong>用户反馈</strong>：<ul><li>提供清晰的上传进度反馈，让用户了解上传的当前状态和预计剩余时间。</li></ul></li><li><strong>权限检查</strong>：<ul><li>确保应用已获取必要的权限，如访问相册或相机权限，以便读取视频文件。</li></ul></li></ol><h3 id="优化手段"><a href="#优化手段" class="headerlink" title="优化手段"></a>优化手段</h3><ol><li><strong>视频压缩</strong>：<ul><li>在上传前对视频进行压缩，减小文件大小，从而减少上传时间和占用的网络带宽。可以使用如FFmpeg等库进行视频转码和压缩。</li></ul></li><li><strong>分片上传</strong>：<ul><li>将大视频文件分割成多个较小的片段，并行上传这些片段。这样可以显著提高上传速度，并降低因网络问题导致上传失败的风险。当所有片段都上传完成后，服务器端可以将这些片段合并成完整的视频。</li></ul></li><li><strong>断点续传</strong>：<ul><li>支持断点续传功能，即在网络中断或应用退出等情况下，能在下次上传时从上次中断的地方继续上传，而不是重新开始上传整个视频。</li></ul></li><li><strong>适当设置HTTP头部</strong>：<ul><li>设置合适的Content-Type，并确保HTTP头部中的其他字段（如Content-Length）正确无误。对于分片上传，每个片段请求都应有对应的头部信息。</li></ul></li><li><strong>使用合适的网络库</strong>：<ul><li>利用成熟的网络库（如AFNetworking、URLSession等）来简化网络请求的代码量，并利用这些库提供的优化功能来提高上传效率。</li></ul></li><li><strong>缓存策略</strong>：<ul><li>对于已上传的视频或片段，可以在本地缓存其状态和信息，以便在网络恢复或应用重启时快速恢复上传状态。</li></ul></li><li><strong>后台上传</strong>：<ul><li>利用iOS的后台任务功能，在应用进入后台时继续上传视频，不影响用户的其他操作。</li></ul></li><li><strong>错误处理和重试机制</strong>：<ul><li>实现完善的错误处理逻辑，当上传失败时，根据错误类型进行重试或提示用户。可以设置合理的重试次数和重试间隔。</li></ul></li></ol><p>综上所述，iOS网络请求上传视频时需要注意多个方面，并通过一系列优化手段来提高上传的效率和稳定性。这些优化手段不仅有助于提升用户体验，还能降低因网络问题导致的数据丢失风险。</p><p>4.自动释放池，什么时候会加 autorelease，一个方法里，alloc一个对象，这个对象加了autorelease吗？如果这个方法返回了这个对象呢？自动释放池能嵌套吗？</p><p>5.循环引用，block什么时候循环引用，block用到了_xxx成员变量，会循环引用吗？成员变量会编译成什么  self -&gt; </p><p>6.NSTimer的循环引用，为什么？</p><p>7.多线程：A/B/C并发，请求完成后执行其他任务</p><p>二面：</p><p>1.通用化技术提升迭代效率指的什么？卡片等是什么实现的</p><p>2.多线程：A -&gt; B   C -&gt; D  B依赖A、D依赖C，都完成后执行E</p><p>3.代理和block怎么选型？</p><p>4.页面传值一对多怎么实现？对象加到数组里，这个对象的引用计数增加了吗？weak呢？</p><p>5.SDWebImage原理，解码是在什么时候做的？一张图片加载到界面的过程，大图加载</p><p>6.设计：多个弹窗依次弹出，有优先级</p><p>三面：</p><p>1.iOS中遇到过的不易解决的问题，怎么解决的？</p><p>2.A -&gt; B -&gt; C 用路由的方式反向传值，什么是路由？什么时候注册？参数是什么类型？</p><p>在iOS应用中通过路由机制进行页面导航和数据传递时，有时需要将数据从一个页面传递回到之前的页面。可以通过闭包（Block）来实现这种反向传值。下面是一个详细的示例，展示了如何通过路由机制进行反向传值。</p><h3 id="示例：通过路由进行反向传值"><a href="#示例：通过路由进行反向传值" class="headerlink" title="示例：通过路由进行反向传值"></a>示例：通过路由进行反向传值</h3><p>假设我们有三个页面：A -&gt; B -&gt; C，并希望在C页面完成某些操作后将数据传回A页面。</p><h4 id="1-定义路由管理器"><a href="#1-定义路由管理器" class="headerlink" title="1. 定义路由管理器"></a>1. 定义路由管理器</h4><p>首先，我们需要一个路由管理器来管理导航和数据传递。我们将使用一个单例类<code>Router</code>来实现。</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// Router.h</span></span><br><span class="line"><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">void</span> (^CompletionHandler)(<span class="hljs-keyword">id</span> data);</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Router</span> : <span class="hljs-title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="hljs-keyword">instancetype</span>)sharedInstance;</span><br><span class="line"></span><br><span class="line">- (<span class="hljs-keyword">void</span>)registerPath:(<span class="hljs-built_in">NSString</span> *)path forClass:(Class)className;</span><br><span class="line">- (<span class="hljs-keyword">void</span>)openPath:(<span class="hljs-built_in">NSString</span> *)path withParams:(<span class="hljs-built_in">NSDictionary</span> *)params completionHandler:(CompletionHandler)completionHandler;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">@end</span></span><br></pre></td></tr></table></figure><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// Router.m</span></span><br><span class="line"><span class="hljs-meta">#import <span class="hljs-meta-string">"Router.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Router</span> ()</span></span><br><span class="line"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSMutableDictionary</span> *routeMap;</span><br><span class="line"><span class="hljs-keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Router</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="hljs-keyword">instancetype</span>)sharedInstance &#123;</span><br><span class="line">    <span class="hljs-keyword">static</span> Router *instance;</span><br><span class="line">    <span class="hljs-keyword">static</span> <span class="hljs-built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="hljs-built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        instance = [[Router alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="hljs-keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="hljs-keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="hljs-keyword">self</span> = [<span class="hljs-keyword">super</span> init];</span><br><span class="line">    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>) &#123;</span><br><span class="line">        _routeMap = [<span class="hljs-built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="hljs-keyword">void</span>)registerPath:(<span class="hljs-built_in">NSString</span> *)path forClass:(Class)className &#123;</span><br><span class="line">    <span class="hljs-keyword">self</span>.routeMap[path] = className;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="hljs-keyword">void</span>)openPath:(<span class="hljs-built_in">NSString</span> *)path withParams:(<span class="hljs-built_in">NSDictionary</span> *)params completionHandler:(CompletionHandler)completionHandler &#123;</span><br><span class="line">    Class className = <span class="hljs-keyword">self</span>.routeMap[path];</span><br><span class="line">    <span class="hljs-keyword">if</span> (className) &#123;</span><br><span class="line">        <span class="hljs-built_in">UIViewController</span> *viewController = [[className alloc] init];</span><br><span class="line">        <span class="hljs-keyword">if</span> ([viewController isKindOfClass:[<span class="hljs-built_in">UIViewController</span> <span class="hljs-keyword">class</span>]]) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (completionHandler) &#123;</span><br><span class="line">                [viewController setValue:completionHandler forKey:<span class="hljs-string">@"completionHandler"</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            [viewController setValuesForKeysWithDictionary:params];</span><br><span class="line">            [[<span class="hljs-built_in">UIApplication</span> sharedApplication].keyWindow.rootViewController presentViewController:viewController animated:<span class="hljs-literal">YES</span> completion:<span class="hljs-literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"No route found for path: %@"</span>, path);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">@end</span></span><br></pre></td></tr></table></figure><h4 id="2-定义页面C"><a href="#2-定义页面C" class="headerlink" title="2. 定义页面C"></a>2. 定义页面C</h4><p>在C页面中定义一个回调Block，用于传递数据。</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// CViewController.h</span></span><br><span class="line"><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">CViewController</span> : <span class="hljs-title">UIViewController</span></span></span><br><span class="line"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-keyword">void</span> (^completionHandler)(<span class="hljs-keyword">id</span> data);</span><br><span class="line"><span class="hljs-keyword">@end</span></span><br></pre></td></tr></table></figure><p>在C页面完成操作时调用回调Block。</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// CViewController.m</span></span><br><span class="line"><span class="hljs-meta">#import <span class="hljs-meta-string">"CViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">CViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="hljs-keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="hljs-keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="hljs-keyword">self</span>.view.backgroundColor = [<span class="hljs-built_in">UIColor</span> whiteColor];</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-built_in">UIButton</span> *button = [<span class="hljs-built_in">UIButton</span> buttonWithType:<span class="hljs-built_in">UIButtonTypeSystem</span>];</span><br><span class="line">    button.frame = <span class="hljs-built_in">CGRectMake</span>(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">50</span>);</span><br><span class="line">    [button setTitle:<span class="hljs-string">@"Send Data"</span> forState:<span class="hljs-built_in">UIControlStateNormal</span>];</span><br><span class="line">    [button addTarget:<span class="hljs-keyword">self</span> action:<span class="hljs-keyword">@selector</span>(sendData) forControlEvents:<span class="hljs-built_in">UIControlEventTouchUpInside</span>];</span><br><span class="line">    [<span class="hljs-keyword">self</span>.view addSubview:button];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="hljs-keyword">void</span>)sendData &#123;</span><br><span class="line">    <span class="hljs-built_in">NSString</span> *data = <span class="hljs-string">@"Some data from C"</span>;</span><br><span class="line">    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.completionHandler) &#123;</span><br><span class="line">        <span class="hljs-keyword">self</span>.completionHandler(data);</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="hljs-keyword">self</span> dismissViewControllerAnimated:<span class="hljs-literal">YES</span> completion:<span class="hljs-literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">@end</span></span><br></pre></td></tr></table></figure><h4 id="3-注册路由"><a href="#3-注册路由" class="headerlink" title="3. 注册路由"></a>3. 注册路由</h4><p>在AppDelegate中注册路由。</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// AppDelegate.m</span></span><br><span class="line"><span class="hljs-meta">#import <span class="hljs-meta-string">"AppDelegate.h"</span></span></span><br><span class="line"><span class="hljs-meta">#import <span class="hljs-meta-string">"Router.h"</span></span></span><br><span class="line"><span class="hljs-meta">#import <span class="hljs-meta-string">"AViewController.h"</span></span></span><br><span class="line"><span class="hljs-meta">#import <span class="hljs-meta-string">"BViewController.h"</span></span></span><br><span class="line"><span class="hljs-meta">#import <span class="hljs-meta-string">"CViewController.h"</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="hljs-built_in">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)launchOptions &#123;</span><br><span class="line">    [[Router sharedInstance] registerPath:<span class="hljs-string">@"a"</span> forClass:[<span class="hljs-built_in">AViewController</span> <span class="hljs-keyword">class</span>]];</span><br><span class="line">    [[Router sharedInstance] registerPath:<span class="hljs-string">@"b"</span> forClass:[BViewController <span class="hljs-keyword">class</span>]];</span><br><span class="line">    [[Router sharedInstance] registerPath:<span class="hljs-string">@"c"</span> forClass:[CViewController <span class="hljs-keyword">class</span>]];</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">self</span>.window = [[<span class="hljs-built_in">UIWindow</span> alloc] initWithFrame:[<span class="hljs-built_in">UIScreen</span> mainScreen].bounds];</span><br><span class="line">    <span class="hljs-keyword">self</span>.window.rootViewController = [[<span class="hljs-built_in">AViewController</span> alloc] init];</span><br><span class="line">    [<span class="hljs-keyword">self</span>.window makeKeyAndVisible];</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-使用路由"><a href="#4-使用路由" class="headerlink" title="4. 使用路由"></a>4. 使用路由</h4><p>在A页面中导航到C页面并处理回调。</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// AViewController.m</span></span><br><span class="line"><span class="hljs-meta">#import <span class="hljs-meta-string">"AViewController.h"</span></span></span><br><span class="line"><span class="hljs-meta">#import <span class="hljs-meta-string">"Router.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">AViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="hljs-keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="hljs-keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="hljs-keyword">self</span>.view.backgroundColor = [<span class="hljs-built_in">UIColor</span> whiteColor];</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-built_in">UIButton</span> *button = [<span class="hljs-built_in">UIButton</span> buttonWithType:<span class="hljs-built_in">UIButtonTypeSystem</span>];</span><br><span class="line">    button.frame = <span class="hljs-built_in">CGRectMake</span>(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">50</span>);</span><br><span class="line">    [button setTitle:<span class="hljs-string">@"Go to C"</span> forState:<span class="hljs-built_in">UIControlStateNormal</span>];</span><br><span class="line">    [button addTarget:<span class="hljs-keyword">self</span> action:<span class="hljs-keyword">@selector</span>(openCViewController) forControlEvents:<span class="hljs-built_in">UIControlEventTouchUpInside</span>];</span><br><span class="line">    [<span class="hljs-keyword">self</span>.view addSubview:button];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="hljs-keyword">void</span>)openCViewController &#123;</span><br><span class="line">    [[Router sharedInstance] openPath:<span class="hljs-string">@"c"</span> withParams:@&#123;&#125; completionHandler:^(<span class="hljs-keyword">id</span> data) &#123;</span><br><span class="line">        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"Received data: %@"</span>, data);</span><br><span class="line">        <span class="hljs-comment">// 处理接收到的数据</span></span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过以上步骤，你可以实现页面间的数据传递和反向传值。路由管理器负责管理页面的导航和数据传递，页面C通过回调Block将数据传回A页面。这种方法不仅简化了页面间的数据传递，还保持了代码的清晰和可维护性。</p><p>3.autoreleasePool和Runloop的关系</p><p>4.mach-o了解吗？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;贝壳&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="贝壳" scheme="http://soso.wiki/tags/%E8%B4%9D%E5%A3%B3/"/>
    
  </entry>
  
  <entry>
    <title>百易图</title>
    <link href="http://soso.wiki/%E7%99%BE%E6%98%93%E5%9B%BE/"/>
    <id>http://soso.wiki/百易图/</id>
    <published>2024-07-22T03:00:00.000Z</published>
    <updated>2024-07-26T09:14:58.768Z</updated>
    
    <content type="html"><![CDATA[<p>百易图<br><a id="more"></a><br>1.内存管理，ARC、MRC，有没有遇到内存问题，怎么解决的，内存泄漏</p><p>2.了解的iOS中的设计模式，tableView用了什么设计模式？享元模式</p><p>3.MVVM怎么实现双向绑定</p><p>4.多线程，多个请求并发，请求回来后处理</p><p>5.加载速度优化，怎么优化的多次刷新</p><p>6.直播聊天室大量消息优化，送礼物怎么保证触达</p><p>7.500人群里抢红包的场景处理</p><p>8.swift类和结构体的区别</p><p>9.减少CPU占用的优化</p><p>参考答案</p><p>1.内存管理，ARC、MRC，有没有遇到内存问题，怎么解决的，内存泄漏</p><p>Tagged Pointer NSNumber、NSDate、NSString等小对象的存储，数据直接存储在指针中</p><p>引用计数来管理OC对象的内存</p><p>引用计数存储在 nonpointer 优化过的isa指针中，也可能存储在SideTable类中，</p><p>SideTable {</p><p>​    spinlock_t slock;</p><p>​    RefcountMap refcnts;</p><p>​    weak_table_t weak_table;</p><p>};</p><p>refcnts 是一个存放着对象引用计数的散列表</p><p>2.了解的iOS中的设计模式，tableView用了什么设计模式？</p><p>在iOS开发中，<code>UITableView</code> 主要使用了一系列设计模式来实现其功能，包括但不限于以下几种设计模式：</p><h3 id="1-委托模式（Delegate）"><a href="#1-委托模式（Delegate）" class="headerlink" title="1. 委托模式（Delegate）"></a>1. 委托模式（Delegate）</h3><p><strong>描述</strong>：通过将一个对象的某些职责委托给另一个对象来实现对象间的松耦合。</p><p><strong>在 <code>UITableView</code> 中的应用</strong>：</p><ul><li><code>UITableView</code> 使用委托模式来处理用户交互和配置特定行为。<code>UITableViewDelegate</code> 协议定义了一些方法，这些方法由委托对象（通常是视图控制器）实现，以响应用户操作（如行选择、行高设置等）。</li></ul><h3 id="2-数据源模式（Data-Source）"><a href="#2-数据源模式（Data-Source）" class="headerlink" title="2. 数据源模式（Data Source）"></a>2. 数据源模式（Data Source）</h3><p><strong>描述</strong>：通过将数据访问和数据管理的职责委托给另一个对象来实现数据的解耦。</p><p><strong>在 <code>UITableView</code> 中的应用</strong>：</p><ul><li><code>UITableView</code> 使用数据源模式来提供数据。<code>UITableViewDataSource</code> 协议定义了一些方法，这些方法由数据源对象实现，以提供表格视图所需的数据（如单元格内容、行数等）。</li></ul><h3 id="3-复用模式（Reuse）"><a href="#3-复用模式（Reuse）" class="headerlink" title="3. 复用模式（Reuse）"></a>3. 复用模式（Reuse）</h3><p><strong>描述</strong>：通过对象的复用来提升性能和减少内存消耗。</p><p><strong>在 <code>UITableView</code> 中的应用</strong>：</p><ul><li><code>UITableView</code> 使用单元格复用机制来提高性能。通过 <code>dequeueReusableCellWithIdentifier:</code> 方法，表格视图可以复用已经创建的单元格，而不是每次都创建新的单元格。</li></ul><h3 id="4-MVC-模式（Model-View-Controller）"><a href="#4-MVC-模式（Model-View-Controller）" class="headerlink" title="4. MVC 模式（Model-View-Controller）"></a>4. MVC 模式（Model-View-Controller）</h3><p><strong>描述</strong>：一种用于组织代码的架构模式，将应用的逻辑层、数据层和视图层分离。</p><p><strong>在 <code>UITableView</code> 中的应用</strong>：</p><ul><li><code>UITableView</code> 本身是视图层的一部分，数据源和委托对象（通常是视图控制器）负责处理数据层和逻辑层。这种分离使得代码更清晰、可维护性更高。</li></ul><p>3.MVVM怎么实现双向绑定</p><p>4.多线程，多个请求并发，请求回来后处理</p><p>5.加载速度优化，怎么优化的多次刷新</p><p>6.直播聊天室大量消息优化，送礼物怎么保证触达</p><p>7.500人群里抢红包的场景处理</p><p>8.swift类和结构体的区别</p><p>9.减少CPU占用的优化</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;百易图&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="百易图" scheme="http://soso.wiki/tags/%E7%99%BE%E6%98%93%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>百融云创面试题</title>
    <link href="http://soso.wiki/%E7%99%BE%E8%9E%8D%E4%BA%91%E5%88%9B%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://soso.wiki/百融云创面试题/</id>
    <published>2024-05-09T12:58:00.000Z</published>
    <updated>2024-07-26T09:15:19.558Z</updated>
    
    <content type="html"><![CDATA[<p>百融云创面试题<br><a id="more"></a></p><p>1.腾讯会议共享屏幕在线编程 <a href="https://leetcode.cn/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/description/" target="_blank" rel="noopener">https://leetcode.cn/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/description/</a><br>2.KVO 原理<br>3.如何调用私有 API？三方库或系统未暴漏的方法<br>4.怎么改一个类的只读属性<br>5.消息机制<br>6.Runloop 流程，用 Runloop 做过什么？卡顿检测，发生卡顿后怎么获取堆栈信息？堆栈信息的原理<br>7.GCD 都用了哪些？网络请求 A 和 B 都回调后，请求 C，如何实现？除了 dispatch_group<br>8.可变数组 NSMutableArray，在头部插入元素，iOS 系统做了什么优化<br>9.Tagged Pointer<br>10.NSString 存储在哪里，引用计数存储哪里？<br>11.dealloc 流程<br>12.避免哈希碰撞的几种方法？<br>13.mach-o 了解吗？存储的方法信息可以无用代码检测？段迁移？<br>14.脚本检测未使用代码原理<br>15.render 渲染流程<br>16.UIView 动画和 CAAnimation 动画有什么联系？<br>17.项目亮点</p><h2 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a>参考答案</h2><h2 id="1-腾讯会议共享屏幕在线编程-https-leetcode-cn-problems-zhan-de-ya-ru-dan-chu-xu-lie-lcof-description"><a href="#1-腾讯会议共享屏幕在线编程-https-leetcode-cn-problems-zhan-de-ya-ru-dan-chu-xu-lie-lcof-description" class="headerlink" title="1.腾讯会议共享屏幕在线编程 https://leetcode.cn/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/description/"></a>1.腾讯会议共享屏幕在线编程 <a href="https://leetcode.cn/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/description/" target="_blank" rel="noopener">https://leetcode.cn/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/description/</a></h2><h2 id="2-KVO-原理工作原理"><a href="#2-KVO-原理工作原理" class="headerlink" title="2.KVO 原理工作原理"></a>2.KVO 原理工作原理</h2><p>KVO 主要依赖于 Objective-C 的动态性和 Runtime 运行时机制。以下是 KVO 的几个核心步骤和原理：</p><h4 id="1-动态子类化"><a href="#1-动态子类化" class="headerlink" title="1. 动态子类化"></a>1. 动态子类化</h4><p>当你第一次给某个对象添加观察者时，Objective-C Runtime 会动态地创建该对象的一个子类。这个子类会重写被观察属性的 setter 方法。</p><p>例如，如果你观察对象 <code>person</code> 的 <code>name</code> 属性：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[person addObserver:<span class="hljs-keyword">self</span> forKeyPath:<span class="hljs-string">@"name"</span> options:<span class="hljs-built_in">NSKeyValueObservingOptionNew</span> context:<span class="hljs-literal">nil</span>];</span><br></pre></td></tr></table></figure><p>Runtime 会创建一个新的类，假设名为 <code>NSKVONotifying_Person</code>，这个类是 <code>Person</code> 类的子类。</p><h4 id="2-重写-setter-方法"><a href="#2-重写-setter-方法" class="headerlink" title="2. 重写 setter 方法"></a>2. 重写 setter 方法</h4><p>在新的子类中，Runtime 会重写被观察属性的 setter 方法。例如，对于 <code>name</code> 属性，其 setter 方法可能如下：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="hljs-keyword">void</span>)setName:(<span class="hljs-built_in">NSString</span> *)name &#123;</span><br><span class="line">    [<span class="hljs-keyword">self</span> willChangeValueForKey:<span class="hljs-string">@"name"</span>];</span><br><span class="line">    [<span class="hljs-keyword">super</span> setName:name];</span><br><span class="line">    [<span class="hljs-keyword">self</span> didChangeValueForKey:<span class="hljs-string">@"name"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>willChangeValueForKey:</code></strong>：通知系统属性即将发生变化。</li><li><strong><code>didChangeValueForKey:</code></strong>：通知系统属性已经发生变化。</li></ul><p>这些方法会触发 KVO 通知机制，向所有观察者发送通知。</p><h4 id="3-注册观察者"><a href="#3-注册观察者" class="headerlink" title="3. 注册观察者"></a>3. 注册观察者</h4><p>当你调用 <code>addObserver:forKeyPath:options:context:</code> 方法时，Runtime 会将观察者注册到一个内部的观察者列表中，这个列表通常是一个哈希表（Hash Table），键是被观察的属性，值是观察者对象。</p><h4 id="4-通知观察者"><a href="#4-通知观察者" class="headerlink" title="4. 通知观察者"></a>4. 通知观察者</h4><p>当属性值发生变化时，重写的 setter 方法会调用 <code>willChangeValueForKey:</code> 和 <code>didChangeValueForKey:</code> 方法，这些方法会触发 KVO 通知机制，向注册的观察者发送通知。观察者会收到 <code>observeValueForKeyPath:ofObject:change:context:</code> 方法的回调。</p><h2 id="3-如何调用私有-API？三方库或系统未暴漏的方法"><a href="#3-如何调用私有-API？三方库或系统未暴漏的方法" class="headerlink" title="3.如何调用私有 API？三方库或系统未暴漏的方法"></a>3.如何调用私有 API？三方库或系统未暴漏的方法</h2><h3 id="1-使用-performSelector-方法"><a href="#1-使用-performSelector-方法" class="headerlink" title="1. 使用 performSelector: 方法"></a>1. 使用 <code>performSelector:</code> 方法</h3><p><code>performSelector:</code> 方法可以动态调用对象的方法，即使这些方法在编译时不可见。</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SEL privateSelector = <span class="hljs-built_in">NSSelectorFromString</span>(<span class="hljs-string">@"privateMethod"</span>);</span><br><span class="line"><span class="hljs-keyword">if</span> ([object respondsToSelector:privateSelector]) &#123;</span><br><span class="line">    [object performSelector:privateSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-使用-Runtime-动态调用"><a href="#2-使用-Runtime-动态调用" class="headerlink" title="2. 使用 Runtime 动态调用"></a>2. 使用 Runtime 动态调用</h3><p>Objective-C 的 Runtime 库提供了一些函数，可以用来动态调用方法。</p><h4 id="示例代码：调用私有方法"><a href="#示例代码：调用私有方法" class="headerlink" title="示例代码：调用私有方法"></a>示例代码：调用私有方法</h4><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">SEL privateSelector = <span class="hljs-built_in">NSSelectorFromString</span>(<span class="hljs-string">@"privateMethod"</span>);</span><br><span class="line"><span class="hljs-keyword">if</span> ([object respondsToSelector:privateSelector]) &#123;</span><br><span class="line">    IMP imp = [object methodForSelector:privateSelector];</span><br><span class="line">    <span class="hljs-keyword">void</span> (*func)(<span class="hljs-keyword">id</span>, SEL) = (<span class="hljs-keyword">void</span> *)imp;</span><br><span class="line">    func(object, privateSelector);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="示例代码：访问私有属性"><a href="#示例代码：访问私有属性" class="headerlink" title="示例代码：访问私有属性"></a>示例代码：访问私有属性</h4><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">Ivar ivar = class_getInstanceVariable([object <span class="hljs-keyword">class</span>], <span class="hljs-string">"_privateProperty"</span>);</span><br><span class="line"><span class="hljs-keyword">id</span> privateValue = object_getIvar(object, ivar);</span><br></pre></td></tr></table></figure><h3 id="3-使用-dlsym-函数"><a href="#3-使用-dlsym-函数" class="headerlink" title="3. 使用 dlsym 函数"></a>3. 使用 <code>dlsym</code> 函数</h3><p>如果你知道私有 API 的符号名称，可以使用 <code>dlsym</code> 函数来获取函数指针，并调用它。</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">void</span> *handle = dlopen(<span class="hljs-literal">NULL</span>, RTLD_LAZY);</span><br><span class="line"><span class="hljs-keyword">if</span> (handle) &#123;</span><br><span class="line">    <span class="hljs-keyword">void</span> (*privateFunction)(<span class="hljs-keyword">void</span>) = dlsym(handle, <span class="hljs-string">"privateFunctionName"</span>);</span><br><span class="line">    <span class="hljs-keyword">if</span> (privateFunction) &#123;</span><br><span class="line">        privateFunction();</span><br><span class="line">    &#125;</span><br><span class="line">    dlclose(handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-怎么改一个类的只读属性"><a href="#4-怎么改一个类的只读属性" class="headerlink" title="4.怎么改一个类的只读属性"></a>4.怎么改一个类的只读属性</h2><h3 id="方法一：通过-KVC-Key-Value-Coding"><a href="#方法一：通过-KVC-Key-Value-Coding" class="headerlink" title="方法一：通过 KVC (Key-Value Coding)"></a>方法一：通过 KVC (Key-Value Coding)</h3><p>Key-Value Coding (KVC) 是一种间接访问对象属性的方法。即使属性是只读的，也可以通过 KVC 修改它的值。</p><p>示例：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">MyClass</span> : <span class="hljs-title">NSObject</span></span></span><br><span class="line"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>, <span class="hljs-keyword">readonly</span>) <span class="hljs-built_in">NSString</span> *readonlyProperty;</span><br><span class="line"><span class="hljs-keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">NSString</span> *_readonlyProperty;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="hljs-keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="hljs-keyword">self</span> = [<span class="hljs-keyword">super</span> init];</span><br><span class="line">    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>) &#123;</span><br><span class="line">        _readonlyProperty = <span class="hljs-string">@"Initial Value"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 修改只读属性</span></span><br><span class="line">MyClass *myObject = [[MyClass alloc] init];</span><br><span class="line"><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"Before: %@"</span>, myObject.readonlyProperty);</span><br><span class="line"></span><br><span class="line">[myObject setValue:<span class="hljs-string">@"New Value"</span> forKey:<span class="hljs-string">@"readonlyProperty"</span>];</span><br><span class="line"><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"After: %@"</span>, myObject.readonlyProperty);</span><br></pre></td></tr></table></figure><h3 id="方法二：使用运行时函数"><a href="#方法二：使用运行时函数" class="headerlink" title="方法二：使用运行时函数"></a>方法二：使用运行时函数</h3><p>在 Objective-C 中，可以使用运行时函数来修改属性的值。</p><p>示例：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">MyClass</span> : <span class="hljs-title">NSObject</span></span></span><br><span class="line"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>, <span class="hljs-keyword">readonly</span>) <span class="hljs-built_in">NSString</span> *readonlyProperty;</span><br><span class="line"><span class="hljs-keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">NSString</span> *_readonlyProperty;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="hljs-keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="hljs-keyword">self</span> = [<span class="hljs-keyword">super</span> init];</span><br><span class="line">    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>) &#123;</span><br><span class="line">        _readonlyProperty = <span class="hljs-string">@"Initial Value"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 修改只读属性</span></span><br><span class="line">MyClass *myObject = [[MyClass alloc] init];</span><br><span class="line"><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"Before: %@"</span>, myObject.readonlyProperty);</span><br><span class="line"></span><br><span class="line">Ivar ivar = class_getInstanceVariable([MyClass <span class="hljs-keyword">class</span>], <span class="hljs-string">"_readonlyProperty"</span>);</span><br><span class="line">object_setIvar(myObject, ivar, <span class="hljs-string">@"New Value"</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"After: %@"</span>, myObject.readonlyProperty);</span><br></pre></td></tr></table></figure><h3 id="方法三：子类化和重写-Getter-方法"><a href="#方法三：子类化和重写-Getter-方法" class="headerlink" title="方法三：子类化和重写 Getter 方法"></a>方法三：子类化和重写 Getter 方法</h3><p>通过创建一个子类并重写只读属性的 getter 方法，可以控制属性的值。</p><p>示例：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">MyClass</span> : <span class="hljs-title">NSObject</span></span></span><br><span class="line"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>, <span class="hljs-keyword">readonly</span>) <span class="hljs-built_in">NSString</span> *readonlyProperty;</span><br><span class="line"><span class="hljs-keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">NSString</span> *_readonlyProperty;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="hljs-keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="hljs-keyword">self</span> = [<span class="hljs-keyword">super</span> init];</span><br><span class="line">    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>) &#123;</span><br><span class="line">        _readonlyProperty = <span class="hljs-string">@"Initial Value"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">MyClassSubclass</span> : <span class="hljs-title">MyClass</span></span></span><br><span class="line"><span class="hljs-keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">MyClassSubclass</span> </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">NSString</span> *_customValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="hljs-built_in">NSString</span> *)readonlyProperty &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> _customValue ? _customValue : [<span class="hljs-keyword">super</span> readonlyProperty];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="hljs-keyword">void</span>)setCustomValue:(<span class="hljs-built_in">NSString</span> *)value &#123;</span><br><span class="line">    _customValue = value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 修改只读属性</span></span><br><span class="line">MyClassSubclass *myObject = [[MyClassSubclass alloc] init];</span><br><span class="line"><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"Before: %@"</span>, myObject.readonlyProperty);</span><br><span class="line"></span><br><span class="line">[myObject setCustomValue:<span class="hljs-string">@"New Value"</span>];</span><br><span class="line"><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"After: %@"</span>, myObject.readonlyProperty);</span><br></pre></td></tr></table></figure><h2 id="5-消息机制"><a href="#5-消息机制" class="headerlink" title="5.消息机制"></a>5.消息机制</h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><ul><li><strong>消息（Message）</strong>：在 Objective-C 中，方法调用被称为“发送消息”。发送消息的语法是 <code>[receiver message]</code>。</li><li><strong>接收者（Receiver）</strong>：接收并处理消息的对象。</li><li><strong>选择器（Selector）</strong>：表示方法名称的一个数据类型，类型为 <code>SEL</code>。选择器是方法的唯一标识符。</li></ul><h3 id="2-消息发送流程"><a href="#2-消息发送流程" class="headerlink" title="2. 消息发送流程"></a>2. 消息发送流程</h3><p>当向一个对象发送消息时，Objective-C 的运行时系统会进行一系列步骤来查找并调用相应的方法。以下是消息发送的基本流程：</p><ol><li><strong>消息发送</strong>：当代码中调用 <code>[object message]</code> 时，编译器将其转换为 <code>objc_msgSend</code> 函数调用。</li><li><strong>查找方法</strong>：<code>objc_msgSend</code> 函数会根据消息的选择器（<code>SEL</code>）在对象的类及其父类的方法列表中查找对应的方法实现。</li><li><strong>调用方法</strong>：找到方法实现后，<code>objc_msgSend</code> 函数会调用该方法。如果没有找到方法实现，则会触发消息转发机制（Message Forwarding）。</li></ol><h3 id="3-objc-msgSend-函数"><a href="#3-objc-msgSend-函数" class="headerlink" title="3. objc_msgSend 函数"></a>3. <code>objc_msgSend</code> 函数</h3><p><code>objc_msgSend</code> 是 Objective-C 运行时系统的核心函数之一，负责消息的分发。其原型如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void objc_msgSend(id self, SEL _cmd, ...);</span><br></pre></td></tr></table></figure><ul><li><strong><code>self</code></strong>：消息的接收者。</li><li><strong><code>_cmd</code></strong>：消息的选择器。</li><li><strong>可变参数</strong>：方法的参数。</li></ul><h3 id="4-消息转发机制"><a href="#4-消息转发机制" class="headerlink" title="4. 消息转发机制"></a>4. 消息转发机制</h3><p>当 <code>objc_msgSend</code> 无法在类的方法列表中找到与选择器匹配的方法时，会触发消息转发机制。消息转发机制包括以下几个步骤：</p><h4 id="4-1-动态方法解析"><a href="#4-1-动态方法解析" class="headerlink" title="4.1 动态方法解析"></a>4.1 动态方法解析</h4><p>首先，运行时系统会尝试动态方法解析，通过调用类的 <code>+resolveInstanceMethod:</code> 或 <code>+resolveClassMethod:</code> 方法来添加方法实现。如果方法实现被动态添加，消息发送会重新开始。</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="hljs-built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (sel == <span class="hljs-keyword">@selector</span>(myMethod)) &#123;</span><br><span class="line">        class_addMethod([<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>], sel, (IMP)myMethodIMP, <span class="hljs-string">"v@:"</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-快速转发"><a href="#4-2-快速转发" class="headerlink" title="4.2 快速转发"></a>4.2 快速转发</h4><p>如果动态方法解析未能添加方法实现，运行时系统会调用 <code>-forwardingTargetForSelector:</code> 方法。这个方法允许将消息转发给另一个对象。</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="hljs-keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (aSelector == <span class="hljs-keyword">@selector</span>(myMethod)) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> someOtherObject;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-常规转发"><a href="#4-3-常规转发" class="headerlink" title="4.3 常规转发"></a>4.3 常规转发</h4><p>如果快速转发也未能处理消息，运行时系统会调用 <code>-methodSignatureForSelector:</code> 和 <code>-forwardInvocation:</code> 方法。首先，通过 <code>-methodSignatureForSelector:</code> 获取方法签名，然后通过 <code>-forwardInvocation:</code> 进行消息转发。</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="hljs-built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (aSelector == <span class="hljs-keyword">@selector</span>(myMethod)) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> [<span class="hljs-built_in">NSMethodSignature</span> signatureWithObjCTypes:<span class="hljs-string">"v@:"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">super</span> methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="hljs-keyword">void</span>)forwardInvocation:(<span class="hljs-built_in">NSInvocation</span> *)anInvocation &#123;</span><br><span class="line">    SEL sel = [anInvocation selector];</span><br><span class="line">    <span class="hljs-keyword">if</span> ([someOtherObject respondsToSelector:sel]) &#123;</span><br><span class="line">        [anInvocation invokeWithTarget:someOtherObject];</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        [<span class="hljs-keyword">super</span> forwardInvocation:anInvocation];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-消息缓存"><a href="#5-消息缓存" class="headerlink" title="5. 消息缓存"></a>5. 消息缓存</h3><p>为了提高消息发送的性能，Objective-C 运行时系统使用方法缓存（Method Caching）。当一个方法第一次被调用时，其实现会被缓存起来，下次调用相同的方法时，可以直接从缓存中获取，而不需要重新查找。</p><h2 id="6-Runloop-流程，用-Runloop-做过什么？卡顿检测，发生卡顿后怎么获取堆栈信息？堆栈信息的原理"><a href="#6-Runloop-流程，用-Runloop-做过什么？卡顿检测，发生卡顿后怎么获取堆栈信息？堆栈信息的原理" class="headerlink" title="6.Runloop 流程，用 Runloop 做过什么？卡顿检测，发生卡顿后怎么获取堆栈信息？堆栈信息的原理"></a>6.Runloop 流程，用 Runloop 做过什么？卡顿检测，发生卡顿后怎么获取堆栈信息？堆栈信息的原理</h2><h3 id="Runloop-基本概念"><a href="#Runloop-基本概念" class="headerlink" title="Runloop 基本概念"></a>Runloop 基本概念</h3><p>RunLoop 是一个事件处理循环，用来调度和处理任务。它可以在没有任务时使线程进入休眠状态，从而节省资源；有任务时则立即唤醒线程处理任务。RunLoop 实质上是一个对象，这个对象管理着其需要处理的事件和消息，并提供一个入口函数来执行这个事件处理循环。</p><h3 id="Runloop-的基本流程"><a href="#Runloop-的基本流程" class="headerlink" title="Runloop 的基本流程"></a>Runloop 的基本流程</h3><p>RunLoop 的基本流程可以概括为以下几个步骤：</p><ol><li><strong>进入循环</strong>：调用 <code>CFRunLoopRun</code> 或者 <code>-[NSRunLoop run]</code> 方法。</li><li><strong>通知观察者</strong>：通知即将进入 RunLoop 事件处理循环。</li><li><strong>检查 Timer</strong>：检查是否有定时器（Timer）需要处理。</li><li><strong>处理输入源</strong>：处理输入源（Input Source），比如用户触摸事件，UI事件等。</li><li><strong>通知观察者</strong>：通知即将进入休眠。</li><li><strong>休眠</strong>：如果没有事件需要处理，线程进入休眠状态，等待事件发生。</li><li><strong>唤醒</strong>：收到外部事件（如 Timer 到时间、输入源事件）唤醒线程。</li><li><strong>通知观察者</strong>：通知即将处理事件。</li><li><strong>处理事件</strong>：处理 Timer 或输入源事件。</li><li><strong>通知观察者</strong>：通知事件已处理完成。</li><li><strong>重复或退出</strong>：重复上述步骤，或根据特定条件退出循环。</li></ol><h3 id="RunLoop-在-iOS-中的应用"><a href="#RunLoop-在-iOS-中的应用" class="headerlink" title="RunLoop 在 iOS 中的应用"></a>RunLoop 在 iOS 中的应用</h3><h4 id="1-保持线程活跃"><a href="#1-保持线程活跃" class="headerlink" title="1. 保持线程活跃"></a>1. <strong>保持线程活跃</strong></h4><p>RunLoop 的一个典型应用是保持线程活跃。默认情况下，子线程在任务完成后会立即退出。通过 RunLoop，可以让子线程在没有任务时处于休眠状态，但不会退出，等待新的任务到来。</p><p>示例代码：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="hljs-keyword">void</span>)startThread &#123;</span><br><span class="line">    <span class="hljs-built_in">NSThread</span> *thread = [[<span class="hljs-built_in">NSThread</span> alloc] initWithTarget:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(threadEntryPoint) object:<span class="hljs-literal">nil</span>];</span><br><span class="line">    [thread start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="hljs-keyword">void</span>)threadEntryPoint &#123;</span><br><span class="line">    <span class="hljs-keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        [[<span class="hljs-built_in">NSThread</span> currentThread] setName:<span class="hljs-string">@"MyThread"</span>];</span><br><span class="line">        <span class="hljs-built_in">NSRunLoop</span> *runLoop = [<span class="hljs-built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line">        [runLoop addPort:[<span class="hljs-built_in">NSMachPort</span> port] forMode:<span class="hljs-built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">        [runLoop run]; <span class="hljs-comment">// 进入 RunLoop</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-处理定时任务"><a href="#2-处理定时任务" class="headerlink" title="2. 处理定时任务"></a>2. <strong>处理定时任务</strong></h4><p>RunLoop 可以用来处理定时任务，比如定时器。通过将 <code>NSTimer</code> 添加到 RunLoop，可以在指定的时间间隔触发任务。</p><p>示例代码：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="hljs-keyword">void</span>)scheduleTimer &#123;</span><br><span class="line">    <span class="hljs-built_in">NSTimer</span> *timer = [<span class="hljs-built_in">NSTimer</span> timerWithTimeInterval:<span class="hljs-number">1.0</span> target:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(timerFired:) userInfo:<span class="hljs-literal">nil</span> repeats:<span class="hljs-literal">YES</span>];</span><br><span class="line">    [[<span class="hljs-built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="hljs-built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="hljs-keyword">void</span>)timerFired:(<span class="hljs-built_in">NSTimer</span> *)timer &#123;</span><br><span class="line">    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"Timer fired!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-处理网络请求"><a href="#3-处理网络请求" class="headerlink" title="3. 处理网络请求"></a>3. <strong>处理网络请求</strong></h4><p>在处理网络请求时，可以使用 RunLoop 来保持线程活跃，等待网络请求完成。<code>NSURLConnection</code> 和 <code>NSURLSession</code> 都使用 RunLoop 来处理网络事件。</p><h4 id="4-处理输入源事件"><a href="#4-处理输入源事件" class="headerlink" title="4. 处理输入源事件"></a>4. <strong>处理输入源事件</strong></h4><p>RunLoop 可以用来处理输入源事件，比如用户触摸事件、UI事件等。</p><h2 id="7-GCD-都用了哪些？网络请求-A-和-B-都回调后，请求-C，如何实现？除了-dispatch-group"><a href="#7-GCD-都用了哪些？网络请求-A-和-B-都回调后，请求-C，如何实现？除了-dispatch-group" class="headerlink" title="7.GCD 都用了哪些？网络请求 A 和 B 都回调后，请求 C，如何实现？除了 dispatch_group"></a>7.GCD 都用了哪些？网络请求 A 和 B 都回调后，请求 C，如何实现？除了 dispatch_group</h2><p>Grand Central Dispatch (GCD) 是苹果公司推出的一种用于并发编程的技术，旨在优化多核设备上的代码执行。GCD 提供了一种简单易用的 API 来管理并发任务，并且能够自动利用系统资源进行优化。以下是一些常见的 GCD 使用场景：</p><h3 id="1-异步任务"><a href="#1-异步任务" class="headerlink" title="1. 异步任务"></a>1. <strong>异步任务</strong></h3><p>GCD 的一个主要用途就是在后台执行耗时任务，从而避免阻塞主线程，提高应用的响应速度。</p><p>示例代码：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>), ^&#123;</span><br><span class="line">    <span class="hljs-comment">// 执行耗时任务</span></span><br><span class="line">    <span class="hljs-built_in">NSData</span> *data = [<span class="hljs-keyword">self</span> fetchDataFromServer];</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// 回到主线程更新 UI</span></span><br><span class="line">    <span class="hljs-built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [<span class="hljs-keyword">self</span> updateUIWithData:data];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="2-并行任务"><a href="#2-并行任务" class="headerlink" title="2. 并行任务"></a>2. <strong>并行任务</strong></h3><p>GCD 可以轻松地创建并行任务，从而充分利用多核处理器的计算能力。</p><p>示例代码：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>);</span><br><span class="line"><span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    [<span class="hljs-keyword">self</span> performTask1];</span><br><span class="line">&#125;);</span><br><span class="line"><span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    [<span class="hljs-keyword">self</span> performTask2];</span><br><span class="line">&#125;);</span><br><span class="line"><span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    [<span class="hljs-keyword">self</span> performTask3];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="3-同步任务"><a href="#3-同步任务" class="headerlink" title="3. 同步任务"></a>3. <strong>同步任务</strong></h3><p>尽管异步任务更常见，有时也需要同步任务来确保任务按顺序执行。</p><p>示例代码：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">dispatch_sync</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>), ^&#123;</span><br><span class="line">    [<span class="hljs-keyword">self</span> performSynchronousTask];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="4-延迟执行"><a href="#4-延迟执行" class="headerlink" title="4. 延迟执行"></a>4. <strong>延迟执行</strong></h3><p>GCD 提供了简洁的 API 来延迟执行任务。</p><p>示例代码：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dispatch_time_t delay = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="hljs-number">5.0</span> * <span class="hljs-built_in">NSEC_PER_SEC</span>));</span><br><span class="line">dispatch_after(delay, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    [<span class="hljs-keyword">self</span> performDelayedTask];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="5-一次性代码"><a href="#5-一次性代码" class="headerlink" title="5. 一次性代码"></a>5. <strong>一次性代码</strong></h3><p>有时我们需要确保某段代码只执行一次，这时候可以使用 <code>dispatch_once</code>。</p><p>示例代码：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-built_in">dispatch_once_t</span> onceToken;</span><br><span class="line"><span class="hljs-built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">    [<span class="hljs-keyword">self</span> initializeOnce];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="6-调度组"><a href="#6-调度组" class="headerlink" title="6. 调度组"></a>6. <strong>调度组</strong></h3><p>调度组可以用来监控一组任务的完成状态，通常用于需要等待多项任务全部完成后才能继续下一步操作的场景。</p><p>示例代码：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line"><span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>);</span><br><span class="line"></span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">    [<span class="hljs-keyword">self</span> performTask1];</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">    [<span class="hljs-keyword">self</span> performTask2];</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">    [<span class="hljs-keyword">self</span> performTask3];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    [<span class="hljs-keyword">self</span> allTasksCompleted];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="7-信号量"><a href="#7-信号量" class="headerlink" title="7. 信号量"></a>7. <strong>信号量</strong></h3><p>信号量可以用来控制并发访问资源的数量，适用于需要限制并发任务数量的场景。</p><p>示例代码：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="hljs-number">2</span>); <span class="hljs-comment">// 允许同时执行两个并发任务</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;</span><br><span class="line">    <span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>), ^&#123;</span><br><span class="line">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment">// 执行任务</span></span><br><span class="line">        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"Task %d started"</span>, i);</span><br><span class="line">        sleep(<span class="hljs-number">2</span>); <span class="hljs-comment">// 模拟耗时任务</span></span><br><span class="line">        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"Task %d completed"</span>, i);</span><br><span class="line">        </span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-Barrier-Block"><a href="#8-Barrier-Block" class="headerlink" title="8. Barrier Block"></a>8. <strong>Barrier Block</strong></h3><p>Barrier Block 用于在并发队列中插入一个障碍，确保在障碍前提交的所有任务执行完成后，才执行障碍后的任务。</p><p>示例代码：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="hljs-string">"com.example.myqueue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    [<span class="hljs-keyword">self</span> performReadTask1];</span><br><span class="line">&#125;);</span><br><span class="line"><span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    [<span class="hljs-keyword">self</span> performReadTask2];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">    [<span class="hljs-keyword">self</span> performWriteTask];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    [<span class="hljs-keyword">self</span> performReadTask3];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="9-Dispatch-Source"><a href="#9-Dispatch-Source" class="headerlink" title="9. Dispatch Source"></a>9. <strong>Dispatch Source</strong></h3><p>Dispatch Source 是一种非常强大的工具，可以用来处理各种系统事件，如文件变化、定时器、信号等。</p><p>示例代码（定时器）：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, dispatch_get_main_queue());</span><br><span class="line">dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, <span class="hljs-number">1.0</span> * <span class="hljs-built_in">NSEC_PER_SEC</span>, <span class="hljs-number">0.1</span> * <span class="hljs-built_in">NSEC_PER_SEC</span>);</span><br><span class="line">dispatch_source_set_event_handler(timer, ^&#123;</span><br><span class="line">    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"Timer fired"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_resume(timer);</span><br></pre></td></tr></table></figure><h3 id="10-Dispatch-Work-Item"><a href="#10-Dispatch-Work-Item" class="headerlink" title="10. Dispatch Work Item"></a>10. <strong>Dispatch Work Item</strong></h3><p>使用 <code>dispatch_block_t</code> 创建可取消的工作项。</p><p>示例代码：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>);</span><br><span class="line">dispatch_block_t workItem = dispatch_block_create(<span class="hljs-number">0</span>, ^&#123;</span><br><span class="line">    <span class="hljs-comment">// 执行任务</span></span><br><span class="line">    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"Work item executed"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">dispatch_async</span>(queue, workItem);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 取消工作项</span></span><br><span class="line">dispatch_block_cancel(workItem);</span><br></pre></td></tr></table></figure><p>在 iOS 开发中，有时候需要等待多个网络请求完成后再进行进一步操作，比如发起新的网络请求。为了实现这种需求，可以使用多种方法，包括 GCD（Grand Central Dispatch）、<code>NSOperationQueue</code> 和第三方库如 <code>PromiseKit</code> 或 <code>Combine</code>。</p><h3 id="方法一：使用-GCD-Grand-Central-Dispatch"><a href="#方法一：使用-GCD-Grand-Central-Dispatch" class="headerlink" title="方法一：使用 GCD (Grand Central Dispatch)"></a>方法一：使用 GCD (Grand Central Dispatch)</h3><p>GCD 提供了一种简单的方法来同步多个异步任务。可以使用 <code>dispatch_group</code> 来实现等待多个任务完成后执行下一步操作。</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 开始请求A</span></span><br><span class="line">dispatch_group_enter(group);</span><br><span class="line">[<span class="hljs-keyword">self</span> performRequestAWithCompletion:^(<span class="hljs-keyword">id</span> response, <span class="hljs-built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="hljs-comment">// 处理请求A的响应</span></span><br><span class="line">    dispatch_group_leave(group);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 开始请求B</span></span><br><span class="line">dispatch_group_enter(group);</span><br><span class="line">[<span class="hljs-keyword">self</span> performRequestBWithCompletion:^(<span class="hljs-keyword">id</span> response, <span class="hljs-built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="hljs-comment">// 处理请求B的响应</span></span><br><span class="line">    dispatch_group_leave(group);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 当请求A和请求B都完成后，执行请求C</span></span><br><span class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    [<span class="hljs-keyword">self</span> performRequestCWithCompletion:^(<span class="hljs-keyword">id</span> response, <span class="hljs-built_in">NSError</span> *error) &#123;</span><br><span class="line">        <span class="hljs-comment">// 处理请求C的响应</span></span><br><span class="line">    &#125;];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="方法二：使用-NSOperationQueue"><a href="#方法二：使用-NSOperationQueue" class="headerlink" title="方法二：使用 NSOperationQueue"></a>方法二：使用 <code>NSOperationQueue</code></h3><p><code>NSOperationQueue</code> 提供了一种更为面向对象的方法来管理异步任务的依赖关系。</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">NSOperationQueue</span> *queue = [[<span class="hljs-built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">queue.maxConcurrentOperationCount = <span class="hljs-number">2</span>; <span class="hljs-comment">// 设置最大并发数</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">NSBlockOperation</span> *operationA = [<span class="hljs-built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">    [<span class="hljs-keyword">self</span> performRequestAWithCompletion:^(<span class="hljs-keyword">id</span> response, <span class="hljs-built_in">NSError</span> *error) &#123;</span><br><span class="line">        <span class="hljs-comment">// 处理请求A的响应</span></span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">NSBlockOperation</span> *operationB = [<span class="hljs-built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">    [<span class="hljs-keyword">self</span> performRequestBWithCompletion:^(<span class="hljs-keyword">id</span> response, <span class="hljs-built_in">NSError</span> *error) &#123;</span><br><span class="line">        <span class="hljs-comment">// 处理请求B的响应</span></span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">NSBlockOperation</span> *operationC = [<span class="hljs-built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">    [<span class="hljs-keyword">self</span> performRequestCWithCompletion:^(<span class="hljs-keyword">id</span> response, <span class="hljs-built_in">NSError</span> *error) &#123;</span><br><span class="line">        <span class="hljs-comment">// 处理请求C的响应</span></span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 设置依赖关系</span></span><br><span class="line">[operationC addDependency:operationA];</span><br><span class="line">[operationC addDependency:operationB];</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 将操作添加到队列</span></span><br><span class="line">[queue addOperation:operationA];</span><br><span class="line">[queue addOperation:operationB];</span><br><span class="line">[queue addOperation:operationC];</span><br></pre></td></tr></table></figure><h3 id="方法三：使用第三方库-PromiseKit"><a href="#方法三：使用第三方库-PromiseKit" class="headerlink" title="方法三：使用第三方库 PromiseKit"></a>方法三：使用第三方库 PromiseKit</h3><p><code>PromiseKit</code> 提供了一种现代的、链式的方式来处理异步操作。</p><p>首先，确保你已经安装了 <code>PromiseKit</code>。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod &apos;PromiseKit&apos;, &apos;~&gt; 6.0&apos;</span><br></pre></td></tr></table></figure><p>然后，你可以使用类似以下的代码来实现：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;PromiseKit/PromiseKit.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">- (AnyPromise *)performRequestA &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> [AnyPromise promiseWithResolverBlock:^(PMKResolver resolve) &#123;</span><br><span class="line">        [<span class="hljs-keyword">self</span> performRequestAWithCompletion:^(<span class="hljs-keyword">id</span> response, <span class="hljs-built_in">NSError</span> *error) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (error) &#123;</span><br><span class="line">                resolve(error);</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                resolve(response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (AnyPromise *)performRequestB &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> [AnyPromise promiseWithResolverBlock:^(PMKResolver resolve) &#123;</span><br><span class="line">        [<span class="hljs-keyword">self</span> performRequestBWithCompletion:^(<span class="hljs-keyword">id</span> response, <span class="hljs-built_in">NSError</span> *error) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (error) &#123;</span><br><span class="line">                resolve(error);</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                resolve(response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (AnyPromise *)performRequestC &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> [AnyPromise promiseWithResolverBlock:^(PMKResolver resolve) &#123;</span><br><span class="line">        [<span class="hljs-keyword">self</span> performRequestCWithCompletion:^(<span class="hljs-keyword">id</span> response, <span class="hljs-built_in">NSError</span> *error) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (error) &#123;</span><br><span class="line">                resolve(error);</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                resolve(response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="hljs-keyword">void</span>)makeRequests &#123;</span><br><span class="line">    [When(@[[<span class="hljs-keyword">self</span> performRequestA], [<span class="hljs-keyword">self</span> performRequestB]]) then:^<span class="hljs-keyword">id</span>(<span class="hljs-keyword">id</span> results) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> [<span class="hljs-keyword">self</span> performRequestC];</span><br><span class="line">    &#125;].catch(^(<span class="hljs-built_in">NSError</span> *error) &#123;</span><br><span class="line">        <span class="hljs-comment">// 处理错误</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法四：使用-Combine（适用于-iOS-13-及以上）"><a href="#方法四：使用-Combine（适用于-iOS-13-及以上）" class="headerlink" title="方法四：使用 Combine（适用于 iOS 13 及以上）"></a>方法四：使用 Combine（适用于 iOS 13 及以上）</h3><p>如果你在使用 iOS 13 及以上版本，可以使用 Combine 框架来处理异步任务。</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">import Combine</span><br><span class="line"></span><br><span class="line">func performRequestA() -&gt; Future&lt;Data, Error&gt; &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> Future &#123; promise <span class="hljs-keyword">in</span></span><br><span class="line">        <span class="hljs-comment">// 模拟网络请求A</span></span><br><span class="line">        <span class="hljs-keyword">self</span>.performRequestA &#123; (data, error) <span class="hljs-keyword">in</span></span><br><span class="line">            <span class="hljs-keyword">if</span> let error = error &#123;</span><br><span class="line">                promise(.failure(error))</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                promise(.success(data))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func performRequestB() -&gt; Future&lt;Data, Error&gt; &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> Future &#123; promise <span class="hljs-keyword">in</span></span><br><span class="line">        <span class="hljs-comment">// 模拟网络请求B</span></span><br><span class="line">        <span class="hljs-keyword">self</span>.performRequestB &#123; (data, error) <span class="hljs-keyword">in</span></span><br><span class="line">            <span class="hljs-keyword">if</span> let error = error &#123;</span><br><span class="line">                promise(.failure(error))</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                promise(.success(data))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func performRequestC() -&gt; Future&lt;Data, Error&gt; &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> Future &#123; promise <span class="hljs-keyword">in</span></span><br><span class="line">        <span class="hljs-comment">// 模拟网络请求C</span></span><br><span class="line">        <span class="hljs-keyword">self</span>.performRequestC &#123; (data, error) <span class="hljs-keyword">in</span></span><br><span class="line">            <span class="hljs-keyword">if</span> let error = error &#123;</span><br><span class="line">                promise(.failure(error))</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                promise(.success(data))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let cancellable = Publishers.Zip(performRequestA(), performRequestB())</span><br><span class="line">    .flatMap &#123; _ <span class="hljs-keyword">in</span></span><br><span class="line">        <span class="hljs-keyword">return</span> performRequestC()</span><br><span class="line">    &#125;</span><br><span class="line">    .sink(receiveCompletion: &#123; completion <span class="hljs-keyword">in</span></span><br><span class="line">        <span class="hljs-keyword">switch</span> completion &#123;</span><br><span class="line">        <span class="hljs-keyword">case</span> .failure(let error):</span><br><span class="line">            print(<span class="hljs-string">"Error: \(error)"</span>)</span><br><span class="line">        <span class="hljs-keyword">case</span> .finished:</span><br><span class="line">            print(<span class="hljs-string">"All requests finished successfully"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, receiveValue: &#123; data <span class="hljs-keyword">in</span></span><br><span class="line">        print(<span class="hljs-string">"Received data: \(data)"</span>)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>GCD</strong>: 适用于需要轻量级并发管理的场景。</li><li><strong>NSOperationQueue</strong>: 提供了更为面向对象的并发管理方式，适用于复杂任务依赖关系的场景。</li><li><strong>PromiseKit</strong>: 提供了一种现代的链式异步处理方式，代码更为简洁。</li><li><strong>Combine</strong>: 适用于 iOS 13 及以上版本，提供了响应式编程的方式来处理异步任务。</li></ul><p>选择哪种方法取决于你的项目需求和个人偏好。希望这些示例能够帮助你实现网络请求 A 和 B 都回调后再请求 C 的需求。</p><h2 id="8-可变数组-NSMutableArray，在头部插入元素，iOS-系统做了什么优化"><a href="#8-可变数组-NSMutableArray，在头部插入元素，iOS-系统做了什么优化" class="headerlink" title="8.可变数组 NSMutableArray，在头部插入元素，iOS 系统做了什么优化"></a>8.可变数组 NSMutableArray，在头部插入元素，iOS 系统做了什么优化</h2><p>在 iOS 系统中，<code>NSMutableArray</code> 是一个动态数组，它在插入和删除元素时会进行一些优化，但具体的优化细节是由底层实现决定的，这些实现细节通常是私有的，Apple 并未公开详细的内部实现。不过，我们可以推测和总结一些常见的优化策略，这些策略可能会在 <code>NSMutableArray</code> 中使用。</p><h3 id="1-内存预分配和扩展"><a href="#1-内存预分配和扩展" class="headerlink" title="1. 内存预分配和扩展"></a>1. 内存预分配和扩展</h3><p><code>NSMutableArray</code> 会预先分配内存来容纳多个元素，以减少频繁的内存分配操作。当数组需要扩展容量时，它可能会一次性分配比当前需求更多的内存空间，以备将来使用。这种策略可以减少内存分配和释放的频率，提高性能。</p><h3 id="2-元素移动优化"><a href="#2-元素移动优化" class="headerlink" title="2. 元素移动优化"></a>2. 元素移动优化</h3><p>在数组头部插入元素时，所有现有元素都需要向后移动一个位置。为了减少内存拷贝的开销，系统可能会使用高效的内存拷贝函数（如 <code>memmove</code>）来移动元素。<code>memmove</code> 函数在处理重叠内存区域时比 <code>memcpy</code> 更安全和高效。</p><h3 id="3-数据结构优化"><a href="#3-数据结构优化" class="headerlink" title="3. 数据结构优化"></a>3. 数据结构优化</h3><p>尽管 <code>NSMutableArray</code> 主要使用动态数组来实现，但底层可能会结合使用其他数据结构（如链表）来优化特定操作的性能。例如，为了优化头部插入操作，系统可能会在特定情况下使用双向链表或者其他更适合插入操作的结构。</p><h3 id="4-缓存局部性"><a href="#4-缓存局部性" class="headerlink" title="4. 缓存局部性"></a>4. 缓存局部性</h3><p><code>NSMutableArray</code> 可能会利用缓存局部性来提高性能。通过将相邻的元素存储在接近的内存地址上，可以提高缓存命中率，从而提高内存访问速度。</p><h3 id="5-并发处理优化"><a href="#5-并发处理优化" class="headerlink" title="5. 并发处理优化"></a>5. 并发处理优化</h3><p>虽然 <code>NSMutableArray</code> 本身不是线程安全的，但在一些多线程环境中，系统可能会使用锁、原子操作或者其他并发控制机制来优化并发访问的性能。</p><p>总的来说，虽然我们无法确切知道 <code>NSMutableArray</code> 的内部优化细节，但可以推测它会采用一些常见的优化策略来提升性能。了解这些优化策略有助于我们在开发过程中做出更好的性能优化决策。</p><h2 id="9-Tagged-Pointer"><a href="#9-Tagged-Pointer" class="headerlink" title="9.Tagged Pointer"></a>9.Tagged Pointer</h2><h3 id="Tagged-Pointer-的基本原理"><a href="#Tagged-Pointer-的基本原理" class="headerlink" title="Tagged Pointer 的基本原理"></a>Tagged Pointer 的基本原理</h3><p><code>Tagged Pointer</code> 的基本原理是利用指针的高位位元来存储数据，而不是使用这些位元来存储内存地址。具体来说：</p><ul><li>在 64 位系统中，指针有 64 位，其中通常只有低 48 位用于存储内存地址，高 16 位未被使用。</li><li><code>Tagged Pointer</code> 技术利用这些未使用的高位位元来存储数据。</li></ul><h3 id="如何识别-Tagged-Pointer"><a href="#如何识别-Tagged-Pointer" class="headerlink" title="如何识别 Tagged Pointer"></a>如何识别 Tagged Pointer</h3><p>在 Objective-C 中，<code>Tagged Pointer</code> 使用最高位（最高位为 1）来标识是否是 <code>Tagged Pointer</code>。例如：</p><ul><li><code>0x8000000000000000</code>：最高位为 1，表示这是一个 <code>Tagged Pointer</code>。</li><li><code>0x0000000000000000</code>：最高位为 0，表示这是一个普通的指针。</li></ul><h3 id="Tagged-Pointer-的数据存储"><a href="#Tagged-Pointer-的数据存储" class="headerlink" title="Tagged Pointer 的数据存储"></a>Tagged Pointer 的数据存储</h3><p><code>Tagged Pointer</code> 可以存储多种类型的数据，包括：</p><ul><li><strong>小整数</strong>：直接在指针中存储整数值。</li><li><strong>小浮点数</strong>：直接在指针中存储浮点数值。</li><li><strong>小字符串</strong>：直接在指针中存储字符串数据。</li></ul><h2 id="10-NSString-存储在哪里，引用计数存储哪里？"><a href="#10-NSString-存储在哪里，引用计数存储哪里？" class="headerlink" title="10.NSString 存储在哪里，引用计数存储哪里？"></a>10.NSString 存储在哪里，引用计数存储哪里？</h2><h3 id="1-常量字符串"><a href="#1-常量字符串" class="headerlink" title="1. 常量字符串"></a>1. 常量字符串</h3><p>常量字符串是指在代码中直接使用的字符串字面量，例如：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">NSString</span> *str = <span class="hljs-string">@"Hello, World!"</span>;</span><br></pre></td></tr></table></figure><p>这些字符串字面量通常会被存储在程序的只读数据段（Read-Only Data Segment）中。这意味着它们在编译时已经确定，并且在程序运行时不会被修改。它们的内存分配通常是由编译器在编译时完成的。</p><h3 id="2-动态字符串"><a href="#2-动态字符串" class="headerlink" title="2. 动态字符串"></a>2. 动态字符串</h3><p>动态字符串是指在程序运行时生成或拼接的字符串，例如：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">NSString</span> *str1 = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@"Hello, %@"</span>, <span class="hljs-string">@"World"</span>];</span><br><span class="line"><span class="hljs-built_in">NSString</span> *str2 = [str1 mutableCopy];</span><br></pre></td></tr></table></figure><p>这些字符串是在程序运行时动态分配内存的。它们通常存储在堆（Heap）中，并由 <code>NSString</code> 和 <code>NSMutableString</code> 的内部实现来管理。</p><h3 id="3-内存管理"><a href="#3-内存管理" class="headerlink" title="3. 内存管理"></a>3. 内存管理</h3><p>在 Objective-C 中，内存管理主要通过引用计数（Reference Counting）来完成。<code>NSString</code> 对象也遵循这一规则：</p><ul><li><strong>ARC（Automatic Reference Counting）</strong>: 在使用 ARC 的情况下，编译器会自动插入内存管理代码，负责增加和减少引用计数。</li><li><strong>手动内存管理（MRC）</strong>: 在不使用 ARC 的情况下，开发者需要手动管理内存，通过 <code>retain</code>、<code>release</code> 和 <code>autorelease</code> 方法来管理引用计数。</li></ul><h3 id="4-内部实现"><a href="#4-内部实现" class="headerlink" title="4. 内部实现"></a>4. 内部实现</h3><p><code>NSString</code> 是一个抽象类，其具体实现有多个子类，这些子类优化了不同类型的字符串存储和操作。常见的子类包括：</p><ul><li><strong><code>__NSCFConstantString</code></strong>: 用于存储常量字符串。</li><li><strong><code>__NSCFString</code></strong>: 一般用于动态创建的不可变字符串。</li><li><strong><code>NSMutableString</code></strong>: 用于可变字符串。</li></ul><p>在实际运行时，<code>NSString</code> 对象的具体存储位置和方式可能会因为优化而有所不同。例如，短字符串可能会被存储在栈上，以提高性能。</p><h3 id="5-字符串缓存"><a href="#5-字符串缓存" class="headerlink" title="5. 字符串缓存"></a>5. 字符串缓存</h3><p>为了提高性能，<code>NSString</code> 类可能会使用一些内部缓存机制。例如，常量字符串可能会被缓存，以避免重复分配内存。这种优化在底层是由 <code>Core Foundation</code> 框架实现的。</p><h3 id="6-Foundation-框架与-Core-Foundation"><a href="#6-Foundation-框架与-Core-Foundation" class="headerlink" title="6. Foundation 框架与 Core Foundation"></a>6. Foundation 框架与 Core Foundation</h3><p><code>NSString</code> 是 Foundation 框架的一部分，但其底层实现依赖于 Core Foundation 中的 <code>CFString</code>。<code>CFString</code> 提供了字符串操作的底层实现，而 <code>NSString</code> 则是在其基础上提供了面向对象的接口。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>常量字符串</strong>: 存储在程序的只读数据段中。</li><li><strong>动态字符串</strong>: 在程序运行时存储在堆中。</li><li><strong>内存管理</strong>: 通过引用计数管理，无论是 ARC 还是 MRC。</li><li><strong>内部实现</strong>: 由多个子类优化不同类型的字符串，底层依赖于 Core Foundation 的 <code>CFString</code>。</li></ul><h2 id="11-dealloc-流程"><a href="#11-dealloc-流程" class="headerlink" title="11.dealloc 流程"></a>11.dealloc 流程</h2><h2 id="12-避免哈希碰撞的几种方法？"><a href="#12-避免哈希碰撞的几种方法？" class="headerlink" title="12.避免哈希碰撞的几种方法？"></a>12.避免哈希碰撞的几种方法？</h2><h3 id="1-更好的哈希函数"><a href="#1-更好的哈希函数" class="headerlink" title="1. 更好的哈希函数"></a>1. 更好的哈希函数</h3><p>选择一个更好的哈希函数可以极大地减少哈希碰撞的可能性。一个好的哈希函数应具有以下特性：</p><ul><li><strong>均匀性</strong>：能够将输入数据均匀地分布到哈希表的各个位置。</li><li><strong>确定性</strong>：相同的输入总是产生相同的哈希值。</li><li><strong>高效性</strong>：计算哈希值的时间复杂度应尽可能低。</li></ul><p>常见的哈希函数包括：</p><ul><li><strong>MD5</strong></li><li><strong>SHA-1</strong></li><li><strong>SHA-256</strong></li></ul><p>在某些特定场景下，自定义的哈希函数也可能是一个有效的选择。</p><h3 id="2-增大哈希表的大小"><a href="#2-增大哈希表的大小" class="headerlink" title="2. 增大哈希表的大小"></a>2. 增大哈希表的大小</h3><p>通过增大哈希表的大小，可以减少哈希碰撞的概率。哈希表的大小通常是一个素数，这样可以更均匀地分布哈希值。</p><h3 id="3-链地址法（Separate-Chaining）"><a href="#3-链地址法（Separate-Chaining）" class="headerlink" title="3. 链地址法（Separate Chaining）"></a>3. 链地址法（Separate Chaining）</h3><p>链地址法是处理哈希碰撞的一种常见方法。每个哈希表的槽（bucket）都包含一个链表（或其他数据结构），用于存储具有相同哈希值的多个元素。</p><h3 id="4-开放定址法（Open-Addressing）"><a href="#4-开放定址法（Open-Addressing）" class="headerlink" title="4. 开放定址法（Open Addressing）"></a>4. 开放定址法（Open Addressing）</h3><p>开放定址法通过在发生碰撞时寻找下一个空闲槽来存储元素。常见的开放定址法包括线性探测、二次探测和双重散列。</p><h4 id="线性探测"><a href="#线性探测" class="headerlink" title="线性探测"></a>线性探测</h4><p>线性探测在发生碰撞时，按固定步长（通常为 1）依次探测下一个槽，直到找到空闲槽为止。</p><h4 id="二次探测"><a href="#二次探测" class="headerlink" title="二次探测"></a>二次探测</h4><p>二次探测在发生碰撞时，按二次方序列探测下一个槽。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index = (index + i^2) % self.size</span><br></pre></td></tr></table></figure><h4 id="双重散列"><a href="#双重散列" class="headerlink" title="双重散列"></a>双重散列</h4><p>双重散列使用两个不同的哈希函数来计算探测序列。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index = (hash1(key) + i * hash2(key)) % self.size</span><br></pre></td></tr></table></figure><h3 id="5-再哈希法（Rehashing）"><a href="#5-再哈希法（Rehashing）" class="headerlink" title="5. 再哈希法（Rehashing）"></a>5. 再哈希法（Rehashing）</h3><p>再哈希法在发生碰撞时，使用另一个哈希函数重新计算哈希值，直到找到空闲槽为止。</p><h3 id="6-动态调整哈希表大小"><a href="#6-动态调整哈希表大小" class="headerlink" title="6. 动态调整哈希表大小"></a>6. 动态调整哈希表大小</h3><p>在哈希表负载因子（Load Factor）达到一定阈值时，动态调整哈希表的大小。负载因子是已存储元素数量与哈希表大小的比值。当负载因子过高时，增大哈希表的大小并重新哈希所有元素。</p><h2 id="13-mach-o-了解吗？存储的方法信息可以无用代码检测？段迁移？"><a href="#13-mach-o-了解吗？存储的方法信息可以无用代码检测？段迁移？" class="headerlink" title="13.mach-o 了解吗？存储的方法信息可以无用代码检测？段迁移？"></a>13.mach-o 了解吗？存储的方法信息可以无用代码检测？段迁移？</h2><p>Mach-O（Mach Object 文件格式）是 macOS 和 iOS 操作系统上使用的一种文件格式，用于可执行文件、目标代码、动态库、内核转储等。Mach-O 格式提供了一种灵活且强大的方式来描述程序的结构，支持多种架构（如 x86_64、arm64）和多种类型的文件（如可执行文件、动态库）。以下是关于 Mach-O 文件格式的详细介绍：</p><h3 id="Mach-O-文件的基本结构"><a href="#Mach-O-文件的基本结构" class="headerlink" title="Mach-O 文件的基本结构"></a>Mach-O 文件的基本结构</h3><p>Mach-O 文件由多个部分组成，每个部分都有特定的用途和结构。主要部分包括：</p><ol><li><strong>Header（头部）</strong>：包含文件的基本信息，如文件类型、CPU 架构、加载命令数量等。</li><li><strong>Load Commands（加载命令）</strong>：描述文件的各个部分如何加载到内存中。这些命令包括段的描述、动态库的引用、符号表的位置等。</li><li><strong>Segments（段）</strong>：包含实际的代码和数据。每个段包含多个 section（节），每个节存储特定类型的数据，如代码节、数据节、符号表等。</li><li><strong>Sections（节）</strong>：段的子部分，存储不同类型的数据，如可执行代码、只读数据、可写数据等。</li></ol><h3 id="详细结构"><a href="#详细结构" class="headerlink" title="详细结构"></a>详细结构</h3><h4 id="1-Header（头部）"><a href="#1-Header（头部）" class="headerlink" title="1. Header（头部）"></a>1. Header（头部）</h4><p>头部是 Mach-O 文件的开始部分，包含文件的基本信息。头部的结构定义如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct mach_header &#123;</span><br><span class="line">    uint32_t magic;          // 魔数，标识文件格式</span><br><span class="line">    cpu_type_t cputype;      // CPU 类型</span><br><span class="line">    cpu_subtype_t cpusubtype;// CPU 子类型</span><br><span class="line">    uint32_t filetype;       // 文件类型（如可执行文件、动态库）</span><br><span class="line">    uint32_t ncmds;          // 加载命令的数量</span><br><span class="line">    uint32_t sizeofcmds;     // 所有加载命令的总大小</span><br><span class="line">    uint32_t flags;          // 标志位</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-Load-Commands（加载命令）"><a href="#2-Load-Commands（加载命令）" class="headerlink" title="2. Load Commands（加载命令）"></a>2. Load Commands（加载命令）</h4><p>加载命令描述文件的各个部分如何加载到内存中。常见的加载命令包括：</p><ul><li><strong>LC_SEGMENT</strong>：描述一个段。</li><li><strong>LC_SYMTAB</strong>：描述符号表的位置。</li><li><strong>LC_DYSYMTAB</strong>：描述动态符号表的位置。</li><li><strong>LC_LOAD_DYLIB</strong>：描述需要加载的动态库。</li></ul><p>每个加载命令的基本结构如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct load_command &#123;</span><br><span class="line">    uint32_t cmd;      // 加载命令的类型</span><br><span class="line">    uint32_t cmdsize;  // 加载命令的大小</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3-Segments（段）"><a href="#3-Segments（段）" class="headerlink" title="3. Segments（段）"></a>3. Segments（段）</h4><p>段是 Mach-O 文件中的主要数据部分，每个段包含多个节。常见的段包括：</p><ul><li><strong>__TEXT</strong>：包含可执行代码和只读数据。</li><li><strong>__DATA</strong>：包含可写数据。</li><li><strong>__LINKEDIT</strong>：包含符号表和其他链接信息。</li></ul><p>段的基本结构如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct segment_command &#123;</span><br><span class="line">    uint32_t cmd;            // LC_SEGMENT</span><br><span class="line">    uint32_t cmdsize;        // 加载命令的大小</span><br><span class="line">    char segname[16];        // 段的名称</span><br><span class="line">    uint32_t vmaddr;         // 段在虚拟内存中的地址</span><br><span class="line">    uint32_t vmsize;         // 段的大小</span><br><span class="line">    uint32_t fileoff;        // 段在文件中的偏移</span><br><span class="line">    uint32_t filesize;       // 段在文件中的大小</span><br><span class="line">    vm_prot_t maxprot;       // 段的最大保护</span><br><span class="line">    vm_prot_t initprot;      // 段的初始保护</span><br><span class="line">    uint32_t nsects;         // 段中节的数量</span><br><span class="line">    uint32_t flags;          // 段的标志</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="4-Sections（节）"><a href="#4-Sections（节）" class="headerlink" title="4. Sections（节）"></a>4. Sections（节）</h4><p>节是段的子部分，存储具体类型的数据。每个节的基本结构如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct section &#123;</span><br><span class="line">    char sectname[16];       // 节的名称</span><br><span class="line">    char segname[16];        // 段的名称</span><br><span class="line">    uint32_t addr;           // 节在虚拟内存中的地址</span><br><span class="line">    uint32_t size;           // 节的大小</span><br><span class="line">    uint32_t offset;         // 节在文件中的偏移</span><br><span class="line">    uint32_t align;          // 节的对齐</span><br><span class="line">    uint32_t reloff;         // 重定位表的偏移</span><br><span class="line">    uint32_t nreloc;         // 重定位表的数量</span><br><span class="line">    uint32_t flags;          // 节的标志</span><br><span class="line">    uint32_t reserved1;      // 保留字段</span><br><span class="line">    uint32_t reserved2;      // 保留字段</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Mach-O-文件类型"><a href="#Mach-O-文件类型" class="headerlink" title="Mach-O 文件类型"></a>Mach-O 文件类型</h3><p>Mach-O 文件有多种类型，主要包括：</p><ul><li><strong>MH_EXECUTE</strong>：可执行文件。</li><li><strong>MH_DYLIB</strong>：动态库。</li><li><strong>MH_BUNDLE</strong>：可加载的代码包。</li><li><strong>MH_OBJECT</strong>：目标文件。</li><li><strong>MH_DYLINKER</strong>：动态链接器。</li></ul><h3 id="使用工具查看-Mach-O-文件"><a href="#使用工具查看-Mach-O-文件" class="headerlink" title="使用工具查看 Mach-O 文件"></a>使用工具查看 Mach-O 文件</h3><p>macOS 提供了一些工具来查看和分析 Mach-O 文件：</p><ul><li><p>otool</p><p>：用于显示 Mach-O 文件的头部、段、节、符号表等信息。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">otool -hV MyApp.app/MyApp  # 显示头部信息</span><br><span class="line">otool -L MyApp.app/MyApp   # 显示动态库依赖</span><br><span class="line">otool -tV MyApp.app/MyApp  # 显示反汇编代码</span><br></pre></td></tr></table></figure></li><li><p>nm</p><p>：用于显示 Mach-O 文件中的符号表。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nm MyApp.app/MyApp</span><br></pre></td></tr></table></figure></li><li><p>dyldinfo</p><p>：用于显示动态链接相关信息。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dyldinfo -all MyApp.app/MyApp</span><br></pre></td></tr></table></figure></li></ul><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>Mach-O 是 macOS 和 iOS 上使用的一种复杂而灵活的文件格式，用于描述可执行文件、动态库等。它通过头部、加载命令、段和节组织数据，支持多种文件类型和 CPU 架构。理解 Mach-O 文件格式有助于进行底层调试、性能优化和安全分析。macOS 提供了一些工具，如 <code>otool</code> 和 <code>nm</code>，可以用来查看和分析 Mach-O 文件的结构和内容。</p><h2 id="14-脚本检测未使用代码原理"><a href="#14-脚本检测未使用代码原理" class="headerlink" title="14.脚本检测未使用代码原理"></a>14.脚本检测未使用代码原理</h2><h2 id="15-Render-渲染流程"><a href="#15-Render-渲染流程" class="headerlink" title="15.Render 渲染流程"></a>15.Render 渲染流程</h2><p>iOS 渲染流程是一个复杂且高效的过程，它负责将应用的界面呈现到屏幕上。理解这个流程有助于优化应用的性能和用户体验。以下是 iOS 渲染流程的概要：</p><h3 id="1-应用层（Application-Layer）"><a href="#1-应用层（Application-Layer）" class="headerlink" title="1. 应用层（Application Layer）"></a>1. 应用层（Application Layer）</h3><p>应用层是 iOS 应用的最上层，包括应用的逻辑、UI 视图控制器（UIViewController）、视图（UIView）等。开发者主要在这一层进行开发。</p><h3 id="2-Core-Animation"><a href="#2-Core-Animation" class="headerlink" title="2. Core Animation"></a>2. Core Animation</h3><p>Core Animation 是 iOS 渲染的核心技术，它负责管理和执行所有的动画和视图层次结构（Layer Tree）。Core Animation 使用双缓冲技术来确保动画的流畅性。主要包括以下几个组成部分：</p><ul><li><strong>Layer Tree</strong>: 由 <code>CALayer</code> 对象组成的层次结构，每个 <code>UIView</code> 对应一个 <code>CALayer</code>。</li><li><strong>Display Tree</strong>: 由 Core Animation 生成的用于实际显示内容的树。</li><li><strong>Render Tree</strong>: 用于渲染的最终树，由 Core Animation 发送给渲染服务器（Render Server）。</li></ul><h3 id="3-渲染服务器（Render-Server）"><a href="#3-渲染服务器（Render-Server）" class="headerlink" title="3. 渲染服务器（Render Server）"></a>3. 渲染服务器（Render Server）</h3><p>渲染服务器是一个独立的进程，负责接收来自 Core Animation 的 Render Tree，并将其转换为 GPU 可以理解的指令。渲染服务器会将这些指令发送给 GPU 进行实际的渲染。</p><h3 id="4-GPU-渲染"><a href="#4-GPU-渲染" class="headerlink" title="4. GPU 渲染"></a>4. GPU 渲染</h3><p>GPU（图形处理单元）接收到渲染指令后，会执行以下操作：</p><ol><li><strong>顶点着色（Vertex Shading）</strong>: 处理顶点数据，包括位置、颜色、纹理等信息。</li><li><strong>图元组装（Primitive Assembly）</strong>: 将顶点连接成图元（如三角形）。</li><li><strong>光栅化（Rasterization）</strong>: 将图元转换为片元（Pixel）。</li><li><strong>片元着色（Fragment Shading）</strong>: 计算每个片元的颜色和其他属性。</li><li><strong>帧缓存操作（Frame Buffer Operations）</strong>: 将最终的片元数据写入帧缓存（Frame Buffer）。</li></ol><h3 id="5-显示层（Display-Layer）"><a href="#5-显示层（Display-Layer）" class="headerlink" title="5. 显示层（Display Layer）"></a>5. 显示层（Display Layer）</h3><p>最终的帧缓存数据会被传递到显示层，由显示层将其显示在屏幕上。iOS 使用 VSync（垂直同步）信号来协调显示更新，以确保屏幕刷新和渲染同步，避免画面撕裂。</p><h3 id="渲染流程的详细步骤"><a href="#渲染流程的详细步骤" class="headerlink" title="渲染流程的详细步骤"></a>渲染流程的详细步骤</h3><ol><li><strong>视图更新（View Update）</strong>:<ul><li>应用程序修改视图或图层属性（如位置、大小、颜色等）。</li><li><code>UIView</code> 的属性变化会触发 <code>CALayer</code> 的相应变化。</li></ul></li><li><strong>布局和显示（Layout and Display）</strong>:<ul><li><code>UIView</code> 布局系统会重新计算视图的布局。</li><li><code>CALayer</code> 会根据视图的变化更新自己的属性。</li></ul></li><li><strong>Core Animation 动画处理（Core Animation Animation Handling）</strong>:<ul><li>Core Animation 会将动画应用到相关的 <code>CALayer</code> 上。</li><li>根据动画时间轴生成 Display Tree。</li></ul></li><li><strong>Render Tree 生成（Render Tree Generation）</strong>:<ul><li>Core Animation 从 Display Tree 生成 Render Tree。</li><li>Render Tree 包含了所有需要渲染的信息。</li></ul></li><li><strong>Render Server 渲染（Render Server Rendering）</strong>:<ul><li>Core Animation 将 Render Tree 发送给渲染服务器。</li><li>渲染服务器将 Render Tree 转换为 GPU 指令。</li></ul></li><li><strong>GPU 渲染（GPU Rendering）</strong>:<ul><li>GPU 执行顶点着色、图元组装、光栅化、片元着色和帧缓存操作。</li><li>渲染结果存储在帧缓存中。</li></ul></li><li><strong>显示更新（Display Update）</strong>:<ul><li>帧缓存内容通过显示层显示在屏幕上。</li><li>VSync 信号确保显示更新和屏幕刷新同步。</li></ul></li></ol><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p>理解 iOS 渲染流程有助于优化应用性能，以下是一些常见的优化策略：</p><ol><li><strong>减少布局计算和视图层次结构的复杂度</strong>。</li><li><strong>使用合适的图层类型（如 <code>CAShapeLayer</code>、<code>CATextLayer</code>）</strong>。</li><li><strong>避免频繁的视图更新和动画</strong>。</li><li><strong>使用异步绘制技术（如 <code>drawRect:</code> 方法）</strong>。</li><li><strong>避免不必要的离屏渲染（Offscreen Rendering）</strong>。</li></ol><p>通过这些优化策略，可以减少 CPU 和 GPU 的负担，提高应用的流畅性和响应速度。</p><h2 id="16-UIView-动画和-CAAnimation-动画有什么联系？"><a href="#16-UIView-动画和-CAAnimation-动画有什么联系？" class="headerlink" title="16.UIView 动画和 CAAnimation 动画有什么联系？"></a>16.UIView 动画和 CAAnimation 动画有什么联系？</h2><p>虽然 <code>UIView</code> 动画和 <code>CAAnimation</code> 动画在使用上有区别，但它们的底层机制是有联系的。<code>UIView</code> 动画实际上是对 <code>CAAnimation</code> 的封装和简化。当你使用 <code>UIView</code> 动画时，UIKit 会在内部创建相应的 <code>CAAnimation</code> 对象，并将其添加到视图的 <code>CALayer</code> 上。</p><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">UIView</span>.animate(withDuration: <span class="hljs-number">1.0</span>, animations: &#123;</span><br><span class="line">    myView.alpha = <span class="hljs-number">0.0</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面的代码等价于：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let animation = <span class="hljs-built_in">CABasicAnimation</span>(keyPath: <span class="hljs-string">"opacity"</span>)</span><br><span class="line">animation.fromValue = <span class="hljs-number">1.0</span></span><br><span class="line">animation.toValue = <span class="hljs-number">0.0</span></span><br><span class="line">animation.duration = <span class="hljs-number">1.0</span></span><br><span class="line">myView.layer.add(animation, forKey: <span class="hljs-string">"opacityAnimation"</span>)</span><br><span class="line">myView.layer.opacity = <span class="hljs-number">0.0</span></span><br></pre></td></tr></table></figure><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p><code>UIView</code> 动画是对 <code>CAAnimation</code> 的封装，提供了更高层次的接口，使得简单动画的实现更加便捷，而 <code>CAAnimation</code> 提供了更强大的功能和更精细的控制，适合复杂的动画需求。在实际开发中，可以根据具体的动画需求选择合适的动画方式。</p><h2 id="17-项目亮点"><a href="#17-项目亮点" class="headerlink" title="17.项目亮点"></a>17.项目亮点</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;百融云创面试题&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="百融云创" scheme="http://soso.wiki/tags/%E7%99%BE%E8%9E%8D%E4%BA%91%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title>OC语法</title>
    <link href="http://soso.wiki/OC%E8%AF%AD%E6%B3%95/"/>
    <id>http://soso.wiki/OC语法/</id>
    <published>2024-05-08T06:21:00.000Z</published>
    <updated>2024-05-08T06:24:06.674Z</updated>
    
    <content type="html"><![CDATA[<p>OC语法<br><a id="more"></a></p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>一个NSObject对象占用多少内存<br>系统分配了16个字节给NSObject对象（malloc_size）<br>但NSObject对象内部只使用了8个字节的空间（class_getInstanceSize）</p><p>对象的isa指针指向哪里<br>instance对象isa指向class对象<br>调用对象方法时，通过isa指针找到类对象，找到对象方法实现进行调用<br>class对象isa指向meta-class对象<br>调用类方法时，通过isa指针找到元类对象，找到类方法的视线进行调用<br>meta-class对象isa指向基类的meta-class对象</p><p>OC的类信息存放在哪里<br>对象方法、属性、成员变量、协议信息，存放在class对象<br>类方法存放在meta-class对象<br>成员变量的具体值，存放在instance对象</p><h2 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h2><p>iOS用什么方式实现一个对象的KVO（KVO的本质是什么）<br>利用runtime动态生成一个子类，并且让instance对象的isa指向该子类<br>当修改instance对象的属性时，会调用Foundation的<code>_NSSetXXXValueAndNotify</code>函数<br>willChangeValueForKey:<br>父类原来的set方法<br>didChangeValueForKey:<br>内部会触发Observer的监听方法（observeValueForKeyPath:ofObject:change:context）</p><p>如何手动触发KVO<br>手动调用willSetValueForKey:和didChangeValueForKey:</p><p>直接修改成员变量的值会触发KVO吗<br>不会</p><p>通过KVC修改属性会触发KVO吗<br>会</p><p>KVC的赋值和取值过程？<br>赋值  先调用setA  isA _age</p><h2 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h2><p>Category的实现原理<br>Category编译后的底层结构是struct category_t 里面存放分类的对象方法、类方法、属性、协议信息<br>在程序运行时，runtime会将Category的数据，合并到类信息中（类对象、元类对象中）</p><p>Category和Class Extension的区别是什么<br>Class Extension在编译时数据就在类信息中<br>Category是在运行时，将数据合并到类信息中</p><p>Categroy中有load方法吗？load方法是什么时候调用的？load方法能继承吗？<br>有load方法<br>load是在程序启动的时候，加载类、分类的时候调用<br>load方法可以继承，但一般不会主动去调用load方法，都是让系统自动调用</p><p>load、initialize方法的区别？在Category中的调用顺序，出现继承时他们之间的调用过程？</p><p>Category能否添加成员变量？如果可以，如何给Category添加成员变量？<br>不能直接给Category添加成员变量，但可以通过runtime实现Category有成员变量的效果</p><h2 id="Objective-C的本质"><a href="#Objective-C的本质" class="headerlink" title="Objective-C的本质"></a>Objective-C的本质</h2><p>OC的本质<br>底层都是C/C++代码，编译成了汇编语言、机器语言<br>OC的面向对象是通过C/C++的结构体实现的</p><p>将OC代码转换成C/C++代码<br>xcrun  -sdk  iphoneos  clang  -arch  arm64  -rewrite-objc  OC源文件  -o  输出的CPP文件</p><p>一个OC对象在内存中的布局<br>struct NSObject_IMPL {<br>    Class isa;<br>}</p><p>Class 即 objc_class<br>class、meta-class对象的本质结构都是struct objc_class</p><p>创建一个实例对象，至少需要多少内存<br>class_getInstanceSize([NSObject class]);</p><p>创建一个实例对象，实际上分配了多少内存<br>malloc_size(obj);</p><h2 id="常见LLDB指令"><a href="#常见LLDB指令" class="headerlink" title="常见LLDB指令"></a>常见LLDB指令</h2><p>p 打印<br>po 打印对象</p><p>读取内存<br>memory read/数据格式字节数  内存地址<br>x/数量格式字节数 内存地址</p><p>修改内存中的值<br>memory write</p><p>OC对象的分类<br>instance对象（实例对象）、class对象（类对象）、meta-class对象（元类对象）</p><p>class对象在内存中存储的信息主要包括<br>isa指针<br>superclass指针<br>属性、对象方法、协议、成员变量</p><p>meta-class对象在内存中存储的信息<br>isa指针<br>superclass指针<br>类方法</p><p>object_getClass([NSObject class]); 获取元类对象<br>class_isMetaClass([NSObject class]); 查看Class是否是元类对象</p><p>instance的isa指向class<br>class的isa指向meta-class<br>meta-class的isa指向基类的meta-class</p><p>class的superclass指向父类的class<br>如果没有父类，superclass指针为nil</p><p>meta-class的superclass指向父类的meta-class<br>基类的meta-class的superclass指向基类的class</p><p>isa指针<br>isa通过&amp; ISA_MASK （位运算），得到真实地址<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class &#123;</span><br><span class="line">Class isa;</span><br><span class="line">Class superClass;</span><br><span class="line">cache_t cache; // 方法缓存</span><br><span class="line">class_data_bits_t bits; // 用于获取具体的类信息</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bits &amp; FAST_DATA_MASK得到class_rw_t</span><br><span class="line">class_rw_t &#123;</span><br><span class="line">uint32_t flags;</span><br><span class="line">uint32_t version;</span><br><span class="line">const class_ro_t *ro;</span><br><span class="line">method_list_t *methods; // 方法列表</span><br><span class="line">property_list_t *properties; // 属性列表</span><br><span class="line">const protocol_list_t *protocols; // 协议列表</span><br><span class="line">Class firstSubClass;</span><br><span class="line">Class nextSiblingClass;</span><br><span class="line">char *demangledName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class_ro_t &#123;</span><br><span class="line">uint32_t flags;</span><br><span class="line">uint32_t instanceStart;</span><br><span class="line">uint32_t instanceSize;</span><br><span class="line">const char *name; // 类名</span><br><span class="line">method_list_t *baseMethodList;</span><br><span class="line">protocol_list_t *baseProtocols;</span><br><span class="line">const ivar_list_t *ivars; // 成员变量列表</span><br><span class="line">const uint8_t *weakIvarLayout;</span><br><span class="line">property_list_t *baseProperties;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>KVC<br>setValue:forKey:原理<br>按照<code>setKey: _setKey:</code>顺序查找方法，找到方法调用<br>没找到方法，查看accessInstanceVariablesDirectly方法的返回值<br>NO-&gt;调用setValue:forUndefinedKey: 并抛出异常NSUnknownKeyException<br>YES-&gt;按照<code>_key _isKey key isKey</code>顺序查找成员变量，找到后直接赋值，找不到报错</p><p>valueForKey:原理<br>按照<code>getKey、key、isKey、_key</code>顺序查找方法，找到方法调用<br>没找到方法，查看accessInstanceVariablesDirectly方法的返回值<br>NO-&gt;调用valueForUndefinedKey: 并抛出异常NSUnknownKeyException<br>YES-&gt;按照<code>_key、_isKey、key、isKey</code>顺序查找成员变量，找到后直接取值</p><p>Caregory的底层结构<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct category_t &#123;</span><br><span class="line">const char *name;</span><br><span class="line">classref cls;</span><br><span class="line">struct method_list_t *instanceMethods;</span><br><span class="line">struct method_list_t *classMethods;</span><br><span class="line">struct protocol_list_t *protocols;</span><br><span class="line">struct property_list_t *instanceProperties;</span><br><span class="line">struct property_list_t *_classProperties;</span><br><span class="line"></span><br><span class="line">method_list_t *methodForMeta(bool isMeta) &#123;</span><br><span class="line">if (isMeta) return classMethods;</span><br><span class="line">else return instanceMethods;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">property_list_t *propertiesForMeta(bool isMeta, struct header_info *hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Category的加载处理过程<br>1.通过Runtime加载某个类的所有Category数据<br>2.把所有Category的方法、属性、协议数据，合并到一个大数组里，后面参与编译的Category数据，会在数组的前面<br>3.将合并后的分类数据（方法、属性、协议），插入到类原来数据的前面</p><p>+load方法<br>+load方法会在runtime加载类、分类时调用<br>每个类、分类的+load方法，在程序运行过程中只调用一次</p><p>调用顺序：<br>1.先调用类的+load，按照编译先后顺序调用（先编译，先调用），调用子类的+load之前会先调用父类的+load<br>2.再调用分类的+load，按照编译先后顺序调用（先编译，先调用）<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1._objc_Init</span><br><span class="line">2.load_images</span><br><span class="line">3.prepare_load_methods</span><br><span class="line">schedule_class_load</span><br><span class="line">add_class_to_loadable_list</span><br><span class="line">add_category_to_loadable_list</span><br><span class="line">4.call_load_methods</span><br><span class="line">call_class_loads</span><br><span class="line">call_category_loads</span><br><span class="line">(*load_method)(cls, SEL_load)</span><br></pre></td></tr></table></figure></p><p>+load方法时根据方法地址直接调用，并不是经过objc_msgSend函数调用</p><p>+initialize方法<br>+initialize方法会在类第一次接收到消息时调用</p><p>调用顺序<br>先调用父类的+initialize，再调用子类的+initialize<br>先初始化父类，在初始化子类，每个类只会初始化一次<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend</span><br><span class="line">class_getInstanceMethod</span><br><span class="line">lookUpImpOrNil</span><br><span class="line">lookUpImpOrForword</span><br><span class="line">_class_initialize</span><br><span class="line">callInitialize</span><br><span class="line">objc_msgSend(cls, SEL_initialize)</span><br></pre></td></tr></table></figure></p><p>+initialize和+load区别<br>+initialize是通过objc_msgSend进行调用<br>如果子类没有实现+initialize，会调用父类的+initialize（所以父类的+initialize可能会被调用多次）<br>如果分类实现了+initialize，就会覆盖类本身的+initialize调用</p><p>如何给分类添加成员变量？<br>因为分类的底层结构限制，不能添加成员变量到分类，可以通过关联对象间接实现</p><p>添加关联对象<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void objc_setAssociatedObject(id object, const void * key,</span><br><span class="line">                                id value, objc_AssociationPolicy policy)</span><br></pre></td></tr></table></figure></p><p>获得关联对象<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id objc_getAssociatedObject(id object, const void * key)</span><br></pre></td></tr></table></figure></p><p>移除所有的关联对象<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void objc_removeAssociatedObjects(id object)</span><br></pre></td></tr></table></figure></p><p>关联对象的原理<br>关联对象并不是存储在关联对象本身内存中<br>关联对象存储在全局统一的一个AssociationsManager中<br>设置关联对象为nil，就相当于移除关联对象</p><p>block的本质<br>block本质上是一个OC对象，内部有个isa指针<br>block是封装了函数调用以及函数调用环境的OC对象</p><p>block的变量捕获<br>局部变量 auto 捕获到block内部  访问方式：值传递<br>局部变量 static 捕获到block内部 访问方式：指针传递<br>全局变量 不捕获 访问方式：直接访问</p><p>auto变量的捕获</p><p>block的类型<br>block有3种类型，可以通过调用class方法或者isa指针查看具体类型，最终都是继承自NSBlock类型<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__NSGlobalBlock__ (_NSConcreteGlobalBlock)  数据区域 .data区</span><br><span class="line">__NSStackBlock__ (_NSConcreteStackBlock)  栈区</span><br><span class="line">__NSMallocBlock__ (_NSConcreteMallocBlock) 堆区</span><br></pre></td></tr></table></figure></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__NSGlobalBlock__  没有访问auto变量</span><br><span class="line">__NSStackBlock__ 访问了auto变量</span><br><span class="line">__NSMallocBlock__  __NSStackBlock__调用了copy</span><br></pre></td></tr></table></figure><p>调用copy后的结果<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_NSConcreteStackBlock  程序的数据区域 复制效果：什么也不做</span><br><span class="line">_NSConcreteStackBlock  栈  复制效果：从栈复制到堆</span><br><span class="line">_NSConcreteMallocBlock 堆  复制效果：引用计数增加</span><br></pre></td></tr></table></figure></p><p>block的copy<br>在ARC下，编辑器会在下列情况自动将栈上的block拷贝到堆上：<br>1.block作为函数返回值时<br>2.将block赋值给强指针时<br>3.block作为Cocoa API中方法名含有usingBlock的方法参数时<br>4.block作为GCD API的方法参数时</p><p>MRC下block的建议写法：<br>@property(copy, nonatomic) void (^block)(void);</p><p>ARC下block的建议写法：<br>@property(strong, nonatomic) void (^block)(void);<br>@property(copy, nonatomic) void (^block)(void);</p><p>对象类型的auto变量<br>当block内部访问了对象类型的auto变量时<br>如果block在栈上，将不会对auto变量产生强引用</p><p>如果block被拷贝到堆上<br>会调用block内部的copy函数<br>copy函数内部会调用<code>_Block_object_assign</code>函数<br><code>_Block_object_assign</code>函数会根据auto变量的修饰符做出相应操作，形成强引用或弱引用</p><p>如果block从堆上移除<br>会调用block内部的dispose函数<br>dispose函数内部会调用<code>_Block_object_dispose</code>函数<br><code>_Block_object_dispose</code>函数会自动释放引用的auto变量（release）</p><p><code>__block</code>修饰符<br>可以解决block内部无法修改auto变量值的问题<br>不能修饰全局变量、静态变量<br>编译器会把<code>__block</code>包装成一个对象</p><p>当block在栈上时，并不会对<code>__block</code>变量产生强引用</p><p>当block被copy到堆时<br>会调用block内部的copy函数<br>copy函数内部会调用<code>_Block_object_assign</code>函数<br><code>_Block_object_assign</code>函数会对<code>__block</code>变量形成强引用（retain）</p><p>当block从堆中移除时<br>会调用block内部的dispose函数<br>dispose函数内部会调用<code>_Block_object_dispose</code>函数<br><code>_Block_object_dispose</code>函数会自动释放引用的<code>__block</code>变量（release）</p><p><code>__block</code>的<code>__forwarding</code>指针</p><p>对象类型的auto变量、__block变量<br>当block在栈上时，对它们都不会产生强引用</p><p>解决循环引用问题 - ARC<br>用<code>__weak</code>、<code>__unsafe_unretained</code>解决<br>用<code>__block</code>解决（必须要调用block）</p><p>解决循环引用问题 - MRC<br>用<code>__unsafe_unretained</code>解决<br>用<code>__block</code>解决(ARC时会retain，MRC时不会retain)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;OC语法&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="底层原理" scheme="http://soso.wiki/categories/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="底层原理" scheme="http://soso.wiki/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
      <category term="OC语法" scheme="http://soso.wiki/tags/OC%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>自如面试题</title>
    <link href="http://soso.wiki/%E8%87%AA%E5%A6%82%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://soso.wiki/自如面试题/</id>
    <published>2023-04-04T11:43:14.000Z</published>
    <updated>2024-04-29T11:40:04.920Z</updated>
    
    <content type="html"><![CDATA[<p>自如面试题<br><a id="more"></a></p><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><p>1.你觉得自己有什么优势？</p><p>2.线程和进程的区别？</p><p>3.线程间是怎么通信的？CPU是怎么处理线程的</p><p>4.同步串行队列会不会开线程？异步串行队列会不会开线程？</p><p>5.GCD项目里有哪些地方用了</p><p>6.怎么保证网络传输的安全？MD5的加密规则，MD5可以破解吗？AES/RSA，RSA有长度限制吗？</p><p>7.什么是死锁</p><p>8.做过哪些优化，什么是离屏渲染？</p><p>9.网络有没有优化过</p><p>10.发一个网络请求经过了哪些步骤？有没有统计发起网络请求和接收网络请求的时长</p><p>11.三次握手和四次挥手</p><p>12.冷启动和热启动怎么区分？冷启动是指关机后首次打开App，热启动是指打开过App杀死后再打开。</p><p>13.什么是平衡二叉树？</p><p>14.合并多个有序链表</p><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><p>1.介绍印象深刻的项目，遇到的问题，怎么解决的</p><p>2.webView 白屏除了证书问题还有什么情况可能会导致。</p><p>3.说一下对 Flutter 的了解。</p><p>4.多个 widget 之间怎么相互传值，正向反向。</p><p>5.说一下对 iOS 的理解。</p><p>6.Runtime 是怎么实现动态化的，其他语言也写一套汇编的逻辑能实现动态化吗？</p><p>7.RunLoop 应用，卡顿检测，runloop 的 activity 之前切换时长多少你觉得是卡顿？runloop 和内存之前的相关知识，autoreleasepool</p><p>8.内存管理</p><p>9.编译后的结构添加不了成员变量了，如果想添加，有没有办法实现？一个类的成员变量在内存中是怎么存储的？怎么读取一个成员变量？有什么要注意的？给 NSNumber 赋值一个 NSString，正确使用 NSString 时会不会有什么问题。</p><p>10.组件化，路由模式，如果一个类被修改了，他的映射关系怎么及时维护？</p><p>11.说一下你了解的设计模式，说一下工厂模式</p><p>12.讲一个你比较熟悉的框架</p><p>13.项目开发流程。有哪些地方可以提高效率</p><p>14.项目是怎么架构的</p><p>15.反转字符串，第一次反转一个  第二次反转两个  最后不够的全拿过来。</p><h3 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h3><p>1.介绍项目</p><p>2.Flutter 开发遇到的问题</p><p>3.Vue 开发遇到的问题  赋值需要用set方法的原因</p><p>4.学习一门新知识的途径</p><p>5.有没有看过一些源码</p><p>6.从框架中你觉得有什么点印象深刻，从框架中有没有什么点应用到项目里</p><p>7.规划  考虑新公司看中哪些方面，</p><p>8.手里有没有offer  offer上的入职时间</p><p>其他<br>问项目中遇到过啥问题，怎么解决的。平时怎么学习相关知识的<br>说说项目中的亮点，你在开发中担任的角色，你负责的模块</p><h2 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a>参考答案</h2><h3 id="一面-1"><a href="#一面-1" class="headerlink" title="一面"></a>一面</h3><p>1.你觉得自己有什么优势？</p><p>2.线程和进程的区别？</p><p>3.线程间是怎么通信的？CPU是怎么处理线程的</p><p>4.同步串行队列会不会开线程？异步串行队列会不会开线程？</p><p>5.GCD项目里有哪些地方用了</p><p>6.怎么保证网络传输的安全？MD5的加密规则，MD5可以破解吗？AES/RSA，RSA有长度限制吗？</p><p>7.什么是死锁</p><p>8.做过哪些优化，什么是离屏渲染？</p><p>9.网络有没有优化过</p><p>10.发一个网络请求经过了哪些步骤？有没有统计发起网络请求和接收网络请求的时长</p><p>11.三次握手和四次挥手</p><p>12.冷启动和热启动怎么区分？冷启动是指关机后首次打开App，热启动是指打开过App杀死后再打开。</p><p>13.什么是平衡二叉树？</p><p>14.合并多个有序链表</p><h3 id="二面-1"><a href="#二面-1" class="headerlink" title="二面"></a>二面</h3><p>1.介绍印象深刻的项目，遇到的问题，怎么解决的</p><p>2.webView 白屏除了证书问题还有什么情况可能会导致。</p><p>3.说一下对 Flutter 的了解。</p><p>4.多个 widget 之间怎么相互传值，正向反向。</p><p>5.说一下对 iOS 的理解。</p><p>6.Runtime 是怎么实现动态化的，其他语言也写一套汇编的逻辑能实现动态化吗？</p><p>7.RunLoop 应用，卡顿检测，runloop 的 activity 之前切换时长多少你觉得是卡顿？runloop 和内存之前的相关知识，autoreleasepool</p><p>8.内存管理</p><p>9.编译后的结构添加不了成员变量了，如果想添加，有没有办法实现？一个类的成员变量在内存中是怎么存储的？怎么读取一个成员变量？有什么要注意的？给 NSNumber 赋值一个 NSString，正确使用 NSString 时会不会有什么问题。</p><p>10.组件化，路由模式，如果一个类被修改了，他的映射关系怎么及时维护？</p><p>11.说一下你了解的设计模式，说一下工厂模式</p><p>12.讲一个你比较熟悉的框架</p><p>13.项目开发流程。有哪些地方可以提高效率</p><p>14.项目是怎么架构的</p><p>15.反转字符串，第一次反转一个  第二次反转两个  最后不够的全拿过来。</p><h3 id="三面-1"><a href="#三面-1" class="headerlink" title="三面"></a>三面</h3><p>1.介绍项目</p><p>2.Flutter 开发遇到的问题</p><p>3.Vue 开发遇到的问题  赋值需要用set方法的原因</p><p>4.学习一门新知识的途径</p><p>5.有没有看过一些源码</p><p>6.从框架中你觉得有什么点印象深刻，从框架中有没有什么点应用到项目里</p><p>7.规划  考虑新公司看中哪些方面，</p><p>8.手里有没有offer  offer上的入职时间</p><p>其他<br>问项目中遇到过啥问题，怎么解决的。平时怎么学习相关知识的<br>说说项目中的亮点，你在开发中担任的角色，你负责的模块</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自如面试题&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="自如" scheme="http://soso.wiki/tags/%E8%87%AA%E5%A6%82/"/>
    
  </entry>
  
  <entry>
    <title>百度知道面试题</title>
    <link href="http://soso.wiki/%E7%99%BE%E5%BA%A6%E7%9F%A5%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://soso.wiki/百度知道面试题/</id>
    <published>2023-04-04T10:30:00.000Z</published>
    <updated>2024-04-28T08:38:00.943Z</updated>
    
    <content type="html"><![CDATA[<p>百度知道面试题<br><a id="more"></a></p><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><p>1.属性关键字，在 ARC、MRC下分别用什么关键字，copy 修饰 NSString，可变字符串用什么修饰？block 用什么修饰？能不能用 strong 修饰？assign 能修饰对象吗？unsafe_unretain 有什么作用？</p><p>2.block，有几种 block，<code>__weak</code> <code>__block</code>，<code>__block</code> 修改局部变量的值原理，只把局部变量变成结构体就可以了吗？</p><p>3.多线程都用过哪些？NSOperation 了解吗？GCD 怎么开一个线程</p><p>4.什么是死锁，举例说明为什么会死锁</p><p>5.内存都有哪些区域？哪些是在栈上，哪些是在堆上？局部变量存在哪里？</p><p>6.+load 父类、子类调用顺序？分类的 +load 会调用吗？项目里有用到 +load 吗？initialize</p><p>7.Category 实现了本类的同名方法，有没有办法来调用本类的方法？</p><p>8.单链表是否有环</p><p>9.两个链表是否相交（怎么判断是否相交？怎么找交点）</p><p>10.两个字符串的最长相同子串的长度</p><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><p>1.较难定位的 Crash 怎么定位？怎么判断是 OOM 导致的 Crash 还是其他导致的 Crach？</p><p>2.Jenkins+Fastlane 实现 CI，自动化的流程除了打包还能做什么？</p><p>3.Flutter 和原生开发你觉得有什么差异</p><p>4.HTTPDNS，使用和不使用有什么区别？有什么好处？</p><p>5.通知是同步的还是异步的，异步的通知什么时候会发出去，通知的原理，通知如何存储，多次添加通知，多次移除通知会有问题吗？</p><p>6.屏幕显示的流程，CPU/GPU，离屏渲染是什么？光栅化的过程</p><p>7.安装包大小优化做了哪些？段迁移了解吗？</p><p>8.App 启动系统做了哪些事情，怎么优化启动速度</p><p>9.tableView 滑动流畅性优化</p><p>10.从点击屏幕到响应事件的流程</p><p>11.UIView 和 CALayer 的关系，为什么要这么设计</p><p>12.autoreleasePool 的原理，设计成双向链表有什么好处</p><p>13.最有成就感的项目，组件化的好处</p><p>14.如果 Code Review，你会关注哪些东西？</p><p>15.相对其他团队成员的优势</p><p>16.分享会怎么做，如果听众有 PM/测试，会怎么分享</p><p>17.团队里有成员不是特别优秀，怎么把控进度</p><p>18.了解百度的技术职级吗？你觉得自己是T几？</p><h3 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h3><p>经理 项目中遇到的有挑战的问题</p><h3 id="四面"><a href="#四面" class="headerlink" title="四面"></a>四面</h3><p>HR</p><h3 id="五面"><a href="#五面" class="headerlink" title="五面"></a>五面</h3><p>1.通过什么途径学的包括 Vue 的其他知识？为什么会有前端的需求？</p><p>2.IM 的气泡，点九图有没有使用类库，有没有兼容性问题，项目适配的最低系统版本是多少？</p><p>3.IM 文本高度计算，图文混排怎么计算高度，高度计算有没有遇到什么问题</p><p>4.整个 IM 页面的布局，最复杂的 cell 布局</p><p>5.收到新消息的处理，怎么处理能够不滚动到页面底部</p><p>6.大量图片列表滑动到指定位置，怎么避免出现内存导致的问题，为什么没有落地</p><p>7.组件化，什么能拆成组件，你认为组件化做的足够好吗？更好的组件化怎么去做？</p><p>8.你认为 iOS 和其他端有什么不一样，有什么经验可以共用？</p><p>9.未来规划</p><h3 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a>参考答案</h3><h3 id="一面-1"><a href="#一面-1" class="headerlink" title="一面"></a>一面</h3><p>1.属性关键字，在 ARC、MRC下分别用什么关键字，copy 修饰 NSString，可变字符串用什么修饰？block 用什么修饰？能不能用 strong 修饰？assign 能修饰对象吗？unsafe_unretain 有什么作用？</p><p>2.block，有几种 block，<code>__weak</code> <code>__block</code>，<code>__block</code> 修改局部变量的值原理，只把局部变量变成结构体就可以了吗？</p><p>3.多线程都用过哪些？NSOperation 了解吗？GCD 怎么开一个线程</p><h4 id="4-什么是死锁，举例说明为什么会死锁"><a href="#4-什么是死锁，举例说明为什么会死锁" class="headerlink" title="4.什么是死锁，举例说明为什么会死锁"></a>4.什么是死锁，举例说明为什么会死锁</h4><blockquote><p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</p></blockquote><p>四个必要条件</p><ul><li><p>互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。</p></li><li><p>请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</p></li><li><p>不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</p></li><li><p>环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。</p></li></ul><p>举例：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="hljs-keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="hljs-keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="hljs-built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"1"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dispatch_sync 同步，阻塞当前线程，即阻塞主线程。block 又在等主线程里的 viewDidLoad 执行完，从而形成了主线程等待主线程，造成死锁。</p><p>参考链接：<a href="https://baike.baidu.com/item/%E6%AD%BB%E9%94%81" target="_blank" rel="noopener">百度百科-死锁</a></p><h4 id="5-内存都有哪些区域？哪些是在栈上，哪些是在堆上？局部变量存在哪里？"><a href="#5-内存都有哪些区域？哪些是在栈上，哪些是在堆上？局部变量存在哪里？" class="headerlink" title="5.内存都有哪些区域？哪些是在栈上，哪些是在堆上？局部变量存在哪里？"></a>5.内存都有哪些区域？哪些是在栈上，哪些是在堆上？局部变量存在哪里？</h4><ul><li>代码段</li><li>数据段</li><li>栈</li><li>堆</li><li>内核区</li></ul><p>栈区：局部变量和实参</p><p>堆区：OC 中使用 new 方法创建的对象</p><h4 id="6-load-父类、子类调用顺序？分类的-load-会调用吗？项目里有用到-load-吗？initialize"><a href="#6-load-父类、子类调用顺序？分类的-load-会调用吗？项目里有用到-load-吗？initialize" class="headerlink" title="6.+load 父类、子类调用顺序？分类的 +load 会调用吗？项目里有用到 +load 吗？initialize"></a>6.+load 父类、子类调用顺序？分类的 +load 会调用吗？项目里有用到 +load 吗？initialize</h4><p>先调用父类，后调用子类，再调用分类。</p><p>+load 调用顺序</p><p>1.先调用类的 +load</p><ul><li>按照编译先后顺序调用（先编译，先调用）</li><li>调用子类的 +load 之前会先调用父类的 +load</li></ul><p>2.再调用分类的 +load</p><ul><li>按照编译先后顺序调用（先编译，先调用）</li></ul><p>+initialize方法会在类第一次接收到消息时调用。+initialize 调用顺序：</p><ul><li>先调用父类的+initialize，再调用子类的+initialize</li><li>(先初始化父类，再初始化子类，每个类只会初始化1次)</li></ul><h4 id="7-Category-实现了本类的同名方法，有没有办法来调用本类的方法？"><a href="#7-Category-实现了本类的同名方法，有没有办法来调用本类的方法？" class="headerlink" title="7.Category 实现了本类的同名方法，有没有办法来调用本类的方法？"></a>7.Category 实现了本类的同名方法，有没有办法来调用本类的方法？</h4><p>Category 实现了本类的同名方法，会调用 Category 的同名方法。</p><h4 id="8-单链表是否有环"><a href="#8-单链表是否有环" class="headerlink" title="8.单链表是否有环"></a>8.单链表是否有环</h4><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasCycle</span>(<span class="hljs-params"> head </span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">let</span> slow = head;</span><br><span class="line">    <span class="hljs-keyword">let</span> fast = head;</span><br><span class="line">    <span class="hljs-keyword">while</span> (fast.next &amp;&amp; fast.next.next) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        <span class="hljs-keyword">if</span> (slow == fast) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-两个链表是否相交（怎么判断是否相交？怎么找交点）"><a href="#9-两个链表是否相交（怎么判断是否相交？怎么找交点）" class="headerlink" title="9.两个链表是否相交（怎么判断是否相交？怎么找交点）"></a>9.两个链表是否相交（怎么判断是否相交？怎么找交点）</h4><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">FindFirstCommonNode</span>(<span class="hljs-params">pHead1, pHead2</span>)</span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> mySet = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();</span><br><span class="line">    <span class="hljs-keyword">let</span> p1 = pHead1;</span><br><span class="line">    <span class="hljs-keyword">while</span> (p1) &#123;</span><br><span class="line">        mySet.add(p1);</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">let</span> p2 = pHead2;</span><br><span class="line">    <span class="hljs-keyword">while</span> (p2) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (mySet.has(p2)) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> p2;</span><br><span class="line">        &#125;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-两个字符串的最长相同子串的长度"><a href="#10-两个字符串的最长相同子串的长度" class="headerlink" title="10.两个字符串的最长相同子串的长度"></a>10.两个字符串的最长相同子串的长度</h4><p>题目链接：<a href="https://www.nowcoder.com/practice/f33f5adc55f444baa0e0ca87ad8a6aac?tpId=188&amp;&amp;tqId=38644&amp;rp=1&amp;ru=/ta/job-code-high-week&amp;qru=/ta/job-code-high-week/question-ranking" target="_blank" rel="noopener">NC127 最长公共子串</a></p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">LCS</span>(<span class="hljs-params"> str1 ,  str2 </span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (str1.length &gt; str2.length) &#123;</span><br><span class="line">        [str1, str2] = [str2, str1];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">let</span> res = <span class="hljs-string">""</span>;</span><br><span class="line">    <span class="hljs-keyword">let</span> len = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; str1.length; i++) &#123;</span><br><span class="line">        <span class="hljs-keyword">let</span> temp = str1.slice(i-len,i+<span class="hljs-number">1</span>);</span><br><span class="line">        <span class="hljs-keyword">if</span> (str2.indexOf(temp) !== <span class="hljs-number">-1</span>) &#123;</span><br><span class="line">            res = temp;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二面-1"><a href="#二面-1" class="headerlink" title="二面"></a>二面</h3><p>1.较难定位的 Crash 怎么定位？怎么判断是 OOM 导致的 Crash 还是其他导致的 Crach？</p><p>2.Jenkins+Fastlane 实现 CI，自动化的流程除了打包还能做什么？</p><p>3.Flutter 和原生开发你觉得有什么差异</p><p>4.HTTPDNS，使用和不使用有什么区别？有什么好处？</p><p>5.通知是同步的还是异步的，异步的通知什么时候会发出去，通知的原理，通知如何存储，多次添加通知，多次移除通知会有问题吗？</p><p>参考链接：<a href="https://blog.csdn.net/ZCMUCZX/article/details/78631447" target="_blank" rel="noopener">iOS-通知中心原理</a></p><p>6.屏幕显示的流程，CPU/GPU，离屏渲染是什么？光栅化的过程</p><p>7.安装包大小优化做了哪些？段迁移了解吗？</p><p>8.App 启动系统做了哪些事情，怎么优化启动速度</p><p>9.tableView 滑动流畅性优化</p><p>10.从点击屏幕到响应事件的流程</p><p>11.UIView 和 CALayer 的关系，为什么要这么设计</p><p>12.autoreleasePool 的原理，设计成双向链表有什么好处</p><p>13.最有成就感的项目，组件化的好处</p><p>14.如果 Code Review，你会关注哪些东西？</p><p>15.相对其他团队成员的优势</p><p>16.分享会怎么做，如果听众有 PM/测试，会怎么分享</p><p>17.团队里有成员不是特别优秀，怎么把控进度</p><p>18.了解百度的技术职级吗？你觉得自己是T几？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;百度知道面试题&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="百度" scheme="http://soso.wiki/tags/%E7%99%BE%E5%BA%A6/"/>
    
      <category term="百度知道" scheme="http://soso.wiki/tags/%E7%99%BE%E5%BA%A6%E7%9F%A5%E9%81%93/"/>
    
  </entry>
  
  <entry>
    <title>美团面试题</title>
    <link href="http://soso.wiki/2021-07-12-%E7%BE%8E%E5%9B%A2%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://soso.wiki/2021-07-12-美团面试题/</id>
    <published>2021-07-12T14:46:00.000Z</published>
    <updated>2024-04-26T08:34:44.313Z</updated>
    
    <content type="html"><![CDATA[<p>美团面试题<br><a id="more"></a></p><p>1.Runtime</p><p>2.Runloop</p><p>3.内存管理</p><p>4.组件化</p><p>5.Flutter</p><p>6.前端</p><p>7.iOS 引用计数和 GC 的区别</p><p>参考链接：<a href="https://www.jianshu.com/p/30efb565d42b" target="_blank" rel="noopener">简书-垃圾回收和自动引用计数</a></p><p>8.算法（二叉树最大深度）</p><p>LeetCode 题目链接：<a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">二叉树的最大深度</a></p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> max = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> maxDepth = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> max(maxDepth(root.left), maxDepth(root.right)) + <span class="hljs-number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;美团面试题&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="美团" scheme="http://soso.wiki/tags/%E7%BE%8E%E5%9B%A2/"/>
    
  </entry>
  
</feed>
