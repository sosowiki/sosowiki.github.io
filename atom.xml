<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>搜搜题</title>
  <icon>https://www.gravatar.com/avatar/0add61f863154d82902310b0dd29ec33</icon>
  <subtitle>SOSOWIKI</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://soso.wiki/"/>
  <updated>2021-06-04T15:49:47.742Z</updated>
  <id>http://soso.wiki/</id>
  
  <author>
    <name>SOSOWIKI</name>
    <email>swift@88.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>首汽租车面试题</title>
    <link href="http://soso.wiki/%E9%A6%96%E6%B1%BD%E7%A7%9F%E8%BD%A6%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://soso.wiki/首汽租车面试题/</id>
    <published>2021-06-04T03:49:00.000Z</published>
    <updated>2021-06-04T15:49:47.742Z</updated>
    
    <content type="html"><![CDATA[<p>首汽租车面试题<br><a id="more"></a></p><p>1.什么是野指针？什么情况下会野指针？</p><p>2.打印结果：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="hljs-keyword">void</span>)testWeak &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">id</span> obj1 = <span class="hljs-string">@"12131"</span>;</span><br><span class="line">    __<span class="hljs-keyword">weak</span> <span class="hljs-keyword">id</span> obj2 = obj1;</span><br><span class="line">    <span class="hljs-keyword">id</span> obj3 = [<span class="hljs-built_in">NSObject</span> new];</span><br><span class="line">    __<span class="hljs-keyword">weak</span> <span class="hljs-keyword">id</span> obj4 = [[<span class="hljs-built_in">NSObject</span> alloc] init];</span><br><span class="line">    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"obj1:%@ obj2:%@ obj3:%@ obj4:%@"</span>,obj1,obj2,obj3,obj4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.子类怎么重写父类的属性？问题简化怎么重写一个类的属性？只重写set方法可以吗？</p><p>4.了解哪些设计模式？单例有哪些不好的地方？</p><p>5.说一下响应者链</p><p>6.Masonry 链式调用的实现，实现一个控制器，属性的链式调用（手写）</p><p>7.打印结果：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="hljs-keyword">void</span>)testGCD &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="hljs-string">"testqueue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"1"</span>);</span><br><span class="line">        <span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"2"</span>);</span><br><span class="line">            <span class="hljs-built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">                <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"3"</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"4"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"5"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>8.项目亮点或难点</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首汽租车面试题&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="首汽租车" scheme="http://soso.wiki/tags/%E9%A6%96%E6%B1%BD%E7%A7%9F%E8%BD%A6/"/>
    
      <category term="首汽" scheme="http://soso.wiki/tags/%E9%A6%96%E6%B1%BD/"/>
    
  </entry>
  
  <entry>
    <title>豆瓣面试题</title>
    <link href="http://soso.wiki/%E8%B1%86%E7%93%A3%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://soso.wiki/豆瓣面试题/</id>
    <published>2021-05-26T05:39:00.000Z</published>
    <updated>2021-06-01T07:29:03.828Z</updated>
    
    <content type="html"><![CDATA[<p>豆瓣面试题<br><a id="more"></a></p><h4 id="1-是在大学里学的-iOS-吗？怎么学的-iOS？"><a href="#1-是在大学里学的-iOS-吗？怎么学的-iOS？" class="headerlink" title="1.是在大学里学的 iOS 吗？怎么学的 iOS？"></a>1.是在大学里学的 iOS 吗？怎么学的 iOS？</h4><h4 id="2-判断2个单链表是否交叉-实现代码-如果有交叉找出交叉点。"><a href="#2-判断2个单链表是否交叉-实现代码-如果有交叉找出交叉点。" class="headerlink" title="2.判断2个单链表是否交叉,实现代码,如果有交叉找出交叉点。"></a>2.判断2个单链表是否交叉,实现代码,如果有交叉找出交叉点。</h4><p><strong>方法一：哈希表法</strong></p><p>遍历链表 A 并将每个结点的地址/引用存储在哈希表中。然后检查链表 B 中的每一个结点 bi是否在哈希表中。若在，则 bi为相交结点。</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> getIntersectionNode = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">headA, headB</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> mySet = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();</span><br><span class="line">    <span class="hljs-keyword">let</span> curr = headA;</span><br><span class="line">    <span class="hljs-keyword">while</span> (curr != <span class="hljs-literal">null</span>) &#123;</span><br><span class="line">        mySet.add(curr);</span><br><span class="line">        curr = curr.next;</span><br><span class="line">    &#125;</span><br><span class="line">    curr = headB;</span><br><span class="line">    <span class="hljs-keyword">while</span> (curr != <span class="hljs-literal">null</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (mySet.has(curr)) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> curr;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>方法二：双指针法</strong></p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> getIntersectionNode = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">headA, headB</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (headA == <span class="hljs-literal">null</span> || headB == <span class="hljs-literal">null</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">let</span> pA = headA, pB = headB;</span><br><span class="line">    <span class="hljs-keyword">while</span> (pA != pB) &#123;</span><br><span class="line">        pA = pA == <span class="hljs-literal">null</span> ? headB : pA.next;</span><br><span class="line">        pB = pB == <span class="hljs-literal">null</span> ? headA : pB.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> pA;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3-说一下-property-属性修饰符，block-为什么用-copy-？weak-的实现原理？atomic-怎么保证安全？怎么解决读写安全？"><a href="#3-说一下-property-属性修饰符，block-为什么用-copy-？weak-的实现原理？atomic-怎么保证安全？怎么解决读写安全？" class="headerlink" title="3.说一下 @property 属性修饰符，block 为什么用 copy ？weak 的实现原理？atomic 怎么保证安全？怎么解决读写安全？"></a>3.说一下 @property 属性修饰符，block 为什么用 copy ？weak 的实现原理？atomic 怎么保证安全？怎么解决读写安全？</h4><p>@property 什么都不写</p><p>基本数据类型默认修饰符是 atomic, readWrite, assign</p><p>对象类型默认修饰符是 atomic, readWrite, strong</p><p><strong>block 为什么用 copy？</strong></p><p>如果是全局静态 block 的话，它直到程序结束的时候，才会被被释放。但是我们实际操作中基本上不会使用到不访问外部变量的 block。</p><p>如果是保存在栈中的 block，它会随着函数调用结束被销毁。从而导致我们在执行一个包含 block 的函数之后，就无法再访问这个 block。因为（函数结束，函数栈就销毁了，存在函数里面的 block 也就没有了），我们再使用 block 时，就会产生空指针异常。</p><p>如果是堆中的 block，也就是 copy 修饰的 block。他的生命周期就是随着对象的销毁而结束的。只要对象不销毁，我们就可以调用的到在堆中的 block。</p><p>这就是为什么我们要用 copy 来修饰 block。因为不用 copy 修饰的访问外部变量的 block，只在他所在的函数被调用的那一瞬间可以使用。之后就消失了。</p><p><strong>weak 的实现原理</strong></p><p>参考链接：<a href="http://www.cocoachina.com/articles/18962" target="_blank" rel="noopener">iOS 底层解析weak的实现原理</a></p><p><strong>atomic 怎么保证安全？</strong></p><p>属性声明为atomic时，在该属性在调用getter和setter方法时，会加上同步锁，即在属性在调用getter和setter方法时，保证同一时刻只能有一个线程调用属性的读/写方法。保证了读和写的过程是可靠的。但并不能保证数据一定是可靠的。</p><p><strong>怎么解决读写安全？</strong></p><ul><li>dispatch_barrier_async</li><li>pthread_rwlock：读写锁</li></ul><h4 id="4-OSSPinLock-为什么不用了？"><a href="#4-OSSPinLock-为什么不用了？" class="headerlink" title="4.OSSPinLock 为什么不用了？"></a>4.OSSPinLock 为什么不用了？</h4><p>系统维护了 5 个不同的线程优先级/QoS: background，utility，default，user-initiated，user-interactive。高优先级线程始终会在低优先级线程前执行，一个线程不会受到比它更低优先级线程的干扰。这种线程调度算法会产生潜在的优先级反转问题，从而破坏了 spin lock。</p><p>具体来说，如果一个低优先级的线程获得锁并访问共享资源，这时一个高优先级的线程也尝试获得这个锁，它会处于 spin lock 的忙等状态从而占用大量 CPU。此时低优先级线程无法与高优先级线程争夺 CPU 时间，从而导致任务迟迟完不成、无法释放 lock。这并不只是理论上的问题，libobjc 已经遇到了很多次这个问题了，于是苹果的工程师停用了 OSSpinLock。</p><p>参考链接：<a href="https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/" target="_blank" rel="noopener">不再安全的 OSSpinLock</a></p><h4 id="5-同时请求两张图片，之后合成一张图"><a href="#5-同时请求两张图片，之后合成一张图" class="headerlink" title="5.同时请求两张图片，之后合成一张图"></a>5.同时请求两张图片，之后合成一张图</h4><ul><li>dispatch_group 配合 dispatch_semaphore</li><li>dispatch_group dispatch_enter dispatch_leave</li><li>dispatch_barrier</li></ul><p>还有其他的方式吗？只使用 dispatch_semphore 和 dispatch_async 怎么实现？</p><h4 id="6-Runloop-有哪些使用场景？"><a href="#6-Runloop-有哪些使用场景？" class="headerlink" title="6.Runloop 有哪些使用场景？"></a>6.Runloop 有哪些使用场景？</h4><ul><li>控制线程生命周期，实现常驻线程。</li><li><p>TableView 延迟加载图片。滑动时不调用赋值图片的方法，等滑动完毕切换到 NSDefaultRunLoopMode 时才调用。</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="hljs-keyword">self</span>.img performSelector:<span class="hljs-keyword">@selector</span>(setImage:) withObject:image afterDelay:<span class="hljs-number">0</span> inModes:[<span class="hljs-built_in">NSDefaultRunLoopMode</span>]];</span><br></pre></td></tr></table></figure></li><li><p>解决 NSTimer 在滑动时停止的问题。</p></li><li>监测 RunLoop 的状态监测应用卡顿。</li></ul><h4 id="7-子线程怎么销毁？换一种问法，常驻线程怎么销毁？NSPort-的生命周期怎么控制？"><a href="#7-子线程怎么销毁？换一种问法，常驻线程怎么销毁？NSPort-的生命周期怎么控制？" class="headerlink" title="7.子线程怎么销毁？换一种问法，常驻线程怎么销毁？NSPort 的生命周期怎么控制？"></a>7.子线程怎么销毁？换一种问法，常驻线程怎么销毁？NSPort 的生命周期怎么控制？</h4><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="hljs-keyword">void</span>)_stopThread &#123;</span><br><span class="line">    <span class="hljs-keyword">self</span>.isRun = <span class="hljs-literal">NO</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 停止当前线程的Runloop</span></span><br><span class="line">    <span class="hljs-built_in">CFRunLoopStop</span>(<span class="hljs-built_in">CFRunLoopGetCurrent</span>());</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">self</span>.innerThread = <span class="hljs-literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考链接：<a href="https://juejin.cn/post/6868551023439544333" target="_blank" rel="noopener">iOS RunLoop 常驻线程简化实现</a></p><h4 id="8-说一下响应者链。有三个视图-A、B、C-依次被添加到-self-view-上，frame-相同，复写-C-的-pointInSide-方法缩小范围，点击-C-的边缘-C-会响应吗？C-不响应的话，B-会响应吗？"><a href="#8-说一下响应者链。有三个视图-A、B、C-依次被添加到-self-view-上，frame-相同，复写-C-的-pointInSide-方法缩小范围，点击-C-的边缘-C-会响应吗？C-不响应的话，B-会响应吗？" class="headerlink" title="8.说一下响应者链。有三个视图 A、B、C 依次被添加到 self.view 上，frame 相同，复写 C 的 pointInSide 方法缩小范围，点击 C 的边缘 C 会响应吗？C 不响应的话，B 会响应吗？"></a>8.说一下响应者链。有三个视图 A、B、C 依次被添加到 self.view 上，frame 相同，复写 C 的 pointInSide 方法缩小范围，点击 C 的边缘 C 会响应吗？C 不响应的话，B 会响应吗？</h4><p>点击 C 的边缘 C 不会响应，B 会响应。</p><h4 id="9-组件是怎么拆分的？组件化是怎么传值的？组件的注册是写在哪里的？写在-load-会不会有性能问题？怎么解决？"><a href="#9-组件是怎么拆分的？组件化是怎么传值的？组件的注册是写在哪里的？写在-load-会不会有性能问题？怎么解决？" class="headerlink" title="9.组件是怎么拆分的？组件化是怎么传值的？组件的注册是写在哪里的？写在 +load 会不会有性能问题？怎么解决？"></a>9.组件是怎么拆分的？组件化是怎么传值的？组件的注册是写在哪里的？写在 +load 会不会有性能问题？怎么解决？</h4><p>参考链接：<a href="https://zhuanlan.zhihu.com/p/22565656" target="_blank" rel="noopener">iOS组件化方案</a></p><h4 id="10-了解-HTTPDNS-吗？询问的操作是谁去问？本层-gt-上层-gt-上上层"><a href="#10-了解-HTTPDNS-吗？询问的操作是谁去问？本层-gt-上层-gt-上上层" class="headerlink" title="10.了解 HTTPDNS 吗？询问的操作是谁去问？本层-&gt;上层-&gt;上上层"></a>10.了解 HTTPDNS 吗？询问的操作是谁去问？本层-&gt;上层-&gt;上上层</h4><ul><li>使用HTTP（HTTPS）协议绕过运营商的 Local DNS，避免域名劫持，也更准确地判断客户端地区和运营商，得到更精准的解析结果；</li><li>HTTPDNS 能够直接得到客户端的出口网关 IP，从而更准确地判断客户端地区和运营商，得到更精准的解析结果；</li></ul><p>参考链接：<a href="https://help.aliyun.com/product/30100.html?spm=a2c4g.11186623.6.540.1ea63eabsBELsu" target="_blank" rel="noopener">HTTPDNS</a></p><h4 id="11-性能优化，tableView-怎么缓存行高？高度存在哪儿？key-是什么？横竖屏怎么缓存行高？一个页面大概率不会横屏，缓存横竖屏两份行高是不是有些浪费，怎么去处理行高？tableView-怎么控制缓存数量，比如最大1000条数据的缓存量。"><a href="#11-性能优化，tableView-怎么缓存行高？高度存在哪儿？key-是什么？横竖屏怎么缓存行高？一个页面大概率不会横屏，缓存横竖屏两份行高是不是有些浪费，怎么去处理行高？tableView-怎么控制缓存数量，比如最大1000条数据的缓存量。" class="headerlink" title="11.性能优化，tableView 怎么缓存行高？高度存在哪儿？key 是什么？横竖屏怎么缓存行高？一个页面大概率不会横屏，缓存横竖屏两份行高是不是有些浪费，怎么去处理行高？tableView 怎么控制缓存数量，比如最大1000条数据的缓存量。"></a>11.性能优化，tableView 怎么缓存行高？高度存在哪儿？key 是什么？横竖屏怎么缓存行高？一个页面大概率不会横屏，缓存横竖屏两份行高是不是有些浪费，怎么去处理行高？tableView 怎么控制缓存数量，比如最大1000条数据的缓存量。</h4><p>提前计算好cell的高度,缓存在相应的数据源模型中。cellHeight</p><h4 id="12-加载大图，地图这种大图怎么加载优化？系统-API-的原理是什么？"><a href="#12-加载大图，地图这种大图怎么加载优化？系统-API-的原理是什么？" class="headerlink" title="12.加载大图，地图这种大图怎么加载优化？系统 API 的原理是什么？"></a>12.加载大图，地图这种大图怎么加载优化？系统 API 的原理是什么？</h4><ul><li>分片比例裁剪方式。参考苹果给出的 <a href="https://developer.apple.com/library/ios/samplecode/LargeImageDownsizing/" target="_blank" rel="noopener">demo</a>,利用 CGImageCreateWithImageInRect 截取原图对应位置的内容,再通过 CGContextDrawImage 渲染到指定位置;</li><li>利用 CATiledLayer 层级的API,自动进行绘制;</li></ul><p>参考链接：<a href="https://www.jianshu.com/p/2d9e58d67d87" target="_blank" rel="noopener">iOS 大图显示解决办法</a></p><h4 id="13-项目怎么分工的？你负责什么？有没有什么值得说的点？H5-与原生交互有什么经验分享吗？怎么给-webView-加载的页面发的网络请求统一加上-header？"><a href="#13-项目怎么分工的？你负责什么？有没有什么值得说的点？H5-与原生交互有什么经验分享吗？怎么给-webView-加载的页面发的网络请求统一加上-header？" class="headerlink" title="13.项目怎么分工的？你负责什么？有没有什么值得说的点？H5 与原生交互有什么经验分享吗？怎么给 webView 加载的页面发的网络请求统一加上 header？"></a>13.项目怎么分工的？你负责什么？有没有什么值得说的点？H5 与原生交互有什么经验分享吗？怎么给 webView 加载的页面发的网络请求统一加上 header？</h4><h4 id="14-AFN-早期版本为什么要使用常驻线程？怎么统一设置-header？"><a href="#14-AFN-早期版本为什么要使用常驻线程？怎么统一设置-header？" class="headerlink" title="14.AFN 早期版本为什么要使用常驻线程？怎么统一设置 header？"></a>14.AFN 早期版本为什么要使用常驻线程？怎么统一设置 header？</h4><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[requestSerializer setValue:value forHTTPHeaderField:httpHeaderField];</span><br></pre></td></tr></table></figure><h4 id="15-RN-和-Flutter-的底层实现有什么区别？"><a href="#15-RN-和-Flutter-的底层实现有什么区别？" class="headerlink" title="15.RN 和 Flutter 的底层实现有什么区别？"></a>15.RN 和 Flutter 的底层实现有什么区别？</h4><p>在 Android 和 iOS 上，默认情况下 Flutter 和 React Native 都需要一个原生平台的 <code>Activity</code> / <code>ViewController</code> 支持，且在原生层面属于一个“单页面应用”，而它们之间最大的不同点其实在于 UI 构建 ：</p><ul><li>React Native ：</li></ul><p>React Native 是一套 UI 框架，默认情况下 React Native 会在 <code>Activity</code> 下加载  JS 文件，然后运行在 <code>JavaScriptCore</code> 中解析 <em>Bundle</em> 文件布局，最终堆叠出一系列的原生控件进行渲染。</p><p>简单来说就是 <strong>通过写 JS 代码配置页面布局，然后 React Native 最终会解析渲染成原生控件</strong>，如 <code>&lt;View&gt;</code> 标签对应 <code>ViewGroup/UIView</code> ，<code>&lt;ScrollView&gt;</code> 标签对应 <code>ScrollView/UIScrollView</code> ，<code>&lt;Image&gt;</code> 标签对应 <code>ImageView/UIImageView</code> 等。</p><ul><li>Flutter ：</li></ul><p>如果说 React Native 是为开发者做了平台兼容，那 Flutter 则更像是为开发者屏蔽平台的概念。</p><p>Flutter 中绝大部分的 <code>Widget</code> 都与平台无关， 开发者基于 <code>Framework</code> 开发 App ，而 <code>Framework</code> 运行在 <code>Engine</code> 之上，由 <code>Engine</code> 进行适配和跨平台支持。这个跨平台的支持过程，其实就是将 <strong>Flutter UI 中的 <code>Widget</code> “数据化” ，然后通过 <code>Engine</code> 上的 <code>Skia</code> 直接绘制到屏幕上 。</strong></p><p>参考链接：<a href="https://www.jianshu.com/p/85a77bb8d926" target="_blank" rel="noopener">Flutter 与 React Native 的对比分析</a></p><h4 id="16-平时怎么学习-iOS？上家公司的离职原因，未来规划，有没有要问我的？"><a href="#16-平时怎么学习-iOS？上家公司的离职原因，未来规划，有没有要问我的？" class="headerlink" title="16.平时怎么学习 iOS？上家公司的离职原因，未来规划，有没有要问我的？"></a>16.平时怎么学习 iOS？上家公司的离职原因，未来规划，有没有要问我的？</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;豆瓣面试题&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="豆瓣" scheme="http://soso.wiki/tags/%E8%B1%86%E7%93%A3/"/>
    
  </entry>
  
  <entry>
    <title>必要商城面试题</title>
    <link href="http://soso.wiki/%E5%BF%85%E8%A6%81%E5%95%86%E5%9F%8E%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://soso.wiki/必要商城面试题/</id>
    <published>2021-05-20T07:38:00.000Z</published>
    <updated>2021-05-21T06:59:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>必要商城面试题<br><a id="more"></a></p><h4 id="1-项目搭建都做了哪些？"><a href="#1-项目搭建都做了哪些？" class="headerlink" title="1.项目搭建都做了哪些？"></a>1.项目搭建都做了哪些？</h4><h4 id="2-有没有做过解耦？"><a href="#2-有没有做过解耦？" class="headerlink" title="2.有没有做过解耦？"></a>2.有没有做过解耦？</h4><p>参考链接：<a href="https://blog.csdn.net/zramals/article/details/81389256" target="_blank" rel="noopener">iOS组件化（四）-代码解耦合</a></p><p><a href="https://blog.csdn.net/zramals/category_9277261.html" target="_blank" rel="noopener">iOS组件化从零开始</a></p><h4 id="3-路由怎么实现传值的？"><a href="#3-路由怎么实现传值的？" class="headerlink" title="3.路由怎么实现传值的？"></a>3.路由怎么实现传值的？</h4><p>参考链接：<a href="https://blog.csdn.net/zramals/article/details/81457669" target="_blank" rel="noopener">iOS组件化（五）-组件间调用</a></p><h4 id="4-项目优化？"><a href="#4-项目优化？" class="headerlink" title="4.项目优化？"></a>4.项目优化？</h4><p>安装包大小优化</p><p>性能优化</p><p>启动优化</p><p>防崩溃</p><h4 id="5-防崩溃处理？"><a href="#5-防崩溃处理？" class="headerlink" title="5.防崩溃处理？"></a>5.防崩溃处理？</h4><p>runtime 交换方法</p><h4 id="6-cell-加载图片的优化？"><a href="#6-cell-加载图片的优化？" class="headerlink" title="6.cell 加载图片的优化？"></a>6.cell 加载图片的优化？</h4><h4 id="7-项目难点？"><a href="#7-项目难点？" class="headerlink" title="7.项目难点？"></a>7.项目难点？</h4><h4 id="8-数据传递除了加密以外，怎么保证数据安全？"><a href="#8-数据传递除了加密以外，怎么保证数据安全？" class="headerlink" title="8.数据传递除了加密以外，怎么保证数据安全？"></a>8.数据传递除了加密以外，怎么保证数据安全？</h4><p>1、使用数字证书锁定来保证不被中间人拦截，将服务器返回的数据和我的本地证书进行对比，确保是从服务器返回回来的。<br>2、使用 https 协议请求网页，post 来请求网页数据，保证用户的账号密码不被被人获取到。<br>3、使用苹果自己的 SSKeyChain 钥匙串，将用户的账号密码保存在钥匙串中。</p><p>参考链接：<a href="https://www.jianshu.com/p/cf7279a75cff" target="_blank" rel="noopener">iOS开发，让数据更安全的几个加密方式</a></p><h4 id="9-原生与-H5-的交互？WKWebView-和-UIWebView-的区别？"><a href="#9-原生与-H5-的交互？WKWebView-和-UIWebView-的区别？" class="headerlink" title="9.原生与 H5 的交互？WKWebView 和 UIWebView 的区别？"></a>9.原生与 H5 的交互？WKWebView 和 UIWebView 的区别？</h4><h4 id="10-Cocopods-怎么管理自己的第三方库？"><a href="#10-Cocopods-怎么管理自己的第三方库？" class="headerlink" title="10.Cocopods 怎么管理自己的第三方库？"></a>10.Cocopods 怎么管理自己的第三方库？</h4><h4 id="11-除了-MVC-有没有了解过别的设计模式？"><a href="#11-除了-MVC-有没有了解过别的设计模式？" class="headerlink" title="11.除了 MVC 有没有了解过别的设计模式？"></a>11.除了 MVC 有没有了解过别的设计模式？</h4><h4 id="12-方法交换原理？"><a href="#12-方法交换原理？" class="headerlink" title="12.方法交换原理？"></a>12.方法交换原理？</h4><p>方法交换，交换的是方法的实现。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;必要商城面试题&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="必要商城" scheme="http://soso.wiki/tags/%E5%BF%85%E8%A6%81%E5%95%86%E5%9F%8E/"/>
    
  </entry>
  
  <entry>
    <title>猿辅导面试题</title>
    <link href="http://soso.wiki/%E7%8C%BF%E8%BE%85%E5%AF%BC%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://soso.wiki/猿辅导面试题/</id>
    <published>2021-05-19T11:00:00.000Z</published>
    <updated>2021-05-20T10:06:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>猿辅导面试题<br><a id="more"></a></p><h4 id="1-加入-nil-会闪退吗"><a href="#1-加入-nil-会闪退吗" class="headerlink" title="1.@[]; 加入 nil 会闪退吗"></a>1.@[]; 加入 nil 会闪退吗</h4><p>会闪退，报错：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-[__NSPlaceholderArray initWithObjects:count:]: attempt to insert <span class="hljs-literal">nil</span> object from objects[<span class="hljs-number">4</span>]</span><br></pre></td></tr></table></figure><h4 id="2-array-i-会不会走-objectAtIndex"><a href="#2-array-i-会不会走-objectAtIndex" class="headerlink" title="2.array[i] 会不会走 objectAtIndex"></a>2.array[i] 会不会走 objectAtIndex</h4><p>会走。</p><p>array[i] 如果数组越界，会崩溃报错：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[__NSArrayI objectAtIndexedSubscript:]: index <span class="hljs-number">6</span> beyond bounds [<span class="hljs-number">0</span> .. <span class="hljs-number">4</span>]<span class="hljs-string">'</span></span><br></pre></td></tr></table></figure><h4 id="3-信号量-3-个网络接口返回执行-4"><a href="#3-信号量-3-个网络接口返回执行-4" class="headerlink" title="3.信号量 3 个网络接口返回执行 4"></a>3.信号量 3 个网络接口返回执行 4</h4><p>有些时候，我们需要阻塞发送请求的线程，比如在多个请求回调后统一操作的需求，而这些请求之间并没有顺序关系，且这些接口都会另开线程进行网络请求的。一般地，这种多线程完成后进行统一操作的需求都会使用队列组(dispatch_group_t)来完成，但是由于是异步请求，没等其异步回调之后，请求的线程就结束了，为此，就需要使用信号量来阻塞住发请求的线程。实现代码如下：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">dispatch_async</span>(queue, <span class="hljs-number">0</span>), ^&#123;</span><br><span class="line">    dispatch_semaphore_t sema = dispatch_semaphore_create(<span class="hljs-number">0</span>);</span><br><span class="line">    [网络请求:^&#123;</span><br><span class="line">        <span class="hljs-comment">//请求回调</span></span><br><span class="line">        dispatch_semaphore_signal(sema);  </span><br><span class="line">    &#125;];</span><br><span class="line">    dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样，请求的线程就可以等到回调结束后再结束了，再配合队列组就能完成上述的需求。这种技巧可用于以下场景：</p><ul><li>多个请求结束后统一操作</li><li>多个请求顺序执行</li></ul><h4 id="4-hook-delelgate-方法"><a href="#4-hook-delelgate-方法" class="headerlink" title="4.hook delelgate 方法"></a>4.hook delelgate 方法</h4><p>参考链接：<a href="https://blog.csdn.net/alpaca12/article/details/77914907" target="_blank" rel="noopener">iOS hook delegate</a></p><h4 id="5-交换方法传入参数-为什么需要先-addMethod"><a href="#5-交换方法传入参数-为什么需要先-addMethod" class="headerlink" title="5.交换方法传入参数 为什么需要先 addMethod"></a>5.交换方法传入参数 为什么需要先 addMethod</h4><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="hljs-keyword">void</span>)exchangeInstanceMethodWithSelfClass:(Class)selfClass</span><br><span class="line">                           originalSelector:(SEL)originalSelector</span><br><span class="line">                           swizzledSelector:(SEL)swizzledSelector &#123;</span><br><span class="line">    </span><br><span class="line">    Method originalMethod = class_getInstanceMethod(selfClass, originalSelector);</span><br><span class="line">    Method swizzledMethod = class_getInstanceMethod(selfClass, swizzledSelector);</span><br><span class="line">    <span class="hljs-built_in">BOOL</span> didAddMethod = class_addMethod(selfClass,</span><br><span class="line">                                        originalSelector,</span><br><span class="line">                                        method_getImplementation(swizzledMethod),</span><br><span class="line">                                        method_getTypeEncoding(swizzledMethod));</span><br><span class="line">    <span class="hljs-keyword">if</span> (didAddMethod) &#123;</span><br><span class="line">        class_replaceMethod(selfClass,</span><br><span class="line">                            swizzledSelector,</span><br><span class="line">                            method_getImplementation(originalMethod),</span><br><span class="line">                            method_getTypeEncoding(originalMethod));</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>防止影响父类的方法。</p><ul><li><p><code>init</code> 方法并不是 <code>Person</code> 类本身的实例（对象）方法，而是父类 <code>NSObject</code> 的方法。由于 <code>Person</code> 本身没有该方法，所以 <code>class_getInstanceMethod</code> 获取到的方法是通过 <code>Person</code> 的 <code>superclass</code> 指针从 <code>NSObject</code> 类中获取到了 <code>init</code> 这个方法。</p></li><li><p><code>method_exchangeImplementations</code> 操作将 <code>NSObject</code> 的 <code>init</code> 方法的实现与 <code>Person</code> 类的 <code>yxc_init</code> 方法的实现进行互换了，这时候调用 <code>init</code> 方法实际上是调用了 <code>yxc_init</code> 方法。</p></li><li><p>创建一个 <code>Person</code> 对象时，调用 <code>init</code> 方法，运行时会去查找 <code>yxc_init</code> 的实现，因为 <code>yxc_init</code> 方法是 <code>Person</code> 自身的方法，所以查找到了直接调用。（消息发送机制）</p></li><li><p>而创建一个 <code>NSObject</code> 对象时，调用 <code>init</code> 方法，运行时去查找 <code>yxc_init</code> 方法的时候，<code>NSObject</code> 是没有这个方法，这个方法存在于 <code>Person</code> 类中，所以查找完毕，还是找不到这个方法，就抛异常了。</p></li><li><p>正确的 hook 做法是，先将 init 方法添加到 Person 类中，如果这个类当前有这个方法（而不是父类），则不添加，直接 exchange，否则添加了 init 方法，然后再将 yxc_init 方法的实现设置成 init 方法的实现。</p></li></ul><p>参考链接：<a href="https://www.jianshu.com/p/d6d5bb9d97f5" target="_blank" rel="noopener">iOS Runtime 黑魔法方法交换(Method swizzling)</a></p><h4 id="6-关联对象有几种策略，如何实现-weak"><a href="#6-关联对象有几种策略，如何实现-weak" class="headerlink" title="6.关联对象有几种策略，如何实现 weak"></a>6.关联对象有几种策略，如何实现 weak</h4><p>在关联对象释放的时候，调用<code>objc_setAssociatedObject(object, key, nil, OBJC_ASSOCIATION_ASSIGN)</code>这样就把宿主对象的该 key 的关联对象清除了，外部读这个 key 的关联对象就是 nil</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">void</span> objc_setWeakAssociatedObject(<span class="hljs-keyword">id</span> _Nonnull object, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> * _Nonnull key, <span class="hljs-keyword">id</span> _Nullable value);</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">void</span> objc_setWeakAssociatedObject(<span class="hljs-keyword">id</span> _Nonnull object, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> * _Nonnull key, <span class="hljs-keyword">id</span> _Nullable value) &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (value) &#123;</span><br><span class="line">        <span class="hljs-comment">//__weak typeof(object) weakObj = object;</span></span><br><span class="line">        [value hc_doSthWhenDeallocWithBlock:^(<span class="hljs-built_in">NSObject</span> *__<span class="hljs-keyword">unsafe_unretained</span>  _Nonnull target) &#123;</span><br><span class="line">            objc_setAssociatedObject(object, key, <span class="hljs-literal">nil</span>, OBJC_ASSOCIATION_ASSIGN); <span class="hljs-comment">// clear association</span></span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    objc_setAssociatedObject(object, key, value, OBJC_ASSOCIATION_ASSIGN); <span class="hljs-comment">// call system imp</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考链接：<a href="https://www.jianshu.com/p/9dc4ea925a3d" target="_blank" rel="noopener">OC-AssociatedObject原理及weak关联对象的实现</a></p><h4 id="7-响应者链-button-超出父视图一半能否响应点击事件"><a href="#7-响应者链-button-超出父视图一半能否响应点击事件" class="headerlink" title="7.响应者链 button 超出父视图一半能否响应点击事件"></a>7.响应者链 button 超出父视图一半能否响应点击事件</h4><p>超出父视图的部分不能响应，在父视图内的部分可以响应。</p><p>如何扩大按钮的点击范围？</p><p>可以重写 button 的 pointInside: 方法</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="hljs-built_in">BOOL</span>)pointInside:(<span class="hljs-built_in">CGPoint</span>)point withEvent:(<span class="hljs-built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="hljs-comment">// 当前btn的大小</span></span><br><span class="line">    <span class="hljs-built_in">CGRect</span> btnBounds = <span class="hljs-keyword">self</span>.bounds;</span><br><span class="line">    <span class="hljs-comment">// 扩大按钮的点击范围，改为负值</span></span><br><span class="line">    btnBounds = <span class="hljs-built_in">CGRectInset</span>(btnBounds, <span class="hljs-number">-15</span>, <span class="hljs-number">-15</span>);</span><br><span class="line">    <span class="hljs-comment">// 若点击的点在新的bounds里，就返回YES</span></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-built_in">CGRectContainsPoint</span>(btnBounds, point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-离屏渲染，为什么会触发"><a href="#8-离屏渲染，为什么会触发" class="headerlink" title="8.离屏渲染，为什么会触发"></a>8.离屏渲染，为什么会触发</h4><p>参考链接：<a href="https://zhuanlan.zhihu.com/p/72653360" target="_blank" rel="noopener">知乎-关于iOS离屏渲染的深入研究</a></p><p><a href="https://www.jianshu.com/p/a72692125718" target="_blank" rel="noopener">简书-iOS离屏渲染产生的原因</a></p><h4 id="9-判断当前任务在哪个-queue-中"><a href="#9-判断当前任务在哪个-queue-中" class="headerlink" title="9.判断当前任务在哪个 queue 中"></a>9.判断当前任务在哪个 queue 中</h4><p><code>dispatch_queue_get_label</code></p><p>参考链接：<a href="https://blog.csdn.net/tongwei117/article/details/82757492" target="_blank" rel="noopener">判断代码在哪个队列中运行</a></p><h4 id="10-SDWebImage-内存缓存怎么实现的"><a href="#10-SDWebImage-内存缓存怎么实现的" class="headerlink" title="10.SDWebImage 内存缓存怎么实现的"></a>10.SDWebImage 内存缓存怎么实现的</h4><p>参考链接：<a href="https://www.jianshu.com/p/fc8e8994dde7" target="_blank" rel="noopener">iOS-SDWebImage缓存机制</a></p><h4 id="11-json-转-model，Runtime-能否获取到自定义属性的类型"><a href="#11-json-转-model，Runtime-能否获取到自定义属性的类型" class="headerlink" title="11.json 转 model，Runtime 能否获取到自定义属性的类型"></a>11.json 转 model，Runtime 能否获取到自定义属性的类型</h4><p><code>class_copyPropertyList</code>可以获取到属性列表</p><p><code>property_getName</code>可以获取到属性名</p><p><code>property_getAttributes</code>可以获取到成员类型</p><h4 id="12-tableView-快速滑动-卡顿发生可能原因"><a href="#12-tableView-快速滑动-卡顿发生可能原因" class="headerlink" title="12.tableView 快速滑动 卡顿发生可能原因"></a>12.tableView 快速滑动 卡顿发生可能原因</h4><p>1.提前计算并缓存好高度，因为 heightForRow 最频繁的调用。</p><p>- (UITableViewCell<em>)tableView:(UITableView</em>)tableView cellForRowAtIndexPath:(NSIndexPath*)indexPath;</p><p>2.异步绘制，遇到复杂界面，性能瓶颈时，可能是突破口。</p><p>3.滑动时按需加载，这个在大量图片展示，网络加载时，很管用。（SDWebImage 已经实现异步加载）。</p><p>4.重用 cells。</p><p>5.如果 cell 内显示得内容来自 web，使用异步加载，缓存结果请求。当 cell 中的部分 View 是非常独立的，并且不便于重用的，而且“体积”非常小，在内存可控的前提下，我们完全可以将这些 view 缓存起来。当然也是缓存在模型中。</p><p>6.少用或不用透明图层，使用不透明视图。对于不透明的 View，设置 opaque 为 YES，这样在绘制该 View 时，就不需要考虑被 View 覆盖的其他内容（尽量设置 Cell 的 view 为 opaque，避免 GPU 对 Cell 下面的内容也进行绘制）</p><p>7.减少 subViews。分析 Cell 结构，尽可能的将 相同内容的抽取到一种样式 Cell 中，前面已经提到了 Cell 的重用机制，这样就能保证 UITbaleView 要显示多少内容，真正创建出的 Cell 可能只比屏幕显示的 Cell 多一点。虽然 Cell 的’体积’可能会大点，但是因为 Cell 的数量不会很多，完全可以接受的</p><p>8.少用 addView 给 cell 动态添加 view，可以初始化的时候就添加，然后通过 hide 控制是否显示。</p><h4 id="13-括号算法"><a href="#13-括号算法" class="headerlink" title="13.括号算法"></a>13.括号算法</h4><p>LeetCode 题目链接：<a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">括号生成</a></p><h4 id="14-CocoaPods-缓存存在哪里，pod-install-执行"><a href="#14-CocoaPods-缓存存在哪里，pod-install-执行" class="headerlink" title="14.CocoaPods 缓存存在哪里，pod install 执行"></a>14.CocoaPods 缓存存在哪里，pod install 执行</h4><p>~/Library/Caches/Cocoapods</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;猿辅导面试题&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="猿辅导" scheme="http://soso.wiki/tags/%E7%8C%BF%E8%BE%85%E5%AF%BC/"/>
    
  </entry>
  
  <entry>
    <title>链表算法题</title>
    <link href="http://soso.wiki/%E9%93%BE%E8%A1%A8%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    <id>http://soso.wiki/链表算法题/</id>
    <published>2021-04-28T05:04:00.000Z</published>
    <updated>2021-05-18T04:57:36.645Z</updated>
    
    <content type="html"><![CDATA[<p>链表算法题（ JavaScript 实现）<br><a id="more"></a></p><h4 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h4><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ReverseList</span>(<span class="hljs-params">pHead</span>)</span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> prev = <span class="hljs-literal">null</span>;</span><br><span class="line">    <span class="hljs-keyword">let</span> curr = pHead;</span><br><span class="line">    <span class="hljs-keyword">while</span> (curr) &#123;</span><br><span class="line">        <span class="hljs-keyword">const</span> next = curr.next;</span><br><span class="line">        curr.next = prev;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h4><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> swapPairs = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> dummyNode = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);</span><br><span class="line">    dummyNode.next = head;</span><br><span class="line">    <span class="hljs-keyword">let</span> temp = dummyNode;</span><br><span class="line">    <span class="hljs-keyword">while</span> (temp.next != <span class="hljs-literal">null</span> &amp;&amp; temp.next.next != <span class="hljs-literal">null</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">let</span> head1 = temp.next;</span><br><span class="line">        <span class="hljs-keyword">let</span> head2 = temp.next.next;</span><br><span class="line">        temp.next = head2;</span><br><span class="line">        head1.next = head2.next;</span><br><span class="line">        head2.next = head1;</span><br><span class="line">        temp = head1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> dummyNode.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="判断链表中是否有环"><a href="#判断链表中是否有环" class="headerlink" title="判断链表中是否有环"></a>判断链表中是否有环</h4><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasCycle</span>(<span class="hljs-params"> head </span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">let</span> slow = head;</span><br><span class="line">    <span class="hljs-keyword">let</span> fast = head;</span><br><span class="line">    <span class="hljs-keyword">while</span> (fast.next &amp;&amp; fast.next.next) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        <span class="hljs-keyword">if</span> (slow == fast) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="环的入口结点"><a href="#环的入口结点" class="headerlink" title="环的入口结点"></a>环的入口结点</h4><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">detectCycle</span>(<span class="hljs-params"> head </span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (!head) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;</span><br><span class="line">    <span class="hljs-keyword">let</span> slow = head, fast = head;</span><br><span class="line">    <span class="hljs-keyword">while</span>(fast.next &amp;&amp; fast.next.next) &#123;</span><br><span class="line">        fast = fast.next.next</span><br><span class="line">        slow = slow.next</span><br><span class="line">        <span class="hljs-keyword">if</span> (slow == fast) &#123;</span><br><span class="line">            <span class="hljs-keyword">var</span> a = head;</span><br><span class="line">            <span class="hljs-keyword">while</span> (slow != a) &#123;</span><br><span class="line">                a = a.next</span><br><span class="line">                slow = slow.next</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="链表中倒数第-k-个结点"><a href="#链表中倒数第-k-个结点" class="headerlink" title="链表中倒数第 k 个结点"></a>链表中倒数第 k 个结点</h4><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">FindKthToTail</span>(<span class="hljs-params"> pHead ,  k </span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> length = getLength(pHead);</span><br><span class="line">    <span class="hljs-keyword">if</span> (length &lt; k) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">let</span> i = length - k;</span><br><span class="line">    <span class="hljs-keyword">let</span> p = pHead;</span><br><span class="line">    <span class="hljs-keyword">while</span> (i &gt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">        p = p.next;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> getLength = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> pHead </span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> p = pHead;</span><br><span class="line">    <span class="hljs-keyword">let</span> length = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span>) &#123;</span><br><span class="line">        p = p.next;</span><br><span class="line">        length++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除链表的倒数第-n-个节点"><a href="#删除链表的倒数第-n-个节点" class="headerlink" title="删除链表的倒数第 n 个节点"></a>删除链表的倒数第 n 个节点</h4><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeNthFromEnd</span>(<span class="hljs-params"> head ,  n </span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> length = getLength(head);</span><br><span class="line">    <span class="hljs-keyword">if</span> (length &lt; n) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">let</span> i = length - n;</span><br><span class="line">    <span class="hljs-keyword">let</span> dummy = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    <span class="hljs-keyword">let</span> p = dummy;</span><br><span class="line">    <span class="hljs-keyword">while</span> (i &gt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">        p = p.next;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    p.next = p.next.next;</span><br><span class="line">    <span class="hljs-keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> getLength = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> head </span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> length = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">let</span> p = head;</span><br><span class="line">    <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span>) &#123;</span><br><span class="line">        p = p.next;</span><br><span class="line">        length ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除有序链表中重复的元素"><a href="#删除有序链表中重复的元素" class="headerlink" title="删除有序链表中重复的元素"></a>删除有序链表中重复的元素</h4><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deleteDuplicates</span>(<span class="hljs-params"> head </span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> p = head;</span><br><span class="line">    <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span> &amp;&amp; p.next != <span class="hljs-literal">null</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (p.val == p.next.val) &#123;</span><br><span class="line">            p.next = p.next.next;</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="交叉链表找交点"><a href="#交叉链表找交点" class="headerlink" title="交叉链表找交点"></a>交叉链表找交点</h4><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">FindFirstCommonNode</span>(<span class="hljs-params">pHead1, pHead2</span>)</span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (pHead1 == <span class="hljs-literal">null</span> || pHead2 == <span class="hljs-literal">null</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">let</span> p1 = pHead1, p2 = pHead2;</span><br><span class="line">    <span class="hljs-keyword">while</span> (p1 != p2) &#123;</span><br><span class="line">        p1 = p1 == <span class="hljs-literal">null</span> ? pHead2 : p1.next;</span><br><span class="line">        p2 = p2 == <span class="hljs-literal">null</span> ? pHead1 : p2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h4><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mergeTwoLists</span>(<span class="hljs-params"> l1 ,  l2 </span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> newHead = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">-1</span>);</span><br><span class="line">    <span class="hljs-keyword">let</span> p = newHead;</span><br><span class="line">    <span class="hljs-keyword">while</span>(l1 != <span class="hljs-literal">null</span> &amp;&amp; l2 != <span class="hljs-literal">null</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">            p.next = l1;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            p.next = l2;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span> (l1 != <span class="hljs-literal">null</span>) &#123;</span><br><span class="line">        p.next = l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span> (l2 != <span class="hljs-literal">null</span>) &#123;</span><br><span class="line">        p.next = l2;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="hljs-keyword">return</span> newHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链表算法题（ JavaScript 实现）&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="算法" scheme="http://soso.wiki/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="链表" scheme="http://soso.wiki/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>核桃编程面试题</title>
    <link href="http://soso.wiki/%E6%A0%B8%E6%A1%83%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://soso.wiki/核桃编程面试题/</id>
    <published>2021-04-28T05:00:00.000Z</published>
    <updated>2021-04-28T05:00:11.140Z</updated>
    
    <content type="html"><![CDATA[<p>核桃编程面试题<br><a id="more"></a></p><p>1.消息发送和消息转发的过程</p><p>2.KVO 的原理</p><p>3.能不能动态添加成员变量</p><p>4.分类为啥不能添加成员变量</p><p>5.说一下 HTTPS 和 TCP、UDP</p><p>6.说一下项目亮点</p><p>7.方法交换注意什么</p><p>8.链表反转</p><p>9.NSNumber 怎么进行优化的，数据存储哪里</p><p>10.GCD 和 NSOperation 各自的优点</p><p>11.Runtime 的应用</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;核桃编程面试题&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="核桃编程" scheme="http://soso.wiki/tags/%E6%A0%B8%E6%A1%83%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>字节跳动面试题</title>
    <link href="http://soso.wiki/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://soso.wiki/字节跳动面试题/</id>
    <published>2021-04-25T11:00:00.000Z</published>
    <updated>2021-05-25T03:42:24.845Z</updated>
    
    <content type="html"><![CDATA[<p>字节跳动面试题<br><a id="more"></a></p><h4 id="1-retain-strong-区别"><a href="#1-retain-strong-区别" class="headerlink" title="1.retain  strong 区别"></a>1.retain  strong 区别</h4><p>在声明 block 时，retain 相当于 assign，strong 相当于 copy，block一般使用 copy</p><h4 id="2-NSClassFromString-原理"><a href="#2-NSClassFromString-原理" class="headerlink" title="2.NSClassFromString 原理"></a>2.NSClassFromString 原理</h4><h5 id="反射方法"><a href="#反射方法" class="headerlink" title="反射方法"></a>反射方法</h5><p>系统<code>Foundation</code>框架为我们提供了一些方法反射的 API，我们可以通过这些 API 执行将字符串转为<code>SEL</code>等操作。由于<code>OC</code>语言的动态性，这些操作都是发生在运行时的。</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// SEL和字符串转换</span></span><br><span class="line">FOUNDATION_EXPORT <span class="hljs-built_in">NSString</span> *<span class="hljs-built_in">NSStringFromSelector</span>(SEL aSelector);</span><br><span class="line">FOUNDATION_EXPORT SEL <span class="hljs-built_in">NSSelectorFromString</span>(<span class="hljs-built_in">NSString</span> *aSelectorName);</span><br><span class="line"><span class="hljs-comment">// Class和字符串转换</span></span><br><span class="line">FOUNDATION_EXPORT <span class="hljs-built_in">NSString</span> *<span class="hljs-built_in">NSStringFromClass</span>(Class aClass);</span><br><span class="line">FOUNDATION_EXPORT Class __<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">NSClassFromString</span>(<span class="hljs-built_in">NSString</span> *aClassName);</span><br><span class="line"><span class="hljs-comment">// Protocol和字符串转换</span></span><br><span class="line">FOUNDATION_EXPORT <span class="hljs-built_in">NSString</span> *<span class="hljs-built_in">NSStringFromProtocol</span>(Protocol *proto) <span class="hljs-built_in">NS_AVAILABLE</span>(<span class="hljs-number">10</span>_5, <span class="hljs-number">2</span>_0);</span><br><span class="line">FOUNDATION_EXPORT Protocol * __<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">NSProtocolFromString</span>(<span class="hljs-built_in">NSString</span> *namestr) <span class="hljs-built_in">NS_AVAILABLE</span>(<span class="hljs-number">10</span>_5, <span class="hljs-number">2</span>_0);</span><br></pre></td></tr></table></figure><h5 id="常用判断方法"><a href="#常用判断方法" class="headerlink" title="常用判断方法"></a>常用判断方法</h5><p>在<code>NSObject</code>类中为我们提供了一些基础方法，用来做一些判断操作，这些方法都是发生在运行时动态判断的。</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 当前对象是否这个类或其子类的实例</span></span><br><span class="line">- (<span class="hljs-built_in">BOOL</span>)isKindOfClass:(Class)aClass;</span><br><span class="line"><span class="hljs-comment">// 当前对象是否是这个类的实例</span></span><br><span class="line">- (<span class="hljs-built_in">BOOL</span>)isMemberOfClass:(Class)aClass;</span><br><span class="line"><span class="hljs-comment">// 当前对象是否遵守这个协议</span></span><br><span class="line">- (<span class="hljs-built_in">BOOL</span>)conformsToProtocol:(Protocol *)aProtocol;</span><br><span class="line"><span class="hljs-comment">// 当前对象是否实现这个方法</span></span><br><span class="line">- (<span class="hljs-built_in">BOOL</span>)respondsToSelector:(SEL)aSelector;</span><br></pre></td></tr></table></figure><p>参考链接：<a href="https://www.jianshu.com/p/5bbde2480680" target="_blank" rel="noopener">iOS反射机制</a></p><h4 id="3-http协议版本"><a href="#3-http协议版本" class="headerlink" title="3.http协议版本"></a>3.http协议版本</h4><p><strong>1、HTTP 0.9 ：</strong><br>（1）只接受GET一种请求方法，没有在通信中指定版本号，且不支持请求头；</p><p>（2）此外该版本也不支持POST方法，因此客户端无法向服务器传递太多信息；</p><p><strong>2、HTTP 1.0：</strong><br>（1）支持POST、GET、HEAD三种方法；</p><p>（2）规定浏览器与服务器之间只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求；</p><p><strong>3、HTTP 1.1：</strong><br>（1）新增了五种请求方法：PUT、DELETE、CONNECT、TRACE、OPTIONS；</p><p>（2）HTTP 1.1 在Request消息头里头多了一个Host域，便于一台WEB服务器上可以在同一个IP地址和端口号上使用不同的主机名来创建多个虚拟WEB站点；</p><p>（3）长连接</p><p>（4）缓存策略不同</p><p>（5）在HTTP/1.1中新增了24个状态响应码：<br>100-199 用于指定客户端应相应的某些动作。<br>200-299 用于表示请求成功。<br>300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。<br>400-499 用于指出客户端的错误。<br>500-599 用于支持服务器错误。</p><p><strong>4、HTTP 2.0</strong></p><p>二进制传输：http 1.x 的解析是基于文本，http2的解析是基于二进制；</p><p>多路复用</p><p>header压缩</p><p>服务端推送</p><h4 id="4-http-code-206-401"><a href="#4-http-code-206-401" class="headerlink" title="4.http code 206  401"></a>4.http code 206  401</h4><p>206 Partial Content</p><p>最后一条会话返回了HTTP/206 “Partial Content”响应.这种响应是在客户端表明自己只需要目标URL上的部分资源的时候返回的.这种情况经常发生在客户端继续请求一个未完成的下载的时候(通常是当客户端加载一个体积较大的嵌入文件,比如视频或PDF文件),或者是客户端尝试实现带宽遏流的时候。</p><p>你可以通过<strong>Range</strong>请求头辨认出一个部分内容请求.该请求头表明了客户端需要请求资源的哪一部分。</p><p>401错误原因：用户没有访问权限，需要进行身份认证。</p><h5 id="http-常见的错误码"><a href="#http-常见的错误码" class="headerlink" title="http 常见的错误码"></a>http 常见的错误码</h5><p>2XX 成功</p><p>· 200 OK，表示从客户端发来的请求在服务器端被正确处理</p><p>· 204 No content，表示请求成功，但响应报文不含实体的主体部分</p><p>· 206 Partial Content，进行范围请求</p><p>3XX 重定向</p><p>· 301 moved permanently，永久性重定向，表示资源已被分配了新的 URL</p><p>· 302 found，临时性重定向，表示资源临时被分配了新的 URL</p><p>· 303 see other，表示资源存在着另一个 URL，应使用 GET 方法丁香获取资源</p><p>· 304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况</p><p>· 307 temporary redirect，临时重定向，和302含义相同</p><p>4XX 客户端错误</p><p>· 400 bad request，请求报文存在语法错误</p><p>· 401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息</p><p>· 403 forbidden，表示对请求资源的访问被服务器拒绝</p><p>· 404 not found，表示在服务器上没有找到请求的资源</p><p>5XX 服务器错误</p><p>· 500 internal sever error，表示服务器端在执行请求时发生了错误</p><p>· 503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求</p><h4 id="5-为什么三次握手，四次挥手"><a href="#5-为什么三次握手，四次挥手" class="headerlink" title="5.为什么三次握手，四次挥手"></a>5.为什么三次握手，四次挥手</h4><h4 id="6-dispatch-async-queue-block-会不会开线程"><a href="#6-dispatch-async-queue-block-会不会开线程" class="headerlink" title="6.dispatch_async(queue,block);会不会开线程"></a>6.dispatch_async(queue,block);会不会开线程</h4><p>除了主队列，其他队列都开线程。</p><h4 id="7-二叉树中和为某一值的路径"><a href="#7-二叉树中和为某一值的路径" class="headerlink" title="7.二叉树中和为某一值的路径"></a>7.二叉树中和为某一值的路径</h4><p>LeetCode题目链接：<a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/" target="_blank" rel="noopener">剑指 Offer 34. 二叉树中和为某一值的路径</a></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;(); </span><br><span class="line">    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="hljs-keyword">int</span> sum) &#123;</span><br><span class="line">        recur(root, sum);</span><br><span class="line">        <span class="hljs-keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">recur</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> tar)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;</span><br><span class="line">        path.add(root.val);</span><br><span class="line">        tar -= root.val;</span><br><span class="line">        <span class="hljs-keyword">if</span>(tar == <span class="hljs-number">0</span> &amp;&amp; root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>)</span><br><span class="line">            res.add(<span class="hljs-keyword">new</span> LinkedList(path));</span><br><span class="line">        recur(root.left, tar);</span><br><span class="line">        recur(root.right, tar);</span><br><span class="line">        path.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-Runtime"><a href="#8-Runtime" class="headerlink" title="8.Runtime"></a>8.Runtime</h4><h4 id="9-UIView-绘制过程"><a href="#9-UIView-绘制过程" class="headerlink" title="9.UIView 绘制过程"></a>9.UIView 绘制过程</h4><p><strong>UIView的绘制原理</strong></p><p><img src="/images/ios/UIView的绘制原理.png" alt="UIView的绘制原理"></p><p>当我们调用 UIView 的 setNeedsDisplay 方法以后,实际上并没有立刻发生当前视图的绘制工作,而是在之后的某一时机才会进行当前视图的绘制 。为什么没有立刻发生当前视图的绘制工作？（因为到当前 runloop 将要结束的时候,才会开始介入到UI视图的绘制流程中）</p><ul><li>当调用 UIView 的 setNeedsDisplay 后</li><li>系统会立刻调用 view 的 layer 的同名方法 [view.layer setNeedsDisplay] ,之后相当于在 layer 上面打上了一个脏标记</li><li>然后再当前 runloop 将要结束的时候,才会调用 CALayer 的 display 函数方法，然后才进入到当前视图的真正绘制工作的流程当中</li><li>CALayer 的 display 方法,在内部会首先判断 layer 的 delegate 是否响应 displayLayer 这个方法</li><li>若不响应,则系统开始绘制流程</li><li>若响应,则开始异步绘制</li></ul><p><strong>系统绘制流程</strong></p><p><img src="/images/ios/系统绘制流程.png" alt="系统绘制流程"></p><ul><li>首先 CALayer 内部会创建一个 CGContextRef ,在 drawRect 方法中,可以通过上下文堆栈当中的取出这个 context，拿到的就是当前控件或者说视图的上下文或者说是 backing store</li><li>然后 layer 会判断它是否有代理，若没有,则调用 CALayer 的 drawInContext。</li><li>若有则调用代理方法,然后做当前视图的绘制工作（这一步发生在系统内部当中）,再在合适的时机,基于 drawRect 回调方法,</li><li>drawRect 默认操作是什么都不做,而之所以有这个接口,就是为了让我们在系统绘制之上,可以做些自定义的绘制工作。</li><li>最后再由 CALayer 上传对应的 backing store 给 GPU,这里的 backing store 我们可以理解为位图。</li></ul><p><strong>异步绘制流程</strong></p><p><img src="/images/ios/异步绘制时序图.png" alt="异步绘制时序图"></p><ul><li>左侧是主队列，右侧是全局并发队列</li><li>假如在某一时机调用了 setNeedsDiaplay 方法后</li><li>在当前 runloop 将要结束的时候,会有系统调用视图所对应 layer 的 display 方法</li><li>如果代理实现了 displayLayer 方法,会调用这个代理的 displayLayer 这个方法</li><li>然后通过子线程的切换,我们会在子线程中去做位图的绘制，此时主线程可以去做些其他的工作</li><li>然后再回到主队列中,提交这个位图,设置给 CALayer 的 contents 属性</li></ul><p><strong>子线程的绘制</strong></p><ol><li>通过 CGBitmapContextCreat 方法,来创建一个位图的上下文</li><li>通过 CoreGraphic 的相关 API,可以做当前 UI 控件的一些绘制工作</li><li>之后通过 CGBitmapContextCreatImage 方法,根据所绘制的上下文,生成一张 CGImage 图片</li><li>最后回到主队列中，将该 <strong>CGImage</strong> 图片设置为 <strong>CALayer</strong> 的 <strong>contents</strong></li></ol><p>参考链接：<a href="https://blog.csdn.net/ochenmengo/article/details/104769773/" target="_blank" rel="noopener">UI绘制原理&amp;系统/异步绘制流程</a></p><p><a href="https://www.jianshu.com/p/1afd22268abc" target="_blank" rel="noopener">UIView的绘制原理及优化</a></p><h4 id="10-autoreleasepool"><a href="#10-autoreleasepool" class="headerlink" title="10.autoreleasepool"></a>10.autoreleasepool</h4><ul><li>子线程使用了 autorelease 后，如果当前线程没有 AutorelesepoolPage 的话，代码执行顺序为 autorelease -&gt; autoreleaseFast -&gt; autoreleaseNoPage。在 autoreleaseNoPage 方法中，会创建一个 hotPage ，然后调用page-&gt;add(obj) 。也就是说即使这个线程没有 AutorelesepoolPage ，使用了 autorelease 对象时也会 new 一个 AutoreleasepoolPage 出来管理 autorelese 对象。</li><li>子线程的 autoreleasepool 是在线程销毁的时候释放的。</li></ul><h4 id="11-VC生命周期，viewWillDisappear-和-viewDidDisappear-之间会不会调用view-的-layout"><a href="#11-VC生命周期，viewWillDisappear-和-viewDidDisappear-之间会不会调用view-的-layout" class="headerlink" title="11.VC生命周期，viewWillDisappear 和 viewDidDisappear 之间会不会调用view 的 layout"></a>11.VC生命周期，viewWillDisappear 和 viewDidDisappear 之间会不会调用view 的 layout</h4><p>push 会调用，pop 不会调用</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-number">1</span> push <span class="hljs-number">2</span></span><br><span class="line"><span class="hljs-number">2</span>-[<span class="hljs-number">2</span> loadView]</span><br><span class="line"><span class="hljs-number">2</span>-[<span class="hljs-number">2</span> viewDidLoad]</span><br><span class="line"><span class="hljs-number">1</span>-[<span class="hljs-number">1</span> viewWillDisappear:]</span><br><span class="line"><span class="hljs-number">2</span>-[<span class="hljs-number">2</span> viewWillAppear:]</span><br><span class="line"><span class="hljs-number">2</span>-[<span class="hljs-number">2</span> viewWillLayoutSubviews]</span><br><span class="line"><span class="hljs-number">2</span>-[<span class="hljs-number">2</span> viewDidLayoutSubviews]</span><br><span class="line"><span class="hljs-number">1</span>-[<span class="hljs-number">1</span> viewWillLayoutSubviews]</span><br><span class="line"><span class="hljs-number">1</span>-[<span class="hljs-number">1</span> viewDidLayoutSubviews]</span><br><span class="line"><span class="hljs-number">1</span>-[<span class="hljs-number">1</span> viewDidDisappear:]</span><br><span class="line"><span class="hljs-number">2</span>-[<span class="hljs-number">2</span> viewDidAppear:]</span><br></pre></td></tr></table></figure><h4 id="12-autorelease-调用-release-会立即销毁吗"><a href="#12-autorelease-调用-release-会立即销毁吗" class="headerlink" title="12.autorelease 调用 release 会立即销毁吗"></a>12.autorelease 调用 release 会立即销毁吗</h4><h4 id="13-GCD能不能取消任务"><a href="#13-GCD能不能取消任务" class="headerlink" title="13.GCD能不能取消任务"></a>13.GCD能不能取消任务</h4><ul><li><p>dispatch_block_cancel</p></li><li><p>定义外部变量，用于标记block是否需要取消</p></li></ul><p>参考链接：<a href="https://www.jianshu.com/p/c45f099c7fd4" target="_blank" rel="noopener">如何取消GCD任务</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;字节跳动面试题&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="字节跳动" scheme="http://soso.wiki/tags/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>平安面试题</title>
    <link href="http://soso.wiki/%E5%B9%B3%E5%AE%89%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://soso.wiki/平安面试题/</id>
    <published>2021-04-15T07:23:00.000Z</published>
    <updated>2021-05-18T02:57:15.889Z</updated>
    
    <content type="html"><![CDATA[<p>平安面试题<br><a id="more"></a></p><p>1.什么是多态？具体在项目中怎么用的？</p><p>2.说一下组件化开发（业务组件非UI组件）；</p><p>3.调用未实现的方法会发生什么，然后通过什么可以进行处理？消息转发的具体流程？消息转发流程在实际中的应用？</p><p>4.KVO 的原理？</p><p>5.分类的底层实现？</p><p>6.App 启动优化？热启动&amp;冷启动，具体优化？</p><p>7.Vue 的双向绑定？</p><p>8.说一下你对 Runloop 的理解，Runloop 的应用？</p><p>9.项目中具体是怎么用的多线程？</p><p>10.bug 管理工具？bug 率，日活？</p><p>11.项目中你的职责所在？</p><p>12.是否读过 SDWebImage，AFNetworking 底层？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;平安面试题&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="平安" scheme="http://soso.wiki/tags/%E5%B9%B3%E5%AE%89/"/>
    
  </entry>
  
  <entry>
    <title>美团优选面试题2及答案</title>
    <link href="http://soso.wiki/%E7%BE%8E%E5%9B%A2%E4%BC%98%E9%80%89%E9%9D%A2%E8%AF%95%E9%A2%982/"/>
    <id>http://soso.wiki/美团优选面试题2/</id>
    <published>2021-04-14T05:38:00.000Z</published>
    <updated>2021-05-24T13:04:38.884Z</updated>
    
    <content type="html"><![CDATA[<p>美团优选面试题2<br><a id="more"></a></p><p>介绍值得说的项目</p><h4 id="1-打印结果"><a href="#1-打印结果" class="headerlink" title="1.打印结果"></a>1.打印结果</h4><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="hljs-keyword">void</span>)someMethod &#123;</span><br><span class="line">  <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;</span><br><span class="line">   <span class="hljs-built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">       <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"%d"</span>,i);</span><br><span class="line">   &#125;);</span><br><span class="line">   i = <span class="hljs-number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>10</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="hljs-keyword">void</span>)someMethod &#123;</span><br><span class="line">  <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;</span><br><span class="line">   <span class="hljs-built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">       <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"%d"</span>,i);</span><br><span class="line">   &#125;);</span><br><span class="line">   i = <span class="hljs-number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>20</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="hljs-keyword">void</span>)someMethod &#123;</span><br><span class="line">  __block <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;</span><br><span class="line">   <span class="hljs-built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">       <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"%d"</span>,i);</span><br><span class="line">   &#125;);</span><br><span class="line">   i = <span class="hljs-number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>20</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="hljs-keyword">void</span>)someMethod &#123;</span><br><span class="line">   <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;</span><br><span class="line">   <span class="hljs-built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">       <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"%d"</span>,i);</span><br><span class="line">   &#125;);</span><br><span class="line">   i = <span class="hljs-number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>10</p><h4 id="2-load-和-initialize-的区别？-load-的调用时机"><a href="#2-load-和-initialize-的区别？-load-的调用时机" class="headerlink" title="2.+load 和 initialize 的区别？+load 的调用时机"></a>2.+load 和 initialize 的区别？+load 的调用时机</h4><p>1.调用方式</p><p>(1) load 是根据函数地址直接调用。</p><p>(2) initialize 是通过 objc_msgSend 调用。</p><p>2.调用时刻(什么时候会调用)</p><p>(1) load 是 runtime 加载类、分类的时候调用(只会调用一次)</p><p>(2) initialize 是类第一次接收到消息的时候调用，每一个类只会 initialize 一次(父类的 initialize 方法可能会被调用多次)。</p><h4 id="3-App-启动-pre-main-做了什么事情"><a href="#3-App-启动-pre-main-做了什么事情" class="headerlink" title="3.App 启动 pre-main 做了什么事情"></a>3.App 启动 pre-main 做了什么事情</h4><p>1.加载 dyld 到 App 进程（dyld 首先读取 mach-o Header 和 load commands，接着就知道了这个可执行文件依赖的动态库）<br>2.加载动态库（包括所依赖的所有动态库）<br>3.Rebase &amp; Bind (使用了ASLR地址空间布局随机化和 Code Sign 来保证应用的安全，Rebase 修正内部指针指向，Bind 修正外部指针指向)<br>4.初始化 Objective-C Runtime （Runtime 维护了一张映射类名与类的全局表，当加载一个 dylib 时，把类的信息注册到这个全局表中，也会把 Category 中的方法注册到对应的类中）<br>5.Initializers 其他初始化代码<br>6.dyld 调用 main() 函数，main() 函数调用 UIApplicationMain(),程序启动。</p><h4 id="4-KVO-的实现原理。"><a href="#4-KVO-的实现原理。" class="headerlink" title="4.KVO 的实现原理。"></a>4.KVO 的实现原理。</h4><ul><li>利用 Runtime API 动态生成一个子类，并且让 instance 对象的 isa 指向这个全新的子类</li><li>当修改 instance 对象的属性时，会调用 Foundation 的 _NSSetXXXValueAndNotify 函数<br>willChangeValueForKey:<br>父类原来的 setter<br>didChangeValueForKey:<br>内部会触发监听器（Oberser）的监听方法(observeValueForKeyPath:ofObject:change:context:）</li></ul><h4 id="5-KVC-的实现原理，是直接访问成员变量赋值吗？"><a href="#5-KVC-的实现原理，是直接访问成员变量赋值吗？" class="headerlink" title="5.KVC 的实现原理，是直接访问成员变量赋值吗？"></a>5.KVC 的实现原理，是直接访问成员变量赋值吗？</h4><p>按照 setKey:、_setKey: 顺序查找方法，找到方法调用。没找到继续。</p><p>查看 accessInstanceVariablesDirectly 方法的返回值。如果是 YES 继续。</p><p>按照<code>_key</code>、<code>_isKey</code>、<code>key</code>、<code>isKey</code>顺序查找成员变量。找到了直接赋值。</p><p>没找到成员变量：调用 setValue:forUndefinedKey: 并抛出异常NSUnknownKeyException</p><h4 id="6-autoreleasepool-什么时候释放？"><a href="#6-autoreleasepool-什么时候释放？" class="headerlink" title="6.autoreleasepool 什么时候释放？"></a>6.autoreleasepool 什么时候释放？</h4><ul><li>子线程使用了 autorelease 后，如果当前线程没有 AutorelesepoolPage 的话，代码执行顺序为 autorelease -&gt; autoreleaseFast -&gt; autoreleaseNoPage。在 autoreleaseNoPage 方法中，会创建一个 hotPage ，然后调用page-&gt;add(obj) 。也就是说即使这个线程没有 AutorelesepoolPage ，使用了 autorelease 对象时也会 new 一个 AutoreleasepoolPage 出来管理 autorelese 对象。</li><li>子线程的 autoreleasepool 是在线程销毁的时候释放的。</li></ul><h4 id="7-Category-添加一个属性系统做了什么？怎么添加属性？为什么不能添加成员变量。关联对象存在哪里？Category-里写了和类相同的方法会怎么样？"><a href="#7-Category-添加一个属性系统做了什么？怎么添加属性？为什么不能添加成员变量。关联对象存在哪里？Category-里写了和类相同的方法会怎么样？" class="headerlink" title="7.Category 添加一个属性系统做了什么？怎么添加属性？为什么不能添加成员变量。关联对象存在哪里？Category 里写了和类相同的方法会怎么样？"></a>7.Category 添加一个属性系统做了什么？怎么添加属性？为什么不能添加成员变量。关联对象存在哪里？Category 里写了和类相同的方法会怎么样？</h4><p>声明了 set 和 get 方法。</p><p>实现关联对象技术的核心对象有</p><ul><li><p>AssociationsManager：关联对象存储在全局的统一的一个 AssociationsManager 中</p></li><li><p>AssociationsHashMap：key 为对象，value 为 ObjectAssociationMap</p></li><li><p>ObjectAssociationMap：key 为关联对象的 key，value 为 ObjcAssociation</p></li><li><p>ObjcAssociation：存储 policy 和 value</p></li></ul><p>会先找到分类里的方法执行。</p><h4 id="8-isa-指向，元类对象-isa-指向哪里？NSObject-的-isa-指向哪里？为什么要设计类、元类？isa-的结构"><a href="#8-isa-指向，元类对象-isa-指向哪里？NSObject-的-isa-指向哪里？为什么要设计类、元类？isa-的结构" class="headerlink" title="8.isa 指向，元类对象 isa 指向哪里？NSObject 的 isa 指向哪里？为什么要设计类、元类？isa 的结构"></a>8.isa 指向，元类对象 isa 指向哪里？NSObject 的 isa 指向哪里？为什么要设计类、元类？isa 的结构</h4><p><img src="/images/ios/isa.png" alt="isa指向"></p><p>元类对象的 isa 指向基类的元类对象。NSObject 的 isa 指向它本身。</p><p>在 arm64 架构之前，isa 就是一个普通的指针，存储着 Class、Meta-Class 对象的内存地址</p><p>从 arm64 架构开始，对 isa 进行了优化，变成了一个共用体（union）结构，还使用位域来存储更多的信息</p><ul><li><p>nonpointer<br>0：代表普通的指针，存储着 Class、Meta-Class对象的内存地址<br>1：代表优化过，使用位域存储更多的信息</p></li><li><p>has_assoc<br>是否有设置过关联对象，如果没有，释放时会更快</p></li><li><p>has_cxx_dtor<br>是否有 C++ 的析构函数（.cxx_destruct），如果没有，释放时会更快</p></li><li><p>shiftcls<br>存储着 Class、Meta-Class 对象的内存地址信息</p></li><li><p>magic<br>用于在调试时分辨对象是否未完成初始化</p></li><li><p>weakly_referenced<br>是否有被弱引用指向过，如果没有，释放时会更快</p></li><li><p>deallocating<br>对象是否正在释放</p></li><li><p>extra_rc<br>里面存储的值是引用计数器减1</p></li><li><p>has_sidetable_rc<br>引用计数器是否过大无法存储在 isa 中<br>如果为1，那么引用计数会存储在一个叫 SideTable 的类的属性中</p></li></ul><h4 id="9-有做过卡顿检测吗？Runloop-检测卡顿怎么知道是哪个方法卡？方法卡了多长时间？"><a href="#9-有做过卡顿检测吗？Runloop-检测卡顿怎么知道是哪个方法卡？方法卡了多长时间？" class="headerlink" title="9.有做过卡顿检测吗？Runloop 检测卡顿怎么知道是哪个方法卡？方法卡了多长时间？"></a>9.有做过卡顿检测吗？Runloop 检测卡顿怎么知道是哪个方法卡？方法卡了多长时间？</h4><h4 id="10-有做闪退监测吗？bugly-是怎么实现的？crash-率是多少？crash-率是怎么算出来的？"><a href="#10-有做闪退监测吗？bugly-是怎么实现的？crash-率是多少？crash-率是怎么算出来的？" class="headerlink" title="10.有做闪退监测吗？bugly 是怎么实现的？crash 率是多少？crash 率是怎么算出来的？"></a>10.有做闪退监测吗？bugly 是怎么实现的？crash 率是多少？crash 率是怎么算出来的？</h4><p>crash 率 = 崩溃次数 / 活跃设备数</p><h4 id="11-两两交换链表中的结点"><a href="#11-两两交换链表中的结点" class="headerlink" title="11.两两交换链表中的结点"></a>11.两两交换链表中的结点</h4><p>实现反转单向链表的函数。<br>如 1-&gt;2-&gt;3-&gt;4 反转后变成 2-&gt;1-&gt;4-&gt;3</p><p>LeetCode题目链接：<a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">两两交换链表中的节点</a></p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> swapPairs = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> dummyNode = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);</span><br><span class="line">    dummyNode.next = head;</span><br><span class="line">    <span class="hljs-keyword">let</span> temp = dummyNode;</span><br><span class="line">    <span class="hljs-keyword">while</span> (temp.next != <span class="hljs-literal">null</span> &amp;&amp; temp.next.next != <span class="hljs-literal">null</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">let</span> head1 = temp.next;</span><br><span class="line">        <span class="hljs-keyword">let</span> head2 = temp.next.next;</span><br><span class="line">        temp.next = head2;</span><br><span class="line">        head1.next = head2.next;</span><br><span class="line">        head2.next = head1;</span><br><span class="line">        temp = head1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> dummyNode.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有什么想问我的？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;美团优选面试题2&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="美团" scheme="http://soso.wiki/tags/%E7%BE%8E%E5%9B%A2/"/>
    
      <category term="美团优选" scheme="http://soso.wiki/tags/%E7%BE%8E%E5%9B%A2%E4%BC%98%E9%80%89/"/>
    
  </entry>
  
  <entry>
    <title>美团面试题2及答案</title>
    <link href="http://soso.wiki/%E7%BE%8E%E5%9B%A2%E9%9D%A2%E8%AF%95%E9%A2%982/"/>
    <id>http://soso.wiki/美团面试题2/</id>
    <published>2021-04-14T02:38:00.000Z</published>
    <updated>2021-04-14T05:47:29.847Z</updated>
    
    <content type="html"><![CDATA[<p>美团面试题2<br><a id="more"></a></p><p>1.gcd, block,<code>__block</code>, <code>static</code><br>2.程序启动时执行了什么<br>3.runloop: 如何让一个 block 只在子线程runloop 上执行<br>4.autorelease 对象何时释放，主线程，子线程分别如何释放<br>5.isa指向的内存布局<br>6.如何定义一个只存在于栈的对象<br>7.线上卡顿监控<br>8.crash 触发流程，涉及的底层系统调用<br>9.链表反转： 1-&gt;2-&gt;3-&gt;4 反转为 2-&gt;1-&gt;4-&gt;3</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;美团面试题2&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="美团" scheme="http://soso.wiki/tags/%E7%BE%8E%E5%9B%A2/"/>
    
  </entry>
  
  <entry>
    <title>百度面试题</title>
    <link href="http://soso.wiki/%E7%99%BE%E5%BA%A6%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://soso.wiki/百度面试题/</id>
    <published>2021-04-13T10:00:00.000Z</published>
    <updated>2021-05-18T01:58:26.742Z</updated>
    
    <content type="html"><![CDATA[<p>百度面试题<br><a id="more"></a></p><h3 id="百度一面"><a href="#百度一面" class="headerlink" title="百度一面"></a>百度一面</h3><p>1.APP优化<br>2.列表快速滑动不需要加载的图片怎么处理<br>3.cell加载大图<br>4.异步绘制<br>5.交换方法<br>6.圆角的处理<br>7.监听子线程处理UI事件</p><h4 id="百度二面"><a href="#百度二面" class="headerlink" title="百度二面"></a>百度二面</h4><p>1.项目经验介绍（问rtmp协议，udp主动丢包策略）<br>2.项目中遇到什么难点<br>3.为什么要制作动态库  系统动态库会影响启动时间吗<br>4.https (ca证书验证流程)<br>5.category原理<br>6.异步发送通知  (NSNotificationQueue)<br>7.算法</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;百度面试题&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="百度" scheme="http://soso.wiki/tags/%E7%99%BE%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>iOS 面试技术点</title>
    <link href="http://soso.wiki/iOS%E9%9D%A2%E8%AF%95%E6%8A%80%E6%9C%AF%E7%82%B9/"/>
    <id>http://soso.wiki/iOS面试技术点/</id>
    <published>2021-04-03T16:06:00.000Z</published>
    <updated>2021-04-04T14:58:58.824Z</updated>
    
    <content type="html"><![CDATA[<p>iOS 面试技术点<br><a id="more"></a></p><table><thead><tr><th>问题</th><th>期望</th></tr></thead><tbody><tr><td>NSDicationary 的本质</td><td>理解哈希表，知道其遍历不是顺序的</td></tr><tr><td>ARC下内存泄漏的原因，循环引用时如何发生以及如何避免</td><td>理解ARC的机制从而知道内存泄漏的产生，并知道循环引用是如何产生和避免</td></tr><tr><td>常见的导致程序崩溃的原因</td><td>知道崩溃的原因本质是僵尸内存或指向错误，能够在实际开发中避免</td></tr><tr><td>使用多线程的几种方式</td><td>知道NSThread、NSOperationQueue和GCD三种多线程实现方式并能简单介绍应用实例，尤其要熟悉GCD的使用</td></tr><tr><td>如何实现一个单例</td><td>能够大体说出单例的实现原理，实现方法多多益善，能讲出各个实现方法的优缺点最好</td></tr><tr><td>NSArray和NSSet的区别以及使用时机</td><td>能够理解顺序表和集合的概念</td></tr><tr><td>NSInteger和int的区别</td><td>能知道NSInteger的位长大于等于int，考察对基础数据类型的理解</td></tr><tr><td>NSDictionary的快速构建方法以及注意事项</td><td>能够知道NSDictionary的快速构建方法，尤其要知道不可传nil的指针</td></tr><tr><td>介绍一下Autolayout和Autoresizing</td><td>考察对两种布局方法的理解，能够答题说出它们的原理</td></tr><tr><td>对象及ViewController的生命周期</td><td>对ViewController的生命周期有所了解</td></tr><tr><td>线程锁的几种使用方式</td><td>至少知道NSLock和synchronized，能够了解semaphore、递归锁、条件锁和分布锁可加分</td></tr><tr><td>block的使用以及注意事项</td><td>实际使用过block以及知道如何避免循环引用</td></tr><tr><td>strong、weak、retain、unsafe_unretain、assign、copy的区别以及使用场景</td><td>能够说出各个修饰符的作用</td></tr><tr><td>数据持久化的几种方式、应用场景和优缺点</td><td>至少知道NSUserDefault和Plist、文件三种保存方式，知道sqlite或CoreData可加分</td></tr><tr><td>如何进行一个http协议的网络请求</td><td>能够知道NSURLConnection或NSURLSession的使用方式</td></tr><tr><td>简介应用的生命周期</td><td>能够知道应用的生命周期，每个周期的回调是在什么时机</td></tr><tr><td>NSNotification的使用及注意事项</td><td>能够理解NSNotification的广播机制、传参以及避免key覆盖</td></tr><tr><td>NSUserDefault使用时应该注意什么</td><td>能够知道NSUserDefault本质是保存到plist文件，以及对象要实现NSCoder协议</td></tr><tr><td>OC Runtime介绍</td><td>对Objective-C的底层能够有自己的正确理解</td></tr><tr><td>OC Runloop介绍</td><td>对Objective-C的底层能够有自己的正确理解</td></tr><tr><td>Category的本质</td><td>对Objective-C的底层能够有自己的正确理解</td></tr><tr><td>函数式编程和ReactiveCocoa</td><td>对Objective-C的底层能够有自己的正确理解</td></tr><tr><td>block的实现原理</td><td>对Objective-C的底层能够有自己的正确理解</td></tr><tr><td>对Cocoa中UITableView、UILabel等组件的实现原理有自己的理解</td><td>能够通过组件的表象看到本质，考察编程经验和推导能力</td></tr><tr><td>介绍UIView的组成</td><td>能够对UIView有深入理解</td></tr><tr><td>介绍CoreGraphics、CoreAnimation、CoreText的技术架构及简单使用</td><td>能够熟悉和理解iOS开发中常用的Core系列库，能熟练使用它们</td></tr><tr><td>介绍Xcode的Build Settings和Build Phases中常用的设置</td><td>能够基本知道iOS项目的编译过程</td></tr><tr><td>一个iOS项目的大体编译、链接以及运行过程</td><td>能够基本知道iOS项目的编译过程</td></tr><tr><td>介绍Cocoapods（或其它包管理工具）的实现思路</td><td>能够基本知道iOS项目的编译过程</td></tr><tr><td>如何使用Xcode进行调试和排错</td><td>知道如何调试和排错</td></tr><tr><td>介绍Instruments中常用的功能</td><td>能够使用工具进行性能分析和监控</td></tr><tr><td>MVVM模式介绍及其优缺点</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iOS 面试技术点&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="技术点" scheme="http://soso.wiki/tags/%E6%8A%80%E6%9C%AF%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>美团优选面试题及答案</title>
    <link href="http://soso.wiki/%E7%BE%8E%E5%9B%A2%E4%BC%98%E9%80%89%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/"/>
    <id>http://soso.wiki/美团优选面试题及答案/</id>
    <published>2021-04-03T15:02:00.000Z</published>
    <updated>2021-04-06T06:31:40.823Z</updated>
    
    <content type="html"><![CDATA[<p>美团优选面试题<br><a id="more"></a></p><h4 id="技术栈是怎么选择的？为什么选择Flutter，没有选择RN"><a href="#技术栈是怎么选择的？为什么选择Flutter，没有选择RN" class="headerlink" title="技术栈是怎么选择的？为什么选择Flutter，没有选择RN"></a>技术栈是怎么选择的？为什么选择<code>Flutter</code>，没有选择<code>RN</code></h4><p><a href="https://www.jianshu.com/p/85a77bb8d926" target="_blank" rel="noopener"> Flutter 与 React Native 的对比分析</a></p><h3 id="1-链表环的入口结点（限制15分钟）"><a href="#1-链表环的入口结点（限制15分钟）" class="headerlink" title="1.链表环的入口结点（限制15分钟）"></a>1.链表环的入口结点（限制15分钟）</h3><p>算法1：遍历链表，使用Set去存一下</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">detectCycle</span>(<span class="hljs-params"> head </span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">const</span> visited = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();</span><br><span class="line">    <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (visited.has(head)) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        visited.add(head);</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法2：快慢指针</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">detectCycle</span>(<span class="hljs-params"> head </span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (!head) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;</span><br><span class="line">    <span class="hljs-keyword">let</span> slow = head, fast = head;</span><br><span class="line">    <span class="hljs-keyword">while</span>(fast.next &amp;&amp; fast.next.next) &#123;</span><br><span class="line">        fast = fast.next.next</span><br><span class="line">        slow = slow.next</span><br><span class="line">        <span class="hljs-keyword">if</span> (slow == fast) &#123;</span><br><span class="line">            <span class="hljs-keyword">var</span> a = head;</span><br><span class="line">            <span class="hljs-keyword">while</span> (slow != a) &#123;</span><br><span class="line">                a = a.next</span><br><span class="line">                slow = slow.next</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-首页的轮播图，滑动主区域-timer会不会停止？"><a href="#2-首页的轮播图，滑动主区域-timer会不会停止？" class="headerlink" title="2.首页的轮播图，滑动主区域 timer会不会停止？"></a>2.首页的轮播图，滑动主区域 timer会不会停止？</h3><p>Timer会停止。因为滑动时Runloop的mode由原来的DefaultMode切换到了UITrackingRunLoopMode。同一时间只能有一种mode。</p><p>解决方法其一是将timer加入到NSRunloopCommonModes中。其二是将timer放到另一个线程中，然后开启另一个线程的runloop，这样可以保证与主线程互不干扰，而现在主线程正在处理页面滑动。示例代码如下：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 方法1</span></span><br><span class="line">[[<span class="hljs-built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="hljs-built_in">NSRunLoopCommonModes</span>];</span><br><span class="line"><span class="hljs-comment">// 方法2</span></span><br><span class="line"><span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), ^&#123;</span><br><span class="line">timer = [<span class="hljs-built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="hljs-number">1</span> target:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(repeat:) userInfo:<span class="hljs-literal">nil</span> repeats:<span class="hljs-literal">true</span>];</span><br><span class="line">[[<span class="hljs-built_in">NSRunLoop</span> currentRunLoop] run];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="3-滑动屏幕，从响应者的角度和手势的角度来分析系统做了什么事情"><a href="#3-滑动屏幕，从响应者的角度和手势的角度来分析系统做了什么事情" class="headerlink" title="3.滑动屏幕，从响应者的角度和手势的角度来分析系统做了什么事情"></a>3.滑动屏幕，从响应者的角度和手势的角度来分析系统做了什么事情</h3><p>从手指触摸屏幕，触摸事件的传递大概经历了3个阶段，系统响应阶段–&gt;SpringBoard.app处理阶段–&gt;前台App处理阶段，大致的流程如下图：</p><p><img src="/images/ios/touch-event.png" alt="图1-事件的生命周期"></p><h5 id="起始阶段"><a href="#起始阶段" class="headerlink" title="起始阶段"></a>起始阶段</h5><ul><li>cpu处于睡眠阶段，等待事件发生</li><li>手指触摸屏幕</li></ul><h5 id="系统响应阶段"><a href="#系统响应阶段" class="headerlink" title="系统响应阶段"></a>系统响应阶段</h5><ul><li>屏幕感应到触摸事件，并将感应到的事件传递给IOKit(用来操作硬件和驱动的框架)</li><li>IOKit.framework封装整个触摸事件为IOHIDEvent对象，直接通过mach port(Mach属于硬件层，仅提供了诸如处理器调度、IPC进程通信等非常少量的基础服务。)转发给SpringBoard.app。</li></ul><h5 id="SpringBoard-app处理阶段"><a href="#SpringBoard-app处理阶段" class="headerlink" title="SpringBoard.app处理阶段"></a>SpringBoard.app处理阶段</h5><ul><li>SpringBoard.app的主线程Runloop收到IOKit.framework转发来的消息苏醒，并触发对应mach port的Source1回调__IOHIDEventSystemClientQueueCallback()。</li><li>如果SpringBoard.app监测到有App在前台(记为xxx.app)，SpringBoard.app再通过mach port转发给xxx.app，如果SpringBoard.app监测到前台没有App运行，则SpringBoard.app进入App内部响应阶段，触发自身主线程runloop的Source0时间源的回调。</li></ul><p>SpringBoard.app是一个系统进程，可以理解为桌面系统，可以统一管理和分发系统接收到的触摸事件。</p><h5 id="App内部响应阶段"><a href="#App内部响应阶段" class="headerlink" title="App内部响应阶段"></a>App内部响应阶段</h5><ul><li>前台App主线程Runloop收到SpringBoard.app转发来的消息而苏醒，并触发对应mach port的Source1回调__IOHIDEventSystemClientQueueCallback()。</li><li>Source1回调内部，触发Source0回调__UIApplicationHandleEventQueue()</li><li>Source0回调内部，封装IOHIDEvent为UIEvent。</li><li>Source0回调内部，调用UIApplication的sendEvent:方法，将UIEvent传给UIWindow，接下来就是寻找最佳响应者的过程，也就是命中测试hit-testing。</li><li>寻找到最佳响应者后，接下来就是事件在响应链中的传递和响应了。需要注意的是，事件除了可以被响应者处理之外，还有可能被手势识别器或者target-action捕捉并处理，这涉及到一个优先级的问题。如果触摸事件在响应链中没有找到能够响应该事件的对象，最终将被释放。</li><li>事件被处理或者释放之后，runloop如果没有其他事件进行处理，将会再次进入休眠状态。</li></ul><h4 id="寻找事件的最佳响应者-Hit-Testing"><a href="#寻找事件的最佳响应者-Hit-Testing" class="headerlink" title="寻找事件的最佳响应者(Hit-Testing)"></a>寻找事件的最佳响应者(Hit-Testing)</h4><p>能够响应触摸事件的例如UIView，UIButton，UIViewController，UIApplication，Appdelegate等都继承自UIResponder类，一个页面上通常会有许许多多个这种类型的对象，都可以对点击事件作出响应。为了避免冲突，这就需要有一个先后顺序，也就是响应的优先级。Hit-Testing的目的就是找到具有最高优先级的响应对象。<br>寻找的具体流程如下：</p><ol><li>UIApplication首先将事件队列中的事件取出，传递给窗口对象。如果有多个窗口，则优先询问windows数组的最后一个窗口。</li><li>如果窗口不能响应事件，则将事件传递给倒数第二个窗口，以此类推。如果窗口能够响应事件，则再依次询问该窗口的子视图。</li><li>重复步骤2。</li><li>若视图的所有子视图均不是最佳响应者，则自身就是最合适的响应者。<br>另外需要注意的是，一下几种状态的视图无法响应事件：</li></ol><ul><li>不允许交互的视图：userInteractionEnabled = NO</li><li>隐藏的视图：hidden = YES</li><li>透明度alpha&lt;0.01的视图</li></ul><p>怎么样验证一下上面所说的Hit-Testing的顺序呢，看一下UIView的API，里面会有一个hitTest：withEvent：方法，这个方法的主要作用就是查询并返回事件在当前视图中的响应者，每个被询问到的视图对象都会调用这个方法来返回当前视图层的响应者。</p><ul><li>如果当前视图无法响应事件，则返回nil。</li><li>如果当前视图可以响应事件，但子视图不能响应事件，则返回自身作为当前视图的响应者。</li><li>如果当前视图可以响应事件，同时有子视图可以响应事件，则返回该子视图作为当前视图的响应者。</li></ul><p>参考链接：<a href="https://www.jianshu.com/p/f73b4bdc73c7" target="_blank" rel="noopener">iOS触摸事件处理</a></p><p>扩展阅读：<a href="https://www.jianshu.com/p/c35ce0f0d1d4" target="_blank" rel="noopener">UIButton在执行动画的时候,点击事件不响应的解决办法</a></p><h3 id="4-网络请求回来后，回到主线程刷新UI，为什么有时候会延迟？"><a href="#4-网络请求回来后，回到主线程刷新UI，为什么有时候会延迟？" class="headerlink" title="4.网络请求回来后，回到主线程刷新UI，为什么有时候会延迟？"></a>4.网络请求回来后，回到主线程刷新UI，为什么有时候会延迟？</h3><p>主线程的RunLoop可能当时在处理的任务比较重，需要执行完后再执行刷新UI操作。</p><h3 id="5-performSelector了解吗？performSelector-afterDelay-怎么确保执行的线程不被销毁。"><a href="#5-performSelector了解吗？performSelector-afterDelay-怎么确保执行的线程不被销毁。" class="headerlink" title="5.performSelector了解吗？performSelector:afterDelay:怎么确保执行的线程不被销毁。"></a>5.performSelector了解吗？performSelector:afterDelay:怎么确保执行的线程不被销毁。</h3><p><code>[self performSelector:@selector(test) withObject:nil afterDelay:.0]</code>实际在runloop里面，是一个定时器，但是因为在子线程，runloop是默认没有开启的。</p><p>performSelector:afterDelay:之后开启runloop，即<code>[[NSRunLoop currentRunLoop] run];</code>。</p><p>port的生命周期结束，runloop也没了，那怎么保证runloop没销毁？</p><p>在子线程调用方法前去开启Runloop。</p><h3 id="6-谈谈autorelease和autoreleasepool"><a href="#6-谈谈autorelease和autoreleasepool" class="headerlink" title="6.谈谈autorelease和autoreleasepool"></a>6.谈谈autorelease和autoreleasepool</h3><p>autorelease的基本用法<br> 1) 会将对象放到一个自动释放池中<br> 2) 当自动释放池被销毁时，会对池子里面的所有对象做一次release操作<br> 3) 会返回对象本身<br> 4) 调用完autorelease方法后，对象的计数器不变</p><p>autorelease的具体使用方法</p><ul><li>生成并持有NSAutoreleasePool对象</li><li>调用已分配对象的autorelease实例方法</li><li>销毁NSAutoreleasePool对象</li></ul><p>NSAutoreleasePool对象生存周期相当于C语言的局部变量作用域，对所有调用过autorelease的实例方法的对象，在销毁NSAutoreleasePool对象时，都将调用release实例方法，即实例对象调用release方法。</p><p>当对象调用了autorelease方法是实现实际大致可以理解为是调用的NSAutoreleasePool调用了类方法addObject</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="hljs-keyword">void</span>)autorelease </span><br><span class="line">&#123;</span><br><span class="line">  [<span class="hljs-built_in">NSAutoreleasePool</span> addObject: <span class="hljs-keyword">self</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AutoreleasePool"><a href="#AutoreleasePool" class="headerlink" title="AutoreleasePool"></a>AutoreleasePool</h4><p>App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是<code>_wrapRunLoopWithAutoreleasePoolHandler()</code>。</p><p>第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用  <code>_objc_autoreleasePoolPush()</code> 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。</p><p>第二个 Observer 监视了两个事件：</p><ul><li><code>BeforeWaiting(准备进入休眠)</code> 时调用<code>_objc_autoreleasePoolPop()</code> 和 <code>_objc_autoreleasePoolPush()</code>释放旧的池并创建新池；</li><li><code>Exit(即将退出Loop)</code> 时调用 <code>_objc_autoreleasePoolPop()</code> 来释放自动释放池。</li></ul><h3 id="7-student类在读书方法里加代码，不改变原方法"><a href="#7-student类在读书方法里加代码，不改变原方法" class="headerlink" title="7.student类在读书方法里加代码，不改变原方法"></a>7.student类在读书方法里加代码，不改变原方法</h3><p>可以使用 Runtime 或者子类。</p><h4 id="iOS系统中有没有用类似的方法实现？"><a href="#iOS系统中有没有用类似的方法实现？" class="headerlink" title="iOS系统中有没有用类似的方法实现？"></a>iOS系统中有没有用类似的方法实现？</h4><p>KVO</p><h3 id="8-KVO实现原理，KVO打印实例对象的class为什么能够做到还是原本类。"><a href="#8-KVO实现原理，KVO打印实例对象的class为什么能够做到还是原本类。" class="headerlink" title="8.KVO实现原理，KVO打印实例对象的class为什么能够做到还是原本类。"></a>8.KVO实现原理，KVO打印实例对象的class为什么能够做到还是原本类。</h3><p>1) 利用RuntimeAPI动态生成一个子类，并且让instance对象的isa指向这个全新的子类<br>2) 当修改instance对象的属性时，会调用Foundation的_NSSetXXXValueAndNotify函数</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">willChangeValueForKey:</span><br><span class="line">父类原来的<span class="hljs-keyword">setter</span></span><br><span class="line">didChangeValueForKey:</span><br><span class="line">内部会触发监听器（Oberser）的监听方法( observeValueForKeyPath:ofObject:change:context:）</span><br></pre></td></tr></table></figure><p>注意事项：需要调用set方法触发KVO</p><p>实现了class方法，返回了父类。</p><h3 id="9-http-get和post区别"><a href="#9-http-get和post区别" class="headerlink" title="9.http get和post区别"></a>9.http get和post区别</h3><p>Get是安全的、幂等的、可缓存的、Get参数一般拼接在url的query参数里，有长度限制。</p><p>Post是不安全的、非幂等的、不可缓存的，Post的参数一般放在请求体里，相对安全。</p><h4 id="https的过程？"><a href="#https的过程？" class="headerlink" title="https的过程？"></a>https的过程？</h4><p><img src="/images/network/https.png" alt="https流程"></p><p><img src="/images/network/https-2.jpeg" alt="https流程"></p><p>一个HTTPS请求实际上包含了两次HTTP传输：</p><p>1）客户端发起一个http请求，连接到服务器的443端口。</p><p>2）服务端把自己的信息以数字证书的形式返回给客户端（证书内容有密钥公钥，网站地址，证书颁发机构，失效日期等）。证书中有一个公钥来加密信息，私钥由服务器持有。</p><p>3）验证证书的合法性</p><p>客户端收到服务器的响应后会先验证证书的合法性（证书中包含的地址与正在访问的地址是否一致，证书是否过期）。</p><p>4）生成随机密码（RSA签名）</p><p>如果验证通过，或用户接受了不受信任的证书，浏览器就会生成一个随机的对称密钥（session key）并用公钥加密，让服务端用私钥解密，解密后就用这个对称密钥进行传输了，并且能够说明服务端确实是私钥的持有者。</p><p>5）生成对称加密算法</p><p>验证完服务端身份后，客户端生成一个对称加密的算法和对应密钥，以公钥加密之后发送给服务端。此时被黑客截获也没用，因为只有服务端的私钥才可以对其进行解密。之后客户端与服务端可以用这个对称加密算法来加密和解密通信内容了。</p><p>6）客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器。</p><p>7）服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。</p><p>8）然后服务器将加密后的密文发送给客户端。</p><p>9）客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成。</p><h4 id="https是绝对的安全吗？怎么保证安全性？"><a href="#https是绝对的安全吗？怎么保证安全性？" class="headerlink" title="https是绝对的安全吗？怎么保证安全性？"></a>https是绝对的安全吗？怎么保证安全性？</h4><p>不是，可以被抓包。</p><h4 id="抓包的原理？"><a href="#抓包的原理？" class="headerlink" title="抓包的原理？"></a>抓包的原理？</h4><p>Charles作用其实相当于拦截器，当客户端和服务器通信时，Charles其实会先接收到服务器的证书，但是它会自己生成一个证书发送给客户端(不管是Web端或App应用)，也就是说它不仅仅是拦截，甚至还可以修改。</p><p>由于Charles更改了证书，所以如果你是使用的Web浏览器，需要导入相应的Charles证书，否则校验不通过会给出安全警告，必须安装Charles的证书后才能进行正常访问。</p><p><img src="/images/network/charles.jpeg" alt="抓包的原理"></p><p>1) Charles拦截客户端的请求。</p><p>2) 服务器向“客户端”（实际上是Charles）返回服务器的CA证书</p><p>3) Charles拦截服务器的响应，获取服务器证书公钥，然后自己制作一张证书，将服务器证书替换后发送给客户端。（这一步，Charles拿到了服务器证书的公钥）</p><p>4) 客户端接收到“服务器”（实际上是Charles）的证书后，生成一个对称密钥，用Charles的公钥加密，发送给“服务器”（Charles）</p><p>5) Charles拦截客户端的响应，用自己的私钥解密对称密钥，然后用服务器证书公钥加密，发送给服务器。（这一步，Charles拿到了对称密钥）</p><p>6) 服务器用自己的私钥解密对称密钥，向“客户端”（Charles）发送响应</p><p>7) Charles拦截服务器的响应，替换成自己的证书后发送给客户端</p><p>至此，连接建立，Charles拿到了服务器证书的公钥和客户端与服务器协商的对称密钥，之后就可以解密或者修改加密的报文了。</p><p>Charles作为“中间人代理”，拿到了服务器证书公钥和 HTTPS 连接的对称密钥，前提是客户端选择信任并安装Charles的CA证书，否则客户端就会“报警”并中止连接。这样看来，HTTPS还是很安全的。</p><h4 id="怎么避免被抓包？"><a href="#怎么避免被抓包？" class="headerlink" title="怎么避免被抓包？"></a>怎么避免被抓包？</h4><p>判断是否有代理，如果有，</p><p>1）可以取消本次的网络请求。</p><p>2）可以取消掉代理，直连服务端。</p><p>校验证书、不使用http，使用更底层的协议。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;美团优选面试题&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="美团" scheme="http://soso.wiki/tags/%E7%BE%8E%E5%9B%A2/"/>
    
      <category term="美团优选" scheme="http://soso.wiki/tags/%E7%BE%8E%E5%9B%A2%E4%BC%98%E9%80%89/"/>
    
  </entry>
  
  <entry>
    <title>小米面试题及答案</title>
    <link href="http://soso.wiki/%E5%B0%8F%E7%B1%B3%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://soso.wiki/小米面试题/</id>
    <published>2021-04-03T14:38:00.000Z</published>
    <updated>2021-04-15T06:37:21.244Z</updated>
    
    <content type="html"><![CDATA[<p>小米面试题<br><a id="more"></a></p><h4 id="1-说说你了解的设计模式。说说你了解的设计原则。"><a href="#1-说说你了解的设计模式。说说你了解的设计原则。" class="headerlink" title="1.说说你了解的设计模式。说说你了解的设计原则。"></a>1.说说你了解的设计模式。说说你了解的设计原则。</h4><h5 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h5><p>1、开闭原则（Open Close Principle）</p><p>开闭原则的意思是：<strong>对扩展开放，对修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p><p>2、里氏代换原则（Liskov Substitution Principle）</p><p>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p><p>3、依赖倒转原则（Dependence Inversion Principle）</p><p>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</p><p>4、接口隔离原则（Interface Segregation Principle）</p><p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p><p>5、迪米特法则，又称最少知道原则（Demeter Principle）</p><p>最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p><p>6、合成复用原则（Composite Reuse Principle）</p><p>合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。</p><h5 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h5><p>装饰模式：在不改变原封装的前提下，为对象动态添加新功能的模式。在 Objective-C 中，它的实现形式为 Category 和 Delegation；在 Swift 中，它的实现形式为 Extension 和 Delegation。</p><p>观察者模式：通知、KVO</p><p>备忘录模式：保存对象当前的状态，并在日后可以恢复的模式。用 UserDefaults 来读写，同时配合栈可以存储一系列状态。它经常用于初始化、重启、App 前后台状态改变等场景。</p><p>工厂模式</p><p>单例模式</p><h4 id="2-什么是队列？同步异步是什么？GCD与NSOperation的相同与不同，使用场景。"><a href="#2-什么是队列？同步异步是什么？GCD与NSOperation的相同与不同，使用场景。" class="headerlink" title="2.什么是队列？同步异步是什么？GCD与NSOperation的相同与不同，使用场景。"></a>2.什么是队列？同步异步是什么？GCD与NSOperation的相同与不同，使用场景。</h4><p>GCD的队列可以分为2大类型<br>并发队列（Concurrent Dispatch Queue）</p><ul><li><p>可以让多个任务并发（同时）执行（自动开启多个线程同时执行任务）</p></li><li><p>并发功能只有在异步（dispatch_async）函数下才有效</p></li></ul><p>串行队列（Serial Dispatch Queue）</p><ul><li>让任务一个接着一个地执行（一个任务执行完毕后，再执行下一个任务）</li></ul><p>同步和异步主要影响：能不能开启新的线程</p><ul><li>同步：在当前线程中执行任务，不具备开启新线程的能力</li><li>异步：在新的线程中执行任务，具备开启新线程的能力</li></ul><p>并发和串行主要影响：任务的执行方式</p><ul><li>并发：多个任务并发（同时）执行</li><li>串行：一个任务执行完毕后，再执行下一个任务</li></ul><table><thead><tr><th></th><th>并发队列</th><th>手动创建的串行队列</th><th>主队列</th></tr></thead><tbody><tr><td>同步（sync）</td><td>没有开启新线程，串行执行任务</td><td>没有开启新线程，串行执行任务</td><td>没有开启新线程，串行执行任务</td></tr><tr><td>异步（async）</td><td>有开启新线程，并发执行任务</td><td>有开启新线程，串行执行任务</td><td>没有开启新线程，串行执行任务</td></tr></tbody></table><p>使用sync函数往当前串行队列中添加任务，会卡住当前的串行队列（产生死锁）</p><h4 id="3-Block，本质，指针引用，值引用，变量捕获（static和auto），-weak-block"><a href="#3-Block，本质，指针引用，值引用，变量捕获（static和auto），-weak-block" class="headerlink" title="3.Block，本质，指针引用，值引用，变量捕获（static和auto），__weak __block"></a>3.Block，本质，指针引用，值引用，变量捕获（static和auto），<code>__weak</code> <code>__block</code></h4><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">NSMutableArray</span> *array = <span class="hljs-literal">nil</span>;</span><br><span class="line"><span class="hljs-keyword">void</span>(^Block)(<span class="hljs-keyword">void</span>) = ^&#123;</span><br><span class="line">array = [<span class="hljs-built_in">NSMutableArray</span> array];</span><br><span class="line">&#125;;</span><br><span class="line">Block();</span><br></pre></td></tr></table></figure><h5 id="有什么问题？"><a href="#有什么问题？" class="headerlink" title="有什么问题？"></a>有什么问题？</h5><p>局部变量是值捕获，不能在block内部修改。</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">NSMutableArray</span> *array = [<span class="hljs-built_in">NSMutableArray</span> array];</span><br><span class="line"><span class="hljs-keyword">void</span>(^Block)(<span class="hljs-keyword">void</span>) = ^&#123;</span><br><span class="line">[array addObject:<span class="hljs-string">"1"</span>];</span><br><span class="line">&#125;;</span><br><span class="line">Block();</span><br></pre></td></tr></table></figure><h5 id="有什么问题？-1"><a href="#有什么问题？-1" class="headerlink" title="有什么问题？"></a>有什么问题？</h5><p>没问题，可以添加元素</p><h4 id="4-交叉链表找交点"><a href="#4-交叉链表找交点" class="headerlink" title="4.交叉链表找交点"></a>4.交叉链表找交点</h4><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">FindFirstCommonNode</span>(<span class="hljs-params">pHead1, pHead2</span>)</span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (pHead1 == <span class="hljs-literal">null</span> || pHead2 == <span class="hljs-literal">null</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">let</span> p1 = pHead1, p2 = pHead2;</span><br><span class="line">    <span class="hljs-keyword">while</span> (p1 != p2) &#123;</span><br><span class="line">        p1 = p1 == <span class="hljs-literal">null</span> ? pHead2 : p1.next;</span><br><span class="line">        p2 = p2 == <span class="hljs-literal">null</span> ? pHead1 : p2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-性能优化，启动优化"><a href="#5-性能优化，启动优化" class="headerlink" title="5.性能优化，启动优化"></a>5.性能优化，启动优化</h4><h5 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h5><ol><li>cell复用，header、footer复用。</li><li>尽量把view设置不透明。</li><li>减少视图的层级。</li><li>尽量避免调整视图层次、添加和移除视图。</li><li>合理选择加载图片的方式，UIImage imageNamed: ImageAssets 用于多个地方重复使用，UIImage imageWithContentsOfFile 一般用在图片数据很大，一般不需要多次使用的情况。</li><li>图片大小最好和UIImageView的大小相同。</li><li>不要阻塞主线程，耗时操作放在子线程进行。</li><li>懒加载。</li><li>缓存，缓存图片SDWebImage，缓存行高，NSCache缓存。</li><li>复用高开销对象NSDateFormatter和NSCalendar。</li><li>减少离屏渲染，优化圆角、阴影。</li><li>使用正确的数据存储。</li></ol><h5 id="启动优化"><a href="#启动优化" class="headerlink" title="启动优化"></a>启动优化</h5><ol><li>将一些耗时操作延迟执行。比如SDK的初始化，界面的创建。</li><li>不能延迟执行的，尽量放到后台执行。比如数据读取，原始 JSON 数据转对象，日志发送。</li><li>减少动态库、合并动态库，定期清理不必要的动态库。</li><li>减少类、分类的数量，合并Category和功能类似的类。删除不必要的方法和类、分类。</li><li>将不必须在+load中做的事延时到+initialize中。</li></ol><h4 id="6-谈谈https"><a href="#6-谈谈https" class="headerlink" title="6.谈谈https"></a>6.谈谈https</h4><p><img src="/images/network/https-2.jpeg" alt="https流程"></p><p>一个HTTPS请求实际上包含了两次HTTP传输：</p><p>1）客户端发起一个http请求，连接到服务器的443端口。</p><p>2）服务端把自己的信息以数字证书的形式返回给客户端（证书内容有密钥公钥，网站地址，证书颁发机构，失效日期等）。证书中有一个公钥来加密信息，私钥由服务器持有。</p><p>3）验证证书的合法性</p><p>客户端收到服务器的响应后会先验证证书的合法性（证书中包含的地址与正在访问的地址是否一致，证书是否过期）。</p><p>4）生成随机密码（RSA签名）</p><p>如果验证通过，或用户接受了不受信任的证书，浏览器就会生成一个随机的对称密钥（session key）并用公钥加密，让服务端用私钥解密，解密后就用这个对称密钥进行传输了，并且能够说明服务端确实是私钥的持有者。</p><p>5）生成对称加密算法</p><p>验证完服务端身份后，客户端生成一个对称加密的算法和对应密钥，以公钥加密之后发送给服务端。此时被黑客截获也没用，因为只有服务端的私钥才可以对其进行解密。之后客户端与服务端可以用这个对称加密算法来加密和解密通信内容了。</p><p>6）客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器。</p><p>7）服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。</p><p>8）然后服务器将加密后的密文发送给客户端。</p><p>9）客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成。</p><h4 id="7-说说响应链"><a href="#7-说说响应链" class="headerlink" title="7.说说响应链"></a>7.说说响应链</h4><p>能够响应触摸事件的例如UIView，UIButton，UIViewController，UIApplication，Appdelegate等都继承自UIResponder类，一个页面上通常会有许许多多个这种类型的对象，都可以对点击事件作出响应。为了避免冲突，这就需要有一个先后顺序，也就是响应的优先级。Hit-Testing的目的就是找到具有最高优先级的响应对象。<br>寻找的具体流程如下：</p><ol><li>UIApplication首先将事件队列中的事件取出，传递给窗口对象。如果有多个窗口，则优先询问windows数组的最后一个窗口。</li><li>如果窗口不能响应事件，则将事件传递给倒数第二个窗口，以此类推。如果窗口能够响应事件，则再依次询问该窗口的子视图。</li><li>重复步骤2。</li><li>若视图的所有子视图均不是最佳响应者，则自身就是最合适的响应者。<br>另外需要注意的是，一下几种状态的视图无法响应事件：</li></ol><ul><li>不允许交互的视图：userInteractionEnabled = NO</li><li>隐藏的视图：hidden = YES</li><li>透明度alpha&lt;0.01的视图</li></ul><p>怎么样验证一下上面所说的Hit-Testing的顺序呢，看一下UIView的API，里面会有一个hitTest：withEvent：方法，这个方法的主要作用就是查询并返回事件在当前视图中的响应者，每个被询问到的视图对象都会调用这个方法来返回当前视图层的响应者。</p><ul><li>如果当前视图无法响应事件，则返回nil。</li><li>如果当前视图可以响应事件，但子视图不能响应事件，则返回自身作为当前视图的响应者。</li><li>如果当前视图可以响应事件，同时有子视图可以响应事件，则返回该子视图作为当前视图的响应者。</li></ul><h4 id="8-你知道哪些锁？（自旋锁，互斥锁）使用场景都有哪些？"><a href="#8-你知道哪些锁？（自旋锁，互斥锁）使用场景都有哪些？" class="headerlink" title="8.你知道哪些锁？（自旋锁，互斥锁）使用场景都有哪些？"></a>8.你知道哪些锁？（自旋锁，互斥锁）使用场景都有哪些？</h4><p>os_unfair_lock<br>OSSpinLock<br>dispatch_semaphore<br>pthread_mutex<br>NSLock<br>NSCondition<br>pthread_mutex(recursive)<br>NSRecursiveLock<br>NSConditionLock<br>@synchronized</p><p>线程同步</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;小米面试题&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="小米" scheme="http://soso.wiki/tags/%E5%B0%8F%E7%B1%B3/"/>
    
  </entry>
  
  <entry>
    <title>滴滴出行面试题及答案</title>
    <link href="http://soso.wiki/%E6%BB%B4%E6%BB%B4%E5%87%BA%E8%A1%8C%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/"/>
    <id>http://soso.wiki/滴滴出行面试题及答案/</id>
    <published>2021-04-02T09:06:00.000Z</published>
    <updated>2021-04-06T07:02:50.406Z</updated>
    
    <content type="html"><![CDATA[<p>滴滴出行面试题<br><a id="more"></a></p><h2 id="1-笔试题"><a href="#1-笔试题" class="headerlink" title="1. 笔试题"></a>1. 笔试题</h2><h4 id="0-姓名？日期。"><a href="#0-姓名？日期。" class="headerlink" title="0.姓名？日期。"></a>0.姓名？日期。</h4><h4 id="1-C语言实现字符串反转：void-reverse-char-str-int-length"><a href="#1-C语言实现字符串反转：void-reverse-char-str-int-length" class="headerlink" title="1.C语言实现字符串反转：void reverse(char *str, int length) {}"></a>1.C语言实现字符串反转：<code>void reverse(char *str, int length) {}</code></h4><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *str, <span class="hljs-keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">char</span> *start, *end, t;</span><br><span class="line">start = str;</span><br><span class="line">end = &amp;str[length - <span class="hljs-number">1</span>];</span><br><span class="line"><span class="hljs-keyword">while</span>(start &lt; end) &#123;</span><br><span class="line">t = *start;</span><br><span class="line">*start = *end;</span><br><span class="line">*end = t;</span><br><span class="line">start++;</span><br><span class="line">end--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; str[i]; i++) &#123;</span><br><span class="line"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c"</span>,str[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-实现一个字符串数组去重函数。"><a href="#2-实现一个字符串数组去重函数。" class="headerlink" title="2.实现一个字符串数组去重函数。"></a>2.实现一个字符串数组去重函数。</h4><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> str_arr = [<span class="hljs-string">"b"</span>,<span class="hljs-string">"c"</span>,<span class="hljs-number">1</span>,<span class="hljs-string">"a"</span>, <span class="hljs-number">3</span>,<span class="hljs-string">"v"</span>, <span class="hljs-string">"2"</span>,<span class="hljs-string">"e"</span>, <span class="hljs-string">"6"</span>,<span class="hljs-string">"g"</span>, <span class="hljs-string">"9"</span>, <span class="hljs-string">"arr"</span>,<span class="hljs-number">9</span>, <span class="hljs-string">"hello"</span>,<span class="hljs-string">",6"</span>, <span class="hljs-string">"9"</span>, <span class="hljs-string">"1"</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>];</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unique</span>(<span class="hljs-params">arr</span>) </span>&#123;</span><br><span class="line"><span class="hljs-keyword">var</span> map = &#123;&#125;, array = [];</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"><span class="hljs-keyword">var</span> key = arr[i] + <span class="hljs-keyword">typeof</span> arr[i];</span><br><span class="line"><span class="hljs-keyword">if</span> (map[key] == <span class="hljs-literal">null</span>) &#123;</span><br><span class="line">map[key] = <span class="hljs-literal">true</span>;</span><br><span class="line">array.push(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-描述OC中对象的实现原理。"><a href="#3-描述OC中对象的实现原理。" class="headerlink" title="3.描述OC中对象的实现原理。"></a>3.描述OC中对象的实现原理。</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@interface NSObject &#123;</span><br><span class="line">Class isa;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">typedef struct objc_class *Class;</span><br></pre></td></tr></table></figure><p>NSObject对象内部存放了一个名叫<code>isa</code>的指针，指向了一个结构体<code>struct objc_class</code></p><p>一个NSObject对象占用多少内存？<br> 1）系统分配了16字节给NSObject对象（通过<code>malloc_size</code>函数可以获得）<br> 2）NSObject对象内部只使用了8个字节的空间，用来存放<code>isa</code>指针变量（64位系统下，可以通过<code>class_getInstanceSize</code>函数获得）</p><h4 id="4-编写代码，实现-NSObject-中添加一个属性-p1"><a href="#4-编写代码，实现-NSObject-中添加一个属性-p1" class="headerlink" title="4.编写代码，实现 NSObject 中添加一个属性 p1"></a>4.编写代码，实现 NSObject 中添加一个属性 p1</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@interface NSObject (TestProperty)</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *p1;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">  </span><br><span class="line">#import &quot;NSObject+TestProperty.h&quot;</span><br><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line"></span><br><span class="line">@implementation NSObject (TestProperty)</span><br><span class="line"></span><br><span class="line">- (void)setP1:(NSString *)p1 &#123;</span><br><span class="line">    </span><br><span class="line">    objc_setAssociatedObject(self, @selector(p1), p1, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)p1 &#123;</span><br><span class="line">    </span><br><span class="line">    objc_getAssociatedObject(self, @selector(p1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h4 id="5-KVO-的实现原理和注意事项。"><a href="#5-KVO-的实现原理和注意事项。" class="headerlink" title="5.KVO 的实现原理和注意事项。"></a>5.KVO 的实现原理和注意事项。</h4><p>1) 利用RuntimeAPI动态生成一个子类，并且让instance对象的isa指向这个全新的子类<br>2) 当修改instance对象的属性时，会调用Foundation的_NSSetXXXValueAndNotify函数</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">willChangeValueForKey:</span><br><span class="line">父类原来的setter</span><br><span class="line">didChangeValueForKey:</span><br><span class="line">内部会触发监听器（Oberser）的监听方法( observeValueForKeyPath:ofObject:change:context:）</span><br></pre></td></tr></table></figure><p>注意事项：需要调用set方法触发KVO</p><h4 id="6-下面的代码有哪些问题？"><a href="#6-下面的代码有哪些问题？" class="headerlink" title="6.下面的代码有哪些问题？"></a>6.下面的代码有哪些问题？</h4><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Demo</span> : <span class="hljs-title">NSObject</span></span></span><br><span class="line"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">assign</span>) <span class="hljs-built_in">BOOL</span> *p1;</span><br><span class="line"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSString</span> *p2;</span><br><span class="line"><span class="hljs-keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Demo</span></span></span><br><span class="line"><span class="hljs-keyword">@dynamic</span> p1;</span><br><span class="line"></span><br><span class="line">- (<span class="hljs-keyword">void</span>)setP2:(<span class="hljs-built_in">NSString</span> *)p2;</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">self</span>.p1 = <span class="hljs-literal">YES</span>;</span><br><span class="line"><span class="hljs-keyword">self</span>.p2 = p2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">@end</span></span><br></pre></td></tr></table></figure><p>BOOL p1不应该带*。</p><p>self.p2 = p2; 调用set方法死循环。</p><p>p1没有set方法。</p><p>p2最好用copy修饰。</p><h4 id="7-JS-和-Native-的通讯方式。"><a href="#7-JS-和-Native-的通讯方式。" class="headerlink" title="7.JS 和 Native 的通讯方式。"></a>7.JS 和 Native 的通讯方式。</h4><p>方法一：拦截URL</p><p>方法二：注册OC与JS方法</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- （void）webViewDidFinishLoad:(UIWebView *)webView &#123;</span><br><span class="line"></span><br><span class="line">    // 获取当前网页的标题    NSString *titleStr = [webView stringByEvaluatingJavaScriptFromString:@&quot;document.title&quot;];</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;%@&quot;,titleStr);</span><br><span class="line"></span><br><span class="line">    // 还可以直接调用js定义的方法    // 比如getShareUrl()为js端定义好的方法，返回值为分享的url    // 我们就可以通过调用这个方法在returnStr中拿到js返回的分享地址    </span><br><span class="line"></span><br><span class="line">NSString *returnStr = [webView stringByEvaluatingJavaScriptFromString:@&quot;getShareUrl()&quot;];</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;%@&quot;,returnStr);</span><br><span class="line"></span><br><span class="line">    // 还可以为js端提供完整的原生方法供其调用（记得导入#import ）   </span><br><span class="line"></span><br><span class="line"> JSContext *context = [webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;];</span><br><span class="line"></span><br><span class="line">    // 可以定义供js调用的方法, testMethod为js调用的方法名    </span><br><span class="line"></span><br><span class="line">context[@&quot;testMethod&quot;] = ^() &#123;</span><br><span class="line"></span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line"></span><br><span class="line">            UIAlertView *alert = [[UIAlertView alloc]initWithTitle:@&quot;&quot; message:@&quot;js调用方法&quot; delegate:nil cancelButtonTitle:@&quot;取消&quot; otherButtonTitles:nil, nil];</span><br><span class="line"></span><br><span class="line">            [alert show];</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>方法三：桥接机制</p><p>OC和JS交互的桥接机制，主要包含3个类，JS端window.WebViewJavascriptBridge，OC端WebViewJavascriptBridge和WebViewJavascriptBridgeBase。</p><p>桥接类支持JS调用OC方法，OC调用JS方法。JS调用OC通过重定向url并取handlerName来调用，OC调用JS通过stringByEvaluatingJavaScriptFromString调用。</p><h4 id="8-网络5层模型是哪5层？"><a href="#8-网络5层模型是哪5层？" class="headerlink" title="8.网络5层模型是哪5层？"></a>8.网络5层模型是哪5层？</h4><p>应用层、传输层、网络层、数据链路层、物理层</p><h4 id="9-把t1表中-name-为-mike-的记录中-status-值改为1"><a href="#9-把t1表中-name-为-mike-的记录中-status-值改为1" class="headerlink" title="9.把t1表中 name 为 mike 的记录中 status 值改为1"></a>9.把t1表中 name 为 mike 的记录中 status 值改为1</h4><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">update</span> t1 <span class="hljs-keyword">set</span> <span class="hljs-keyword">status</span> = <span class="hljs-number">1</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">name</span> = mike</span><br></pre></td></tr></table></figure><h4 id="10-常用的-Linux-命令。"><a href="#10-常用的-Linux-命令。" class="headerlink" title="10.常用的 Linux 命令。"></a>10.常用的 Linux 命令。</h4><p>cd 进入指定的目录</p><p>cd .. 返回上一级目录</p><p>ls 查看当前目录下的所有的目录与文件名</p><p>touch filename 表示创建一个文件</p><p>mkdir dirname 表示创建一个目录</p><p>rm filename 表示删除一个文件</p><p>rm -rf dirname 表示删除该目录及其所有的子级目录一起删掉</p><p>ctrl+c 强制终止，不会终止进程</p><p>sudo 以管理员身份运行上一个命令</p><p>:q 退出</p><p>:q! 强制退出</p><p>:wq 保存并退出</p><h4 id="11-用过的包-库管理工具。"><a href="#11-用过的包-库管理工具。" class="headerlink" title="11.用过的包/库管理工具。"></a>11.用过的包/库管理工具。</h4><p>CocoaPods</p><h2 id="2-一面"><a href="#2-一面" class="headerlink" title="2. 一面"></a>2. 一面</h2><h4 id="1、说一下你觉得项目中遇到了什么印象深刻的问题，你是怎么解决的？"><a href="#1、说一下你觉得项目中遇到了什么印象深刻的问题，你是怎么解决的？" class="headerlink" title="1、说一下你觉得项目中遇到了什么印象深刻的问题，你是怎么解决的？"></a>1、说一下你觉得项目中遇到了什么印象深刻的问题，你是怎么解决的？</h4><h4 id="2、大学里学了哪些课？信息管理与信息系统专业是哪个学院的？"><a href="#2、大学里学了哪些课？信息管理与信息系统专业是哪个学院的？" class="headerlink" title="2、大学里学了哪些课？信息管理与信息系统专业是哪个学院的？"></a>2、大学里学了哪些课？信息管理与信息系统专业是哪个学院的？</h4><h4 id="3、项目里的网络请求用到了网络5层模型的哪些，TCP-IP-属于哪一层？HTTP-呢？"><a href="#3、项目里的网络请求用到了网络5层模型的哪些，TCP-IP-属于哪一层？HTTP-呢？" class="headerlink" title="3、项目里的网络请求用到了网络5层模型的哪些，TCP/IP 属于哪一层？HTTP 呢？"></a>3、项目里的网络请求用到了网络5层模型的哪些，TCP/IP 属于哪一层？HTTP 呢？</h4><p>TCP/IP属于传输层</p><p>HTTP属于应用层</p><h4 id="4、你觉得自己是什么级别的？优势和不足主要是哪方面？"><a href="#4、你觉得自己是什么级别的？优势和不足主要是哪方面？" class="headerlink" title="4、你觉得自己是什么级别的？优势和不足主要是哪方面？"></a>4、你觉得自己是什么级别的？优势和不足主要是哪方面？</h4><h4 id="5、GCD-平时项目里怎么用的？"><a href="#5、GCD-平时项目里怎么用的？" class="headerlink" title="5、GCD 平时项目里怎么用的？"></a>5、GCD 平时项目里怎么用的？</h4><p>dispatch_get_mainQueue：获取主线程</p><p>dispatch_sync：同步操作</p><p>dispatch_group：线程同步</p><p>dispatch_barrier：多读单写</p><p>dispatch_semaphore：加锁，控制并发数</p><p>dispatch_once：只执行一次</p><p>dispatch_after：延时执行</p><h4 id="6、为什么操作-UI-需要在主线程？"><a href="#6、为什么操作-UI-需要在主线程？" class="headerlink" title="6、为什么操作 UI 需要在主线程？"></a>6、为什么操作 UI 需要在主线程？</h4><p>因为UIKit不是线程安全的。<br>如果不在主线程中操作UI，可能会造成如下的情况：<br>（1）两个线程同时设置同一个背景图片，那么很有可能因为当前图片被释放了两次而导致应用崩溃。<br>（2）两个线程同时设置同一个UIView的背景颜色，那么很有可能渲染显示的是颜色A，而此时在UIView逻辑树上的背景颜色属性为B。<br>（3）两个线程同时操作view的树形结构：在线程A中for循环遍历并操作当前View的所有subView，然后此时线程B中将某个subView直接删除，这就导致了错乱还可能导致应用崩溃。<br>虽然，iOS4之后苹果将大部分绘图的方法和诸如 UIColor 和 UIFont 这样的类改写为了线程安全可用，但是仍然强烈建议将UI操作保证在主线程中执行。</p><h4 id="7、哪些是你独立开发的项目？"><a href="#7、哪些是你独立开发的项目？" class="headerlink" title="7、哪些是你独立开发的项目？"></a>7、哪些是你独立开发的项目？</h4><h4 id="8、问了一下上家公司的情况"><a href="#8、问了一下上家公司的情况" class="headerlink" title="8、问了一下上家公司的情况"></a>8、问了一下上家公司的情况</h4><h4 id="9、之后有什么打算？"><a href="#9、之后有什么打算？" class="headerlink" title="9、之后有什么打算？"></a>9、之后有什么打算？</h4><h4 id="10、上家薪资多少？你还有啥想问的吗？"><a href="#10、上家薪资多少？你还有啥想问的吗？" class="headerlink" title="10、上家薪资多少？你还有啥想问的吗？"></a>10、上家薪资多少？你还有啥想问的吗？</h4><h2 id="3-二面"><a href="#3-二面" class="headerlink" title="3. 二面"></a>3. 二面</h2><h4 id="1、自定义封装控件需要注意什么？有什么规范？"><a href="#1、自定义封装控件需要注意什么？有什么规范？" class="headerlink" title="1、自定义封装控件需要注意什么？有什么规范？"></a>1、自定义封装控件需要注意什么？有什么规范？</h4><ul><li>头文件尽量不要过多引入其他的类,解耦合</li><li>如果使用了第三方框架, 不要在头文件引入改类 切记, 不要暴露第三方组件的任何属性,枚举等等</li><li>定义该类的常量,方便修改</li><li>尽量不要引入其他项目中的类,除了一些必要的分类,业务类尽量不要引入</li><li><code>Frame</code>布局 使用分类 <code>UIView+Helper</code></li><li>尽量不要暴露成员变量或者属性,除非有必要, 其余情况最好提供接口进行操作. 注意属性的可读。</li><li>封装的工具类 注意如果是分类可以实现的尽量迁移到分类中, 并且命名 最好以<code>dd_</code> 开头, 例如<code>-(void)dd_layoutWithDirection:(DDImageDirection)imageDirection</code> ,之所以这样是因为,OC没有命名空间,后加载的分类可以覆盖掉前面的同名方法. 而且一旦和系统方法重名将造成巨大的<code>bug</code></li><li>注意 驼峰命名原则,类,协议,代理属性，命名首字母大写,最好添加<code>DD</code>类前缀</li></ul><h4 id="2、说一下你了解的设计模式。"><a href="#2、说一下你了解的设计模式。" class="headerlink" title="2、说一下你了解的设计模式。"></a>2、说一下你了解的设计模式。</h4><h5 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h5><p>1、开闭原则（Open Close Principle）</p><p>开闭原则的意思是：<strong>对扩展开放，对修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p><p>2、里氏代换原则（Liskov Substitution Principle）</p><p>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p><p>3、依赖倒转原则（Dependence Inversion Principle）</p><p>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</p><p>4、接口隔离原则（Interface Segregation Principle）</p><p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p><p>5、迪米特法则，又称最少知道原则（Demeter Principle）</p><p>最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p><p>6、合成复用原则（Composite Reuse Principle）</p><p>合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。</p><h5 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h5><p>装饰模式、工厂模式、单例模式、观察者模式、备忘录模式。</p><h4 id="3、数据库怎么优化？我说数据量大的话加索引提升查询效率。问其他优化呢？比如数据库大小有没有做过优化？"><a href="#3、数据库怎么优化？我说数据量大的话加索引提升查询效率。问其他优化呢？比如数据库大小有没有做过优化？" class="headerlink" title="3、数据库怎么优化？我说数据量大的话加索引提升查询效率。问其他优化呢？比如数据库大小有没有做过优化？"></a>3、数据库怎么优化？我说数据量大的话加索引提升查询效率。问其他优化呢？比如数据库大小有没有做过优化？</h4><p>（1）根据服务层面：配置mysql性能优化参数；</p><p>（2）从系统层面增强mysql的性能：优化数据表结构、字段类型、字段索引、分表，分库、读写分离等等。</p><p>（3）从数据库层面增强性能：优化SQL语句，合理使用字段索引。</p><p>（4）从代码层面增强性能：使用缓存和NoSQL数据库方式存储，如MongoDB/Memcached/Redis来缓解高并发下数据库查询的压力。</p><p>（5）减少数据库操作次数，尽量使用数据库访问驱动的批处理方法。</p><p>（6）不常使用的数据迁移备份，避免每次都在海量数据中去检索。</p><p>（7）提升数据库服务器硬件配置，或者搭建数据库集群。</p><p>（8）编程手段防止SQL注入：使用JDBC PreparedStatement按位插入或查询；正则表达式过滤（非法字符串过滤）；</p><h4 id="4、内存优化是怎么做的？什么情况会发生内存泄漏？"><a href="#4、内存优化是怎么做的？什么情况会发生内存泄漏？" class="headerlink" title="4、内存优化是怎么做的？什么情况会发生内存泄漏？"></a>4、内存优化是怎么做的？什么情况会发生内存泄漏？</h4><ol><li>减少内存泄漏。</li><li>降低内存使用峰值。<ul><li>懒加载。</li><li>灵活运用图片和文件加载。</li><li>拉长文件处理机制，逐步处理文件。</li></ul></li></ol><h4 id="5、App-启动时间优化？"><a href="#5、App-启动时间优化？" class="headerlink" title="5、App 启动时间优化？"></a>5、App 启动时间优化？</h4><ol><li>将一些耗时操作延迟执行。比如SDK的初始化，界面的创建。</li><li>不能延迟执行的，尽量放到后台执行。比如数据读取，原始 JSON 数据转对象，日志发送。</li><li>减少动态库、合并动态库，定期清理不必要的动态库。</li><li>减少类、分类的数量，合并Category和功能类似的类。删除不必要的方法和类、分类。</li><li>将不必须在+load中做的事延时到+initialize中。</li></ol><h4 id="6、视图做过哪些优化，我提了-TableView。那就以-TableView-说一下优化了哪些方面？"><a href="#6、视图做过哪些优化，我提了-TableView。那就以-TableView-说一下优化了哪些方面？" class="headerlink" title="6、视图做过哪些优化，我提了 TableView。那就以 TableView 说一下优化了哪些方面？"></a>6、视图做过哪些优化，我提了 TableView。那就以 TableView 说一下优化了哪些方面？</h4><ol><li>cell复用，header、footer复用。</li><li>尽量把view设置不透明。</li><li>减少视图的层级。</li><li>尽量避免调整视图层次、添加和移除视图。</li><li>合理选择加载图片的方式，UIImage imageNamed: ImageAssets 用于多个地方重复使用，UIImage imageWithContentsOfFile 一般用在图片数据很大，一般不需要多次使用的情况。</li><li>图片大小最好和UIImageView的大小相同。</li><li>不要阻塞主线程，耗时操作放在子线程进行。</li><li>懒加载。</li><li>缓存，缓存图片SDWebImage，缓存行高，NSCache缓存。</li><li>复用高开销对象NSDateFormatter和NSCalendar。</li><li>减少离屏渲染，优化圆角、阴影。</li><li>使用正确的数据存储。</li></ol><h4 id="7、AFNetworking-内部是怎么样的一个过程？"><a href="#7、AFNetworking-内部是怎么样的一个过程？" class="headerlink" title="7、AFNetworking 内部是怎么样的一个过程？"></a>7、AFNetworking 内部是怎么样的一个过程？</h4><h4 id="8、你还有什么想问我的？"><a href="#8、你还有什么想问我的？" class="headerlink" title="8、你还有什么想问我的？"></a>8、你还有什么想问我的？</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;滴滴出行面试题&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="滴滴" scheme="http://soso.wiki/tags/%E6%BB%B4%E6%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>好未来面试题及答案</title>
    <link href="http://soso.wiki/%E5%A5%BD%E6%9C%AA%E6%9D%A5%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/"/>
    <id>http://soso.wiki/好未来面试题及答案/</id>
    <published>2020-02-20T09:40:00.000Z</published>
    <updated>2021-04-06T06:57:35.088Z</updated>
    
    <content type="html"><![CDATA[<p>好未来面试题</p><a id="more"></a><h2 id="1-一面"><a href="#1-一面" class="headerlink" title="1. 一面"></a>1. 一面</h2><h3 id="1、说一下optional。-是什么意思？有几种解包方式？"><a href="#1、说一下optional。-是什么意思？有几种解包方式？" class="headerlink" title="1、说一下optional。?!  ?? 是什么意思？有几种解包方式？"></a>1、说一下optional。?!  ?? 是什么意思？有几种解包方式？</h3><p>解包方式：if let、guard、!强制解包、?? 等。</p><p>?!</p><p>??  <code>let a = b ?? c</code> 如果b不为nil，则a = b;否则a = c;</p><h2 id="2、说一下闭包。"><a href="#2、说一下闭包。" class="headerlink" title="2、说一下闭包。"></a>2、说一下闭包。</h2><p>闭包是能够读取其他函数内部变量的函数，可以理解成定义在一个函数内部的函数。</p><p>可以用typealias起别名</p><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">typealias</span> testBlock = (<span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Void</span></span><br><span class="line"><span class="hljs-keyword">let</span> aaa: testBlock = &#123;str <span class="hljs-keyword">in</span></span><br><span class="line">    <span class="hljs-built_in">print</span>(str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值捕获</p><p>闭包可以捕获上下文中的常量和变量</p><p>逃逸闭包</p><p>当一个闭包作为参数传入函数中，这个闭包需要等函数执行结束返回后执行，这种情况就称作这个闭包在函数中逃逸。在涉及异步操作时经常用到，特别是网络请求后要进行请求成功后的回调时，闭包就要逃逸掉，这时就要在闭包形参前加上<code>@escaping</code>关键字。</p><h3 id="3、比较代理、通知、KVO？这三个谁的效率最高，谁的效率最低？"><a href="#3、比较代理、通知、KVO？这三个谁的效率最高，谁的效率最低？" class="headerlink" title="3、比较代理、通知、KVO？这三个谁的效率最高，谁的效率最低？"></a>3、比较代理、通知、KVO？这三个谁的效率最高，谁的效率最低？</h3><p>KVO 效率最低，因为使用到了 Runtime。</p><p>代理效率最高，因为是一对一。</p><h3 id="4、NSString-和-String-的区别？"><a href="#4、NSString-和-String-的区别？" class="headerlink" title="4、NSString 和 String 的区别？"></a>4、NSString 和 String 的区别？</h3><p>String 是值类型，NSString 是引用类型。</p><h3 id="5、Swift-跟-OC-的区别？OC-是面向对象的，Swift-呢？（面向对象、面向协议、响应式编程）解释一下面向协议编程？"><a href="#5、Swift-跟-OC-的区别？OC-是面向对象的，Swift-呢？（面向对象、面向协议、响应式编程）解释一下面向协议编程？" class="headerlink" title="5、Swift 跟 OC 的区别？OC 是面向对象的，Swift 呢？（面向对象、面向协议、响应式编程）解释一下面向协议编程？"></a>5、Swift 跟 OC 的区别？OC 是面向对象的，Swift 呢？（面向对象、面向协议、响应式编程）解释一下面向协议编程？</h3><p>OC 是动态的语言，Swift 是静态的语言。</p><h3 id="6、说一下-MRC-？自动释放池？自动释放池什么时候释放？"><a href="#6、说一下-MRC-？自动释放池？自动释放池什么时候释放？" class="headerlink" title="6、说一下 MRC ？自动释放池？自动释放池什么时候释放？"></a>6、说一下 MRC ？自动释放池？自动释放池什么时候释放？</h3><p>iOS 在主线程的Runloop中注册了2个Observer</p><p>第1个Observer监听了kCFRunLoopEntry事件，会调用objc_autoreleasePoolPush()</p><p>第2个Observer</p><p>监听了kCFRunLoopBeforeWaiting事件，会调用objc_autoreleasePoolPop()、objc_autoreleasePoolPush()</p><p>监听了kCFRunLoopBeforeExit事件，会调用objc_autoreleasePoolPop()</p><h3 id="7、说一下多线程？"><a href="#7、说一下多线程？" class="headerlink" title="7、说一下多线程？"></a>7、说一下多线程？</h3><p>NSThread</p><p>NSOperation</p><p>GCD</p><h3 id="8、分别用-OC-和-Swift-手写一下单例。"><a href="#8、分别用-OC-和-Swift-手写一下单例。" class="headerlink" title="8、分别用 OC 和 Swift 手写一下单例。"></a>8、分别用 OC 和 Swift 手写一下单例。</h3><p>单例模式在创建过程中，要保证实例变量只被创建一次。在整个开发中需要特别注意线程安全，即使在多线程情况下，依然只初始化一次变量。</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (instanceType)sharedManager &#123;</span><br><span class="line">  <span class="hljs-keyword">static</span> Manager *sharedManager = <span class="hljs-literal">nil</span>;</span><br><span class="line">  <span class="hljs-keyword">static</span> <span class="hljs-built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">  <span class="hljs-built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">    sharedManager = [[Manager alloc] init];</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="hljs-keyword">return</span> sharedManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Swift 中，let 关键字已经保证了实例变量不会被修改，所以单例的创建就简单很多：<br><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Manager</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> shared = <span class="hljs-type">Manager</span>();</span><br><span class="line">  <span class="hljs-keyword">private</span> <span class="hljs-keyword">init</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="9、SnaptKit-内部看过吗？"><a href="#9、SnaptKit-内部看过吗？" class="headerlink" title="9、SnaptKit 内部看过吗？"></a>9、SnaptKit 内部看过吗？</h3><h3 id="10、链式语法的实现。"><a href="#10、链式语法的实现。" class="headerlink" title="10、链式语法的实现。"></a>10、链式语法的实现。</h3><p>UIView.top.equalTo().offSet(10)</p><p>UIView.left.equalTo().offSet(10)</p><p>为什么能写成UIView.top.left.offSet(10) ？</p><p>block 返回 self 自身，例如：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 当前类是ViewController类 block 返回类对象 类对象就可以继续调用 test 方法了</span></span><br><span class="line">- (ViewController *(^)(<span class="hljs-keyword">int</span>))test&#123;</span><br><span class="line">    </span><br><span class="line">    ViewController *(^block)(<span class="hljs-keyword">int</span> i) = ^ViewController *(<span class="hljs-keyword">int</span> i)&#123;</span><br><span class="line">        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"%d"</span>,i);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="hljs-keyword">return</span> block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用的时候就可以这样写：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">self</span>.test(<span class="hljs-number">1</span>).test(<span class="hljs-number">2</span>).test(<span class="hljs-number">3</span>);</span><br></pre></td></tr></table></figure><h5 id="链条的执行顺序"><a href="#链条的执行顺序" class="headerlink" title="链条的执行顺序"></a>链条的执行顺序</h5><ol><li>self 调用 test 方法 test 方法返回 block</li><li>block 得到小括号中的参数 并执行 block 中的代码</li><li>block 返回对象 对象接着调用 test 方法 实际应用中 test 可以是任何这种格式的方法</li></ol><p><a href="https://www.jianshu.com/p/bc498acf2406/" target="_blank" rel="noopener">OC中链式语法的使用及原理</a></p><h2 id="2-二面"><a href="#2-二面" class="headerlink" title="2. 二面"></a>2. 二面</h2><p>主要是手写算法题：</p><h3 id="1、用两个栈实现队列。"><a href="#1、用两个栈实现队列。" class="headerlink" title="1、用两个栈实现队列。"></a>1、用两个栈实现队列。</h3><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> inStack = [];</span><br><span class="line"><span class="hljs-keyword">var</span> outStack = [];</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">push</span>(<span class="hljs-params">node</span>)</span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    inStack.push(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pop</span>(<span class="hljs-params"></span>)</span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (outStack.length == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">while</span>(inStack.length != <span class="hljs-number">0</span>) &#123;</span><br><span class="line">            outStack.push(inStack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> outStack.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、从扑克牌中抽出5张，写一个方法判断是不是顺子。（如34567）大小王是万能的，可以替代任意数字。"><a href="#2、从扑克牌中抽出5张，写一个方法判断是不是顺子。（如34567）大小王是万能的，可以替代任意数字。" class="headerlink" title="2、从扑克牌中抽出5张，写一个方法判断是不是顺子。（如34567）大小王是万能的，可以替代任意数字。"></a>2、从扑克牌中抽出5张，写一个方法判断是不是顺子。（如34567）大小王是万能的，可以替代任意数字。</h3><p><a href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/" target="_blank" rel="noopener">剑指 Offer 61. 扑克牌中的顺子</a></p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> isStraight = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> repeat = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();</span><br><span class="line">    <span class="hljs-keyword">let</span> max = <span class="hljs-number">0</span>, min = <span class="hljs-number">14</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 跳过大小王</span></span><br><span class="line">        max = <span class="hljs-built_in">Math</span>.max(max, nums[i]); <span class="hljs-comment">// 最大牌</span></span><br><span class="line">        min = <span class="hljs-built_in">Math</span>.min(min, nums[i]); <span class="hljs-comment">// 最小牌</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (repeat.has(nums[i])) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        repeat.add(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> max - min &lt; <span class="hljs-number">5</span>; <span class="hljs-comment">// 最大牌 - 最小牌 &lt; 5 则可构成顺子</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-三面"><a href="#3-三面" class="headerlink" title="3. 三面"></a>3. 三面</h2><p>项目经理聊项目</p><h2 id="4-四面"><a href="#4-四面" class="headerlink" title="4. 四面"></a>4. 四面</h2><p>HR问了很多问题，包括个人优缺点，闲暇时间会做什么，在前公司3年的成长等等。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好未来面试题&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="好未来" scheme="http://soso.wiki/tags/%E5%A5%BD%E6%9C%AA%E6%9D%A5/"/>
    
  </entry>
  
  <entry>
    <title>微店面试题</title>
    <link href="http://soso.wiki/%E5%BE%AE%E5%BA%97%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/"/>
    <id>http://soso.wiki/微店面试题及答案/</id>
    <published>2020-02-20T09:29:00.000Z</published>
    <updated>2021-04-03T09:40:39.285Z</updated>
    
    <content type="html"><![CDATA[<p>微店面试题<br><a id="more"></a></p><h2 id="1-一面"><a href="#1-一面" class="headerlink" title="1. 一面"></a>1. 一面</h2><p>1、说项目里的有价值的东西？</p><p>2、HTTPS 过程是怎么样的？非对称加密</p><p>3、Swift 中逃逸闭包和非逃逸闭包的区别？</p><p>4、属性用 copy 关键字，是深拷贝还是浅拷贝？深拷贝和浅拷贝的区别？</p><p>5、SDWebImage 的缓存机制？LRU 内部原理？下载完成图片后，是先存到内存、磁盘后，才显示到界面上吗？</p><p>6、AFN 用到了 NSOperation、GCD，说一下内部 Operation 相关的？Manager？</p><p>7、GCD 内部实现？</p><p>8、约束 left/right 和 leading/trailing 的区别？约束报黄怎么解决？</p><p>9、KVO 的原理？具体 NSObject 的两个方法？</p><p>10、消息转发流程？使用场景？</p><p>11、数据库减字段怎么容错？</p><p>12、有没有打包过私有库？</p><p>13、从点击 App 的图标到 App 启动，说一下这个过程？+load 发生在什么时候？</p><p>14、用什么管理第三方库？CocoaPods 中的 .lock 文件存储了什么信息？</p><p>15、说一下一个项目的架构？</p><p>16、组件化？</p><p>17、手写冒泡排序算法？算法复杂度？</p><h2 id="2-二面"><a href="#2-二面" class="headerlink" title="2. 二面"></a>2. 二面</h2><p>1、项目介绍，开发人员分工？购物车本地化如果加入购物车的价格变了怎么处理的？</p><p>2、写一下其中一个项目的项目架构？写一下用到的第三方库。</p><p>3、项目用什么管理的？CocoaPods 指定版本号带 ~ 跟不带 ~各有什么含义？</p><p>4、AFN 实现原理？发10个网络请求，AFN 内部是怎么处理的？</p><p>5、SDWebImage 是怎么加载图片的？用的是 Get 还是 Post ？如果让你实现，你会选择 Get 还是 Post ？</p><p>6、HTTPS 流程是怎么样的？（画一下客户端、服务器的时序图）</p><p>7、加密算法，对称加密和非对称加密？</p><p>8、如何理解 OC 是动态语言？</p><p>9、Runtime？用 Runtime 做过什么？</p><p>10、Runloop？内部实现原理？跟自己写个 for 循环有没有区别？</p><p>11、内存管理？内存优化？</p><p>12、卡顿？</p><p>13、多线程？用 GCD 实现同步多个异步调用（a，b），然后再同步执行（c，d）</p><p>14、从点击 App 图标，到显示界面流程？</p><p>15、组件化？</p><p>16、编译过程？某一个东西是属于哪一步骤的？</p><p>17、微信支付流程（客户端、微信 SDK 、自己服务器、微信服务器时序图）</p><p>18、RN、Week？内部是怎么用 JS 调用原生的？</p><p>19、日志记录？</p><p>20、遇到的闪退？Bug？</p><p>21、竞争同一个资源？</p><p>22、进程线程与 App 的关系。</p><p>23、Git rebase</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;微店面试题&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="微店" scheme="http://soso.wiki/tags/%E5%BE%AE%E5%BA%97/"/>
    
  </entry>
  
  <entry>
    <title>美团面试题及答案</title>
    <link href="http://soso.wiki/%E7%BE%8E%E5%9B%A2%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/"/>
    <id>http://soso.wiki/美团面试题及答案/</id>
    <published>2020-02-20T09:27:00.000Z</published>
    <updated>2021-04-13T14:55:30.877Z</updated>
    
    <content type="html"><![CDATA[<p>美团面试题<br><a id="more"></a></p><h3 id="1、Block-的底层原理，结构，内存以及需要注意的地方。"><a href="#1、Block-的底层原理，结构，内存以及需要注意的地方。" class="headerlink" title="1、Block 的底层原理，结构，内存以及需要注意的地方。"></a>1、Block 的底层原理，结构，内存以及需要注意的地方。</h3><p>block本质上也是一个OC对象，它内部也有个isa指针。<br>block是封装了函数调用以及函数调用环境的OC对象。<br><img src="/images/ios/block.png" alt="block的底层结构"></p><table><thead><tr><th>block类型</th><th>环境</th></tr></thead><tbody><tr><td><strong>NSGlobalBlock</strong></td><td>没有访问auto变量</td></tr><tr><td><strong>NSStackBlock</strong></td><td>访问了auto变量</td></tr><tr><td><strong>NSMallocBlock</strong></td><td><strong>NSStackBlock</strong>调用了copy</td></tr></tbody></table><h3 id="2、图片渲染，一张-png-jpg-格式的图片渲染到页面上显示有哪些流程。png-和-jpg-的区别。png-一定是无损的吗？"><a href="#2、图片渲染，一张-png-jpg-格式的图片渲染到页面上显示有哪些流程。png-和-jpg-的区别。png-一定是无损的吗？" class="headerlink" title="2、图片渲染，一张 png/jpg 格式的图片渲染到页面上显示有哪些流程。png 和 jpg 的区别。png 一定是无损的吗？"></a>2、图片渲染，一张 png/jpg 格式的图片渲染到页面上显示有哪些流程。png 和 jpg 的区别。png 一定是无损的吗？</h3><p><strong>图片渲染的过程:</strong> 读取文件 -&gt; 计算frame -&gt;图片解码 -&gt;解码后通过数据总线交给GPU -&gt;GPU获取图片frame后进行顶点变换计算 -&gt;光栅化 -&gt;根据纹理坐标获取每一个像素点的颜色值 -&gt; 交给帧缓冲区 -&gt;渲染到屏幕上</p><p><a href="https://www.jianshu.com/p/b77399fbef5b" target="_blank" rel="noopener">iOS中图片渲染的流程</a></p><p><a href="https://link.jianshu.com/?t=https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="noopener">iOS 保持界面流畅的技巧</a></p><p><a href="https://link.jianshu.com/?t=http://sonnewilling.com/blog/2016/10/19/iostu-xing-yuan-li-yu-chi-ping-xuan-ran/#fn:1" target="_blank" rel="noopener">iOS图形原理与离屏渲染</a></p><h3 id="3、Runtime。"><a href="#3、Runtime。" class="headerlink" title="3、Runtime。"></a>3、Runtime。</h3><p>OC中的方法调用其实都是转成了objc_msgSend函数的调用，给receiver（方法调用者）发送了一条消息（selector方法名）<br>objc_msgSend底层有3大阶段<br>消息发送（当前类、父类中查找）、动态方法解析、消息转发</p><h4 id="具体应用"><a href="#具体应用" class="headerlink" title="具体应用"></a>具体应用</h4><p>利用关联对象（AssociatedObject）给分类添加属性<br>遍历类的所有成员变量（修改textfield的占位文字颜色、字典转模型、自动归档解档）<br>交换方法实现（交换系统的方法）<br>利用消息转发机制解决方法找不到的异常问题</p><h3 id="4、Runloop-的结构和循环流程，用-Runloop-做过什么事情。"><a href="#4、Runloop-的结构和循环流程，用-Runloop-做过什么事情。" class="headerlink" title="4、Runloop 的结构和循环流程，用 Runloop 做过什么事情。"></a>4、Runloop 的结构和循环流程，用 Runloop 做过什么事情。</h3><p>01、通知Observers：进入Loop<br>02、通知Observers：即将处理Timers<br>03、通知Observers：即将处理Sources<br>04、处理Blocks<br>05、处理Source0（可能会再次处理Blocks）<br>06、如果存在Source1，就跳转到第8步<br>07、通知Observers：开始休眠（等待消息唤醒）<br>08、通知Observers：结束休眠（被某个消息唤醒）<br>01&gt; 处理Timer<br>02&gt; 处理GCD Async To Main Queue<br>03&gt; 处理Source1<br>09、处理Blocks<br>10、根据前面的执行结果，决定如何操作<br>01&gt; 回到第02步<br>02&gt; 退出Loop<br>11、通知Observers：退出Loop</p><p>控制线程生命周期（线程保活）</p><p>解决NSTimer在滑动时停止工作的问题 </p><p>监控应用卡顿</p><p>性能优化</p><h3 id="5、多线程，NSOperationQueue-和-GCD-的区别。用多线程做过什么事情。线程安全的问题。加锁有几种方式。"><a href="#5、多线程，NSOperationQueue-和-GCD-的区别。用多线程做过什么事情。线程安全的问题。加锁有几种方式。" class="headerlink" title="5、多线程，NSOperationQueue 和 GCD 的区别。用多线程做过什么事情。线程安全的问题。加锁有几种方式。"></a>5、多线程，NSOperationQueue 和 GCD 的区别。用多线程做过什么事情。线程安全的问题。加锁有几种方式。</h3><p>dispatch_after</p><p>dispatch_group</p><p>dispatch_barrier</p><p>dispatch_once</p><p>OSSpinLock<br>os_unfair_lock<br>pthread_mutex<br>dispatch_semaphore<br>dispatch_queue(DISPATCH_QUEUE_SERIAL)<br>NSLock<br>NSRecursiveLock<br>NSCondition<br>NSConditionLock<br>@synchronized</p><h3 id="6、NSURLSession-和-NSURLConnection-的区别，-NSURLConnection-是怎么封装的。CFNetwork。"><a href="#6、NSURLSession-和-NSURLConnection-的区别，-NSURLConnection-是怎么封装的。CFNetwork。" class="headerlink" title="6、NSURLSession 和 NSURLConnection 的区别， NSURLConnection 是怎么封装的。CFNetwork。"></a>6、NSURLSession 和 NSURLConnection 的区别， NSURLConnection 是怎么封装的。CFNetwork。</h3><h3 id="7、做过什么动画。"><a href="#7、做过什么动画。" class="headerlink" title="7、做过什么动画。"></a>7、做过什么动画。</h3><h3 id="8、HTTPS-的工作原理，和-HTTP-的区别。RSA-加密原理。"><a href="#8、HTTPS-的工作原理，和-HTTP-的区别。RSA-加密原理。" class="headerlink" title="8、HTTPS 的工作原理，和 HTTP 的区别。RSA 加密原理。"></a>8、HTTPS 的工作原理，和 HTTP 的区别。RSA 加密原理。</h3><h3 id="9、网络层级，TCP-和-UDP-的区别。"><a href="#9、网络层级，TCP-和-UDP-的区别。" class="headerlink" title="9、网络层级，TCP 和 UDP 的区别。"></a>9、网络层级，TCP 和 UDP 的区别。</h3><table><thead><tr><th>TCP</th><th>UDP</th><th></th></tr></thead><tbody><tr><td>面向连接</td><td>面向数据报</td><td></td></tr><tr><td>可靠传输</td><td>不可靠传输</td><td></td></tr><tr><td>传输效率低</td><td>传输效率高</td></tr></tbody></table><h3 id="10、SDWebImage-的框架结构，缓存机制。"><a href="#10、SDWebImage-的框架结构，缓存机制。" class="headerlink" title="10、SDWebImage 的框架结构，缓存机制。"></a>10、SDWebImage 的框架结构，缓存机制。</h3><h3 id="11、Git-的-rebase-的原理。Git-流程。"><a href="#11、Git-的-rebase-的原理。Git-流程。" class="headerlink" title="11、Git 的 rebase 的原理。Git 流程。"></a>11、Git 的 rebase 的原理。Git 流程。</h3><h3 id="12、对组件化的了解，组件化是为了解决什么问题。"><a href="#12、对组件化的了解，组件化是为了解决什么问题。" class="headerlink" title="12、对组件化的了解，组件化是为了解决什么问题。"></a>12、对组件化的了解，组件化是为了解决什么问题。</h3><h3 id="13、JSPatch-的原理。"><a href="#13、JSPatch-的原理。" class="headerlink" title="13、JSPatch 的原理。"></a>13、JSPatch 的原理。</h3><h3 id="14、单例是为了处理什么问题而使用的，单例和全局变量的区别。"><a href="#14、单例是为了处理什么问题而使用的，单例和全局变量的区别。" class="headerlink" title="14、单例是为了处理什么问题而使用的，单例和全局变量的区别。"></a>14、单例是为了处理什么问题而使用的，单例和全局变量的区别。</h3><h3 id="15、对设计模式的掌握。"><a href="#15、对设计模式的掌握。" class="headerlink" title="15、对设计模式的掌握。"></a>15、对设计模式的掌握。</h3><h3 id="16、分层打印二叉树。"><a href="#16、分层打印二叉树。" class="headerlink" title="16、分层打印二叉树。"></a>16、分层打印二叉树。</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;美团面试题&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="美团" scheme="http://soso.wiki/tags/%E7%BE%8E%E5%9B%A2/"/>
    
  </entry>
  
  <entry>
    <title>苏宁面试题</title>
    <link href="http://soso.wiki/%E8%8B%8F%E5%AE%81%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/"/>
    <id>http://soso.wiki/苏宁面试题及答案/</id>
    <published>2020-02-20T07:47:00.000Z</published>
    <updated>2021-04-03T09:41:30.746Z</updated>
    
    <content type="html"><![CDATA[<p>苏宁面试题<br><a id="more"></a></p><h2 id="1-笔试题"><a href="#1-笔试题" class="headerlink" title="1. 笔试题"></a>1. 笔试题</h2><h3 id="1-1-冒泡排序"><a href="#1-1-冒泡排序" class="headerlink" title="1.1 冒泡排序"></a>1.1 冒泡排序</h3><p>Objective-C 实现如下：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (void)bubbleSort:(NSMutableArray *)array &#123;</span><br><span class="line">  for (int i = 0; i &lt; array.count; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    for (int j = 0; j &lt; array.count-1-i; j++)</span><br><span class="line">    &#123;</span><br><span class="line">      NSInteger left = [array[j] integerValue];</span><br><span class="line">      NSInteger right = [array[j+1] integerValue];</span><br><span class="line">      if (left &lt; right) &#123;</span><br><span class="line">        [array exchangeObjectAtIndex:j withObjectAtIndex:j+1];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  NSLog(@&quot;%@&quot;,array);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>参考链接：<a href="https://objc.vip/冒泡排序/" target="_blank" rel="noopener">【算法】冒泡排序</a></p><h3 id="1-2-二分查找"><a href="#1-2-二分查找" class="headerlink" title="1.2 二分查找"></a>1.2 二分查找</h3><p>Swift实现如下：<br><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">binarySearch</span>&lt;T: comparable&gt;<span class="hljs-params">(_a: [T], key: T)</span></span> -&gt; <span class="hljs-type">Int</span>? &#123;</span><br><span class="line">  <span class="hljs-keyword">var</span> lowerBound = <span class="hljs-number">0</span></span><br><span class="line">  <span class="hljs-keyword">var</span> upperBound = a.<span class="hljs-built_in">count</span></span><br><span class="line">  <span class="hljs-keyword">while</span> lowerBound &lt; upperBound &#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> midIndex = lowerBound + (upperBound - lowerBound) / <span class="hljs-number">2</span></span><br><span class="line">    <span class="hljs-keyword">if</span> a[midIndex] == key &#123;</span><br><span class="line">      <span class="hljs-keyword">return</span> midIndex</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> a[midIndex] &lt; key &#123;</span><br><span class="line">      lowerBound = midIndex + <span class="hljs-number">1</span></span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">      upperBound = midIndex</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>参考链接：<a href="https://objc.vip/二分查找/" target="_blank" rel="noopener">【算法】二分查找</a></p><h3 id="1-3-合并两个数组去重"><a href="#1-3-合并两个数组去重" class="headerlink" title="1.3 合并两个数组去重"></a>1.3 合并两个数组去重</h3><p>参考链接：<a href="https://objc.vip/合并两个数组并去重/" target="_blank" rel="noopener">【算法】合并两个数组并去重</a></p><h3 id="1-4-两个大数相加"><a href="#1-4-两个大数相加" class="headerlink" title="1.4 两个大数相加"></a>1.4 两个大数相加</h3><p>参考链接：<a href="https://www.jianshu.com/p/fdeb84644b50" target="_blank" rel="noopener">大数相加算法</a></p><h2 id="2-一面"><a href="#2-一面" class="headerlink" title="2. 一面"></a>2. 一面</h2><h3 id="2-1-SDWebImage-的缓存机制？LRU-说一下。"><a href="#2-1-SDWebImage-的缓存机制？LRU-说一下。" class="headerlink" title="2.1 SDWebImage 的缓存机制？LRU 说一下。"></a>2.1 SDWebImage 的缓存机制？LRU 说一下。</h3><p>SDWebImage加载图片拿到url会先把url的MD5值作为key从内存中查找，如果内存中有，则直接取图片显示；如果内存中没有，会从磁盘中查找。磁盘中没有，会走下载流程。<br>LRU 最近最少使用。缓存容量满时，会先清理最近最少的缓存。</p><h3 id="2-2-数据库升级，比如从-1-0-升级到-2-0，增加了字段。"><a href="#2-2-数据库升级，比如从-1-0-升级到-2-0，增加了字段。" class="headerlink" title="2.2 数据库升级，比如从 1.0 升级到 2.0，增加了字段。"></a>2.2 数据库升级，比如从 1.0 升级到 2.0，增加了字段。</h3><p>做好兼容处理。</p><h3 id="2-3-性能优化"><a href="#2-3-性能优化" class="headerlink" title="2.3 性能优化"></a>2.3 性能优化</h3><h4 id="2-3-1-优化启动时间"><a href="#2-3-1-优化启动时间" class="headerlink" title="2.3.1 优化启动时间"></a>2.3.1 优化启动时间</h4><ol><li>将一些耗时操作延迟执行。比如SDK的初始化，界面的创建。</li><li>不能延迟执行的，尽量放到后台执行。比如数据读取，原始 JSON 数据转对象，日志发送。</li><li>减少动态库、合并动态库，定期清理不必要的动态库。</li><li>减少类、分类的数量，合并Category和功能类似的类。删除不必要的方法和类、分类。</li><li>将不必须在+load中做的事延时到+initialize中。</li></ol><h4 id="2-3-2-减少CPU、GPU资源消耗"><a href="#2-3-2-减少CPU、GPU资源消耗" class="headerlink" title="2.3.2 减少CPU、GPU资源消耗"></a>2.3.2 减少CPU、GPU资源消耗</h4><ol><li>cell复用，header、footer复用。</li><li>尽量把view设置不透明。</li><li>减少视图的层级。</li><li>尽量避免调整视图层次、添加和移除视图。</li><li>合理选择加载图片的方式，UIImage imageNamed: ImageAssets 用于多个地方重复使用，UIImage imageWithContentsOfFile 一般用在图片数据很大，一般不需要多次使用的情况。</li><li>图片大小最好和UIImageView的大小相同。</li><li>不要阻塞主线程，耗时操作放在子线程进行。</li><li>懒加载。</li><li>缓存，缓存图片SDWebImage，缓存行高，NSCache缓存。</li><li>复用高开销对象NSDateFormatter和NSCalendar。</li><li>减少离屏渲染，优化圆角、阴影。</li><li>使用正确的数据存储。</li></ol><h4 id="2-3-3-内存优化"><a href="#2-3-3-内存优化" class="headerlink" title="2.3.3 内存优化"></a>2.3.3 内存优化</h4><ol><li>减少内存泄漏。</li><li>降低内存使用峰值。<ul><li>懒加载。</li><li>灵活运用图片和文件加载。</li><li>拉长文件处理机制，逐步处理文件。</li></ul></li></ol><h4 id="2-3-4-耗电优化"><a href="#2-3-4-耗电优化" class="headerlink" title="2.3.4 耗电优化"></a>2.3.4 耗电优化</h4><p>耗电功率是个比较综合的指标，影响因素很多。密集的网络请求，长链接，密集的CPU操作（比如大量的复杂计算）都会使耗电功率增加。网络状况（流畅的Wi-Fi还是信号不好的3G）都会影响。</p><ol><li>优化网络。<ul><li>减少、压缩网络数据。</li><li>若多次网络请求结果相同，尽量使用缓存。</li><li>网络不可用时，不进行网络请求。</li></ul></li><li>优化CPU、GPU消耗。</li><li>优化I/O操作，使用dispatch_io。</li><li>定位优化<ul><li>尽量降低定位精度，如不要使用精度最高的KCLLocationAccuracyBest。</li><li>如果只是需要快速确定用户位置，用 CLLocationManager 的 requestLocation 方法定位，定位完成后，定位硬件会自动断电。</li></ul></li></ol><h3 id="2-4-Git-开发流程。"><a href="#2-4-Git-开发流程。" class="headerlink" title="2.4 Git 开发流程。"></a>2.4 Git 开发流程。</h3><ul><li>master </li><li>develop</li><li>dev-xx 具体开发人员分支</li></ul><p>开发完成后发起PR。项目提审打Tag</p><h3 id="2-5-微信登录流程。"><a href="#2-5-微信登录流程。" class="headerlink" title="2.5 微信登录流程。"></a>2.5 微信登录流程。</h3><p>注册微信的AppKey与AppSecret。使用微信SDK方法调起微信，回调拿到一些参数，把包含openId等协定好的参数传给服务器，由服务器判断该用户是否注册过，如果注册过，返回登录成功后的用户相关信息。</p><h3 id="2-6-WebView-与-JS-交互。"><a href="#2-6-WebView-与-JS-交互。" class="headerlink" title="2.6 WebView 与 JS 交互。"></a>2.6 WebView 与 JS 交互。</h3><p>H5调用原生采用拦截协议的方式。<br>执行JS方法：evaluateScript<br>也可以使用JSBridge等方式。</p><h3 id="2-7-说一下Runloop，苹果设计-Runloop-的初衷是什么？"><a href="#2-7-说一下Runloop，苹果设计-Runloop-的初衷是什么？" class="headerlink" title="2.7 说一下Runloop，苹果设计 Runloop 的初衷是什么？"></a>2.7 说一下Runloop，苹果设计 Runloop 的初衷是什么？</h3><p>Runloop 运行循环。<br>让线程在有任务的时候忙任务，没任务的时候休眠。<br>参考链接：<a href="https://objc.vip/RunloopSummary/" target="_blank" rel="noopener">【iOS 开发】RunLoop 总结</a></p><h3 id="2-8-Delegate"><a href="#2-8-Delegate" class="headerlink" title="2.8 Delegate"></a>2.8 Delegate</h3><p>代理用assign修饰。</p><h3 id="2-9-GCD"><a href="#2-9-GCD" class="headerlink" title="2.9 GCD"></a>2.9 GCD</h3><p>参考链接：<a href="https://www.jianshu.com/p/93cecfd5fc89" target="_blank" rel="noopener">GCD 的 API</a></p><h3 id="2-10-深拷贝与浅拷贝"><a href="#2-10-深拷贝与浅拷贝" class="headerlink" title="2.10 深拷贝与浅拷贝"></a>2.10 深拷贝与浅拷贝</h3><p>深拷贝是拷贝整个对象。<br>浅拷贝只拷贝对象的指针。<br>copy用于修饰NSArray、NSDictionary、NSString。如果=右边赋值的对象是可变的，copy是深拷贝，拷贝对象的本身。如果赋值的对象是不可变的，copy是浅拷贝，只拷贝对象的指针。<br>用copy和用strong的区别？<br>用copy更安全，避免赋的值是可变的。如果能确保赋的值是不可变的，那么用strong和用copy都是浅拷贝，copy只是多了一个判断，判断可变还是不可变，其他是一样的。<br>NSMutableArray、NSMutableDictionary用Strong修饰，如果用copy，就会拷贝一份，变成不可变的，如果增删数据，就会发生错误。</p><h3 id="2-11-进程间通信"><a href="#2-11-进程间通信" class="headerlink" title="2.11 进程间通信"></a>2.11 进程间通信</h3><p>URL Schemes</p><h3 id="2-12-线程间通信，两个线程怎么切换？"><a href="#2-12-线程间通信，两个线程怎么切换？" class="headerlink" title="2.12 线程间通信，两个线程怎么切换？"></a>2.12 线程间通信，两个线程怎么切换？</h3><p>performSelectorOnThread</p><h3 id="2-13-多态"><a href="#2-13-多态" class="headerlink" title="2.13 多态"></a>2.13 多态</h3><p>多态（Polymorphism）按字面的意思就是“多种状态”。在面向对象语言中，接口的多种不同的实现方式即为多态。<br>子类继承父类后，子类重写父类的方法，实现多态。</p><h3 id="2-14-HTTP-三次握手，四次挥手。"><a href="#2-14-HTTP-三次握手，四次挥手。" class="headerlink" title="2.14 HTTP 三次握手，四次挥手。"></a>2.14 HTTP 三次握手，四次挥手。</h3><h2 id="3-二面"><a href="#3-二面" class="headerlink" title="3. 二面"></a>3. 二面</h2><h3 id="3-1-有没有复杂点的页面。"><a href="#3-1-有没有复杂点的页面。" class="headerlink" title="3.1 有没有复杂点的页面。"></a>3.1 有没有复杂点的页面。</h3><h3 id="3-2-（这个部门是做智能硬件的）蓝牙有哪些API。"><a href="#3-2-（这个部门是做智能硬件的）蓝牙有哪些API。" class="headerlink" title="3.2 （这个部门是做智能硬件的）蓝牙有哪些API。"></a>3.2 （这个部门是做智能硬件的）蓝牙有哪些API。</h3><h3 id="3-3-播放音频，展示音频的曲线，具体怎么做？"><a href="#3-3-播放音频，展示音频的曲线，具体怎么做？" class="headerlink" title="3.3 播放音频，展示音频的曲线，具体怎么做？"></a>3.3 播放音频，展示音频的曲线，具体怎么做？</h3><h2 id="4-三面"><a href="#4-三面" class="headerlink" title="4. 三面"></a>4. 三面</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;苏宁面试题&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="苏宁" scheme="http://soso.wiki/tags/%E8%8B%8F%E5%AE%81/"/>
    
  </entry>
  
  <entry>
    <title>开果科技面试题</title>
    <link href="http://soso.wiki/%E5%BC%80%E6%9E%9C%E7%A7%91%E6%8A%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://soso.wiki/开果科技面试题/</id>
    <published>2019-09-06T15:30:00.000Z</published>
    <updated>2019-09-06T16:13:42.745Z</updated>
    
    <content type="html"><![CDATA[<p>开果科技面试题<br><a id="more"></a></p><h1 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h1><p>1、卡顿原因、解决办法。为什么透明视图不如不透明视图？</p><p>2、闪退原因、监测、过程。友盟是怎么捕获闪退的？从一个事件到闪退发生了什么？</p><p>3、图片的压缩，从600k到500k，不能设置固定压缩比，应该怎么做？压缩图片，压缩图片实际压缩的是哪些东西？加载超大图；图片在计算机中的存储形式；10M的图片加载到内存中是多大？大图是怎么加载的？</p><p>图像文件存储的都是每一个像素对应的颜色值。</p><p>4、字典的本质？哈希表原理？</p><p>哈希表。</p><p>5、链表和数组，哪个容易找到地址？</p><p>数组。</p><ul><li><p>在内存中，数组是一块连续的区域。插入和删除数据效率低。随机读取效率很高，因为数组是连续的，知道每一个数据的内存地址，可以直接找到给地址的数据。</p></li><li><p>链表增加和删除数据很容易。查找数据时效率低，因为不具有随机访问性。</p></li></ul><p>6、列表有好多页，某一页和后边加载的一页中有相同的数据，怎么处理？</p><p>7、动态库和静态库的区别。</p><p>8、设计模式。</p><h1 id="二面-电话面试"><a href="#二面-电话面试" class="headerlink" title="二面(电话面试)"></a>二面(电话面试)</h1><p>1、什么时候开始接触 iOS？怎么学的iOS？</p><p>2、公司多少人？什么项目？</p><p>3、你会选择什么样的公司？</p><p>4、数据库（SQLite/Realm）是怎么保证线程安全的？</p><p>5、UserDeafaults 系统做了哪些优化？为什么可以在主线程上去做存取？如果让你实现，方法已经是同步的方法了，你会怎么处理？</p><p>6、+load 和 +initialize 方法什么时候会调用，+load 和 +initialize 方法、main 方法这三个的调用顺序。</p><p>7、@class 和 #import 在编译的时候有哪些区别？</p><p>8、JSON 转 Model 你用的是什么？MJExtension 字典转模型的具体步骤？拿到字典了，第一步做什么，第二步做什么？</p><p>9、WebView 跟 JS 是怎么交互的？</p><p>10、WebView 怎么存 cookie？</p><p>11、A-&gt;B-&gt;C-&gt;D 从D返回到B。说几个不同的实现思路。</p><ul><li>方案1：for 循环 self.navigationController.viewControllers 判断某个控制器是否是 B 如果是就 popToViewController:B。</li><li>方案2：self.navigationController.viewControllers 是一个不可变数组，可以赋值给一个可变的数组，然后把 C 移除，然后再赋值给 viewControllers。</li><li>其他方案：提示不一定要 push，present出来的怎么弄？</li></ul><p>12、二分查找。</p><p>13、深拷贝与浅拷贝，某个值得改变可能会影响原始值，那是深拷贝还是浅拷贝？</p><p>14、性能优化？图片加载到 UIImageView 上经过了哪些过程？</p><p>15、Label 怎么多行显示。</p><p>16、Button有哪些状态？</p><p>17、dispatch_group_notify 是在哪个线程上？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开果科技面试题&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="开果" scheme="http://soso.wiki/tags/%E5%BC%80%E6%9E%9C/"/>
    
      <category term="面试题" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
</feed>
