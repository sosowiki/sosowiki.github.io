<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SOSOWIKI</title>
  <icon>https://www.gravatar.com/avatar/0add61f863154d82902310b0dd29ec33</icon>
  <subtitle>SOSOWIKI</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://soso.wiki/"/>
  <updated>2025-09-28T12:50:23.185Z</updated>
  <id>http://soso.wiki/</id>
  
  <author>
    <name>SOSOWIKI</name>
    <email>swift@88.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>红松</title>
    <link href="http://soso.wiki/%E7%BA%A2%E6%9D%BE/"/>
    <id>http://soso.wiki/红松/</id>
    <published>2025-09-26T08:00:00.000Z</published>
    <updated>2025-09-28T12:50:23.185Z</updated>
    
    <content type="html"><![CDATA[<p>红松<br><a id="more"></a></p><p>一面：</p><p>1.组件化，区别，优缺点</p><p>2.SDK 体积优化</p><p>3.IM是使用还是实现</p><p>4.MVCS，SectionProvider</p><p>5.RN 的原理，实现过 RN 吗</p><p>6.地图</p><p>7.内存管理，性能优化，卡顿</p><p>8.MVP 和 MVVM 的区别</p><p>9.Runtime、Runloop 的原理和应用</p><p>10.鸿蒙的了解</p><p>11.WebView 的了解</p><p>12.HTTP2和 HTTP3了解吗？</p><p>二面：</p><p>1.SDK 体积优化与构建提效</p><p>2.SectionProvider 拆分 TableView 的背景</p><p>3.怎么打出SDK包 .xcframework，打包配置都有哪些</p><p>多个组件依赖同一个组件的不同版本，为什么会报错</p><p>5.组件化，你觉得好的组件化应该是哪种，壳工程要提供哪些，分层</p><p>6.podfile 和 podspec 区别</p><p>7.启动优化，合并类和分类数量</p><p>8.页面卡顿都有哪些检测手段，可能有哪些原因</p><p>9.做过哪些工具，排查问题</p><p>10.埋点怎么确保数据不遗漏，应该选择在什么时机上报？</p><p>11.怎么优化弱网环境体验，UDP</p><p>12.在别人眼里你是个什么样的人？代码 CR 体现细心的地方</p><p>13.离职原因，想找一个什么样的工作</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;红松&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="红松" scheme="http://soso.wiki/tags/%E7%BA%A2%E6%9D%BE/"/>
    
  </entry>
  
  <entry>
    <title>老虎国际</title>
    <link href="http://soso.wiki/%E8%80%81%E8%99%8E%E5%9B%BD%E9%99%85/"/>
    <id>http://soso.wiki/老虎国际/</id>
    <published>2025-09-26T06:00:00.000Z</published>
    <updated>2025-09-28T12:46:59.428Z</updated>
    
    <content type="html"><![CDATA[<p>老虎国际<br><a id="more"></a></p><p>1.组件化，怎么通信的，有没有公共数据，组件传值，多个组件都可以修改这个值 值变化时通知到另一个组件</p><p>2.SDK 体积优化，构建提效，为啥构建那么久</p><p>3.IM 页面复杂吗？底层怎么实现的？IM 从数据库读出来的和接口拉回来的数据怎么合并，有冲突了怎么办？IM 的异常场景，发送失败之类的</p><p>4.SSE 直接更新 UI 和其他方式</p><p>5.鸿蒙遇到的问题，有没有鸿蒙版本的问题，用的是 V2 还是 V1</p><p>算法：</p><p>从4个算法题中选择，要求用 OC 或 Swift 实现，用飞书运行</p><p>1.子串是否是回文子串</p><p>2.数组是否是调性数组</p><h3 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a>参考答案</h3><p>1.组件化，怎么通信的，有没有公共数据，组件传值，多个组件都可以修改这个值 值变化时通知到另一个组件</p><p>共享数据模型：</p><p>单例 + Notification</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// SharedModel.h</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">SharedModel</span> : <span class="hljs-title">NSObject</span></span></span><br><span class="line"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *value;</span><br><span class="line">+ (<span class="hljs-keyword">instancetype</span>)shared;</span><br><span class="line"><span class="hljs-keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// SharedModel.m</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">SharedModel</span></span></span><br><span class="line">+ (<span class="hljs-keyword">instancetype</span>)shared &#123;</span><br><span class="line">    <span class="hljs-keyword">static</span> SharedModel *instance;</span><br><span class="line">    <span class="hljs-keyword">static</span> <span class="hljs-built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="hljs-built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        instance = [[SharedModel alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="hljs-keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 修改值时发通知</span></span><br><span class="line">[SharedModel shared].value = <span class="hljs-string">@"new value"</span>;</span><br><span class="line">[[<span class="hljs-built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:<span class="hljs-string">@"SharedValueDidChange"</span></span><br><span class="line">                                                    object:<span class="hljs-literal">nil</span></span><br><span class="line">                                                  userInfo:@&#123;<span class="hljs-string">@"newValue"</span>: [SharedModel shared].value&#125;];</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 监听值变化</span></span><br><span class="line">[[<span class="hljs-built_in">NSNotificationCenter</span> defaultCenter] addObserverForName:<span class="hljs-string">@"SharedValueDidChange"</span></span><br><span class="line">                                                  object:<span class="hljs-literal">nil</span></span><br><span class="line">                                                   queue:[<span class="hljs-built_in">NSOperationQueue</span> mainQueue]</span><br><span class="line">                                              usingBlock:^(<span class="hljs-built_in">NSNotification</span> * _Nonnull note) &#123;</span><br><span class="line">    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"值变化: %@"</span>, note.userInfo[<span class="hljs-string">@"newValue"</span>]);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>单例 + KVO</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 监听</span></span><br><span class="line">[[SharedModel shared] addObserver:<span class="hljs-keyword">self</span></span><br><span class="line">                        forKeyPath:<span class="hljs-string">@"value"</span></span><br><span class="line">                           options:<span class="hljs-built_in">NSKeyValueObservingOptionNew</span></span><br><span class="line">                           context:<span class="hljs-literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 回调</span></span><br><span class="line">- (<span class="hljs-keyword">void</span>)observeValueForKeyPath:(<span class="hljs-built_in">NSString</span> *)keyPath</span><br><span class="line">                      ofObject:(<span class="hljs-keyword">id</span>)object</span><br><span class="line">                        change:(<span class="hljs-built_in">NSDictionary</span>&lt;<span class="hljs-built_in">NSKeyValueChangeKey</span>,<span class="hljs-keyword">id</span>&gt; *)change</span><br><span class="line">                       context:(<span class="hljs-keyword">void</span> *)context &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> ([keyPath isEqualToString:<span class="hljs-string">@"value"</span>]) &#123;</span><br><span class="line">        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"值变化：%@"</span>, change[<span class="hljs-built_in">NSKeyValueChangeNewKey</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单例 + Block 回调（自定义）</p><p>你也可以在 SharedModel 里维护一个回调列表，当值修改时手动调用回调。</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">void</span>(^ValueChangeBlock)(<span class="hljs-built_in">NSString</span> *newValue);</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">SharedModel</span> : <span class="hljs-title">NSObject</span></span></span><br><span class="line"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *value;</span><br><span class="line"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSMutableArray</span>&lt;ValueChangeBlock&gt; *observers;</span><br><span class="line">+ (<span class="hljs-keyword">instancetype</span>)shared;</span><br><span class="line">- (<span class="hljs-keyword">void</span>)addObserver:(ValueChangeBlock)block;</span><br><span class="line"><span class="hljs-keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">SharedModel</span></span></span><br><span class="line">+ (<span class="hljs-keyword">instancetype</span>)shared &#123;</span><br><span class="line">    <span class="hljs-keyword">static</span> SharedModel *instance;</span><br><span class="line">    <span class="hljs-keyword">static</span> <span class="hljs-built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="hljs-built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        instance = [[SharedModel alloc] init];</span><br><span class="line">        instance.observers = [<span class="hljs-built_in">NSMutableArray</span> array];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="hljs-keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="hljs-keyword">void</span>)setValue:(<span class="hljs-built_in">NSString</span> *)value &#123;</span><br><span class="line">    _value = [value <span class="hljs-keyword">copy</span>];</span><br><span class="line">    <span class="hljs-keyword">for</span> (ValueChangeBlock block <span class="hljs-keyword">in</span> <span class="hljs-keyword">self</span>.observers) &#123;</span><br><span class="line">        block(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="hljs-keyword">void</span>)addObserver:(ValueChangeBlock)block &#123;</span><br><span class="line">    [<span class="hljs-keyword">self</span>.observers addObject:[block <span class="hljs-keyword">copy</span>]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 使用</span></span><br><span class="line">[[SharedModel shared] addObserver:^(<span class="hljs-built_in">NSString</span> *newValue) &#123;</span><br><span class="line">    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"值变化了：%@"</span>, newValue);</span><br><span class="line">&#125;];</span><br><span class="line">[SharedModel shared].value = <span class="hljs-string">@"hello"</span>;</span><br></pre></td></tr></table></figure><p>2.SDK 体积优化，构建提效，为啥构建那么久</p><p>3.IM 页面复杂吗？底层怎么实现的？IM 从数据库读出来的和接口拉回来的数据怎么合并，有冲突了怎么办？IM 的异常场景，发送失败之类的</p><p>4.SSE 直接更新 UI 和其他方式</p><p>5.鸿蒙遇到的问题，有没有鸿蒙版本的问题，用的是 V2 还是 V1</p><p>算法：</p><p>从4个算法题中选择，要求用 OC 或 Swift 实现，用飞书运行</p><p>1.子串是否是回文子串</p><p>2.数组是否是调性数组</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;老虎国际&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="老虎国际" scheme="http://soso.wiki/tags/%E8%80%81%E8%99%8E%E5%9B%BD%E9%99%85/"/>
    
  </entry>
  
  <entry>
    <title>宏鹄出行</title>
    <link href="http://soso.wiki/%E5%AE%8F%E9%B9%84%E5%87%BA%E8%A1%8C/"/>
    <id>http://soso.wiki/宏鹄出行/</id>
    <published>2025-09-26T04:30:00.000Z</published>
    <updated>2025-09-28T12:48:44.029Z</updated>
    
    <content type="html"><![CDATA[<p>宏鹄出行<br><a id="more"></a></p><p>1.隐私权限检测，作为平台方，看业务方有没有用到隐私权限，没有源码</p><p>2.年初定了崩溃率和卡顿率，现在看劣化了，你作为平台，应该怎么做？</p><p>3.造成卡顿有哪些原因</p><p>4.你的优化方案遇到挑战，别人不认可怎么办？</p><p>5.单一职责是什么意思？</p><p>6.你希望下家公司、同事是什么样的，有什么期望，你期望在团队中的定位是什么？</p><p>7.你觉得什么能激励到你？</p><p>8.三年规划</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;宏鹄出行&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="宏鹄出行" scheme="http://soso.wiki/tags/%E5%AE%8F%E9%B9%84%E5%87%BA%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>好未来</title>
    <link href="http://soso.wiki/2025-09-24-%E5%A5%BD%E6%9C%AA%E6%9D%A5/"/>
    <id>http://soso.wiki/2025-09-24-好未来/</id>
    <published>2025-09-24T10:00:00.000Z</published>
    <updated>2025-09-25T14:27:40.450Z</updated>
    
    <content type="html"><![CDATA[<p>好未来<br><a id="more"></a></p><p>项目：</p><p>1.体积优化的背景，做了哪些手段，收益，二进制是自动打包还是手动打包？二进制的代码问题怎么调试？有没有遇到打二进制后变成release包和开发不一致的情况</p><p>2.MVCS、SectionProvider 的背景，怎么实现的？</p><p>3.加载速度优化</p><p>4.静态分析都有哪些类型的问题？是定期做吗？为什么不搞成流水线自动检测？</p><p>5.活动页组件化怎么做的？frame 可配置吗？</p><p>6.双向通信</p><p>7.接口层和 JS 逻辑层异常监控</p><p>8.iOS26 关注了吗</p><p>9.用 AI 做了哪些事情，哪些重复性的可以用 AI 替代？用的具体是哪个 AI？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好未来&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="好未来" scheme="http://soso.wiki/tags/%E5%A5%BD%E6%9C%AA%E6%9D%A5/"/>
    
  </entry>
  
  <entry>
    <title>米可世界</title>
    <link href="http://soso.wiki/2025-09-24-%E7%B1%B3%E5%8F%AF%E4%B8%96%E7%95%8C/"/>
    <id>http://soso.wiki/2025-09-24-米可世界/</id>
    <published>2025-09-24T08:00:00.000Z</published>
    <updated>2025-09-28T12:43:58.111Z</updated>
    
    <content type="html"><![CDATA[<p>米可世界<br><a id="more"></a></p><p>1.Runloop 的流程，底层实现，项目里实际使用，监控卡顿监听的具体是哪个状态，Source0 和 Source1 区别</p><p>2.局部对象的释放时机；autoreleasepool的实现，weak 存在哪里</p><p>3.SDK 构建提效，有没有二进制化的经验，缓存</p><p>4.feed 流滑动卡顿可能有哪些原因；离屏渲染为什么会影响；那些异步的库，不也是在另一个屏幕缓冲区处理的吗？</p><p>5.首屏优化，有没有针对各个模块的，比如卡线程了，怎么检测，怎么优化</p><p>6.IM Socket 的流程</p><p>7.FMDB 的内部实现，是线程安全的吗？和其他如 WCDB 效率的比较；</p><p>8.用过哪些锁？效率比较；@synchronized 的作用是什么？</p><p>9.上传大图，怎么分片，怎么控制线程最大并发数，怎么告诉web上传进度？上传进度细颗粒度，每片都有哪些状态，现有上传单个图片的方法，怎么实时同步进度</p><p>10.SDWebImage 加载图片的流程，缓存机制，LRU怎么实现的？加载图片传入了 UIImageView 下载完图片后怎么拿到这个对象，因为是异步的</p><p>11.OOM 怎么避免？</p><p>12.MVCS 与 SectionProvider 怎么实现的</p><p>二面：</p><p>项目：</p><p>1.构建提效，怎么定位的是头文件导入的问题</p><p>2.封装父类沉淀气泡动画与事件分发能力，怎么做的？</p><p>3.随版转为非随实现怎么做的？活动页组件化，组件之间怎么交互</p><p>4.画一下贝壳的架构，平级组件通信，传值</p><p>场景：</p><p>1.没法复现的crash，怎么去处理，如果是内部反馈的，有设备，怎么处理</p><p>2.有没有处理卡顿的经验，性能平台来了个卡顿，你会怎么处理</p><p>3.快封板了，产品要加一个紧急的功能，评估有风险，你会怎么做？</p><p>4.有没有经历过严重的线上问题，假如现在有个线上问题，你会怎么做？</p><p>5.领导交给你一个没有接触过的领域的问题，你会怎么做</p><h3 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a>参考答案</h3><p>1.Runloop 的流程，底层实现，项目里实际使用，监控卡顿监听的具体是哪个状态，Source0 和 Source1 区别</p><p>（1）1. RunLoop 的流程</p><p>RunLoop 是一个事件循环机制，内部主要流程可以简化为：</p><ol><li><strong>通知 Observers</strong>：进入 Loop 前，会发通知（如 kCFRunLoopEntry）。</li><li><strong>处理 Timer</strong>：检查是否有已到期的 Timer 任务。</li><li><strong>处理 Source0</strong>：非基于端口的事件（UI 事件、Block 回调等），需要主动唤醒。</li><li><strong>处理 Source1</strong>：基于 Mach port 的事件（系统事件、IPC、触摸事件）。</li><li><strong>进入休眠</strong>：调用 mach_msg_trap 等底层系统调用，线程进入休眠状态。</li><li><strong>被唤醒</strong>：<ul><li>有事件到来（Source、Timer、GCD dispatch）。</li><li>外部手动唤醒（CFRunLoopWakeUp）。</li></ul></li><li><strong>通知 Observers</strong>：将要处理事件（kCFRunLoopBeforeSources / kCFRunLoopBeforeWaiting / kCFRunLoopAfterWaiting）。</li><li><strong>循环往复</strong>：直到 CFRunLoopStop 被调用。</li></ol><p>（2） 底层实现<br>    •    核心结构：CFRunLoop 和 CFRunLoopMode，每个线程对应一个 RunLoop（存储在 pthread 的 TLS 中）。<br>    •    事件驱动：通过 Mach port 和 内核态通信。比如触摸事件从 IOKit -&gt; SpringBoard -&gt; App -&gt; RunLoop Mach port。<br>    •    休眠/唤醒：利用系统调用 mach_msg_trap 进入内核，等待消息；有事件时唤醒。<br>    •    RunLoopObserver：内部维护一组回调，挂在不同状态点（Entry、BeforeTimers、BeforeSources、BeforeWaiting、AfterWaiting、Exit）。</p><p>（3）项目里的实际使用</p><ul><li><strong>定时器</strong>：NSTimer / CADisplayLink / performSelector:afterDelay: 本质依赖 RunLoop。</li><li><strong>常驻线程</strong>：如 AFNetworking 的网络请求线程，使用 RunLoop 保持线程不退出。</li><li><strong>事件响应</strong>：触摸事件、UI 更新都跑在主线程 RunLoop 中。</li><li><strong>GCD 与 RunLoop</strong>：dispatch_async 提交到主队列的 block，本质通过 CFRunLoopSource 执行。</li><li><strong>性能优化</strong>：比如在 NSRunLoopCommonModes 下添加任务，避免因 UI 滑动（UITrackingRunLoopMode）而阻塞。</li></ul><p>（4）卡顿监控监听的状态</p><p>常见的 卡顿监控（UI 卡顿监控） 原理就是利用 RunLoop Observer，在关键状态点打点：<br>    •    监听 kCFRunLoopBeforeSources 和 kCFRunLoopAfterWaiting。<br>    •    在 BeforeSources 说明即将处理事件。<br>    •    在 AfterWaiting 说明刚被唤醒，准备进入事件处理。<br>    •    如果这两个状态之间持续很久没有切换，说明 RunLoop 卡在某个任务（主线程卡住）。</p><p>具体做法：</p><pre><code>1.    在主线程 RunLoop 添加 Observer，监听这两个状态。2.    同时开一个子线程用 dispatch_semaphore_wait + 超时机制判断。3.    超过阈值（如 &gt; 200ms）没有状态切换，判定为卡顿。4.    结合堆栈采样（backtrace）就能定位具体卡住的位置。</code></pre><p>（5）source0 与 source1 区别</p><ol><li><p>Source0<br> •    定义：非基于内核端口（port）的事件源。<br> •    特点：<br> •    纯用户态，不会主动唤醒 RunLoop，需要外部手动唤醒。<br> •    常用于 App 内部事件分发，例如 performSelector:onThread:。<br> •    触发方式：<br> •    调用 CFRunLoopSourceSignal(source) 标记为待处理。<br> •    再调用 CFRunLoopWakeUp(runloop) 唤醒 RunLoop。<br> •    例子：<br> •    performSelector:onThread:<br> •    手动创建的 CFRunLoopSource0</p></li><li><p>Source1<br> •    定义：基于 Mach port 的事件源。<br> •    特点：<br> •    内核态驱动，系统事件到达时可以直接唤醒 RunLoop。<br> •    主要用来处理 系统消息（如触摸、系统回调、CFMachPort）。<br> •    触发方式：<br> •    当端口有消息时，内核会唤醒 RunLoop，执行对应的回调。<br> •    例子：<br> •    系统的触摸事件、屏幕旋转事件。<br> •    CFMachPort、CFSocket</p></li></ol><p>2.局部对象的释放时机；autoreleasepool的实现，weak 存在哪里</p><p>（1）局部对象的释放时机</p><ul><li><p>在 ARC 下，局部变量对象（比如方法里的 <code>NSObject *obj = [[NSObject alloc] init];</code>）的释放时机主要取决于 <strong>作用域 + 引用计数</strong>。</p></li><li><p>编译器会在合适的位置插入 objc_release。</p></li><li><p>通常规则：</p><ol><li>如果是强引用（strong），在超出作用域时编译器插入 release。</li><li>如果放在了 @autoreleasepool 内，且对象通过 autorelease 创建（如 [NSString stringWithFormat:@”xx”]），则会在 pool 清空时统一 release。</li><li>如果没有显式放进 autoreleasepool，那么局部对象的 autorelease 会挂在当前线程的默认 <strong>autoreleasepool page</strong> 上（RunLoop 每次循环会清理一次）。</li></ol></li><li>所以：<ul><li>alloc/init 的对象：离开作用域立即释放。</li><li>工厂方法 (stringWith…) 返回的对象：通常是 autorelease，释放时机取决于最近的 autoreleasepool drain。</li></ul></li></ul><p>(2) autoreleasepool 的实现</p><ul><li>@autoreleasepool {} 在编译后会被转化为：<figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">void</span>* context = objc_autoreleasePoolPush();</span><br><span class="line">&#123;  <span class="hljs-comment">// pool 内部作用域</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">objc_autoreleasePoolPop(context);</span><br></pre></td></tr></table></figure></li></ul><p>​    •    底层实现依赖 AutoreleasePoolPage：<br>​    •    每个线程维护一个栈状的双向链表结构。<br>​    •    objc_autorelease(obj) 会把对象的指针放入当前 page。<br>​    •    pool 被 pop 时，会遍历这个 page，依次对对象发送 release。<br>​    •    RunLoop 机制：<br>​    •    主线程的 RunLoop 每次事件循环开始会 push 一个 pool，结束时 pop。<br>​    •    这保证了常见的 UIKit API 里 autorelease 对象能在一次事件处理后被释放。</p><p>（3）weak 的存储位置<br>    •    weak 指针并不是单纯的内存地址，它需要 运行时的弱引用表（weak_table_t） 管理：<br>    •    weak_table_t 是一个 hash 表，key 是对象地址（被引用的对象），value 是指向该对象的所有 weak 指针地址集合。<br>    •    当对象的引用计数归零时，dealloc 流程会调用 objc_destroyWeak，把所有指向该对象的 weak 指针置为 nil。<br>    •    所以 weak 指针存储在：<br>    •    指针本身依然在栈上 / 堆上（取决于变量声明位置），<br>    •    但 runtime 维护了一份全局的弱引用表，用来统一管理 对象 ↔ weak 指针列表 的关系。<br>    •    注意：<br>    •    weak 本身是一个普通指针，只不过 runtime 在对象销毁时会把它自动清空。<br>    •    所以 weak 查找和赋值都会经过 runtime 的弱引用表操作，有一定性能开销。</p><p>3.SDK 构建提效，有没有二进制化的经验，缓存</p><p>模块化/组件化<br>SDK 内部拆分为稳定依赖（binary、SPM precompiled）+ 高频改动部分（源码），避免全量编译。</p><p>构建缓存<br>  CI 里缓存 DerivedData、Pods、SPM 构建产物。</p><p>4.Feed 流滑动卡顿可能有哪些原因；离屏渲染为什么会影响；那些异步的库，不也是在另一个屏幕缓冲区处理的吗？</p><p>（1） Feed 流滑动卡顿的常见原因<br>卡顿一般是因为 <strong>主线程在 16.67ms（60fps 下）或者 8.3ms（120fps 下）没有完成一次绘制提交</strong>。常见原因：</p><ul><li><strong>布局计算过重</strong><ul><li>大量 autoLayout 约束计算</li><li>cell 高度动态计算不缓存</li></ul></li><li><p><strong>主线程阻塞</strong></p><ul><li>大量 JSON 解析、IO、图片解码放在主线程</li><li>复杂业务逻辑或锁竞争</li></ul></li><li><p><strong>绘制负担过重</strong></p><ul><li>大量圆角、阴影、mask、group opacity 等触发离屏渲染</li><li>大图缩放、解码延迟</li></ul></li><li><p><strong>频繁创建/销毁对象</strong></p><ul><li>cell 重复 init，而不是重用</li></ul></li><li><p><strong>图片处理问题</strong></p><ul><li>未做预解码、下采样，导致 GPU/CPU 开销大</li></ul></li></ul><p>（2）为什么离屏渲染会影响滑动流畅度</p><ul><li><p><strong>什么是离屏渲染 (Offscreen Rendering)</strong></p><ul><li><p>GPU 本来在 <strong>On-Screen Buffer</strong>（屏幕缓冲区）里画东西，顺序执行即可。</p></li><li><p>一旦遇到圆角 + mask、阴影、layer.shouldRasterize 等情况，GPU 会：</p><ol><li>先新建一个 <strong>Offscreen Buffer</strong></li><li>把内容画到这个 buffer</li><li>再拷贝回 On-Screen Buffer</li></ol></li></ul></li></ul><ul><li><p><strong>开销在哪</strong></p><ul><li>新建 buffer 本身消耗内存</li><li>GPU 切换上下文（Context Switch）有性能开销</li><li>结果要 copy 回主屏幕 buffer，增加带宽占用</li></ul></li><li><p><strong>为什么会卡顿</strong></p><ul><li>这不是“异步”的，而是 GPU 的额外工作，依然要卡在 <strong>渲染管线</strong>（Display Link vsync 同步）。</li><li>如果离屏渲染量大，GPU 跟不上 vsync 节奏，就掉帧 → feed 滑动卡顿。</li></ul></li></ul><p>（3）“异步绘制库” 和离屏渲染的区别</p><p>你说的 “异步的库”（比如 YYAsyncLayer, Texture (AsyncDisplayKit)）其实跟 Core Animation 的 Offscreen Rendering 不一样：</p><ul><li><p><strong>异步绘制库</strong></p><ul><li>把文本排版、图片合成、UI 绘制逻辑放到 <strong>后台线程的 CGContext</strong> 里完成</li><li>得到一张最终的位图（Bitmap）</li><li>主线程只把这张图交给 layer.contents</li><li>→ 避免了主线程阻塞 &amp; 避免 GPU 临时建 buffer</li></ul></li><li><p><strong>GPU 离屏渲染</strong></p><ul><li>是 <strong>渲染阶段</strong> GPU 为了实现特效而“不得不”建一个临时 buffer</li><li>发生在绘制提交之后、硬件管线中</li><li>→ 无法用“放后台线程”解决，因为是 GPU 硬件的需求</li></ul></li></ul><p>可以这样理解：</p><ul><li><strong>异步绘制库：CPU 先画好 → 减轻主线程 &amp; GPU 压力</strong></li><li><strong>离屏渲染：GPU 临时建 buffer → 加重 GPU 压力</strong></li></ul><p>总结：</p><ul><li>Feed 卡顿大多是 <strong>主线程阻塞 + GPU 负担过重</strong>。</li><li>离屏渲染会卡，是因为 <strong>GPU 在渲染管线上多了额外 buffer 开销</strong>。</li><li>异步绘制库的“异步 buffer”不是 GPU 的 Offscreen Buffer，而是 <strong>CPU 侧先生成位图</strong>，两者概念完全不同。</li></ul><p>5.首屏优化，有没有针对各个模块的，比如卡线程了，怎么检测，怎么优化<br>卡线程检测方法</p><pre><code>1.    Runloop 卡顿监控•    利用 CFRunLoopObserver 监听主线程 RunLoop 的状态（kCFRunLoopBeforeSources、kCFRunLoopAfterWaiting 等）。•    当 RunLoop 某次循环超过阈值（如 &gt;200ms）还未完成，就认为发生了卡顿。•    工具类库：YYAsyncLayer、FBRetainCycleDetector + 自己封装卡顿监控。2.    堆栈采样 (Stack Sampling)•    使用子线程定时采样主线程调用栈（比如每 50ms 取一次）。•    当检测到主线程长时间无响应时，打印采样栈，可快速定位阻塞点。•    开源方案：KSCrash、PLCrashReporter。3.    系统工具•    Instruments → Time Profiler：定位函数耗时。•    Instruments → Main Thread Checker：发现 UI API 是否在子线程调用。•    Instruments → System Trace：更底层地看线程调度与锁等待。</code></pre><p>常见模块的首屏优化点：<br>（1）启动阶段（冷启动）</p><ul><li><strong>优化检测</strong></li><li><p>利用 DYLD_PRINT_STATISTICS 环境变量观察动态库加载耗时。</p><ul><li>Xcode 的 App Launch 模板可分析启动阶段。</li></ul></li><li><p><strong>优化手段</strong></p><ul><li>减少动态库数量，合并 Pod。</li><li>用 App Clips 或延迟加载来减少首次启动体积。</li><li>+load 和 +initialize 里避免做耗时操作。</li></ul></li></ul><p>（2） 主线程耗时操作</p><ul><li><p><strong>检测</strong></p><ul><li>Runloop 卡顿监控 + Instruments。</li></ul></li><li><p><strong>优化</strong></p><ul><li>UI 布局计算移到子线程（AutoLayout 的约束尽量减少层级）。</li><li>图片解码、JSON 解析放子线程（YYImage / YYModel 的异步方案）。</li><li>渲染复杂 UI 时用 CALayer 或离屏渲染优化。</li></ul></li></ul><p>（3）网络模块</p><ul><li><p><strong>检测</strong></p><ul><li>在首屏接口加埋点（发起时间 - 响应时间）。</li><li>Charles / Wireshark 抓包分析耗时。</li></ul></li><li><p><strong>优化</strong></p><ul><li><p>核心数据接口提前并发请求，不要串行。</p></li><li><p>使用缓存（磁盘缓存、内存缓存、预加载）。</p></li><li><p>大图延迟加载，必要时用占位图。</p></li></ul></li></ul><p>（4） 图片加载</p><ul><li><p><strong>检测</strong></p><ul><li>Instruments → Allocations/Time Profiler 观察解码与内存情况。</li></ul></li><li><p><strong>优化</strong></p><ul><li>预解码（SDWebImage、YYImage）。</li><li>降低分辨率，避免原图直接展示。</li><li>使用 WebP/HEIF 格式。</li></ul></li></ul><p>（5）渲染与绘制</p><ul><li><strong>检测</strong></li><li><p>Instruments → Core Animation 检测 FPS、离屏渲染。</p><ul><li>GPU Driver template 观察 GPU 是否被打满。</li></ul></li><li><p><strong>优化</strong></p><ul><li>减少视图层级，避免过度使用透明度/圆角/阴影。</li><li>尽量用 CAShapeLayer 替代复杂绘制。</li><li>提前渲染静态页面的快照。</li></ul></li></ul><p>（6）数据处理 &amp; 本地 IO</p><ul><li><p><strong>检测</strong></p><ul><li>Time Profiler 定位磁盘/数据库耗时。</li></ul></li><li><p><strong>优化</strong></p><ul><li>首页不要做大量磁盘读写。</li><li>CoreData/SQLite 的查询下沉到子线程。</li><li>UserDefaults 批量写时要避免阻塞。</li></ul></li></ul><p>6.IM Socket 的流程</p><p>1.建立连接</p><ul><li><p>使用 CFStream（CoreFoundation）、CFSocket、或者三方库（如 <a href="https://github.com/robbiehanson/CocoaAsyncSocket" target="_blank" rel="noopener">CocoaAsyncSocket</a>）来建立 TCP 连接。</p></li><li><p>或者直接用 <strong>WebSocket</strong>（iOS 13+ 推荐 URLSessionWebSocketTask，早期可用 SocketRocket）。</p></li><li><p>流程：</p><ol><li>客户端发起连接请求（IP + 端口）。</li><li>服务器返回是否成功。</li><li>成功后，进入可读写状态。</li></ol></li></ul><p>2.登录/鉴权</p><ul><li>建立连接后，通常第一步是发送 <strong>登录包 / 鉴权信息</strong>（例如 userId、token、设备信息）。</li><li>服务器验证通过后，会返回 <strong>登录成功 ACK</strong>。</li><li>只有在鉴权成功后，Socket 才允许继续收发消息。</li></ul><p>3.维持长连接</p><ul><li>长连接需要保持心跳（心跳包 ping/pong）。</li><li>客户端定时（如 30s/60s）发送 <strong>心跳包</strong>，服务器回应 <strong>心跳 ACK</strong>。</li><li>如果心跳超时（连续几次未响应），认为连接断开，需要自动重连。</li></ul><p>4.消息收发</p><ul><li><p><strong>发送消息：</strong></p><ul><li>将消息序列化成约定的数据格式（JSON / Protobuf / 二进制协议）。</li><li>封装消息头（包含消息类型、长度、消息 ID 等）。</li><li>通过 Socket write/send 发出。</li></ul></li><li><p><strong>接收消息：</strong></p><ul><li>Socket 输入流回调或代理触发。</li><li>先读消息头，解析数据包长度。</li><li>再按协议读取完整消息体。</li><li>反序列化成业务层可用的模型对象。</li></ul></li></ul><p>5.消息确认（ACK机制）</p><ul><li><p>为了保证消息可靠性，通常采用 <strong>消息回执机制</strong>：</p><ul><li>客户端发送消息 → 服务器收到后，返回 ACK（确认包，包含消息 ID）。</li></ul></li><li>如果客户端在一定时间内未收到 ACK，则重发消息。</li></ul><p>6.断线重连</p><ul><li><p>网络变化（WiFi/4G切换）、App 后台 → 前台，都会导致连接中断。</p></li><li><p>需要实现 <strong>自动重连机制</strong>：</p><ul><li>发现连接断开 → 进入重连流程。</li><li>指数退避重试（如 1s → 2s → 4s → 8s…，有上限）。</li><li>连接成功后，重新鉴权、同步离线消息。</li></ul></li></ul><p>7.离线消息同步</p><ul><li>断线期间可能会有消息未收到。</li><li>重新连接成功后，客户端需要调用接口获取 <strong>离线消息</strong>，再和本地消息队列合并。</li></ul><p>8.退出/释放</p><ul><li>用户主动退出登录时，发送 <strong>退出包</strong>。</li><li>关闭 Socket，释放资源。</li></ul><p>7.FMDB 的内部实现，是线程安全的吗？和其他如 WCDB 效率的比较；</p><p>（1）FMDB 的线程安全性</p><ol><li><strong>FMDatabase</strong></li></ol><ul><li>FMDatabase 本身 <strong>不是线程安全的</strong>。<ul><li>官方明确建议：<strong>一个 FMDatabase 实例只能在单一线程中使用</strong>，不能跨线程共享。</li></ul></li></ul><ol start="2"><li><strong>FMDatabaseQueue</strong></li></ol><ul><li><p>为了保证线程安全，FMDB 提供了 FMDatabaseQueue。</p></li><li><p>内部实现方式：</p><ul><li>维护一个 dispatch_queue（串行队列）。<ul><li>通过 inDatabase: 或 inTransaction: 方法，将所有对数据库的操作 block 串行提交到这个队列里执行。</li></ul></li><li>这样可以保证同一时间只有一个线程在访问数据库，从而避免 SQLite 的并发写入问题（SQLite 本身写操作也是串行化的）。</li></ul></li></ul><ol start="3"><li><strong>FMDatabasePool</strong><ul><li>为了优化多读场景，FMDB 还提供 FMDatabasePool。</li><li>内部维护多个数据库连接（通常用于读操作）。</li><li>读操作可以并发分配给不同的连接，写操作仍然会被串行化。</li></ul></li></ol><p>结论：</p><ul><li><strong>单独使用 FMDatabase → 线程不安全</strong></li><li><strong>使用 FMDatabaseQueue/Pool → 线程安全</strong></li></ul><p>8.用过哪些锁？效率比较；@synchronized 的作用是什么？</p><ol><li><strong>OSSpinLock（已废弃）</strong><ul><li>自旋锁，忙等，会不断轮询等待锁释放。</li><li>性能很高，但存在优先级反转问题（高优先级线程可能被低优先级线程“饿死”），Apple 已经不推荐使用。</li><li>iOS 10+ 建议用 os_unfair_lock 代替。</li></ul></li><li><strong>os_unfair_lock</strong><ul><li>自旋锁的替代品，会在等待时挂起线程，避免优先级反转。</li><li>适合短时间、高频加锁的场景。</li><li>性能比 pthread_mutex 更好。</li></ul></li><li><strong>pthread_mutex（互斥锁）</strong><ul><li>POSIX 标准互斥锁。</li><li>比较通用，支持递归锁（PTHREAD_MUTEX_RECURSIVE）。</li><li>开销比 os_unfair_lock 大一些，因为需要进入内核等待。</li></ul></li><li><strong>NSLock</strong><ul><li>Objective-C 封装，内部基于 pthread_mutex。</li><li>提供了面向对象的 API，简单易用。</li><li>性能略低于 os_unfair_lock。</li></ul></li><li><strong>NSRecursiveLock</strong><ul><li>递归锁，允许同一线程多次获得同一把锁，避免死锁。</li><li>底层也是 pthread_mutex(recursive)。</li></ul></li><li><strong>NSCondition / NSConditionLock</strong><ul><li>条件锁，用于线程间的条件同步（等待某个条件满足才继续）。</li><li>常用于“生产者—消费者”模型。</li></ul></li><li><strong>dispatch_semaphore</strong><ul><li>GCD 提供的信号量机制。</li><li>可用于资源计数、并发数控制，也可以当成锁来用。</li><li>性能和可控性较好。</li></ul></li><li><strong>@synchronized</strong><ul><li>Objective-C 关键字，基于 objc_sync_enter/objc_sync_exit 实现。</li><li>内部使用哈希表管理对象锁。</li><li>使用简单，但性能比 NSLock 差一些，因为额外做了对象管理和异常处理。</li><li>适合快速实现线程安全，但不推荐在性能敏感场景中使用。</li></ul></li></ol><p>9.上传大图，怎么分片，怎么控制线程最大并发数，怎么告诉web上传进度？上传进度细颗粒度，每片都有哪些状态，现有上传单个图片的方法，怎么实时同步进度</p><p>（1）分片策略</p><ul><li><p><strong>分片大小</strong>：一般 2MB5MB 一片比较合理（20M → 104 片）。</p><ul><li>分片太小：请求数太多，开销大；</li><li>分片太大：失败重传成本高。</li></ul></li><li><p><strong>分片切割</strong>：用 NSData 的 subdataWithRange: 或者 InputStream，把整张图片按顺序拆成多个 NSData。</p></li></ul><p>示例：<br><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">NSData</span> *imageData = <span class="hljs-built_in">UIImageJPEGRepresentation</span>(image, <span class="hljs-number">0.9</span>);</span><br><span class="line"><span class="hljs-built_in">NSUInteger</span> chunkSize = <span class="hljs-number">2</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>; <span class="hljs-comment">// 2MB</span></span><br><span class="line"><span class="hljs-built_in">NSUInteger</span> length = [imageData length];</span><br><span class="line"><span class="hljs-built_in">NSUInteger</span> offset = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-built_in">NSMutableArray</span> *chunks = [<span class="hljs-built_in">NSMutableArray</span> array];</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">while</span> (offset &lt; length) &#123;</span><br><span class="line">    <span class="hljs-built_in">NSUInteger</span> thisChunkSize = MIN(chunkSize, length - offset);</span><br><span class="line">    <span class="hljs-built_in">NSData</span>* chunk = [imageData subdataWithRange:<span class="hljs-built_in">NSMakeRange</span>(offset, thisChunkSize)];</span><br><span class="line">    [chunks addObject:chunk];</span><br><span class="line">    offset += thisChunkSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>（2）控制并发数</p><ul><li><strong>不要一次性全部并发上传</strong>（可能耗尽带宽/内存/线程）。</li><li>推荐用 <strong>NSOperationQueue</strong> 或 <strong>GCD 信号量</strong>来限制最大并发数。</li></ul><p>例子：最多并发 3 个分片上传</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="hljs-number">3</span>); <span class="hljs-comment">// 最大并发 3</span></span><br><span class="line"><span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSData</span> *chunk <span class="hljs-keyword">in</span> chunks) &#123;</span><br><span class="line">    <span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">        </span><br><span class="line">        [<span class="hljs-keyword">self</span> uploadChunk:chunk completion:^&#123;</span><br><span class="line">            dispatch_semaphore_signal(semaphore);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要更优雅，可以用 NSOperationQueue，设置 maxConcurrentOperationCount = 3。</p><p>（3）上传进度<br>方式 A: NSURLSessionUploadTask + progress</p><ul><li>每个分片创建一个 NSURLSessionUploadTask，监听其 NSProgress 对象。</li><li>NSProgress 能返回当前上传的字节数，结合所有分片，汇总出整体进度。</li></ul><p>方式B: NSURLSession delegate (更灵活)</p><p>汇总整体进度 所有分片进度的加权平均</p><ul><li>每个分片有状态（Pending/Uploading/Success/Failed）。</li><li>上传时监听 NSURLSession 的进度回调，实时拿到字节数。</li><li>汇总所有分片进度得到整体进度。</li><li>再把整体进度同步给 UI 或 Web。</li></ul><p>10.SDWebImage 加载图片的流程，缓存机制，LRU怎么实现的？加载图片传入了 UIImageView 下载完图片后怎么拿到这个对象，因为是异步的</p><p>（1）SDWebImage 加载图片的流程</p><ol><li>入口：<figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[imageView sd_setImageWithURL:url placeholderImage:<span class="hljs-literal">nil</span> options:<span class="hljs-number">0</span> completed:<span class="hljs-literal">nil</span>];</span><br></pre></td></tr></table></figure></li></ol><p>传入 UIImageView 和 URL 后，会走到 SDWebImageManager 的 loadImageWithURL。</p><ol start="2"><li>检查缓存：<br>•    先查 内存缓存（SDImageCache.memoryCache，底层是 NSCache + LRU）<br>•    内存没有，再查 磁盘缓存（通过 key -&gt; 文件路径 / SQLite 索引）</li><li>下载图片（如果缓存都没有）：<br>•    调用 SDWebImageDownloader，内部基于 NSURLSession 创建下载任务，异步下载数据。<br>•    支持下载队列、并发控制、请求去重、进度回调。</li><li>解码 &amp; 缓存：<br>•    图片数据下载完成后，会进行 解码（decode），避免主线程卡顿。<br>•    然后写入 内存缓存 + 磁盘缓存。</li><li>回调 UI：<br>•    下载完成后，主线程回调，把 UIImage 设置到传入的 UIImageView.image 上。</li></ol><p>（2）缓存机制</p><p>SDWebImage 的缓存分两级：</p><ol><li><strong>内存缓存</strong></li></ol><ul><li><p>使用 NSCache 封装（带自动清理机制，内存紧张时会自动回收）。</p></li><li><p>内部实现了 <strong>LRU (Least Recently Used)</strong> 算法：</p></li></ul><pre><code>- 每次访问一个图片，会把它放到链表头。- 淘汰时从链表尾部移除最久未使用的对象。- 在 SD 里，具体用的是 SDMemoryCache，基于 YYMemoryCache 的思想，维护了一个 **双向链表 + 哈希表** 结构。</code></pre><ol start="2"><li><strong>磁盘缓存</strong></li></ol><ul><li><p>旧版本用 NSKeyedArchiver 直接存二进制文件。</p></li><li><p>新版本用 sqlite + 文件混合存储：</p></li></ul><pre><code>- 小文件直接存 sqlite。- 大文件写到磁盘，sqlite 里保存路径索引。</code></pre><ul><li>有过期策略、容量控制（例如超过 1 周 / 超过 500MB 自动清理）。<br>（3）LRU 实现思路（简化版）<figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// LRU 的核心：哈希表 + 双向链表</span></span><br><span class="line"><span class="hljs-keyword">class</span> LRUCache &#123;</span><br><span class="line">    <span class="hljs-built_in">NSMutableDictionary</span> *dict; <span class="hljs-comment">// key -&gt; node</span></span><br><span class="line">    Node *head, *tail;         <span class="hljs-comment">// 双向链表</span></span><br><span class="line"></span><br><span class="line">    - (<span class="hljs-keyword">id</span>)get:(<span class="hljs-built_in">NSString</span> *)key &#123;</span><br><span class="line">        Node *node = dict[key];</span><br><span class="line">        <span class="hljs-keyword">if</span> (node) &#123;</span><br><span class="line">            [<span class="hljs-keyword">self</span> moveToHead:node]; <span class="hljs-comment">// 最近使用过，移动到头部</span></span><br><span class="line">            <span class="hljs-keyword">return</span> node.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    - (<span class="hljs-keyword">void</span>)put:(<span class="hljs-built_in">NSString</span> *)key value:(<span class="hljs-keyword">id</span>)value &#123;</span><br><span class="line">        Node *node = dict[key];</span><br><span class="line">        <span class="hljs-keyword">if</span> (node) &#123;</span><br><span class="line">            node.value = value;</span><br><span class="line">            [<span class="hljs-keyword">self</span> moveToHead:node];</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            node = [[Node alloc] initWithKey:key value:value];</span><br><span class="line">            dict[key] = node;</span><br><span class="line">            [<span class="hljs-keyword">self</span> addToHead:node];</span><br><span class="line">            <span class="hljs-keyword">if</span> (dict.count &gt; capacity) &#123;</span><br><span class="line">                Node *removed = [<span class="hljs-keyword">self</span> removeTail]; <span class="hljs-comment">// 淘汰最久没用的</span></span><br><span class="line">                [dict removeObjectForKey:removed.key];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>（4）UIImageView 与异步回调<br>UIImageView 是通过 AssociatedObject 绑定 URL 的，所以异步回调时 SDWebImage 能知道要给哪个 imageView 设置图。</p><p>11.OOM 怎么避免？</p><p>避免 OOM 的核心就是 减少单次内存峰值 + 控制整体内存占用 + 及时释放资源。实际项目中通常要针对业务做专项优化，比如：<br>    •    大图 -&gt; 缩放解码<br>    •    视频 -&gt; 硬解码，流式处理<br>    •    数据 -&gt; 分页加载，NSCache 管理<br>    •    缓存 -&gt; 收到内存警告立即清理</p><p>12.MVCS 与 SectionProvider 怎么实现的</p><p>二面：</p><p>1.构建提效，怎么定位的是头文件导入的问题</p><ul><li>Xcode 里加上编译参数 -ftime-trace（Clang 10+ 支持），会输出每个编译单元里函数/头文件的编译耗时，可以用 Chrome 打开 .json 文件可视化。</li><li>或者加 -Xclang -ftime-trace 看更详细的时间线。</li></ul><p>2.封装父类沉淀气泡动画与事件分发能力，怎么做的？</p><p>3.随版转为非随实现怎么做的？活动页组件化，组件之间怎么交互</p><p>4.画一下贝壳的架构，平级组件通信，传值</p><p>场景：</p><p>1.没法复现的crash，怎么去处理，如果是内部反馈的，有设备，怎么处理</p><p>（1）收集更多上下文信息</p><ul><li><p>Crash 日志（Crash Report）</p><ul><li>通过 Xcode Organizer（连接 TestFlight/符号化）或第三方平台（如 Firebase Crashlytics、Bugly、友盟）获取。</li><li>确保符号化，得到可读的堆栈。</li></ul></li><li><p>埋点/日志</p><ul><li>在关键逻辑、崩溃堆栈附近增加埋点，把上下文（参数、线程状态、业务数据）上传到日志系统。</li><li>尝试记录 NSError、response 数据、关键对象是否为 nil、线程调用情况。</li></ul></li><li><p>Breadcrumb（面包屑日志）</p><ul><li>记录用户操作轨迹，能帮助复现 crash 前的路径。</li></ul></li></ul><p>（2）分析崩溃堆栈</p><ul><li><p>崩溃类型</p><ul><li>EXC_BAD_ACCESS → 野指针、提前释放对象、越界访问。</li></ul></li><li><p>SIGABRT → 主动调用 abort()，例如断言失败。</p><ul><li>NSInvalidArgumentException → 对象方法找不到。</li><li>Deadlock / Watchdog → UI 卡死，主线程被阻塞。</li></ul></li><li><p>崩溃频率/机型分布</p><ul><li>是集中在特定系统版本、设备、机型？</li></ul></li><li>如果只有个别用户/机型，可能是硬件差异或极端场景。</li></ul><p>（3）推测可能场景</p><p>无法复现的 crash 大多和以下因素相关：</p><ul><li>多线程并发：数据竞争、非线程安全容器（如 NSMutableArray）、UI 更新不在主线程。</li><li>弱网/超时场景：下载/上传中途取消、断点续传异常。</li><li>生命周期问题：VC 已销毁，但异步回调还在访问它。</li><li>三方库 Bug：检查是否依赖版本过低。</li><li>内存压力：大图加载、缓存策略不当。</li></ul><p>（4）间接定位方法</p><ul><li>符号化 Crash 日志 + 版本代码行号 → 锁定出错代码位置。</li><li>异常保护：加入容错机制（比如防越界、防 nil、KVO 移除检查）。</li><li>增加断言/保护：让 crash 更早、更明确地暴露（例如 debug 环境直接 assert）。</li><li>Mock 极端场景：弱网、低内存、后台切前台、旋转、快速频繁操作等。</li></ul><p>（5）修复和验证</p><ul><li>根据堆栈定位加日志、加 guard 判断。</li><li>在本地写小 demo 尝试模拟类似调用链。</li><li>修复后用灰度发布观察 crash 是否下降。</li></ul><p>2.有没有处理卡顿的经验，性能平台来了个卡顿，你会怎么处理</p><p>iOS 上“卡顿”其实就是主线程掉帧，通常是 CPU 或 GPU 在某一帧渲染/计算超时导致的。面试或实际工作里，如果性能平台上报了卡顿，我会按以下步骤来处理：</p><p>（1）先定位问题</p><ul><li><p>确认复现路径：在性能平台（如 Matrix、火焰图、Instruments 采集）找到具体的卡顿堆栈和发生场景。</p></li><li><p>确认卡顿类型：是</p><ul><li>CPU 卡顿（大量计算、JSON 解析、排序、加解密、CoreData、IO）</li><li>GPU 卡顿（视图层级过深、离屏渲染、过多阴影圆角、图片过大缩放）</li><li>I/O 卡顿（大文件读写、数据库慢查询、主线程访问磁盘/网络）</li></ul></li></ul><p>（2） 工具分析</p><ul><li>Instruments → Time Profiler：看 CPU 占用和热点函数。</li><li>Instruments → Core Animation：看是否掉帧，GPU 渲染瓶颈。</li><li>Performance Platform Flame Graph（火焰图）：确认是哪个方法阻塞了主线程。</li><li>Runloop 监控：分析 Runloop 卡住的原因，是否死锁、长任务。</li></ul><p>（3）常见优化方向</p><p><strong>CPU 优化</strong></p><ul><li>耗时操作下放到子线程（JSON 解析、图片解码、CoreData）。</li><li>使用更高效的数据结构和算法。</li><li>尽量减少频繁的对象创建与销毁。</li><li>图片提前解码（YYImage / SDWebImage 已有优化）。</li></ul><p><strong>GPU 优化</strong></p><ul><li>控制视图层级，不要超过必要深度。</li><li>避免频繁离屏渲染：圆角/阴影/遮罩可以通过 cornerRadius+maskToBounds=NO + shadowPath 或使用预处理图片解决。</li><li>图片资源按需缩放到合适分辨率，避免大图直接缩放。</li><li>合理使用异步绘制（比如 YYText、AsyncDisplayKit）。</li></ul><p><strong>I/O 优化</strong></p><ul><li>文件读写/数据库操作放在后台线程。</li><li>SQLite 加索引，CoreData 分批查询。</li><li>网络请求分批、避免主线程等待。</li></ul><p>（4）实际案例处理思路</p><p>假设性能平台报某个页面“进入卡顿”：</p><ol><li><p>打开火焰图，看是不是 viewDidLoad/viewWillAppear 阶段执行了大量计算。</p><ul><li>如果是 JSON/字典转模型 → 下放子线程，或用更快的序列化库（YYModel）。</li><li>如果是 UI 初始化太多 → 分批加载、懒加载、不在首屏就不要一次性建完。</li></ul></li><li><p>如果是滑动列表卡顿：</p><ul><li>检查 Cell 的绘制，是否有圆角 + 阴影导致离屏渲染。</li><li>图片是否未压缩，直接用大图缩放。</li><li>AutoLayout 是否约束复杂，可以改成 frame/手写布局。  </li></ul></li><li><p>如果堆栈显示 MainThread 被某个同步锁阻塞 → 优化并发，避免主线程等待异步结果。</p></li></ol><p>先定位卡顿位置（堆栈/火焰图/Runloop），再根据类型（CPU、GPU、I/O）针对性优化，确保主线程尽量“轻、快、短”。   </p><p>3.快封板了，产品要加一个紧急的功能，评估有风险，你会怎么做？</p><ol><li><strong>确认需求背景</strong><ul><li>我会先和产品确认，这个功能的紧急性和业务价值，判断是否真的必须在当前版本上线。</li></ul></li><li><strong>快速风险评估</strong><ul><li>从代码改动范围、对核心流程的影响、测试时间是否充足、苹果审核时间等方面快速评估风险。</li></ul></li><li><strong>提出多种方案</strong><ul><li><strong>立即实现方案</strong>：风险大，但能满足业务。</li><li><strong>降级/临时方案</strong>：比如通过远程配置、埋点或弱化版本先满足部分诉求。</li><li><strong>延期方案</strong>：保证当前版本质量，把功能放到下个迭代。</li></ul></li><li><strong>沟通与决策</strong><ul><li>把风险和后果客观告知产品和项目负责人，让他们和我一起权衡利弊做决定，而不是我单方面拍板。</li></ul></li><li><strong>技术兜底措施</strong><ul><li>如果最终决定紧急上线，我会尽量把功能设计成可控的，比如加开关、最小化改动，留出核心流程的冒烟测试时间，确保不影响主要用户路径。</li></ul></li></ol><p>4.有没有经历过严重的线上问题，假如现在有个线上问题，你会怎么做？</p><p>1) 立刻要做的（0–30 分钟）——缓解与信息同步（必须）</p><ul><li>报警确认：查看监控 &amp; 崩溃平台（Crashlytics/Sentry/Bugly/AppCenter）确认影响范围/趋势（用户数、错误率、版本、国家）。</li><li>抢占沟通渠道：在 Slack/企业微信/紧急群 建立 incident channel（@oncall、PM、QA、后端、客服、运营、法务）。</li><li>临时公告（外部/内部）：给客服和用户团队一条标准状态消息（示例见下）。</li><li>立即开启指标快照：请求产品/数据同学导出最近 1h/24h 的关键指标（崩溃率、活跃用户、错误事件、留存、支付失败率）。</li><li>如果能做<strong>无代码的快速缓解</strong>（后端开关、feature-flag、下发配置）立即执行并记录时间。</li></ul><p>示例内部消息（Slack/企业群）：</p><blockquote><p>【INCIDENT】iOS 主流程崩溃激增，开始响应。影响：约 X% 活跃用户，版本 vX.Y.Z 占比 Z%。负责人：@xxx（iOS），@yyy（后端）。当前操作：1) 收集日志 2) 尝试后端开关 3) 立刻准备 hotfix。请各组保留通道畅通。</p></blockquote><p>2) 快速诊断（30 分钟内完成初步判断）<br>    •    收集崩溃样本：筛选最频繁的崩溃堆栈（按版本/机型/系统版本分组）。<br>    •    符号化 &amp; 分析：<br>    •    使用 dSYM + Crashlytics/Sentry 自动符号化。<br>    •    查找回归范围：是哪次提交/哪个 release 引入（git bisect / 对照 release note）。<br>    •    判断是否是客户端 bug、SDK 问题、还是后端变更导致。<br>3) 应急缓解（并行进行：30–90 分钟）<br>    •    如果能用后端/配置开关解决（例如禁用某特性、回退后端接口），优先做：<br>    •    请求后端下线/回滚相关接口或加速降级逻辑。<br>    •    如果必须在客户端修复：<br>    •    创建 hotfix 分支并 cherry-pick 修复 commit。<br>    •    本地与 CI 快跑 smoke tests；如果公司有内部企业签名/MDM，优先发内测/灰度：<br>    •    TestFlight 内部 + 外部分组（如果 Apple 审核不可控，使用企业签名或私有分发先行）。<br>    •    若无法快速上新：考虑在服务器侧做兼容性保护或向客户端下发最新配置来绕开 bug。<br>4) 发布策略（1–4 小时）<br>    •    紧急修复后优先做 灰度/阶段发布：<br>    •    TestFlight → 小比例外部用户 → Phased Release（App Store）或按地区分批上架。<br>    •    提交 App Store 时写清楚 Release Notes &amp; Contact（加快审核时常用“critical bug fix”）。<br>    •    在发布前必须做回归验证（关键路径、支付、登录、崩溃率采样）。</p><p>5) 复盘与长期修复（事故结束后 24–72 小时）<br>    •    召开 postmortem：记录时间线（detection → mitigation → fix → release）、根因、影响、教训、责任与改进计划。<br>    •    输出可执行改进项（例如：增加监控阈值、改善异常处理、引入 feature flags、扩展自动化回滚、完善 CI 流程）。<br>    •    更新 runbook，把此次步骤写成可重复的 playbook。<br>6) 工具 &amp; 技术点清单（作为 Senior iOS 要会的）<br>    •    崩溃分析：Crashlytics、Sentry、Bugly、App Center；dSYM 管理（Bitcode 环境需注意 dSYM 对应）。<br>    •    日志收集：自定义日志 + 采样（可用 OSLog、ELK、Datadog）、网络抓包（Charles/Proxyman）。<br>    •    回滚手段：后端开关、feature-flag（LaunchDarkly/Unleash）、灰度发布。<br>    •    发布渠道：TestFlight、企业签名、App Store Phased Release；熟悉 Apple 审核时间与加速审批渠道。<br>    •    Git 流程：hotfix 分支、cherry-pick、CI 快跑、tag/release。<br>    •    常用命令/操作：symbolicatecrash、atos、xcrun、导出 dSYM、批量下载崩溃日志脚本。</p><p>5.领导交给你一个没有接触过的领域的问题，你会怎么做</p><p>（1）明确目标</p><ul><li><p>和领导对齐需求：弄清楚调研的范围、重点和预期产出。</p><ul><li>是写一个调研报告？</li><li>还是给出可行性方案？</li><li>还是要做 PoC（验证性 demo）？</li></ul></li><li><p>了解业务背景：为什么要调研这项技术，它要解决什么问题。</p></li></ul><p>（2）快速建立基本认知</p><ul><li>官方文档、白皮书、开源项目主页 → 搞清楚基本概念和定位。</li><li>行业文章、技术博客、会议演讲视频 → 获取发展趋势和实际案例。</li><li>如果有竞品或友商应用场景 → 看他们是如何应用的。</li></ul><p>（3）梳理核心问题</p><p>围绕调研目标，提炼出关键点，比如：</p><ul><li>技术特性：优缺点、适用场景、技术原理。</li><li>使用成本：学习成本、迁移成本、运维成本。</li><li>风险点：稳定性、性能、社区活跃度、安全性。</li><li>替代方案：和现有技术的对比。</li></ul><p>（4）实践验证</p><ul><li>搭建最小可运行的 Demo（能跑起来最关键的功能）。</li><li>尝试集成到现有项目中的某个小模块，看看兼容性和实际表现。</li><li>记录踩坑点，避免团队后续重复。</li></ul><p>（5）整理成果并汇报</p><ul><li>写调研文档（背景、结论、对比、风险、建议）。</li><li>结论要有 定性分析（优劣势）+ 定量指标（性能、内存、开发工时等）。</li><li>提供清晰的建议：是否引入、如何引入、替代方案是什么。</li></ul><p>核心思路是 先明确目标 → 快速建立知识框架 → 针对核心问题深挖 → 实践验证 → 形成可落地的结论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;米可世界&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="米可世界" scheme="http://soso.wiki/tags/%E7%B1%B3%E5%8F%AF%E4%B8%96%E7%95%8C/"/>
    
  </entry>
  
  <entry>
    <title>京东金融</title>
    <link href="http://soso.wiki/2025-09-23-%E4%BA%AC%E4%B8%9C%E9%87%91%E8%9E%8D/"/>
    <id>http://soso.wiki/2025-09-23-京东金融/</id>
    <published>2025-09-23T09:00:00.000Z</published>
    <updated>2025-09-25T14:30:10.033Z</updated>
    
    <content type="html"><![CDATA[<p>京东金融<br><a id="more"></a></p><p>1.组件化，优缺点</p><p>2.SDK版本，A、B组件依赖 C，都改了 C 组件的版本，怎么保证功能可用性</p><p>3.主导的项目，SDK 体积优化，未使用的方法怎么避免误判</p><p>4.鸿蒙开发了哪些页面，列表 List 里的不同组件判断是用 Switch 吗？用过 LazyForEach 吗？JSON 转模型怎么转的？</p><p>5.有没有接触 VisionPro、机器学习、实况活动</p><p>6.规划</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;京东金融&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="京东金融" scheme="http://soso.wiki/tags/%E4%BA%AC%E4%B8%9C%E9%87%91%E8%9E%8D/"/>
    
  </entry>
  
  <entry>
    <title>掌阅</title>
    <link href="http://soso.wiki/%E6%8E%8C%E9%98%85/"/>
    <id>http://soso.wiki/掌阅/</id>
    <published>2025-09-23T06:00:00.000Z</published>
    <updated>2025-09-28T12:52:15.735Z</updated>
    
    <content type="html"><![CDATA[<p>掌阅<br><a id="more"></a></p><p>一面：</p><p>1.组件化，这些方案的优缺点</p><p>2.怎么知道多次刷新的</p><p>3.解决过的线上问题，OOM，野指针，APM监控是怎么捕获，怎么上报的？</p><p>4.算法：查找两个视图的公共父视图。</p><p>二面：</p><p>1.挑选一个项目介绍自己负责的部分</p><p>2.组件化中页面是一一对应的吗？</p><p>3.AB 实验是怎么做的？</p><p>4.埋点设计：在VIP中心怎么统计到来源</p><p>5.推荐列表划了很多页后卡顿，你觉得是问题吗？有哪些优化手段</p><p>6.讲讲做过的业务</p><p>7.算法：把无序数组变成均匀的V字形数组</p><p>三面：HR</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;掌阅&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="掌阅" scheme="http://soso.wiki/tags/%E6%8E%8C%E9%98%85/"/>
    
  </entry>
  
  <entry>
    <title>猫糖跳动</title>
    <link href="http://soso.wiki/%E7%8C%AB%E7%B3%96%E8%B7%B3%E5%8A%A8/"/>
    <id>http://soso.wiki/猫糖跳动/</id>
    <published>2025-09-18T09:00:00.000Z</published>
    <updated>2025-09-18T09:47:27.050Z</updated>
    
    <content type="html"><![CDATA[<p>猫糖跳动<br><a id="more"></a></p><p>1.Swift 的底层原理</p><p>2.Swift 的派发机制</p><p>3.Struct 中包含 Class 里的一个属性，会 copy 吗？</p><p>4.App 启动为什么需要 Rebase&amp;Bind</p><p>5.GCD 怎么取消任务</p><p>6.Hook 和反 Hook 的方法</p><p>7.弱网环境下上传大图</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;猫糖跳动&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="猫糖跳动" scheme="http://soso.wiki/tags/%E7%8C%AB%E7%B3%96%E8%B7%B3%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>首汽约车</title>
    <link href="http://soso.wiki/%E9%A6%96%E6%B1%BD%E7%BA%A6%E8%BD%A6/"/>
    <id>http://soso.wiki/首汽约车/</id>
    <published>2025-09-18T06:00:00.000Z</published>
    <updated>2025-09-18T09:46:40.464Z</updated>
    
    <content type="html"><![CDATA[<p>首汽约车<br><a id="more"></a></p><p>1.组件化</p><p>2.多线程，遇到哪些问题；一个页面8个请求，需要注意什么？数据读写安全</p><p>3.tableView 流畅性</p><p>4.用过 RAC、RxSwift 吗？</p><p>5.用地图多吗？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首汽约车&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="首汽约车" scheme="http://soso.wiki/tags/%E9%A6%96%E6%B1%BD%E7%BA%A6%E8%BD%A6/"/>
    
  </entry>
  
  <entry>
    <title>马上消费金融</title>
    <link href="http://soso.wiki/%E9%A9%AC%E4%B8%8A%E6%B6%88%E8%B4%B9%E9%87%91%E8%9E%8D/"/>
    <id>http://soso.wiki/马上消费金融/</id>
    <published>2025-09-16T09:00:00.000Z</published>
    <updated>2025-09-18T09:45:31.549Z</updated>
    
    <content type="html"><![CDATA[<p>马上消费金融<br><a id="more"></a></p><p>一面：</p><p>项目：</p><p>1.组件化，类似 CTMediator ？平级组件 A 和 B，Protocol 是写A里还是B里？怎么知道对外的API</p><p>2.路由硬编码？</p><p>3.SDK 体积优化，图片占大头吗？构建时长为什么那么长？</p><p>4.私有方法调用其实暴漏出来方法就能解决吧？</p><p>5.MVCS、MVC、MVVM 的共性和区别；SectionProvider 拆分 TableView，Cell 是在什么时候注册的？怎么自注册？在复用的时候判断是否有，用NSDictionary存，没有则创建。</p><p>6.鸿蒙开发是什么水平？</p><p>7.随版-&gt;非随怎么做的？</p><p>8.抽象手百能力，有点类似依赖注入？</p><p>9.接口精简字段怎么保证历史版本没问题？</p><p>10.活动页组件化是类似 DSL 吗？有下发样式吗？</p><p>11.H5 怎么提升访问速度？</p><p>12.H5、小程序双向通信方法做了啥？</p><p>13.接口层、JS 监控；遇到堆栈不清晰的怎么处理？</p><p>14.抽离公共组件需要注意什么？</p><p>基础知识：</p><p>1.URL 的组成，#的作用</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://user:pass@www.example.com:8080/path/page.html?id=10&amp;sort=asc#content</span><br></pre></td></tr></table></figure><ul><li><strong>协议</strong>：https</li><li><strong>用户信息</strong>：user:pass</li><li><strong>主机</strong>：<a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a></li><li><strong>端口</strong>：8080</li><li><strong>路径</strong>：/path/page.html</li><li><strong>查询参数</strong>：id=10&amp;sort=asc</li><li><strong>片段</strong>：content  用 # 引入，通常用于定位页面内部的位置（不会发送到服务器，只在浏览器端解析）</li></ul><p>2.AFN post 请求怎么修改 body 格式</p><p>3.autoreleasepool、Runloop什么时候释放</p><p>算法：括号匹配口述，如果栈提前为空，符合吗？</p><p>栈提前为空，通常意味着字符串里出现了多余的右括号</p><ul><li>在 “())” 里，前两个 () 匹配没问题，但当遇到第三个 ) 时，栈已经空了 → 没有对应的左括号 → <strong>不合法</strong>。</li><li>在 “)(“ 里，第一个就是右括号，栈一开始就空 → <strong>不合法</strong>。</li></ul><p>只有在整个遍历结束后，栈为空，才说明括号完全匹配。</p><p>二面：</p><p>项目</p><p>1.组件间通信</p><p>2.SDK构建时长为啥那么久？组件化应该怎么细分</p><p>3.加载速度优化，缓存的策略</p><p>4.活动页组件化应该是模块化吧</p><p>5.鸿蒙为什么iOS来开发，安卓更接近吧</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;马上消费金融&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="马上消费金融" scheme="http://soso.wiki/tags/%E9%A9%AC%E4%B8%8A%E6%B6%88%E8%B4%B9%E9%87%91%E8%9E%8D/"/>
    
  </entry>
  
  <entry>
    <title>雷神网络</title>
    <link href="http://soso.wiki/%E9%9B%B7%E7%A5%9E%E7%BD%91%E7%BB%9C/"/>
    <id>http://soso.wiki/雷神网络/</id>
    <published>2025-09-15T11:00:00.000Z</published>
    <updated>2025-09-16T15:35:32.992Z</updated>
    
    <content type="html"><![CDATA[<p>雷神网络<br><a id="more"></a></p><p>1.Runtime 的流程，实际项目中使用</p><p>2.IM 高并发时怎么避免卡顿？卡顿与即时性，几千条消息</p><p>批量刷新，可以设置积累几条消息后刷新，或多长时间没有消息时刷新；</p><p>用户滑动时不刷新</p><p>3.设计 SDK 怎么考虑安全性，不容易崩溃、扩展性？</p><p>分层、写代码用安全方法、开闭原则、尽可能少的暴漏非必要的属性</p><p>4.鸿蒙和原生开发效率的比较</p><p>5.AI提效做了哪些</p><p>项目：</p><p>1.SDK 构建时长为什么那么长？</p><p>2.百度文库的架构，怎么集成的小程序？</p><p>3.百度小程序跨域怎么解决的？</p><p>4.小程序、H5 双向通信方法小程序提供有，你做的是？</p><p>5.稳定性，崩溃、卡顿检测</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;雷神网络&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="雷神网络" scheme="http://soso.wiki/tags/%E9%9B%B7%E7%A5%9E%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>乐信圣文</title>
    <link href="http://soso.wiki/%E4%B9%90%E4%BF%A1%E5%9C%A3%E6%96%87/"/>
    <id>http://soso.wiki/乐信圣文/</id>
    <published>2025-09-15T09:00:00.000Z</published>
    <updated>2025-09-16T15:34:59.479Z</updated>
    
    <content type="html"><![CDATA[<p>乐信圣文<br><a id="more"></a></p><p>编程题：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在输入框中输入“10+2”，点击确定按钮，输出“10+2=12”  支持+-*/ 要求：考虑面向对象、扩展性，如又来了第五种运算%。40分钟</span><br></pre></td></tr></table></figure><p>基础：</p><p>1.@property weak 和 assign 的区别，assign 什么情况下修饰对象，unsafe_unretain 的作用</p><p>2.category 和 extension 的区别，多个 category 实现了同名方法，执行哪个？</p><p>3.通知是同步的还是异步的？</p><p>4.内存泄漏都有哪些场景，除了循环引用还有别的吗？</p><p>5.Runloop 和线程的关系，Mode 的作用，为什么这么设计？除了隔离还有什么作用？Runloop 什么时候停止？</p><p>项目：</p><p>1.构建提效</p><p>2.私有方法调用</p><p>3.MVCS 和 MVC 的区别</p><p>4.子孙组件传值</p><p>另一位面试官：</p><p>原生和跨端的占比</p><p>最近做的项目</p><h2 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a>参考答案</h2><p>编程题：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在输入框中输入“10+2”，点击确定按钮，输出“10+2=12”  支持+-*/ 要求：考虑面向对象、扩展性，如又来了第五种运算%。40分钟</span><br></pre></td></tr></table></figure><p>使用策略模式和工厂模式</p><p>策略模式：将一系列算法或行为定义成一组可以相互替换的策略类，并让它们在同一个接口下独立实现，从而使得算法的选择可以在运行时决定。</p><p>（1）抽象策略  定义统一接口</p><p>（2）具体策略 实现某个特定的算法逻辑</p><p>（3）上下文 持有策略，并通过它来执行算法</p><ul><li><strong>策略模式</strong>：侧重于 <strong>同一个对象可以有不同的行为</strong>，运行时可切换。</li><li><p><strong>工厂模式</strong>：侧重于 <strong>对象如何被创建</strong>，屏蔽创建的复杂性。</p></li><li><p>运算的 <strong>加减乘除</strong> = <strong>不同的策略（策略模式）</strong></p></li><li>运算类由 <strong>工厂统一创建（工厂模式）</strong></li><li>所以我们用了 <strong>工厂 + 策略</strong> 的组合。</li></ul><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/// 运算协议</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">@protocol</span> <span class="hljs-title">OperatorProtocol</span> &lt;<span class="hljs-title">NSObject</span>&gt;</span></span><br><span class="line">- (<span class="hljs-keyword">double</span>)calculateWithLeft:(<span class="hljs-keyword">double</span>)left right:(<span class="hljs-keyword">double</span>)right;</span><br><span class="line"><span class="hljs-keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/// 加法</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">AddOperator</span> : <span class="hljs-title">NSObject</span> &lt;<span class="hljs-title">OperatorProtocol</span>&gt;</span></span><br><span class="line"><span class="hljs-keyword">@end</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">AddOperator</span></span></span><br><span class="line">- (<span class="hljs-keyword">double</span>)calculateWithLeft:(<span class="hljs-keyword">double</span>)left right:(<span class="hljs-keyword">double</span>)right &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> left + right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/// 减法</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">SubOperator</span> : <span class="hljs-title">NSObject</span> &lt;<span class="hljs-title">OperatorProtocol</span>&gt;</span></span><br><span class="line"><span class="hljs-keyword">@end</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">SubOperator</span></span></span><br><span class="line">- (<span class="hljs-keyword">double</span>)calculateWithLeft:(<span class="hljs-keyword">double</span>)left right:(<span class="hljs-keyword">double</span>)right &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> left - right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/// 乘法</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">MulOperator</span> : <span class="hljs-title">NSObject</span> &lt;<span class="hljs-title">OperatorProtocol</span>&gt;</span></span><br><span class="line"><span class="hljs-keyword">@end</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">MulOperator</span></span></span><br><span class="line">- (<span class="hljs-keyword">double</span>)calculateWithLeft:(<span class="hljs-keyword">double</span>)left right:(<span class="hljs-keyword">double</span>)right &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> left * right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/// 除法</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">DivOperator</span> : <span class="hljs-title">NSObject</span> &lt;<span class="hljs-title">OperatorProtocol</span>&gt;</span></span><br><span class="line"><span class="hljs-keyword">@end</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">DivOperator</span></span></span><br><span class="line">- (<span class="hljs-keyword">double</span>)calculateWithLeft:(<span class="hljs-keyword">double</span>)left right:(<span class="hljs-keyword">double</span>)right &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (right == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"除数不能为0"</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> left / right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/// 取模</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">ModOperator</span> : <span class="hljs-title">NSObject</span> &lt;<span class="hljs-title">OperatorProtocol</span>&gt;</span></span><br><span class="line"><span class="hljs-keyword">@end</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ModOperator</span></span></span><br><span class="line">- (<span class="hljs-keyword">double</span>)calculateWithLeft:(<span class="hljs-keyword">double</span>)left right:(<span class="hljs-keyword">double</span>)right &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> fmod(left, right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/// 工厂类</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">OperatorFactory</span> : <span class="hljs-title">NSObject</span></span></span><br><span class="line">+ (<span class="hljs-keyword">id</span>&lt;OperatorProtocol&gt;)operatorForSymbol:(<span class="hljs-built_in">NSString</span> *)symbol;</span><br><span class="line"><span class="hljs-keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">OperatorFactory</span></span></span><br><span class="line">+ (<span class="hljs-keyword">id</span>&lt;OperatorProtocol&gt;)operatorForSymbol:(<span class="hljs-built_in">NSString</span> *)symbol &#123;</span><br><span class="line">    <span class="hljs-keyword">static</span> <span class="hljs-built_in">NSDictionary</span> *map;</span><br><span class="line">    <span class="hljs-keyword">static</span> <span class="hljs-built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="hljs-built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        map = @&#123;</span><br><span class="line">            <span class="hljs-string">@"+"</span>: [AddOperator new],</span><br><span class="line">            <span class="hljs-string">@"-"</span>: [SubOperator new],</span><br><span class="line">            <span class="hljs-string">@"*"</span>: [MulOperator new],</span><br><span class="line">            <span class="hljs-string">@"/"</span>: [DivOperator new],</span><br><span class="line">            <span class="hljs-string">@"%"</span>: [ModOperator new]</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="hljs-keyword">return</span> map[symbol];</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/// 主控制器逻辑</span></span><br><span class="line"><span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="hljs-keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="hljs-comment">// 假设输入框的字符串</span></span><br><span class="line">        <span class="hljs-built_in">NSString</span> *input = <span class="hljs-string">@"10+2"</span>; </span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment">// 简单解析：找到第一个运算符位置</span></span><br><span class="line">        <span class="hljs-built_in">NSCharacterSet</span> *operators = [<span class="hljs-built_in">NSCharacterSet</span> characterSetWithCharactersInString:<span class="hljs-string">@"+-*/%"</span>];</span><br><span class="line">        <span class="hljs-built_in">NSRange</span> range = [input rangeOfCharacterFromSet:operators];</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-keyword">if</span> (range.location != <span class="hljs-built_in">NSNotFound</span>) &#123;</span><br><span class="line">            <span class="hljs-built_in">NSString</span> *leftStr = [input substringToIndex:range.location];</span><br><span class="line">            <span class="hljs-built_in">NSString</span> *rightStr = [input substringFromIndex:range.location + <span class="hljs-number">1</span>];</span><br><span class="line">            <span class="hljs-built_in">NSString</span> *symbol = [input substringWithRange:range];</span><br><span class="line">            </span><br><span class="line">            <span class="hljs-keyword">double</span> left = [leftStr doubleValue];</span><br><span class="line">            <span class="hljs-keyword">double</span> right = [rightStr doubleValue];</span><br><span class="line">            </span><br><span class="line">            <span class="hljs-keyword">id</span>&lt;OperatorProtocol&gt; op = [OperatorFactory operatorForSymbol:symbol];</span><br><span class="line">            <span class="hljs-keyword">if</span> (op) &#123;</span><br><span class="line">                <span class="hljs-keyword">double</span> result = [op calculateWithLeft:left right:right];</span><br><span class="line">                <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"%@=%g"</span>, input, result);</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"不支持的运算符: %@"</span>, symbol);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基础：</p><p>1.@property weak 和 assign 的区别，assign 什么情况下修饰对象，unsafe_unretain 的作用</p><p>2.category 和 extension 的区别，多个 category 实现了同名方法，执行哪个？</p><p>3.通知是同步的还是异步的</p><p>同步的</p><p>4.内存泄漏都有哪些场景，除了循环引用还有别的吗？</p><p>循环引用：block、NSTimer、delegate</p><p>非循环引用：非 OC 对象，如 CGImage 等需要手动调用 Release</p><p>5.Runloop 和线程的关系，Mode的作用，为什么这么设计？除了隔离还有什么作用？Runloop 什么时候停止</p><ul><li>主线程的 RunLoop：几乎不停止，除非 App 结束。</li><li>子线程的 RunLoop：<ul><li>没有事件源就退出；</li><li>或者你显式 CFRunLoopStop()；</li><li>或者超时返回；</li><li>或者线程销毁。</li></ul></li></ul><p>项目：</p><p>1.构建提效，类数量 删除2200+头文件，删除未使用的类100+</p><p>2.私有方法调用</p><p>3.MVCS 和 MVC 的区别</p><p>4.子孙组件传值</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;乐信圣文&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="乐信圣文" scheme="http://soso.wiki/tags/%E4%B9%90%E4%BF%A1%E5%9C%A3%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>转转</title>
    <link href="http://soso.wiki/2024-09-03-%E8%BD%AC%E8%BD%AC/"/>
    <id>http://soso.wiki/2024-09-03-转转/</id>
    <published>2024-09-03T07:00:00.000Z</published>
    <updated>2025-04-09T12:25:55.933Z</updated>
    
    <content type="html"><![CDATA[<p>转转<br><a id="more"></a></p><p>一面：</p><p>1.活动页组件化，JSON 结构，跳转区分 Scheme 和 HTTP 是谁来处理的？</p><p>2.加载速度优化</p><p>3.检测无用代码是检测的 mach-o 的无用类还是方法？</p><p>4.多个请求完成后通知除了 GCD 还有什么方法？</p><p>5.webView 和原生的交互，设计一个监听原生页面声明周期，通知 H5，（有些需要监听，有些不需要监听）</p><p>6.webView 加载速度优化，项目里用到的</p><p>7.组件化怎么划分的模块，分层</p><p>8.内存管理，项目里常见的循环引用，为什么用 NSProxy，和 NSObject 区别</p><p>二面：</p><p>1.介绍项目亮点</p><p>2.设计原生与 Flutter/H5 交互  上中下三层</p><p>3.iOS 和 H5 交互方法，优缺点</p><p>4.具体规划，目前待遇，offer，期望薪资</p><h1 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a>参考答案</h1><p>一面：</p><p>1.活动页组件化，JSON 结构，跳转区分 Scheme 和 HTTP 是谁来处理的？</p><p>2.加载速度优化</p><p>3.检测无用代码是检测的 mach-o 的无用类还是方法？</p><p>4.多个请求完成后通知除了 GCD 还有什么方法？</p><p>5.webView 和原生的交互，设计一个监听原生页面声明周期，通知 H5，（有些需要监听，有些不需要监听）</p><p>6.webView 加载速度优化，项目里用到的</p><p>7.组件化怎么划分的模块，分层</p><p>（1）Accessories App附属品</p><p>Watch、Extension、Widget</p><p>（2）Business 业务组件</p><p>文库、网盘、性能监控、付费咨询、Feed、搜索等</p><p>（3）Interface 接口层</p><p>（4）Underlays 服务组件</p><p>搜索工具、Feed通用业务，天气通用数据组件等</p><p>（5）Services 服务组件</p><p>IM、Talos、Performance、UBC、AFX等</p><p>（6）Basics 基础组件</p><p>BDPDevice、Cocoa（BBAFoundation、BBAUIKit、BDPWindow、BDPAppearance、AFX）、Network</p><p>（7）Vendors 三方库</p><p>AFNetworking、SDWebImage、YYModel等</p><p>8.内存管理，项目里常见的循环引用，为什么用 NSProxy，和 NSObject 区别</p><ul><li><code>NSProxy</code> 主要用于代理和消息转发，它提供了一个机制来实现不直接处理方法调用的对象。</li><li><code>NSObject</code> 是所有 Objective-C 对象的基础类，提供了对象管理和通用功能的实现。</li></ul><p>通常情况下，如果你需要实现一种代理模式或远程调用，<code>NSProxy</code> 是合适的选择。如果你在创建一个普通的对象，<code>NSObject</code> 是你通常会继承的类。</p><p>二面：</p><p>1.介绍项目亮点</p><p>2.设计原生与 Flutter/H5 交互  上中下三层</p><p>3.iOS 和 H5 交互方法，优缺点</p><p>4.具体规划，目前待遇，offer，期望薪资</p><h2 id="📘-iOS-面试通关手册（组件化-H5-性能-架构）"><a href="#📘-iOS-面试通关手册（组件化-H5-性能-架构）" class="headerlink" title="📘 iOS 面试通关手册（组件化 / H5 / 性能 / 架构）"></a>📘 iOS 面试通关手册（组件化 / H5 / 性能 / 架构）</h2><hr><h3 id="🧩-一面核心题目详解"><a href="#🧩-一面核心题目详解" class="headerlink" title="🧩 一面核心题目详解"></a>🧩 一面核心题目详解</h3><h4 id="1-活动页组件化，JSON-结构，跳转区分-Scheme-和-HTTP-是谁来处理的？"><a href="#1-活动页组件化，JSON-结构，跳转区分-Scheme-和-HTTP-是谁来处理的？" class="headerlink" title="1. 活动页组件化，JSON 结构，跳转区分 Scheme 和 HTTP 是谁来处理的？"></a>1. 活动页组件化，JSON 结构，跳转区分 Scheme 和 HTTP 是谁来处理的？</h4><p><strong>答案要点：</strong></p><ul><li>JSON 描述跳转目标（如 URL、pageId、params）</li><li><p><code>RouterManager</code>/<code>Navigator</code> 统一解析 URL，决定打开方式：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span> ([url.scheme isEqualToString:<span class="hljs-string">@"http"</span>] || [url.scheme isEqualToString:<span class="hljs-string">@"https"</span>]) &#123;</span><br><span class="line">    <span class="hljs-comment">// 打开 WebView</span></span><br><span class="line">&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ([url.scheme isEqualToString:<span class="hljs-string">@"app"</span>]) &#123;</span><br><span class="line">    <span class="hljs-comment">// 原生跳转</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>分离跳转逻辑与页面结构，便于动态配置与热更新。</p></li></ul><hr><h4 id="2-加载速度优化"><a href="#2-加载速度优化" class="headerlink" title="2. 加载速度优化"></a>2. 加载速度优化</h4><p><strong>优化方式：</strong></p><ul><li>首屏优化：异步加载、骨架屏占位、按需加载</li><li>图片优化：压缩、缓存（SDWebImage）、懒加载</li><li>数据优化：合并请求、接口聚合、GZIP 压缩</li><li>离线缓存：预加载 HTML、JS Bundle、资源包</li><li>网络优化：HTTP2、多路复用、CDN 配置</li></ul><hr><h4 id="3-检测无用代码是检测-Mach-O-的类还是方法？"><a href="#3-检测无用代码是检测-Mach-O-的类还是方法？" class="headerlink" title="3. 检测无用代码是检测 Mach-O 的类还是方法？"></a>3. 检测无用代码是检测 Mach-O 的类还是方法？</h4><p><strong>答法：</strong></p><ul><li>都可以，通过静态分析：<ul><li><code>LinkMap</code> 文件分析未被引用的符号</li><li><code>Clang 插桩</code>、<code>Swift Demangle</code> 查看未调用的方法</li></ul></li><li>Mach-O 是最终产物，反映“未被链接进二进制”的部分</li></ul><hr><h4 id="4-多请求完成通知除了-GCD，还有什么？"><a href="#4-多请求完成通知除了-GCD，还有什么？" class="headerlink" title="4. 多请求完成通知除了 GCD，还有什么？"></a>4. 多请求完成通知除了 GCD，还有什么？</h4><p><strong>方案：</strong></p><ul><li><code>NSOperationQueue + addDependency</code></li><li>Promise/Future：PromiseKit、Combine、RxSwift</li><li>KVO 监听属性变化，触发 UI 更新</li><li>Dispatch Semaphore：手动控制信号</li></ul><hr><h4 id="5-WebView-与原生交互，监听页面生命周期通知-H5"><a href="#5-WebView-与原生交互，监听页面生命周期通知-H5" class="headerlink" title="5. WebView 与原生交互，监听页面生命周期通知 H5"></a>5. WebView 与原生交互，监听页面生命周期通知 H5</h4><p><strong>设计：</strong></p><ul><li><p>原生页面生命周期调用 JS 通知：</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[webView evaluateJavaScript:<span class="hljs-string">@"window.onNativeLifeCycle('viewDidAppear')"</span>]</span><br></pre></td></tr></table></figure></li><li><p>JS 注册：</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">window</span>.onNativeLifeCycle = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">state</span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (state === <span class="hljs-string">'viewDidAppear'</span>) &#123; <span class="hljs-comment">/* 处理 */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可配置控制哪些生命周期需要同步（如通过 JSBridge 参数指定）</p></li></ul><hr><h4 id="6-WebView-加载速度优化（项目中用到的）"><a href="#6-WebView-加载速度优化（项目中用到的）" class="headerlink" title="6. WebView 加载速度优化（项目中用到的）"></a>6. WebView 加载速度优化（项目中用到的）</h4><p><strong>方法：</strong></p><ul><li>离线资源包（JS/CSS/HTML）打包在本地</li><li>WKWebView 复用池（WebViewPool）减少初始化开销</li><li>设置 cachePolicy，合理使用缓存</li><li>禁用插件（如 JS 插件、自动检测）提高启动速度</li></ul><hr><h4 id="7-组件化怎么划分模块-分层？"><a href="#7-组件化怎么划分模块-分层？" class="headerlink" title="7. 组件化怎么划分模块 / 分层？"></a>7. 组件化怎么划分模块 / 分层？</h4><p><strong>推荐结构：</strong></p><ul><li>Base 层：网络、工具类、日志、配置</li><li>UI 层：通用 UI 组件（按钮、卡片、弹窗）</li><li>Biz 层：独立业务模块（登录、支付、商城）</li><li>Service 层：统一服务（埋点、权限、推送）</li><li>Protocol 层：各模块之间解耦协议</li></ul><p><strong>关键词：</strong> 解耦、高内聚、低耦合、模块隔离、可热更新</p><hr><h4 id="8-内存管理：循环引用、NSProxy-与-NSObject-区别"><a href="#8-内存管理：循环引用、NSProxy-与-NSObject-区别" class="headerlink" title="8. 内存管理：循环引用、NSProxy 与 NSObject 区别"></a>8. 内存管理：循环引用、NSProxy 与 NSObject 区别</h4><p><strong>常见循环引用：</strong></p><ul><li>Timer 持有控制器</li><li>Block 捕获 self</li><li>delegate 强引用</li></ul><p><strong>NSProxy 使用：</strong></p><ul><li>中转代理（如 NSTimer）：<figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">NSTimer</span> *timer = [<span class="hljs-built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="hljs-number">1</span> target:[WeakProxy proxyWithTarget:<span class="hljs-keyword">self</span>] selector:<span class="hljs-keyword">@selector</span>(run) userInfo:<span class="hljs-literal">nil</span> repeats:<span class="hljs-literal">YES</span>];</span><br></pre></td></tr></table></figure></li></ul><p><strong>与 NSObject 区别：</strong></p><ul><li>NSProxy 是消息转发专用，不继承 NSObject，无默认行为</li><li>NSObject 有默认的内存管理 / KVO / 响应链</li></ul><hr><h3 id="🚀-二面核心题目详解"><a href="#🚀-二面核心题目详解" class="headerlink" title="🚀 二面核心题目详解"></a>🚀 二面核心题目详解</h3><h4 id="1-项目亮点介绍"><a href="#1-项目亮点介绍" class="headerlink" title="1. 项目亮点介绍"></a>1. 项目亮点介绍</h4><p><strong>答题建议：</strong></p><ul><li>选一个“有挑战/成果”的模块深入讲：<ul><li>比如：活动页组件化、加载优化、自研 Bridge 桥接方案</li><li>体现技术落地、团队协作、提效效果</li></ul></li></ul><hr><h4 id="2-原生与-Flutter-H5-交互设计（上下三层）"><a href="#2-原生与-Flutter-H5-交互设计（上下三层）" class="headerlink" title="2. 原生与 Flutter/H5 交互设计（上下三层）"></a>2. 原生与 Flutter/H5 交互设计（上下三层）</h4><p><strong>三层架构：</strong></p><ul><li>上层：业务 API（login、pay、share）</li><li>中层：Bridge 协议定义、参数统一封装（JSON）</li><li>底层：Native 实现，JS 调用处理、回调、权限判断等</li></ul><hr><h4 id="3-iOS-与-H5-交互方法及优缺点"><a href="#3-iOS-与-H5-交互方法及优缺点" class="headerlink" title="3. iOS 与 H5 交互方法及优缺点"></a>3. iOS 与 H5 交互方法及优缺点</h4><table><thead><tr><th>方法</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><code>evaluateJavaScript</code></td><td>简单直接</td><td>无回调、不安全</td></tr><tr><td><code>WKScriptMessageHandler</code></td><td>安全规范、结构清晰</td><td>配置繁琐，不适合高频交互</td></tr><tr><td>URL Scheme 拦截</td><td>通用性强</td><td>参数受限、安全差</td></tr></tbody></table><hr><h4 id="4-当前待遇-amp-期望薪资"><a href="#4-当前待遇-amp-期望薪资" class="headerlink" title="4. 当前待遇 &amp; 期望薪资"></a>4. 当前待遇 &amp; 期望薪资</h4><p><strong>建议答法：</strong></p><ul><li>当前总包/薪资范围</li><li>期望平台成长 + 技术深度 +回报匹配</li><li>可接受一定灵活性，但看重发展潜力</li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转转&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="转转" scheme="http://soso.wiki/tags/%E8%BD%AC%E8%BD%AC/"/>
    
  </entry>
  
  <entry>
    <title>京东</title>
    <link href="http://soso.wiki/2024-08-29-%E4%BA%AC%E4%B8%9C/"/>
    <id>http://soso.wiki/2024-08-29-京东/</id>
    <published>2024-08-29T09:30:00.000Z</published>
    <updated>2024-09-11T07:53:08.376Z</updated>
    
    <content type="html"><![CDATA[<p>京东<br><a id="more"></a></p><p>一面：</p><p>1.SDK 体积优化</p><p>2.组件化</p><p>3.端到端监控，具体实现</p><p>4.YYModel 的实现原理，和 MJExtension 区别，为什么比 MJExtension 快？</p><p>5.OOM 怎么排查</p><p>6.Facebook 出的异步渲染框架 AsyncDisplayKit 原理</p><p>7.样式字段很多，怎么和逻辑字段分开下发？</p><p>8.跨端方案，Talos lite</p><p>9.怎么提升代码质量</p><p>10.设计模式：策略模式、中介者模式</p><p>11.打点 cell 50%展现时打点</p><p>打点规范，怎么快速找到某一个页面的所有点击点位</p><p>12.产品上的业务指标</p><p>13.读写安全，除了加锁还有哪些方法</p><p>14.算法：实现一个列表，复用，不卡顿，cell 上是多个文本</p><p>二面：</p><p>1.Flutter 与 iOS 交互方法？</p><p>2.Flutter 的 UI 层在哪儿？RN 是原生控件</p><p>3.组件化的 Router 里的映射表什么时候生成？</p><p>4.JSBridge 原理，前端 JS 有哪些异步方法？前端有哪些存储方法，localstorage有大小限制吗？</p><p>5.iOS 打包流程，命令  Xcode build；Cocoapods 打包出来的第三方库是什么形式的？源码还是二进制？.a和.framework 有什么区别？</p><p>6.接口监控</p><p>7.为什么用到动态库，动态库类型是什么 so？</p><p>8.加载速度优化</p><p>9.SDK 体积优化</p><p>10.RN 的原理，怎么转成了原生控件？了解哪些动态化的方案？Weex、小程序等的区别</p><p>11.了解哪些性能优化，滑动流畅性的指标</p><p>12.深拷贝和浅拷贝的区别</p><p>13.App 启动流程，优化手段，main函数有哪些优化地方</p><p>14.发一个 Post 请求，怎么加快速度？Get 和 Post 请求区别，Get 可以将参数放在请求体吗？</p><p>15.触摸屏幕流程</p><p>16.Swift 中 Class 和 Struct 区别，Struct 可以继承吗？</p><p>17.堆和栈的区别</p><p>18.内存 isa</p><p>19.绘制流程</p><p>20.加载速度优化，各个阶段耗时有统计吗？网络的耗时在哪块儿？</p><p>21.IM 的架构</p><p>22.IM 怎么保证消息的顺序</p><h2 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a>参考答案</h2><p>一面：</p><p>1.SDK体积优化</p><p>2.组件化</p><p>3.端到端监控，具体实现</p><p>4.OOM怎么排查</p><p>5.样式字段很多，怎么和逻辑字段分开下发？</p><p>6.跨端方案，Talos lite</p><p>7.怎么提升代码质量</p><p>8.设计模式：策略模式、中介者模式</p><p>常见的23种设计模式包括：</p><ol><li><strong>创建型模式</strong>：<ul><li>单例模式 (Singleton)</li><li>工厂方法模式 (Factory Method)</li><li>抽象工厂模式 (Abstract Factory)</li><li>建造者模式 (Builder)</li><li>原型模式 (Prototype)</li></ul></li><li><strong>结构型模式</strong>：<ul><li>适配器模式 (Adapter)</li><li>桥接模式 (Bridge)</li><li>组合模式 (Composite)</li><li>装饰器模式 (Decorator)</li><li>外观模式 (Facade)</li><li>享元模式 (Flyweight)</li><li>代理模式 (Proxy)</li></ul></li><li><strong>行为型模式</strong>：<ul><li>责任链模式 (Chain of Responsibility)</li><li>命令模式 (Command)</li><li>解释器模式 (Interpreter)</li><li>迭代器模式 (Iterator)</li><li>中介者模式 (Mediator)</li><li>存储器模式 (Memento)</li><li>观察者模式 (Observer)</li><li>状态模式 (State)</li><li>策略模式 (Strategy)</li><li>模板方法模式 (Template Method)</li><li>访问者模式 (Visitor)</li></ul></li></ol><h4 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a><a href="https://www.runoob.com/design-pattern/mediator-pattern.html" target="_blank" rel="noopener">中介者模式</a></h4><p>中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性，属于行为型模式。</p><p>中介者模式定义了一个中介对象来封装一系列对象之间的交互。中介者使各对象之间不需要显式地相互引用，从而使其耦合松散，且可以独立地改变它们之间的交互。</p><h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a><a href="https://www.runoob.com/design-pattern/strategy-pattern.html" target="_blank" rel="noopener">策略模式</a></h4><p>在策略模式（Strategy Pattern）中一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。</p><p>在策略模式定义了一系列算法或策略，并将每个算法封装在独立的类中，使得它们可以互相替换。通过使用策略模式，可以在运行时根据需要选择不同的算法，而不需要修改客户端代码。</p><p>在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。</p><p>9.打点 cell 50%展现时打点</p><p>可以使用<code>UITableView</code>的<code>scrollViewDidScroll</code>方法来检测<code>cell</code>的可见区域。具体步骤如下：</p><ol><li><strong>设置UITableViewDelegate</strong>: 确保你的视图控制器实现了<code>UITableViewDelegate</code>协议，并设置<code>delegate</code>。</li><li><strong>计算可见区域</strong>: 在<code>scrollViewDidScroll</code>方法中，计算每个<code>cell</code>的可见区域，并检查它是否至少展现了50%。</li><li><strong>打点逻辑</strong>: 根据计算结果进行打点操作，例如记录数据或发送网络请求。</li></ol><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#import <span class="hljs-meta-string">"ViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">ViewController</span> () &lt;<span class="hljs-title">UITableViewDelegate</span>, <span class="hljs-title">UITableViewDataSource</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">weak</span>, <span class="hljs-keyword">nonatomic</span>) <span class="hljs-keyword">IBOutlet</span> <span class="hljs-built_in">UITableView</span> *tableView;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="hljs-keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="hljs-keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="hljs-keyword">self</span>.tableView.delegate = <span class="hljs-keyword">self</span>;</span><br><span class="line">    <span class="hljs-keyword">self</span>.tableView.dataSource = <span class="hljs-keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">#pragma mark - UITableViewDataSource</span></span><br><span class="line"></span><br><span class="line">- (<span class="hljs-built_in">NSInteger</span>)tableView:(<span class="hljs-built_in">UITableView</span> *)tableView numberOfRowsInSection:(<span class="hljs-built_in">NSInteger</span>)section &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>; <span class="hljs-comment">// 示例行数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="hljs-built_in">UITableViewCell</span> *)tableView:(<span class="hljs-built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="hljs-built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">    <span class="hljs-built_in">UITableViewCell</span> *cell = [tableView dequeueReusableCellWithIdentifier:<span class="hljs-string">@"cell"</span> forIndexPath:indexPath];</span><br><span class="line">    cell.textLabel.text = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@"Row %ld"</span>, (<span class="hljs-keyword">long</span>)indexPath.row];</span><br><span class="line">    <span class="hljs-keyword">return</span> cell;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">#pragma mark - UIScrollViewDelegate</span></span><br><span class="line"></span><br><span class="line">- (<span class="hljs-keyword">void</span>)scrollViewDidScroll:(<span class="hljs-built_in">UIScrollView</span> *)scrollView &#123;</span><br><span class="line">    <span class="hljs-built_in">NSArray</span>&lt;<span class="hljs-built_in">UITableViewCell</span> *&gt; *visibleCells = [<span class="hljs-keyword">self</span>.tableView visibleCells];</span><br><span class="line">    <span class="hljs-built_in">CGRect</span> visibleRect;</span><br><span class="line">    visibleRect.origin = <span class="hljs-keyword">self</span>.tableView.contentOffset;</span><br><span class="line">    visibleRect.size = <span class="hljs-keyword">self</span>.tableView.bounds.size;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">UITableViewCell</span> *cell <span class="hljs-keyword">in</span> visibleCells) &#123;</span><br><span class="line">        <span class="hljs-built_in">CGRect</span> cellRect = [<span class="hljs-keyword">self</span>.tableView convertRect:cell.frame toView:<span class="hljs-keyword">self</span>.tableView.superview];</span><br><span class="line">        <span class="hljs-built_in">CGRect</span> intersection = <span class="hljs-built_in">CGRectIntersection</span>(visibleRect, cellRect);</span><br><span class="line">        <span class="hljs-built_in">CGFloat</span> intersectionRatio = intersection.size.height / cellRect.size.height;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> (intersectionRatio &gt;= <span class="hljs-number">0.5</span>) &#123;</span><br><span class="line">            <span class="hljs-built_in">NSIndexPath</span> *indexPath = [<span class="hljs-keyword">self</span>.tableView indexPathForCell:cell];</span><br><span class="line">            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"Cell at %ld is at least 50%% visible."</span>, (<span class="hljs-keyword">long</span>)indexPath.row);</span><br><span class="line">            <span class="hljs-comment">// 打点逻辑，例如记录或发送请求</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul><li><strong>计算可见区域</strong>：使用<code>convertRect:toView:</code>方法将<code>cell</code>的frame转换到<code>superview</code>的坐标系，然后计算交集区域。</li><li><strong>检查比例</strong>：判断交集区域的高度与<code>cell</code>的总高度的比例是否大于或等于50%。</li></ul><p>这个实现将确保在<code>UITableView</code>滚动时，对每个<code>cell</code>进行检查，并在其至少展现50%时执行打点操作。</p><p>打点规范，怎么快速找到某一个页面的所有点击点位</p><p>10.产品上的业务指标</p><p>11.读写安全，除了加锁还有哪些方法</p><p>12.算法：实现一个列表，复用，不卡顿，cell上是多个文本</p><p>二面：</p><p>1.Flutter 与 iOS 交互方法？</p><p>2.Flutter 的 UI 层在哪儿？RN 是原生控件</p><p>3.组件化的 Router 里的映射表什么时候生成？</p><p>4.JSBridge 原理</p><p>5.iOS 打包流程，命令  Xcode build；Cocoapods 打包出来的第三方库是什么形式的？源码还是二进制？.a和.framework 有什么区别？</p><p>CocoaPods 打包出来的第三方库可以是源码形式，也可以是二进制形式，取决于库的发布方式。</p><ol><li><strong>源码形式</strong>：大多数CocoaPods库以源码形式提供。这意味着CocoaPods会将库的源代码下载到你的项目中，并在构建时编译这些代码。</li><li><strong>二进制形式</strong>：一些库提供二进制预编译版本，以减少编译时间和提高构建速度。在这种情况下，CocoaPods会下载预编译的二进制文件，而不是源码。</li></ol><p>你可以在<code>Podspec</code>文件中检查库的具体形式，通常在<code>source</code>字段中定义了库的来源。如果是二进制库，<code>Podspec</code>会指定二进制文件的URL和相关配置。</p><p><code>.a</code>和<code>.framework</code>是iOS开发中常见的两种二进制文件格式，分别代表静态库和动态库。它们的主要区别如下：</p><ol><li><strong><code>.a</code>（静态库）</strong>：<ul><li><strong>打包形式</strong>：静态库是一个归档文件，包含了多个编译好的目标文件（<code>.o</code>文件）。</li><li><strong>链接方式</strong>：在编译时，静态库的代码会被直接链接到应用程序中。每次构建时，库的代码会被复制到最终的可执行文件中。</li><li><strong>更新</strong>：如果静态库的代码有更新，必须重新编译整个应用程序。</li><li><strong>体积</strong>：由于代码被复制到应用程序中，最终的应用包可能会较大。</li></ul></li><li><strong><code>.framework</code>（动态库）</strong>：<ul><li><strong>打包形式</strong>：动态库是一个文件夹（包），包含库的二进制文件以及相关的资源文件（如头文件和配置文件）。它可以包含多个版本和资源。</li><li><strong>链接方式</strong>：动态库在运行时被加载到内存中。应用程序在运行时与库链接，而不是在编译时。这样，多个应用程序可以共享同一个动态库。</li><li><strong>更新</strong>：更新动态库只需替换库文件，不需要重新编译依赖于该库的应用程序。</li><li><strong>体积</strong>：动态库的使用可以减少最终应用程序的体积，因为库的代码和资源在运行时被共享和加载。</li></ul></li></ol><p>简而言之，<code>.a</code>是静态库，编译时直接包含在应用中；<code>.framework</code>是动态库，在运行时动态加载和共享。</p><p>6.接口监控</p><p>7.为什么用到动态库，动态库类型是什么 so？</p><p>8.加载速度优化</p><p>9.SDK 体积优化</p><p>10.RN 的原理，怎么转成了原生控件？了解哪些动态化的方案？Weex、小程序等的区别</p><p>11.了解哪些性能优化，滑动流畅性的指标</p><p>12.深拷贝和浅拷贝的区别</p><p>13.App 启动流程，优化手段，main函数有哪些优化地方</p><p>14.发一个 Post 请求，怎么加快速度？Get 和 Post 请求区别，Get 可以将参数放在请求体吗？</p><p>15.触摸屏幕流程</p><p>16.Swift 中 Class 和 Struct 区别，Struct 可以继承吗？</p><p>17.堆和栈的区别</p><p>18.内存 isa</p><p>19.绘制流程</p><p>20.加载速度优化，各个阶段耗时有统计吗？网络的耗时在哪块儿？</p><p>21.IM 的架构</p><p>22.IM 怎么保证消息的顺序</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;京东&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="京东" scheme="http://soso.wiki/tags/%E4%BA%AC%E4%B8%9C/"/>
    
      <category term="京东搜索" scheme="http://soso.wiki/tags/%E4%BA%AC%E4%B8%9C%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>天眼查</title>
    <link href="http://soso.wiki/2024-08-29-%E5%A4%A9%E7%9C%BC%E6%9F%A5/"/>
    <id>http://soso.wiki/2024-08-29-天眼查/</id>
    <published>2024-08-29T03:00:00.000Z</published>
    <updated>2024-08-29T09:14:55.744Z</updated>
    
    <content type="html"><![CDATA[<p>天眼查<br><a id="more"></a></p><p>1.通用化技术提升迭代效率</p><p>2.降低三方 App 接入成本</p><p>3.SDK 体积优化，为什么用 Masonry 会增加体积</p><p>4.加载速度优化，怎么统计的？多个请求并发怎么处理的？</p><p>5.引用计数，isa 里都有什么？weak 的实现？对象的释放流程</p><p>6.方法交换交换的是什么？</p><p>7.SDWebImage加载url的流程，三级缓存，清除缓存</p><p>7.block 的变量捕获，为什么用<code>__block</code>可以修改局部变量的值</p><p>8.找出代码里有问题的地方，可变数组用 copy 修饰，调用添加元素方法会发生什么？能不能上报、拦截闪退？线程不安全怎么处理？常用的加锁方式，区别？</p><p>9.<a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">删除链表的倒数第 N 个结点</a></p><h2 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a>参考答案</h2><p>1.通用化技术提升迭代效率</p><p>2.降低三方 App 接入成本</p><p>3.SDK 体积优化，为什么用 Masonry 会增加体积</p><p>4.加载速度优化，怎么统计的？多个请求并发怎么处理的？</p><p>5.引用计数，isa 里都有什么？weak 的实现？对象的释放流程，怎么判断是否有弱引用</p><p>isa</p><ul><li><p>nonpointer 0，代表普通的指针，存储着Class、Meta-Class对象的内存地址1，代表优化过，使用位域存储更多的信息</p></li><li><p>has_assoc 是否有设置过关联对象，如果没有，释放时会更快</p></li><li><p>has_cxx_dtor 是否有C++的析构函数（.cxx_destruct），如果没有，释放时会更快</p></li><li><p>shiftcls 存储着Class、Meta-Class对象的内存地址信息</p></li><li><p>magic 用于在调试时分辨对象是否未完成初始化</p></li><li><p>weakly_referenced 是否有被弱引用指向过，如果没有，释放时会更快</p></li><li><p>deallocating 对象是否正在释放</p></li><li><p>extra_rc 里面存储的值是引用计数器减1</p></li><li><p>has_sidetable_rc 引用计数器是否过大无法存储在isa中如果为1，那么引用计数会存储在一个叫SideTable的类的属性中</p></li></ul><p>6.方法交换交换的是什么？</p><p>7.block 的变量捕获，为什么用<code>__block</code>可以修改局部变量的值</p><p>8.找出代码里有问题的地方，可变数组用 copy 修饰，调用添加元素方法会发生什么？能不能上报、拦截闪退？线程不安全怎么处理？常用的加锁方式，区别？</p><p>9.<a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">删除链表的倒数第 N 个结点</a></p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="hljs-comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="hljs-comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="hljs-comment"> * &#125;</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">var</span> removeNthFromEnd = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head, n</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> length = getLength(head);</span><br><span class="line">    <span class="hljs-keyword">let</span> i = length - n;</span><br><span class="line">    <span class="hljs-keyword">let</span> dummyNode = <span class="hljs-keyword">new</span> ListNode();</span><br><span class="line">    dummyNode.next = head;</span><br><span class="line">    <span class="hljs-keyword">let</span> p = dummyNode;</span><br><span class="line">    <span class="hljs-keyword">while</span> (i &gt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">        p = p.next;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    p.next = p.next.next;</span><br><span class="line">    <span class="hljs-keyword">return</span> dummyNode.next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> getLength = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> length = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">let</span> p = head;</span><br><span class="line">    <span class="hljs-keyword">while</span> (p) &#123;</span><br><span class="line">        length++;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;天眼查&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="天眼查" scheme="http://soso.wiki/tags/%E5%A4%A9%E7%9C%BC%E6%9F%A5/"/>
    
  </entry>
  
  <entry>
    <title>二叉树算法题</title>
    <link href="http://soso.wiki/2024-08-29-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    <id>http://soso.wiki/2024-08-29-二叉树算法题/</id>
    <published>2024-08-28T16:06:00.000Z</published>
    <updated>2024-08-28T16:13:54.197Z</updated>
    
    <content type="html"><![CDATA[<p>二叉树算法题（ JavaScript 实现）<br><a id="more"></a></p><h4 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">二叉树的中序遍历</a></h4><p>递归：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> inorderTraversal = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> res = []</span><br><span class="line">    <span class="hljs-keyword">const</span> inorder = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(root.left);</span><br><span class="line">        res.push(root.val);</span><br><span class="line">        inorder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    inorder(root);</span><br><span class="line">    <span class="hljs-keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>迭代：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> inorderTraversal = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">const</span> res = [];</span><br><span class="line">    <span class="hljs-keyword">const</span> stack = [];</span><br><span class="line">    <span class="hljs-keyword">let</span> cur = root;</span><br><span class="line">    <span class="hljs-keyword">while</span> (stack.length || cur) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (cur) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            cur = stack.pop();</span><br><span class="line">            res.push(cur.val);</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">二叉树的层序遍历</a></h4><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> levelOrder = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">const</span> res = [], queue = [];</span><br><span class="line">    queue.push(root);</span><br><span class="line">    <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">while</span> (queue.length) &#123;</span><br><span class="line">        <span class="hljs-keyword">let</span> curLevel = [];</span><br><span class="line">        <span class="hljs-keyword">let</span> length = queue.length;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="hljs-keyword">let</span> node = queue.shift();</span><br><span class="line">            curLevel.push(node.val);</span><br><span class="line">            <span class="hljs-keyword">if</span> (node.left) &#123;</span><br><span class="line">                queue.push(node.left);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="hljs-keyword">if</span> (node.right) &#123;</span><br><span class="line">                queue.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.push(curLevel);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">二叉树的最大深度</a></h4><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> maxDepth = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.max(maxDepth(root.left), maxDepth(root.right)) + <span class="hljs-number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a><a href="https://leetcode.cn/problems/invert-binary-tree/" target="_blank" rel="noopener">翻转二叉树</a></h4><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> invertTree = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">let</span> left = invertTree(root.left);</span><br><span class="line">    <span class="hljs-keyword">let</span> right = invertTree(root.right);</span><br><span class="line">    root.left = right;</span><br><span class="line">    root.right = left;</span><br><span class="line">    <span class="hljs-keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="二叉树的直径"><a href="#二叉树的直径" class="headerlink" title="二叉树的直径"></a><a href="https://leetcode.cn/problems/diameter-of-binary-tree/" target="_blank" rel="noopener">二叉树的直径</a></h4><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> diameterOfBinaryTree = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> ans = <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDepth</span>(<span class="hljs-params">root</span>) </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">let</span> left = getDepth(root.left);</span><br><span class="line">        <span class="hljs-keyword">let</span> right = getDepth(root.right);</span><br><span class="line">        ans = <span class="hljs-built_in">Math</span>.max(ans, left + right + <span class="hljs-number">1</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.max(left, right) + <span class="hljs-number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    getDepth(root);</span><br><span class="line">    <span class="hljs-keyword">return</span> ans - <span class="hljs-number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;二叉树算法题（ JavaScript 实现）&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="算法" scheme="http://soso.wiki/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="http://soso.wiki/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>百川智能</title>
    <link href="http://soso.wiki/%E7%99%BE%E5%B7%9D%E6%99%BA%E8%83%BD/"/>
    <id>http://soso.wiki/百川智能/</id>
    <published>2024-08-28T03:00:00.000Z</published>
    <updated>2024-08-30T05:53:38.036Z</updated>
    
    <content type="html"><![CDATA[<p>百川智能<br><a id="more"></a></p><p>一面：</p><p>1.SDK体积优化</p><p>2.webView白屏</p><p>3.线上闪退处理流程</p><p>4.Runtime、Runloop应用，结合项目；为什么开启runloop</p><p>5.MVC MVVM 项目里具体的用法</p><p>算法：</p><p>1.单链表中是否存在环？如果存在，返回环的起始节点。解释快慢指针原理。</p><p>2.一百盏灯排成一行,从左到右编号1-100,每盏灯都有一根开关,一开始全是灭的,另外有100小孩,第一个把1的倍数的开关拉一下,第二个把凡是2的倍数开关拉一下,这样下去到最后一盏灯,有哪些是亮的？（口述思路）</p><p>二面：</p><p>1.写一个工具方法：用 OC 或 Swift 实现，查找数组的第 k 个大的元素</p><p>要求能在项目里实际使用，可以用三方库。注意边界条件。</p><p>2.卡片动态化，怎么避免因为卡片样式等接需求</p><p>3.IM列表数据过大的问题</p><p>4.删除消息怎么保证多端一致性</p><p>5.怎么解决ViewModel过大的问题，MVVM和MVC的核心区别是双向绑定吗？</p><p>6.为什么选择SSE</p><p>7.离线包</p><p>8.webView cookie 丢失问题</p><p>9.RN长列表性能问题</p><h2 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a>参考答案</h2><p>(GPT)</p><p>1.SDK体积优化</p><p>2.webView白屏</p><p>3.线上闪退处理流程</p><p>4.Runtime、Runloop应用，结合项目</p><p>算法：</p><p>1.单链表中是否存在环？如果存在，返回环的起始节点。解释快慢指针原理。</p><p>2.一百盏灯排成一行,从左到右编号1-100,每盏灯都有一根开关,一开始全是灭的,另外有100小孩,第一个把1的倍数的开关拉一下,第二个把凡是2的倍数开关拉一下,这样下去到最后一盏灯,有哪些是亮的？（口述思路）</p><p>这个问题可以通过分析开关操作的规律来解决。我们来详细探讨一下每盏灯的状态。</p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><ul><li>一开始，每盏灯都是灭的。</li><li>每个小孩操作的是与他们编号相同的倍数的开关。例如，第一个小孩操作的是1、2、3、4、…、100号开关；第二个小孩操作的是2、4、6、8、…、100号开关，依此类推。</li></ul><h3 id="观察灯的状态"><a href="#观察灯的状态" class="headerlink" title="观察灯的状态"></a>观察灯的状态</h3><p>每盏灯的状态取决于被多少个小孩操作。一个灯的状态会在操作次数（开关次数）为奇数时变为亮，为偶数时保持灭。</p><p>我们可以发现：</p><ul><li>如果灯的编号是 ( n )，那么它会被所有 ( n ) 的因子的小孩操作。比如，灯编号为12的灯会被1、2、3、4、6、12号小孩操作。</li><li>因此，每盏灯的状态由它的因子数量决定。如果因子数量是奇数，则灯是亮的。如果因子数量是偶数，则灯是灭的。</li></ul><h3 id="因子数量的分析"><a href="#因子数量的分析" class="headerlink" title="因子数量的分析"></a>因子数量的分析</h3><p>每个正整数 ( n ) 的因子数量通常是偶数，因为因子通常成对出现（比如 ( 1 ) 和 ( n ), ( 2 ) 和 ( n/2 ) 等）。然而，完全平方数（如1, 4, 9, 16, …）的因子数量是奇数，因为一个因子对（如 ( \sqrt{n} )）会被重复计算一次。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul><li>只有完全平方数的因子数量是奇数，因此只有那些灯编号是完全平方数的灯会在最后亮着。</li></ul><h3 id="列出完全平方数"><a href="#列出完全平方数" class="headerlink" title="列出完全平方数"></a>列出完全平方数</h3><ol><li>( 1^2 = 1 )</li><li>( 2^2 = 4 )</li><li>( 3^2 = 9 )</li><li>( 4^2 = 16 )</li><li>( 5^2 = 25 )</li><li>( 6^2 = 36 )</li><li>( 7^2 = 49 )</li><li>( 8^2 = 64 )</li><li>( 9^2 = 81 )</li><li>( 10^2 = 100 )</li></ol><p>所以，最后亮着的灯的编号是：1, 4, 9, 16, 25, 36, 49, 64, 81, 100。</p><p>二面：</p><p>1.写一个工具方法：用 OC 或 Swift 实现，查找数组的第 k 个大的元素</p><p>要求能在项目里实际使用，可以用三方库。注意边界条件。</p><p>2.卡片动态化，怎么避免因为卡片样式等接需求</p><p>3.IM列表数据过大的问题</p><p>4.删除消息怎么保证多端一致性</p><p>5.怎么解决ViewModel过大的问题，MVVM和MVC的核心区别是双向绑定吗？</p><p>6.为什么选择SSE</p><p>相较于其他流式数据传输方式，SSE 的优点包括：</p><ol><li><strong>简单实现</strong>：SSE 使用标准的 HTTP 协议，易于实现和调试，尤其是对于基本的实时推送需求。</li><li><strong>自动重连</strong>：SSE 支持自动重连机制，连接丢失后会自动尝试重新建立连接，确保数据传输的可靠性。</li><li><strong>单向通信</strong>：适用于只需要从服务器到客户端的单向数据流的场景，例如新闻推送或实时更新。</li><li><strong>轻量级</strong>：SSE 不需要额外的握手或复杂的协议栈，相比 WebSocket，SSE 的实现和维护成本较低。</li><li><strong>文本数据</strong>：SSE 以 UTF-8 编码的文本格式传输数据，解析起来较为简单。</li></ol><p>这些优点使 SSE 在需要简单、可靠的实时数据推送时成为一个合适的选择。</p><p>流式数据可以通过多种方式进行传输，具体选择取决于应用场景、性能需求和技术栈。以下是一些常见的流式数据传输方法：</p><h3 id="1-WebSocket"><a href="#1-WebSocket" class="headerlink" title="1. WebSocket"></a>1. <strong>WebSocket</strong></h3><ul><li><strong>描述</strong>：WebSocket 是一种在单个 TCP 连接上进行全双工通信的协议。与 HTTP 不同，它允许在客户端和服务器之间进行双向实时数据交换。</li><li><strong>适用场景</strong>：需要双向实时通信的应用，例如在线游戏、实时聊天、协作工具。</li><li><strong>优点</strong>：低延迟、双向通信、持久连接。</li></ul><h3 id="2-Server-Sent-Events-SSE"><a href="#2-Server-Sent-Events-SSE" class="headerlink" title="2. Server-Sent Events (SSE)"></a>2. <strong>Server-Sent Events (SSE)</strong></h3><ul><li><strong>描述</strong>：SSE 允许服务器通过单向的持久连接向客户端推送实时事件。客户端可以通过 EventSource API 接收这些事件。</li><li><strong>适用场景</strong>：需要从服务器向客户端推送实时数据的应用，例如实时更新的新闻推送、监控系统。</li><li><strong>优点</strong>：简单易用、自动重连、支持文本数据。</li></ul><h3 id="3-HTTP-2"><a href="#3-HTTP-2" class="headerlink" title="3. HTTP/2"></a>3. <strong>HTTP/2</strong></h3><ul><li><strong>描述</strong>：HTTP/2 是 HTTP 协议的升级版，支持多路复用（multiplexing），允许在单个 TCP 连接上并发传输多个请求和响应。</li><li><strong>适用场景</strong>：需要高效和快速加载的网页应用、实时更新的内容。</li><li><strong>优点</strong>：减少延迟、提高传输效率、支持流式数据传输。</li></ul><h3 id="4-gRPC"><a href="#4-gRPC" class="headerlink" title="4. gRPC"></a>4. <strong>gRPC</strong></h3><ul><li><strong>描述</strong>：gRPC 是 Google 开发的开源高性能 RPC 框架，支持双向流式通信。基于 HTTP/2，提供了高效的通信机制。</li><li><strong>适用场景</strong>：微服务架构、需要高效传输和处理大规模数据的系统。</li><li><strong>优点</strong>：强类型、安全、高性能、支持双向流。</li></ul><h3 id="5-MQTT-Message-Queuing-Telemetry-Transport"><a href="#5-MQTT-Message-Queuing-Telemetry-Transport" class="headerlink" title="5. MQTT (Message Queuing Telemetry Transport)"></a>5. <strong>MQTT (Message Queuing Telemetry Transport)</strong></h3><ul><li><strong>描述</strong>：MQTT 是一种轻量级的消息传输协议，设计用于低带宽、不稳定的网络环境。支持发布/订阅模型。</li><li><strong>适用场景</strong>：物联网（IoT）设备通信、低带宽网络中的消息传输。</li><li><strong>优点</strong>：轻量、可靠、适合低带宽和高延迟的环境。</li></ul><h3 id="6-Apache-Kafka"><a href="#6-Apache-Kafka" class="headerlink" title="6. Apache Kafka"></a>6. <strong>Apache Kafka</strong></h3><ul><li><strong>描述</strong>：Apache Kafka 是一个分布式流媒体平台，用于构建实时数据流应用和数据管道。支持高吞吐量的数据传输。</li><li><strong>适用场景</strong>：需要处理大量实时数据的应用、数据管道、日志聚合。</li><li><strong>优点</strong>：高吞吐量、可扩展、持久性、高可靠性。</li></ul><h3 id="7-Redis-Streams"><a href="#7-Redis-Streams" class="headerlink" title="7. Redis Streams"></a>7. <strong>Redis Streams</strong></h3><ul><li><strong>描述</strong>：Redis Streams 是 Redis 的一种数据结构，用于处理流数据。支持持久化、高效的流数据存储和处理。</li><li><strong>适用场景</strong>：需要高效处理流数据的应用，例如实时数据分析、日志处理。</li><li><strong>优点</strong>：高性能、简单易用、支持持久化和数据恢复。</li></ul><h3 id="8-WebRTC"><a href="#8-WebRTC" class="headerlink" title="8. WebRTC"></a>8. <strong>WebRTC</strong></h3><ul><li><strong>描述</strong>：WebRTC 是一种支持浏览器之间直接进行实时通信的技术，支持视频、音频和数据流。</li><li><strong>适用场景</strong>：视频会议、实时数据传输、点对点通信。</li><li><strong>优点</strong>：低延迟、点对点通信、支持多种数据类型。</li></ul><h3 id="9-Chunked-Transfer-Encoding"><a href="#9-Chunked-Transfer-Encoding" class="headerlink" title="9. Chunked Transfer Encoding"></a>9. <strong>Chunked Transfer Encoding</strong></h3><ul><li><strong>描述</strong>：这是 HTTP/1.1 中的一种传输编码方式，允许服务器分块传输数据，客户端可以在接收数据时开始处理。</li><li><strong>适用场景</strong>：需要逐步传输大数据的场景。</li><li><strong>优点</strong>：支持动态生成和传输数据，减少了延迟。</li></ul><h3 id="10-Data-Streams-File-Streams"><a href="#10-Data-Streams-File-Streams" class="headerlink" title="10. Data Streams (File Streams)"></a>10. <strong>Data Streams (File Streams)</strong></h3><ul><li><strong>描述</strong>：通过文件流传输数据，通常用于大文件的逐步传输和处理。</li><li><strong>适用场景</strong>：大文件传输、流式处理数据。</li><li><strong>优点</strong>：支持大数据文件的逐步传输、处理。</li></ul><p>选择合适的流式数据传输方式需要考虑具体的应用需求、数据量、实时性要求、网络条件等因素。每种技术都有其特定的优点和适用场景。</p><p>7.离线包</p><p>8.webView cookie 丢失问题</p><p>iOS WebView 中的 Cookie 丢失通常可以由以下几个原因引起：</p><ol><li><strong>App 重新启动</strong>：WebView 的 Cookie 存储在内存中，当应用被终止或重启时，这些 Cookie 可能会丢失。</li><li><strong>Cookies 设置</strong>：iOS 的 WebView 可能会受到应用的 Cookie 设置或隐私策略的影响，特别是在使用 <code>WKWebView</code> 时，它的 Cookie 存储可能与 <code>UIWebView</code> 不同。</li><li><strong>共享 Cookie</strong>：<code>WKWebView</code> 和 <code>UIWebView</code> 使用不同的 Cookie 存储机制，它们之间的 Cookie 可能无法共享。</li><li><strong>域名问题</strong>：确保设置和读取 Cookie 的域名一致，跨域请求可能导致 Cookie 丢失。</li></ol><h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h3><ol><li><p><strong>使用 <code>WKWebView</code> 的 <code>WKWebsiteDataStore</code></strong>：</p><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> webView = <span class="hljs-type">WKWebView</span>(frame: .zero, configuration: <span class="hljs-type">WKWebViewConfiguration</span>())</span><br><span class="line"><span class="hljs-keyword">let</span> dataStore = <span class="hljs-type">WKWebsiteDataStore</span>.<span class="hljs-keyword">default</span>()</span><br><span class="line">webView.configuration.websiteDataStore = dataStore</span><br></pre></td></tr></table></figure></li><li><p><strong>持久化 Cookie</strong>： 你可以手动持久化和恢复 Cookie。例如，通过 <code>HTTPCookieStorage</code> 保存 Cookie，然后在应用启动时恢复：</p><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// Save cookies</span></span><br><span class="line"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> cookies = <span class="hljs-type">HTTPCookieStorage</span>.shared.cookies &#123;</span><br><span class="line">    <span class="hljs-type">UserDefaults</span>.standard.<span class="hljs-keyword">set</span>(cookies.<span class="hljs-built_in">map</span> &#123; <span class="hljs-type">NSKeyedArchiver</span>.archivedData(withRootObject: \$<span class="hljs-number">0</span>) &#125;, forKey: <span class="hljs-string">"savedCookies"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Load cookies</span></span><br><span class="line"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> cookieData = <span class="hljs-type">UserDefaults</span>.standard.array(forKey: <span class="hljs-string">"savedCookies"</span>) <span class="hljs-keyword">as</span>? [<span class="hljs-type">Data</span>] &#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> cookies = cookieData.compactMap &#123; <span class="hljs-type">NSKeyedUnarchiver</span>.unarchiveObject(with: \$<span class="hljs-number">0</span>) <span class="hljs-keyword">as</span>? <span class="hljs-type">HTTPCookie</span> &#125;</span><br><span class="line">    cookies.forEach &#123; <span class="hljs-type">HTTPCookieStorage</span>.shared.setCookie(\$<span class="hljs-number">0</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>确保 WebView 配置正确</strong>：确保 WebView 使用的是适当的 <code>WKWebViewConfiguration</code>，并且 Cookie 设置没有被隐私设置或其他配置所干扰。</p></li></ol><p>这些方法可以帮助管理和解决 iOS WebView 中的 Cookie 丢失问题。</p><p><a href="https://www.jianshu.com/p/8636ccd3674b" target="_blank" rel="noopener">https://www.jianshu.com/p/8636ccd3674b</a></p><p>9.RN长列表性能问题</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;百川智能&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="百川智能" scheme="http://soso.wiki/tags/%E7%99%BE%E5%B7%9D%E6%99%BA%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>汽车之家</title>
    <link href="http://soso.wiki/%E6%B1%BD%E8%BD%A6%E4%B9%8B%E5%AE%B6/"/>
    <id>http://soso.wiki/汽车之家/</id>
    <published>2024-08-23T06:00:00.000Z</published>
    <updated>2024-08-28T07:40:22.757Z</updated>
    
    <content type="html"><![CDATA[<p>汽车之家<br><a id="more"></a><br>1.动态库和静态库的区别</p><p>2.网络优化</p><p>3.静态分析发现了哪些问题？</p><p>4.加载速度优化</p><p>5.Crash 监测，野指针定位</p><p>.打印结果</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;</span><br><span class="line"> <span class="hljs-keyword">int</span>(^aBlock)(<span class="hljs-keyword">int</span>) = ^(<span class="hljs-keyword">int</span> num) &#123;</span><br><span class="line">     a += num;</span><br><span class="line">     <span class="hljs-keyword">if</span> (a &lt; <span class="hljs-number">5</span>) &#123;</span><br><span class="line">         aBlock(a);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="hljs-keyword">return</span> a++;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"%d"</span>, aBlock(<span class="hljs-number">1</span>));</span><br></pre></td></tr></table></figure><p>aBlock为什么是空？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;汽车之家&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="汽车之家" scheme="http://soso.wiki/tags/%E6%B1%BD%E8%BD%A6%E4%B9%8B%E5%AE%B6/"/>
    
  </entry>
  
  <entry>
    <title>元石</title>
    <link href="http://soso.wiki/%E5%85%83%E7%9F%B3/"/>
    <id>http://soso.wiki/元石/</id>
    <published>2024-08-23T03:00:00.000Z</published>
    <updated>2024-08-28T07:32:32.818Z</updated>
    
    <content type="html"><![CDATA[<p>元石<br><a id="more"></a></p><p>一面：</p><p>项目</p><p>1.SSE 怎么实现逐字打印效果，event来了个卡片，怎么保证顺序？</p><p>2.三方接入成本为什么还需要5人日？toast这种是不是SDK实现好点，担心增加体积可以用subPackage</p><p>3.SDK体积优化</p><p>4.加载速度优化</p><p>5.活动页组件化</p><p>6.卡顿监控，能获取到卡顿的堆栈吗？</p><p>7.组件化能不在+load注册吗？attribute注册了解吗？</p><p>算法：</p><p>1.<a href="https://leetcode.cn/problems/combination-sum/" target="_blank" rel="noopener">39. 组合总和</a></p><p>2.合并两个有序链表</p><p>二面：</p><p>1.通用化技术提升迭代效率，scheme和动态化，设计scheme需要有哪些注意点</p><p>2.白屏率怎么统计？</p><p>3.活动页组件化</p><p>4.RN跟Flutter的对比</p><p>5.SSE实现打字机效果，对SSE的了解，切换前后台，怎么断点续传</p><p>6.算法：反转数  输入int  返回int   边界条件、能运行</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;元石&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="元石" scheme="http://soso.wiki/tags/%E5%85%83%E7%9F%B3/"/>
    
  </entry>
  
  <entry>
    <title>度小满</title>
    <link href="http://soso.wiki/%E5%BA%A6%E5%B0%8F%E6%BB%A1/"/>
    <id>http://soso.wiki/度小满/</id>
    <published>2024-08-20T14:50:00.000Z</published>
    <updated>2024-08-20T14:50:56.034Z</updated>
    
    <content type="html"><![CDATA[<p>度小满<br><a id="more"></a></p><p>一面：</p><p>1.内存管理，内存泄漏，监测方法，解决办法</p><p>2.App启动流程，优化方法，查看每个阶段耗时的方法</p><p>Category和Extension区别，使用场景</p><p>Category可以添加属性吗？</p><p>3.webView和原生交互，怎么提升webView加载速度？H5怎么加载本地的JS和图片资源？</p><p>4.HTTP和HTTPS的区别，HTTPS怎么保证安全？GET和POST区别？请求头里一般有什么？</p><p>5.MVC、MVP、MVVM区别，使用场景</p><p>6.用OC实现一个栈，push  pop  isEmpty方法，栈和队列的区别，使用场景</p><p>7.了解鸿蒙吗</p><p>二面：</p><p>1.了解提升研发效率的方法，跨平台框架？</p><p>2.Flutter和原生交互方法</p><p>3.小程序的实现原理，SN的实现原理</p><p>3.设计图片下载框架，包括内存，缓存，解码等；缓存的技术指标是什么？(命中率) 在缓存即将达到最大容量时，同时有大量写入缓存的操作，怎么优化？</p><p>4.下载限制并发数量，下载断点续传    http请求码是多少</p><p>5.同层渲染怎么实现</p><p>6.webView加载速度优化</p><p>7.线上卡顿监控，卡顿优化</p><p>8.线上内存监控</p><p>9.口述快速排序，快速排序用迭代实现</p><p>10.HTTPS的流程，客户端校验证书的过程，链式验证</p><p>三面：</p><p>1.监控</p><p>2.原生与H5交互，注入和post message怎么选型的？</p><p>3.有没有关注过业务指标，技术手段提升业务指标的情况？收银台支付成功率？</p><p>4.其他：年龄、看机会原因，有没有别的offer</p><h2 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a>参考答案</h2><p>1.内存管理，内存泄漏，卡顿监测方法，解决办法</p><p>2.App启动流程，优化方法，查看每个阶段耗时的方法</p><p>3.webView和原生交互，怎么提升webView加载速度？H5怎么加载本地的JS和图片资源？</p><p>4.HTTP和HTTPS的区别，HTTPS怎么保证安全？GET和POST区别？请求头里一般有什么？</p><p>HTTP（HyperText Transfer Protocol）和HTTPS（HyperText Transfer Protocol Secure）是用于在网络上传输数据的两种协议。它们有以下主要区别：</p><ol><li><strong>安全性</strong>：<ul><li><strong>HTTP</strong>：数据以纯文本形式传输，不加密。因此，数据在传输过程中容易被截获和篡改。</li><li><strong>HTTPS</strong>：在HTTP的基础上增加了SSL/TLS加密层。数据在传输过程中会被加密，提供了数据的保密性和完整性，防止被窃听和篡改。</li></ul></li><li><strong>端口</strong>：<ul><li><strong>HTTP</strong>：默认使用80端口。</li><li><strong>HTTPS</strong>：默认使用443端口。</li></ul></li><li><strong>证书</strong>：<ul><li><strong>HTTP</strong>：不需要证书。</li><li><strong>HTTPS</strong>：需要SSL/TLS证书，用于加密通信和验证服务器身份。证书由受信任的证书颁发机构（CA）签发。</li></ul></li><li><strong>性能</strong>：<ul><li><strong>HTTP</strong>：因为没有加密和解密的过程，速度相对较快。</li><li><strong>HTTPS</strong>：由于需要进行加密和解密操作，性能会有所下降，但现代硬件和优化技术已经极大地减少了这种影响。</li></ul></li></ol><p>GET和POST区别</p><ul><li><strong>GET</strong>：主要用于获取数据，参数在URL中，适合传输较少、非敏感数据，幂等且可缓存。</li><li><strong>POST</strong>：主要用于提交数据，参数在请求体中，适合传输大量、敏感数据，非幂等且通常不缓存。</li></ul><p>以下是一些常见的HTTP请求头字段及其作用：</p><h3 id="1-通用请求头字段"><a href="#1-通用请求头字段" class="headerlink" title="1. 通用请求头字段"></a>1. <strong>通用请求头字段</strong></h3><ul><li><strong>Host</strong>：指定请求的目标主机和端口，例如：<code>Host: www.example.com</code>。这是HTTP/1.1中必须包含的头字段。</li><li><strong>User-Agent</strong>：标识发出请求的客户端软件信息，例如浏览器类型和版本、操作系统等，例如：<code>User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3</code>。</li><li><strong>Accept</strong>：指定客户端能够处理的内容类型，例如：<code>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</code>。</li><li><strong>Accept-Language</strong>：指定客户端首选的语言和地区，例如：<code>Accept-Language: en-US,en;q=0.5</code>。</li><li><strong>Accept-Encoding</strong>：指定客户端支持的内容编码类型，例如：<code>Accept-Encoding: gzip, deflate, br</code>。</li><li><strong>Connection</strong>：控制连接的管理，例如：<code>Connection: keep-alive</code>或<code>Connection: close</code>。</li></ul><h3 id="2-请求头字段（请求特有）"><a href="#2-请求头字段（请求特有）" class="headerlink" title="2. 请求头字段（请求特有）"></a>2. <strong>请求头字段（请求特有）</strong></h3><ul><li><strong>Referer</strong>：指示请求的来源页面的URL，例如：<code>Referer: https://www.example.com/previous-page</code>。</li><li><strong>Cookie</strong>：发送存储在客户端的Cookie数据，例如：<code>Cookie: sessionId=abc123; theme=light</code>。</li><li><strong>Authorization</strong>：用于传递身份验证凭据，例如：<code>Authorization: Bearer token123</code>或<code>Authorization: Basic base64credentials</code>。</li><li><strong>Content-Type</strong>：指定请求体的媒体类型，常用于POST和PUT请求，例如：<code>Content-Type: application/json</code>或<code>Content-Type: application/x-www-form-urlencoded</code>。</li><li><strong>Content-Length</strong>：表示请求体的字节长度，例如：<code>Content-Length: 348</code>。</li><li><strong>Origin</strong>：表明请求的来源，用于跨域请求，例如：<code>Origin: https://www.example.com</code>。</li><li><strong>If-Modified-Since</strong>：用于条件请求，只在指定日期之后资源被修改时才返回，例如：<code>If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT</code>。</li><li><strong>If-None-Match</strong>：用于条件请求，当ETag不匹配时才返回，例如：<code>If-None-Match: &quot;abc123&quot;</code>。</li><li><strong>Range</strong>：请求部分资源内容，例如：<code>Range: bytes=500-999</code>。</li></ul><h3 id="3-自定义请求头字段"><a href="#3-自定义请求头字段" class="headerlink" title="3. 自定义请求头字段"></a>3. <strong>自定义请求头字段</strong></h3><ul><li><strong>X-Requested-With</strong>：通常用于标识Ajax请求，例如：<code>X-Requested-With: XMLHttpRequest</code>。</li><li><strong>X-CSRF-Token</strong>：用于传递CSRF（跨站请求伪造）令牌，以防止CSRF攻击。</li><li><strong>X-Forwarded-For</strong>：记录原始客户端IP地址，常用于代理服务器，例如：<code>X-Forwarded-For: 203.0.113.195</code>。</li></ul><h3 id="4-HTTP-2-特有头字段"><a href="#4-HTTP-2-特有头字段" class="headerlink" title="4. HTTP/2 特有头字段"></a>4. <strong>HTTP/2 特有头字段</strong></h3><ul><li><strong>:method</strong>：表示HTTP方法，例如：<code>:method: GET</code>。</li><li><strong>:scheme</strong>：表示请求的协议（http或https），例如：<code>:scheme: https</code>。</li><li><strong>:path</strong>：表示请求的路径和查询字符串，例如：<code>:path: /index.html</code>。</li><li><strong>:authority</strong>：表示服务器的主机名和端口，类似于HTTP/1.1的Host头字段，例如：<code>:authority: www.example.com</code>。</li></ul><h3 id="示例请求头"><a href="#示例请求头" class="headerlink" title="示例请求头"></a>示例请求头</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET /index.html HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: en-US,en;q=0.5</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Referer: https://www.example.com/previous-page</span><br><span class="line">Cookie: sessionId=abc123; theme=light</span><br><span class="line">Authorization: Bearer token123</span><br></pre></td></tr></table></figure><p>这些请求头字段在客户端和服务器之间传递时，提供了关于请求和客户端环境的丰富信息，使得服务器能够理解和处理请求，并返回适当的响应。</p><p>5.MVC、MVP、MVVM区别，使用场景</p><p>6.用OC实现一个栈，push  pop  isEmpty方法，栈和队列的区别，使用场景</p><p>7.了解鸿蒙吗</p><p>二面：</p><p>1.了解提升研发效率的方法，跨平台框架？</p><p>2.Flutter和原生交互方法</p><p>3.小程序的实现原理，SN的实现原理</p><p>3.设计图片下载框架，包括内存，缓存，解码等；缓存的技术指标是什么？(命中率) 在缓存即将达到最大容量时，同时有大量写入缓存的操作，怎么优化？</p><p>4.下载限制并发数量，下载断点续传    http请求码是多少</p><p>5.同层渲染怎么实现</p><p><a href="https://developers.weixin.qq.com/community/develop/article/doc/000c4e433707c072c1793e56f5c813" target="_blank" rel="noopener">小程序同层渲染原理剖析</a></p><p><a href="https://zhuanlan.zhihu.com/p/498449103" target="_blank" rel="noopener">小程序在同层渲染上的探索</a></p><p>6.webView加载速度优化</p><p>7.线上卡顿监控，卡顿优化</p><p>8.线上内存监控</p><p><a href="https://wetest.qq.com/labs/367" target="_blank" rel="noopener">iOS微信内存监控 </a></p><p>9.口述快速排序，快速排序用迭代实现</p><p>10.HTTPS的流程，客户端校验证书的过程，链式验证</p><p>第一步是检查证书的链式验证。客户端会使用已信任的根证书（Root Certificate Authority）去验证服务器证书的有效性。根证书是权威机构颁发的，被广泛信任的证书，用于证明其它证书的合法性。客户端会检查服务器证书中的颁发者，然后递归地检查颁发者的证书，直到检查到根证书或者找不到信任的根证书为止。</p><p>第二步是检查证书的有效期。客户端会检查证书的有效起始日期和有效截止日期，确保证书在有效期内。如果证书过期，客户端将拒绝连接。</p><p>第三步是检查证书的公钥。客户端会验证服务器证书中的公钥和域名是否匹配。客户端会从证书中提取服务器的公钥，并与服务器进行握手协议，验证证书中的公钥是否与服务器的公钥匹配。如果不匹配，客户端将拒绝连接。</p><p>除了上述基本的校验步骤，客户端还可以进行更加严格的校验，以提高安全性。例如，客户端可以检查证书中是否包含指纹信息（Fingerprint），从而确保证书的完整性和一致性。客户端也可以检查证书中的扩展字段，查看是否存在其他安全相关的信息。</p><p>总结来说，客户端校验证书的过程包括链式验证、有效期验证和公钥匹配验证。通过这些验证步骤，客户端能够确保所连接的服务器是合法且可信赖的，从而保障通信的安全性。</p><p>三面：</p><p>1.监控</p><p>2.原生与H5交互，注入和post message怎么选型的？</p><p>在移动开发中，原生与H5（HTML5）交互是一个常见的需求。为了实现这种交互，通常有两种主要的方法：注入（Injection）和 <code>postMessage</code>。各有优缺点，选择哪种方法取决于具体的应用场景和需求。下面对这两种方法进行详细比较和建议：</p><h3 id="注入（Injection）"><a href="#注入（Injection）" class="headerlink" title="注入（Injection）"></a>注入（Injection）</h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ol><li><strong>灵活性高</strong>：可以直接在H5页面中注入原生代码，灵活性较高。</li><li><strong>强大的控制力</strong>：原生代码可以直接操作H5页面的DOM和JavaScript，控制力强。</li><li><strong>无需特定API支持</strong>：不需要依赖特定的API或者更新H5页面的代码。</li></ol><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ol><li><strong>安全性问题</strong>：注入代码可能会带来安全风险，容易被恶意代码利用。</li><li><strong>维护复杂</strong>：代码维护复杂，尤其是原生代码和H5页面频繁变动时。</li><li><strong>浏览器兼容性</strong>：不同浏览器对注入代码的支持可能有所不同。</li></ol><h3 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage"></a><code>postMessage</code></h3><h4 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h4><ol><li><strong>安全性高</strong>：通过消息传递的方式进行交互，安全性较高，不容易被恶意代码利用。</li><li><strong>标准化</strong>：<code>postMessage</code>是HTML5标准的一部分，具有较好的跨浏览器兼容性。</li><li><strong>易于调试和维护</strong>：消息传递方式使得代码逻辑更加清晰，易于调试和维护。</li></ol><h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><ol><li><strong>性能影响</strong>：在高频率消息传递的情况下，可能会有性能影响。</li><li><strong>依赖API</strong>：需要H5页面和原生代码都支持<code>postMessage</code> API。</li><li><strong>有限的控制力</strong>：相比直接注入代码，控制力稍弱，只能通过消息进行交互。</li></ol><h3 id="如何选择？"><a href="#如何选择？" class="headerlink" title="如何选择？"></a>如何选择？</h3><p>选择哪种方法取决于具体的应用场景和需求：</p><ol><li><strong>安全性优先</strong>：如果安全性是首要考虑因素，建议使用<code>postMessage</code>，因为这种方法更安全，不容易被恶意代码利用。</li><li><strong>高频交互</strong>：如果需要高频率的交互，且对性能要求较高，可以考虑注入方式，但要特别注意代码的安全性和浏览器兼容性。</li><li><strong>跨浏览器兼容</strong>：如果需要在多个浏览器中运行，并且希望代码易于维护和调试，<code>postMessage</code>是更好的选择。</li><li><strong>快速开发</strong>：如果需要快速实现功能，且不考虑长远的维护和安全性问题，注入方式可能会更快捷。</li></ol><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>综合来看，<code>postMessage</code>在大多数情况下是更优的选择，特别是在考虑安全性、标准化和易于维护的情况下。但在某些特定场景下，比如需要高频率的交互或者对H5页面进行强控制时，注入方式也不失为一个可选方案。最终的选择应根据具体的项目需求和开发环境来决定。</p><p>3.有没有关注过业务指标，技术手段提升业务指标的情况？收银台支付成功率？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;度小满&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://soso.wiki/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://soso.wiki/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="度小满" scheme="http://soso.wiki/tags/%E5%BA%A6%E5%B0%8F%E6%BB%A1/"/>
    
  </entry>
  
</feed>
