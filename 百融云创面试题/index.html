<!DOCTYPE html>
<html  lang="zh">
<head>
    <meta charset="utf-8" />

<meta name="generator" content="Hexo 3.8.0" />

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<title>百融云创面试题 - SOSOWIKI</title>


    <meta name="description" content="百融云创面试题">
<meta name="keywords" content="面试,百融云创">
<meta property="og:type" content="article">
<meta property="og:title" content="百融云创面试题">
<meta property="og:url" content="http://soso.wiki/百融云创面试题/index.html">
<meta property="og:site_name" content="SOSOWIKI">
<meta property="og:description" content="百融云创面试题">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://soso.wiki/images/girl.png">
<meta property="og:updated_time" content="2024-05-28T08:48:49.475Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="百融云创面试题">
<meta name="twitter:description" content="百融云创面试题">
<meta name="twitter:image" content="http://soso.wiki/images/girl.png">







<link rel="icon" href="/images/favicon.jpeg">


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.7.2/css/bulma.css">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.1/css/all.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css">


    
    
    
    <style>body>.footer,body>.navbar,body>.section{opacity:0}</style>
    

    
    
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css">
    

    
    

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css">


    
    
    
    

<link rel="stylesheet" href="/css/back-to-top.css">


    
    

    
    
<script>
var _hmt = _hmt || [];
(function() {
    var hm = document.createElement("script");
    hm.src = "//hm.baidu.com/hm.js?b07e5a4ee78cf8302e7e2cf5b9db7f2c";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
})();
</script>

    
    

    
    
<link rel="stylesheet" href="/css/progressbar.css">
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

    
    
    


<link rel="stylesheet" href="/css/style.css">
</head>
<body class="is-1-column">
    <nav class="navbar navbar-main">
    <div class="container">
        <div class="navbar-brand is-flex-center">
            <a class="navbar-item navbar-logo" href="/">
            
                <img src="/images/logo-2.png" alt="百融云创面试题" height="28">
            
            </a>
        </div>
        <div class="navbar-menu">
            
            <div class="navbar-start">
                
                <a class="navbar-item"
                href="/">首页</a>
                
                <a class="navbar-item"
                href="/archives">归档</a>
                
                <a class="navbar-item"
                href="/tags">标签</a>
                
                <a class="navbar-item"
                href="/about">关于</a>
                
            </div>
            
            <div class="navbar-end">
                
                
                
                <a class="navbar-item search" title="搜索" href="javascript:;">
                    <i class="fas fa-search"></i>
                </a>
                
            </div>
        </div>
    </div>
</nav>
    
    <section class="section">
        <div class="container">
            <div class="columns">
                <div class="column is-12 has-order-2 column-main"><div class="card">
    
    <div class="card-image">
        <span  class="image is-7by1">
            <img class="thumbnail" src="/images/girl.png" alt="百融云创面试题">
        </span>
    </div>
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2024-05-09T12:58:00.000Z">2024-05-09</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/面试题/">面试题</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    1 小时 读完 (大约 9168 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                百融云创面试题
            
        </h1>
        <div class="content">
            <p>百融云创面试题<br><a id="more"></a></p>
<p>1.腾讯会议共享屏幕在线编程 <a href="https://leetcode.cn/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/description/" target="_blank" rel="noopener">https://leetcode.cn/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/description/</a><br>2.KVO 原理<br>3.如何调用私有 API？三方库或系统未暴漏的方法<br>4.怎么改一个类的只读属性<br>5.消息机制<br>6.Runloop 流程，用 Runloop 做过什么？卡顿检测，发生卡顿后怎么获取堆栈信息？堆栈信息的原理<br>7.GCD 都用了哪些？网络请求 A 和 B 都回调后，请求 C，如何实现？除了 dispatch_group<br>8.可变数组 NSMutableArray，在头部插入元素，iOS 系统做了什么优化<br>9.Tagged Pointer<br>10.NSString 存储在哪里，引用计数存储哪里？<br>11.dealloc 流程<br>12.避免哈希碰撞的几种方法？<br>13.mach-o 了解吗？存储的方法信息可以无用代码检测？段迁移？<br>14.脚本检测未使用代码原理<br>15.render 渲染流程<br>16.UIView 动画和 CAAnimation 动画有什么联系？<br>17.项目亮点</p>
<h2 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a>参考答案</h2><h2 id="1-腾讯会议共享屏幕在线编程-https-leetcode-cn-problems-zhan-de-ya-ru-dan-chu-xu-lie-lcof-description"><a href="#1-腾讯会议共享屏幕在线编程-https-leetcode-cn-problems-zhan-de-ya-ru-dan-chu-xu-lie-lcof-description" class="headerlink" title="1.腾讯会议共享屏幕在线编程 https://leetcode.cn/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/description/"></a>1.腾讯会议共享屏幕在线编程 <a href="https://leetcode.cn/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/description/" target="_blank" rel="noopener">https://leetcode.cn/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/description/</a></h2><h2 id="2-KVO-原理工作原理"><a href="#2-KVO-原理工作原理" class="headerlink" title="2.KVO 原理工作原理"></a>2.KVO 原理工作原理</h2><p>KVO 主要依赖于 Objective-C 的动态性和 Runtime 运行时机制。以下是 KVO 的几个核心步骤和原理：</p>
<h4 id="1-动态子类化"><a href="#1-动态子类化" class="headerlink" title="1. 动态子类化"></a>1. 动态子类化</h4><p>当你第一次给某个对象添加观察者时，Objective-C Runtime 会动态地创建该对象的一个子类。这个子类会重写被观察属性的 setter 方法。</p>
<p>例如，如果你观察对象 <code>person</code> 的 <code>name</code> 属性：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[person addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew context:nil];</span><br></pre></td></tr></table></figure>
<p>Runtime 会创建一个新的类，假设名为 <code>NSKVONotifying_Person</code>，这个类是 <code>Person</code> 类的子类。</p>
<h4 id="2-重写-setter-方法"><a href="#2-重写-setter-方法" class="headerlink" title="2. 重写 setter 方法"></a>2. 重写 setter 方法</h4><p>在新的子类中，Runtime 会重写被观察属性的 setter 方法。例如，对于 <code>name</code> 属性，其 setter 方法可能如下：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)setName:(NSString *)name &#123;</span><br><span class="line">    [self willChangeValueForKey:@&quot;name&quot;];</span><br><span class="line">    [super setName:name];</span><br><span class="line">    [self didChangeValueForKey:@&quot;name&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>willChangeValueForKey:</code></strong>：通知系统属性即将发生变化。</li>
<li><strong><code>didChangeValueForKey:</code></strong>：通知系统属性已经发生变化。</li>
</ul>
<p>这些方法会触发 KVO 通知机制，向所有观察者发送通知。</p>
<h4 id="3-注册观察者"><a href="#3-注册观察者" class="headerlink" title="3. 注册观察者"></a>3. 注册观察者</h4><p>当你调用 <code>addObserver:forKeyPath:options:context:</code> 方法时，Runtime 会将观察者注册到一个内部的观察者列表中，这个列表通常是一个哈希表（Hash Table），键是被观察的属性，值是观察者对象。</p>
<h4 id="4-通知观察者"><a href="#4-通知观察者" class="headerlink" title="4. 通知观察者"></a>4. 通知观察者</h4><p>当属性值发生变化时，重写的 setter 方法会调用 <code>willChangeValueForKey:</code> 和 <code>didChangeValueForKey:</code> 方法，这些方法会触发 KVO 通知机制，向注册的观察者发送通知。观察者会收到 <code>observeValueForKeyPath:ofObject:change:context:</code> 方法的回调。</p>
<h2 id="3-如何调用私有-API？三方库或系统未暴漏的方法"><a href="#3-如何调用私有-API？三方库或系统未暴漏的方法" class="headerlink" title="3.如何调用私有 API？三方库或系统未暴漏的方法"></a>3.如何调用私有 API？三方库或系统未暴漏的方法</h2><h3 id="1-使用-performSelector-方法"><a href="#1-使用-performSelector-方法" class="headerlink" title="1. 使用 performSelector: 方法"></a>1. 使用 <code>performSelector:</code> 方法</h3><p><code>performSelector:</code> 方法可以动态调用对象的方法，即使这些方法在编译时不可见。</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SEL privateSelector = NSSelectorFromString(@&quot;privateMethod&quot;);</span><br><span class="line">if ([object respondsToSelector:privateSelector]) &#123;</span><br><span class="line">    [object performSelector:privateSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-使用-Runtime-动态调用"><a href="#2-使用-Runtime-动态调用" class="headerlink" title="2. 使用 Runtime 动态调用"></a>2. 使用 Runtime 动态调用</h3><p>Objective-C 的 Runtime 库提供了一些函数，可以用来动态调用方法。</p>
<h4 id="示例代码：调用私有方法"><a href="#示例代码：调用私有方法" class="headerlink" title="示例代码：调用私有方法"></a>示例代码：调用私有方法</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line"></span><br><span class="line">SEL privateSelector = NSSelectorFromString(@&quot;privateMethod&quot;);</span><br><span class="line">if ([object respondsToSelector:privateSelector]) &#123;</span><br><span class="line">    IMP imp = [object methodForSelector:privateSelector];</span><br><span class="line">    void (*func)(id, SEL) = (void *)imp;</span><br><span class="line">    func(object, privateSelector);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码：访问私有属性"><a href="#示例代码：访问私有属性" class="headerlink" title="示例代码：访问私有属性"></a>示例代码：访问私有属性</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line"></span><br><span class="line">Ivar ivar = class_getInstanceVariable([object class], &quot;_privateProperty&quot;);</span><br><span class="line">id privateValue = object_getIvar(object, ivar);</span><br></pre></td></tr></table></figure>
<h3 id="3-使用-dlsym-函数"><a href="#3-使用-dlsym-函数" class="headerlink" title="3. 使用 dlsym 函数"></a>3. 使用 <code>dlsym</code> 函数</h3><p>如果你知道私有 API 的符号名称，可以使用 <code>dlsym</code> 函数来获取函数指针，并调用它。</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;dlfcn.h&gt;</span><br><span class="line"></span><br><span class="line">void *handle = dlopen(NULL, RTLD_LAZY);</span><br><span class="line">if (handle) &#123;</span><br><span class="line">    void (*privateFunction)(void) = dlsym(handle, &quot;privateFunctionName&quot;);</span><br><span class="line">    if (privateFunction) &#123;</span><br><span class="line">        privateFunction();</span><br><span class="line">    &#125;</span><br><span class="line">    dlclose(handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-怎么改一个类的只读属性"><a href="#4-怎么改一个类的只读属性" class="headerlink" title="4.怎么改一个类的只读属性"></a>4.怎么改一个类的只读属性</h2><h3 id="方法一：通过-KVC-Key-Value-Coding"><a href="#方法一：通过-KVC-Key-Value-Coding" class="headerlink" title="方法一：通过 KVC (Key-Value Coding)"></a>方法一：通过 KVC (Key-Value Coding)</h3><p>Key-Value Coding (KVC) 是一种间接访问对象属性的方法。即使属性是只读的，也可以通过 KVC 修改它的值。</p>
<p>示例：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@interface MyClass : NSObject</span><br><span class="line">@property (nonatomic, strong, readonly) NSString *readonlyProperty;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation MyClass &#123;</span><br><span class="line">    NSString *_readonlyProperty;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        _readonlyProperty = @&quot;Initial Value&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// 修改只读属性</span><br><span class="line">MyClass *myObject = [[MyClass alloc] init];</span><br><span class="line">NSLog(@&quot;Before: %@&quot;, myObject.readonlyProperty);</span><br><span class="line"></span><br><span class="line">[myObject setValue:@&quot;New Value&quot; forKey:@&quot;readonlyProperty&quot;];</span><br><span class="line">NSLog(@&quot;After: %@&quot;, myObject.readonlyProperty);</span><br></pre></td></tr></table></figure>
<h3 id="方法二：使用运行时函数"><a href="#方法二：使用运行时函数" class="headerlink" title="方法二：使用运行时函数"></a>方法二：使用运行时函数</h3><p>在 Objective-C 中，可以使用运行时函数来修改属性的值。</p>
<p>示例：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line"></span><br><span class="line">@interface MyClass : NSObject</span><br><span class="line">@property (nonatomic, strong, readonly) NSString *readonlyProperty;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation MyClass &#123;</span><br><span class="line">    NSString *_readonlyProperty;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        _readonlyProperty = @&quot;Initial Value&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// 修改只读属性</span><br><span class="line">MyClass *myObject = [[MyClass alloc] init];</span><br><span class="line">NSLog(@&quot;Before: %@&quot;, myObject.readonlyProperty);</span><br><span class="line"></span><br><span class="line">Ivar ivar = class_getInstanceVariable([MyClass class], &quot;_readonlyProperty&quot;);</span><br><span class="line">object_setIvar(myObject, ivar, @&quot;New Value&quot;);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;After: %@&quot;, myObject.readonlyProperty);</span><br></pre></td></tr></table></figure>
<h3 id="方法三：子类化和重写-Getter-方法"><a href="#方法三：子类化和重写-Getter-方法" class="headerlink" title="方法三：子类化和重写 Getter 方法"></a>方法三：子类化和重写 Getter 方法</h3><p>通过创建一个子类并重写只读属性的 getter 方法，可以控制属性的值。</p>
<p>示例：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">@interface MyClass : NSObject</span><br><span class="line">@property (nonatomic, strong, readonly) NSString *readonlyProperty;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation MyClass &#123;</span><br><span class="line">    NSString *_readonlyProperty;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        _readonlyProperty = @&quot;Initial Value&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface MyClassSubclass : MyClass</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation MyClassSubclass &#123;</span><br><span class="line">    NSString *_customValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)readonlyProperty &#123;</span><br><span class="line">    return _customValue ? _customValue : [super readonlyProperty];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setCustomValue:(NSString *)value &#123;</span><br><span class="line">    _customValue = value;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// 修改只读属性</span><br><span class="line">MyClassSubclass *myObject = [[MyClassSubclass alloc] init];</span><br><span class="line">NSLog(@&quot;Before: %@&quot;, myObject.readonlyProperty);</span><br><span class="line"></span><br><span class="line">[myObject setCustomValue:@&quot;New Value&quot;];</span><br><span class="line">NSLog(@&quot;After: %@&quot;, myObject.readonlyProperty);</span><br></pre></td></tr></table></figure>
<h2 id="5-消息机制"><a href="#5-消息机制" class="headerlink" title="5.消息机制"></a>5.消息机制</h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><ul>
<li><strong>消息（Message）</strong>：在 Objective-C 中，方法调用被称为“发送消息”。发送消息的语法是 <code>[receiver message]</code>。</li>
<li><strong>接收者（Receiver）</strong>：接收并处理消息的对象。</li>
<li><strong>选择器（Selector）</strong>：表示方法名称的一个数据类型，类型为 <code>SEL</code>。选择器是方法的唯一标识符。</li>
</ul>
<h3 id="2-消息发送流程"><a href="#2-消息发送流程" class="headerlink" title="2. 消息发送流程"></a>2. 消息发送流程</h3><p>当向一个对象发送消息时，Objective-C 的运行时系统会进行一系列步骤来查找并调用相应的方法。以下是消息发送的基本流程：</p>
<ol>
<li><strong>消息发送</strong>：当代码中调用 <code>[object message]</code> 时，编译器将其转换为 <code>objc_msgSend</code> 函数调用。</li>
<li><strong>查找方法</strong>：<code>objc_msgSend</code> 函数会根据消息的选择器（<code>SEL</code>）在对象的类及其父类的方法列表中查找对应的方法实现。</li>
<li><strong>调用方法</strong>：找到方法实现后，<code>objc_msgSend</code> 函数会调用该方法。如果没有找到方法实现，则会触发消息转发机制（Message Forwarding）。</li>
</ol>
<h3 id="3-objc-msgSend-函数"><a href="#3-objc-msgSend-函数" class="headerlink" title="3. objc_msgSend 函数"></a>3. <code>objc_msgSend</code> 函数</h3><p><code>objc_msgSend</code> 是 Objective-C 运行时系统的核心函数之一，负责消息的分发。其原型如下：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void objc_msgSend(id self, SEL _cmd, ...);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>self</code></strong>：消息的接收者。</li>
<li><strong><code>_cmd</code></strong>：消息的选择器。</li>
<li><strong>可变参数</strong>：方法的参数。</li>
</ul>
<h3 id="4-消息转发机制"><a href="#4-消息转发机制" class="headerlink" title="4. 消息转发机制"></a>4. 消息转发机制</h3><p>当 <code>objc_msgSend</code> 无法在类的方法列表中找到与选择器匹配的方法时，会触发消息转发机制。消息转发机制包括以下几个步骤：</p>
<h4 id="4-1-动态方法解析"><a href="#4-1-动态方法解析" class="headerlink" title="4.1 动态方法解析"></a>4.1 动态方法解析</h4><p>首先，运行时系统会尝试动态方法解析，通过调用类的 <code>+resolveInstanceMethod:</code> 或 <code>+resolveClassMethod:</code> 方法来添加方法实现。如果方法实现被动态添加，消息发送会重新开始。</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    if (sel == @selector(myMethod)) &#123;</span><br><span class="line">        class_addMethod([self class], sel, (IMP)myMethodIMP, &quot;v@:&quot;);</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-2-快速转发"><a href="#4-2-快速转发" class="headerlink" title="4.2 快速转发"></a>4.2 快速转发</h4><p>如果动态方法解析未能添加方法实现，运行时系统会调用 <code>-forwardingTargetForSelector:</code> 方法。这个方法允许将消息转发给另一个对象。</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    if (aSelector == @selector(myMethod)) &#123;</span><br><span class="line">        return someOtherObject;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-3-常规转发"><a href="#4-3-常规转发" class="headerlink" title="4.3 常规转发"></a>4.3 常规转发</h4><p>如果快速转发也未能处理消息，运行时系统会调用 <code>-methodSignatureForSelector:</code> 和 <code>-forwardInvocation:</code> 方法。首先，通过 <code>-methodSignatureForSelector:</code> 获取方法签名，然后通过 <code>-forwardInvocation:</code> 进行消息转发。</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    if (aSelector == @selector(myMethod)) &#123;</span><br><span class="line">        return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    return [super methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;</span><br><span class="line">    SEL sel = [anInvocation selector];</span><br><span class="line">    if ([someOtherObject respondsToSelector:sel]) &#123;</span><br><span class="line">        [anInvocation invokeWithTarget:someOtherObject];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        [super forwardInvocation:anInvocation];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-消息缓存"><a href="#5-消息缓存" class="headerlink" title="5. 消息缓存"></a>5. 消息缓存</h3><p>为了提高消息发送的性能，Objective-C 运行时系统使用方法缓存（Method Caching）。当一个方法第一次被调用时，其实现会被缓存起来，下次调用相同的方法时，可以直接从缓存中获取，而不需要重新查找。</p>
<h2 id="6-Runloop-流程，用-Runloop-做过什么？卡顿检测，发生卡顿后怎么获取堆栈信息？堆栈信息的原理"><a href="#6-Runloop-流程，用-Runloop-做过什么？卡顿检测，发生卡顿后怎么获取堆栈信息？堆栈信息的原理" class="headerlink" title="6.Runloop 流程，用 Runloop 做过什么？卡顿检测，发生卡顿后怎么获取堆栈信息？堆栈信息的原理"></a>6.Runloop 流程，用 Runloop 做过什么？卡顿检测，发生卡顿后怎么获取堆栈信息？堆栈信息的原理</h2><h3 id="Runloop-基本概念"><a href="#Runloop-基本概念" class="headerlink" title="Runloop 基本概念"></a>Runloop 基本概念</h3><p>RunLoop 是一个事件处理循环，用来调度和处理任务。它可以在没有任务时使线程进入休眠状态，从而节省资源；有任务时则立即唤醒线程处理任务。RunLoop 实质上是一个对象，这个对象管理着其需要处理的事件和消息，并提供一个入口函数来执行这个事件处理循环。</p>
<h3 id="Runloop-的基本流程"><a href="#Runloop-的基本流程" class="headerlink" title="Runloop 的基本流程"></a>Runloop 的基本流程</h3><p>RunLoop 的基本流程可以概括为以下几个步骤：</p>
<ol>
<li><strong>进入循环</strong>：调用 <code>CFRunLoopRun</code> 或者 <code>-[NSRunLoop run]</code> 方法。</li>
<li><strong>通知观察者</strong>：通知即将进入 RunLoop 事件处理循环。</li>
<li><strong>检查 Timer</strong>：检查是否有定时器（Timer）需要处理。</li>
<li><strong>处理输入源</strong>：处理输入源（Input Source），比如用户触摸事件，UI事件等。</li>
<li><strong>通知观察者</strong>：通知即将进入休眠。</li>
<li><strong>休眠</strong>：如果没有事件需要处理，线程进入休眠状态，等待事件发生。</li>
<li><strong>唤醒</strong>：收到外部事件（如 Timer 到时间、输入源事件）唤醒线程。</li>
<li><strong>通知观察者</strong>：通知即将处理事件。</li>
<li><strong>处理事件</strong>：处理 Timer 或输入源事件。</li>
<li><strong>通知观察者</strong>：通知事件已处理完成。</li>
<li><strong>重复或退出</strong>：重复上述步骤，或根据特定条件退出循环。</li>
</ol>
<h3 id="RunLoop-在-iOS-中的应用"><a href="#RunLoop-在-iOS-中的应用" class="headerlink" title="RunLoop 在 iOS 中的应用"></a>RunLoop 在 iOS 中的应用</h3><h4 id="1-保持线程活跃"><a href="#1-保持线程活跃" class="headerlink" title="1. 保持线程活跃"></a>1. <strong>保持线程活跃</strong></h4><p>RunLoop 的一个典型应用是保持线程活跃。默认情况下，子线程在任务完成后会立即退出。通过 RunLoop，可以让子线程在没有任务时处于休眠状态，但不会退出，等待新的任务到来。</p>
<p>示例代码：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)startThread &#123;</span><br><span class="line">    NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(threadEntryPoint) object:nil];</span><br><span class="line">    [thread start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)threadEntryPoint &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        [[NSThread currentThread] setName:@&quot;MyThread&quot;];</span><br><span class="line">        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];</span><br><span class="line">        [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];</span><br><span class="line">        [runLoop run]; // 进入 RunLoop</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-处理定时任务"><a href="#2-处理定时任务" class="headerlink" title="2. 处理定时任务"></a>2. <strong>处理定时任务</strong></h4><p>RunLoop 可以用来处理定时任务，比如定时器。通过将 <code>NSTimer</code> 添加到 RunLoop，可以在指定的时间间隔触发任务。</p>
<p>示例代码：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)scheduleTimer &#123;</span><br><span class="line">    NSTimer *timer = [NSTimer timerWithTimeInterval:1.0 target:self selector:@selector(timerFired:) userInfo:nil repeats:YES];</span><br><span class="line">    [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)timerFired:(NSTimer *)timer &#123;</span><br><span class="line">    NSLog(@&quot;Timer fired!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-处理网络请求"><a href="#3-处理网络请求" class="headerlink" title="3. 处理网络请求"></a>3. <strong>处理网络请求</strong></h4><p>在处理网络请求时，可以使用 RunLoop 来保持线程活跃，等待网络请求完成。<code>NSURLConnection</code> 和 <code>NSURLSession</code> 都使用 RunLoop 来处理网络事件。</p>
<h4 id="4-处理输入源事件"><a href="#4-处理输入源事件" class="headerlink" title="4. 处理输入源事件"></a>4. <strong>处理输入源事件</strong></h4><p>RunLoop 可以用来处理输入源事件，比如用户触摸事件、UI事件等。</p>
<h2 id="7-GCD-都用了哪些？网络请求-A-和-B-都回调后，请求-C，如何实现？除了-dispatch-group"><a href="#7-GCD-都用了哪些？网络请求-A-和-B-都回调后，请求-C，如何实现？除了-dispatch-group" class="headerlink" title="7.GCD 都用了哪些？网络请求 A 和 B 都回调后，请求 C，如何实现？除了 dispatch_group"></a>7.GCD 都用了哪些？网络请求 A 和 B 都回调后，请求 C，如何实现？除了 dispatch_group</h2><p>Grand Central Dispatch (GCD) 是苹果公司推出的一种用于并发编程的技术，旨在优化多核设备上的代码执行。GCD 提供了一种简单易用的 API 来管理并发任务，并且能够自动利用系统资源进行优化。以下是一些常见的 GCD 使用场景：</p>
<h3 id="1-异步任务"><a href="#1-异步任务" class="headerlink" title="1. 异步任务"></a>1. <strong>异步任务</strong></h3><p>GCD 的一个主要用途就是在后台执行耗时任务，从而避免阻塞主线程，提高应用的响应速度。</p>
<p>示例代码：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    // 执行耗时任务</span><br><span class="line">    NSData *data = [self fetchDataFromServer];</span><br><span class="line">    </span><br><span class="line">    // 回到主线程更新 UI</span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [self updateUIWithData:data];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="2-并行任务"><a href="#2-并行任务" class="headerlink" title="2. 并行任务"></a>2. <strong>并行任务</strong></h3><p>GCD 可以轻松地创建并行任务，从而充分利用多核处理器的计算能力。</p>
<p>示例代码：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    [self performTask1];</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    [self performTask2];</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    [self performTask3];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="3-同步任务"><a href="#3-同步任务" class="headerlink" title="3. 同步任务"></a>3. <strong>同步任务</strong></h3><p>尽管异步任务更常见，有时也需要同步任务来确保任务按顺序执行。</p>
<p>示例代码：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    [self performSynchronousTask];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="4-延迟执行"><a href="#4-延迟执行" class="headerlink" title="4. 延迟执行"></a>4. <strong>延迟执行</strong></h3><p>GCD 提供了简洁的 API 来延迟执行任务。</p>
<p>示例代码：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dispatch_time_t delay = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5.0 * NSEC_PER_SEC));</span><br><span class="line">dispatch_after(delay, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    [self performDelayedTask];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="5-一次性代码"><a href="#5-一次性代码" class="headerlink" title="5. 一次性代码"></a>5. <strong>一次性代码</strong></h3><p>有时我们需要确保某段代码只执行一次，这时候可以使用 <code>dispatch_once</code>。</p>
<p>示例代码：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static dispatch_once_t onceToken;</span><br><span class="line">dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">    [self initializeOnce];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="6-调度组"><a href="#6-调度组" class="headerlink" title="6. 调度组"></a>6. <strong>调度组</strong></h3><p>调度组可以用来监控一组任务的完成状态，通常用于需要等待多项任务全部完成后才能继续下一步操作的场景。</p>
<p>示例代码：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line"></span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">    [self performTask1];</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">    [self performTask2];</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">    [self performTask3];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    [self allTasksCompleted];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="7-信号量"><a href="#7-信号量" class="headerlink" title="7. 信号量"></a>7. <strong>信号量</strong></h3><p>信号量可以用来控制并发访问资源的数量，适用于需要限制并发任务数量的场景。</p>
<p>示例代码：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(2); // 允许同时执行两个并发任务</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">        </span><br><span class="line">        // 执行任务</span><br><span class="line">        NSLog(@&quot;Task %d started&quot;, i);</span><br><span class="line">        sleep(2); // 模拟耗时任务</span><br><span class="line">        NSLog(@&quot;Task %d completed&quot;, i);</span><br><span class="line">        </span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-Barrier-Block"><a href="#8-Barrier-Block" class="headerlink" title="8. Barrier Block"></a>8. <strong>Barrier Block</strong></h3><p>Barrier Block 用于在并发队列中插入一个障碍，确保在障碍前提交的所有任务执行完成后，才执行障碍后的任务。</p>
<p>示例代码：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;com.example.myqueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    [self performReadTask1];</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    [self performReadTask2];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">    [self performWriteTask];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    [self performReadTask3];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="9-Dispatch-Source"><a href="#9-Dispatch-Source" class="headerlink" title="9. Dispatch Source"></a>9. <strong>Dispatch Source</strong></h3><p>Dispatch Source 是一种非常强大的工具，可以用来处理各种系统事件，如文件变化、定时器、信号等。</p>
<p>示例代码（定时器）：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue());</span><br><span class="line">dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, 1.0 * NSEC_PER_SEC, 0.1 * NSEC_PER_SEC);</span><br><span class="line">dispatch_source_set_event_handler(timer, ^&#123;</span><br><span class="line">    NSLog(@&quot;Timer fired&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_resume(timer);</span><br></pre></td></tr></table></figure>
<h3 id="10-Dispatch-Work-Item"><a href="#10-Dispatch-Work-Item" class="headerlink" title="10. Dispatch Work Item"></a>10. <strong>Dispatch Work Item</strong></h3><p>使用 <code>dispatch_block_t</code> 创建可取消的工作项。</p>
<p>示例代码：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">dispatch_block_t workItem = dispatch_block_create(0, ^&#123;</span><br><span class="line">    // 执行任务</span><br><span class="line">    NSLog(@&quot;Work item executed&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_async(queue, workItem);</span><br><span class="line"></span><br><span class="line">// 取消工作项</span><br><span class="line">dispatch_block_cancel(workItem);</span><br></pre></td></tr></table></figure>
<p>在 iOS 开发中，有时候需要等待多个网络请求完成后再进行进一步操作，比如发起新的网络请求。为了实现这种需求，可以使用多种方法，包括 GCD（Grand Central Dispatch）、<code>NSOperationQueue</code> 和第三方库如 <code>PromiseKit</code> 或 <code>Combine</code>。</p>
<h3 id="方法一：使用-GCD-Grand-Central-Dispatch"><a href="#方法一：使用-GCD-Grand-Central-Dispatch" class="headerlink" title="方法一：使用 GCD (Grand Central Dispatch)"></a>方法一：使用 GCD (Grand Central Dispatch)</h3><p>GCD 提供了一种简单的方法来同步多个异步任务。可以使用 <code>dispatch_group</code> 来实现等待多个任务完成后执行下一步操作。</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line"></span><br><span class="line">// 开始请求A</span><br><span class="line">dispatch_group_enter(group);</span><br><span class="line">[self performRequestAWithCompletion:^(id response, NSError *error) &#123;</span><br><span class="line">    // 处理请求A的响应</span><br><span class="line">    dispatch_group_leave(group);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 开始请求B</span><br><span class="line">dispatch_group_enter(group);</span><br><span class="line">[self performRequestBWithCompletion:^(id response, NSError *error) &#123;</span><br><span class="line">    // 处理请求B的响应</span><br><span class="line">    dispatch_group_leave(group);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 当请求A和请求B都完成后，执行请求C</span><br><span class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    [self performRequestCWithCompletion:^(id response, NSError *error) &#123;</span><br><span class="line">        // 处理请求C的响应</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="方法二：使用-NSOperationQueue"><a href="#方法二：使用-NSOperationQueue" class="headerlink" title="方法二：使用 NSOperationQueue"></a>方法二：使用 <code>NSOperationQueue</code></h3><p><code>NSOperationQueue</code> 提供了一种更为面向对象的方法来管理异步任务的依赖关系。</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br><span class="line">queue.maxConcurrentOperationCount = 2; // 设置最大并发数</span><br><span class="line"></span><br><span class="line">NSBlockOperation *operationA = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">    [self performRequestAWithCompletion:^(id response, NSError *error) &#123;</span><br><span class="line">        // 处理请求A的响应</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">NSBlockOperation *operationB = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">    [self performRequestBWithCompletion:^(id response, NSError *error) &#123;</span><br><span class="line">        // 处理请求B的响应</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">NSBlockOperation *operationC = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">    [self performRequestCWithCompletion:^(id response, NSError *error) &#123;</span><br><span class="line">        // 处理请求C的响应</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 设置依赖关系</span><br><span class="line">[operationC addDependency:operationA];</span><br><span class="line">[operationC addDependency:operationB];</span><br><span class="line"></span><br><span class="line">// 将操作添加到队列</span><br><span class="line">[queue addOperation:operationA];</span><br><span class="line">[queue addOperation:operationB];</span><br><span class="line">[queue addOperation:operationC];</span><br></pre></td></tr></table></figure>
<h3 id="方法三：使用第三方库-PromiseKit"><a href="#方法三：使用第三方库-PromiseKit" class="headerlink" title="方法三：使用第三方库 PromiseKit"></a>方法三：使用第三方库 PromiseKit</h3><p><code>PromiseKit</code> 提供了一种现代的、链式的方式来处理异步操作。</p>
<p>首先，确保你已经安装了 <code>PromiseKit</code>。</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod &apos;PromiseKit&apos;, &apos;~&gt; 6.0&apos;</span><br></pre></td></tr></table></figure>
<p>然后，你可以使用类似以下的代码来实现：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;PromiseKit/PromiseKit.h&gt;</span><br><span class="line"></span><br><span class="line">- (AnyPromise *)performRequestA &#123;</span><br><span class="line">    return [AnyPromise promiseWithResolverBlock:^(PMKResolver resolve) &#123;</span><br><span class="line">        [self performRequestAWithCompletion:^(id response, NSError *error) &#123;</span><br><span class="line">            if (error) &#123;</span><br><span class="line">                resolve(error);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                resolve(response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (AnyPromise *)performRequestB &#123;</span><br><span class="line">    return [AnyPromise promiseWithResolverBlock:^(PMKResolver resolve) &#123;</span><br><span class="line">        [self performRequestBWithCompletion:^(id response, NSError *error) &#123;</span><br><span class="line">            if (error) &#123;</span><br><span class="line">                resolve(error);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                resolve(response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (AnyPromise *)performRequestC &#123;</span><br><span class="line">    return [AnyPromise promiseWithResolverBlock:^(PMKResolver resolve) &#123;</span><br><span class="line">        [self performRequestCWithCompletion:^(id response, NSError *error) &#123;</span><br><span class="line">            if (error) &#123;</span><br><span class="line">                resolve(error);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                resolve(response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)makeRequests &#123;</span><br><span class="line">    [When(@[[self performRequestA], [self performRequestB]]) then:^id(id results) &#123;</span><br><span class="line">        return [self performRequestC];</span><br><span class="line">    &#125;].catch(^(NSError *error) &#123;</span><br><span class="line">        // 处理错误</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法四：使用-Combine（适用于-iOS-13-及以上）"><a href="#方法四：使用-Combine（适用于-iOS-13-及以上）" class="headerlink" title="方法四：使用 Combine（适用于 iOS 13 及以上）"></a>方法四：使用 Combine（适用于 iOS 13 及以上）</h3><p>如果你在使用 iOS 13 及以上版本，可以使用 Combine 框架来处理异步任务。</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">import Combine</span><br><span class="line"></span><br><span class="line">func performRequestA() -&gt; Future&lt;Data, Error&gt; &#123;</span><br><span class="line">    return Future &#123; promise in</span><br><span class="line">        // 模拟网络请求A</span><br><span class="line">        self.performRequestA &#123; (data, error) in</span><br><span class="line">            if let error = error &#123;</span><br><span class="line">                promise(.failure(error))</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                promise(.success(data))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func performRequestB() -&gt; Future&lt;Data, Error&gt; &#123;</span><br><span class="line">    return Future &#123; promise in</span><br><span class="line">        // 模拟网络请求B</span><br><span class="line">        self.performRequestB &#123; (data, error) in</span><br><span class="line">            if let error = error &#123;</span><br><span class="line">                promise(.failure(error))</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                promise(.success(data))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func performRequestC() -&gt; Future&lt;Data, Error&gt; &#123;</span><br><span class="line">    return Future &#123; promise in</span><br><span class="line">        // 模拟网络请求C</span><br><span class="line">        self.performRequestC &#123; (data, error) in</span><br><span class="line">            if let error = error &#123;</span><br><span class="line">                promise(.failure(error))</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                promise(.success(data))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let cancellable = Publishers.Zip(performRequestA(), performRequestB())</span><br><span class="line">    .flatMap &#123; _ in</span><br><span class="line">        return performRequestC()</span><br><span class="line">    &#125;</span><br><span class="line">    .sink(receiveCompletion: &#123; completion in</span><br><span class="line">        switch completion &#123;</span><br><span class="line">        case .failure(let error):</span><br><span class="line">            print(&quot;Error: \(error)&quot;)</span><br><span class="line">        case .finished:</span><br><span class="line">            print(&quot;All requests finished successfully&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, receiveValue: &#123; data in</span><br><span class="line">        print(&quot;Received data: \(data)&quot;)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>GCD</strong>: 适用于需要轻量级并发管理的场景。</li>
<li><strong>NSOperationQueue</strong>: 提供了更为面向对象的并发管理方式，适用于复杂任务依赖关系的场景。</li>
<li><strong>PromiseKit</strong>: 提供了一种现代的链式异步处理方式，代码更为简洁。</li>
<li><strong>Combine</strong>: 适用于 iOS 13 及以上版本，提供了响应式编程的方式来处理异步任务。</li>
</ul>
<p>选择哪种方法取决于你的项目需求和个人偏好。希望这些示例能够帮助你实现网络请求 A 和 B 都回调后再请求 C 的需求。</p>
<h2 id="8-可变数组-NSMutableArray，在头部插入元素，iOS-系统做了什么优化"><a href="#8-可变数组-NSMutableArray，在头部插入元素，iOS-系统做了什么优化" class="headerlink" title="8.可变数组 NSMutableArray，在头部插入元素，iOS 系统做了什么优化"></a>8.可变数组 NSMutableArray，在头部插入元素，iOS 系统做了什么优化</h2><p>在 iOS 系统中，<code>NSMutableArray</code> 是一个动态数组，它在插入和删除元素时会进行一些优化，但具体的优化细节是由底层实现决定的，这些实现细节通常是私有的，Apple 并未公开详细的内部实现。不过，我们可以推测和总结一些常见的优化策略，这些策略可能会在 <code>NSMutableArray</code> 中使用。</p>
<h3 id="1-内存预分配和扩展"><a href="#1-内存预分配和扩展" class="headerlink" title="1. 内存预分配和扩展"></a>1. 内存预分配和扩展</h3><p><code>NSMutableArray</code> 会预先分配内存来容纳多个元素，以减少频繁的内存分配操作。当数组需要扩展容量时，它可能会一次性分配比当前需求更多的内存空间，以备将来使用。这种策略可以减少内存分配和释放的频率，提高性能。</p>
<h3 id="2-元素移动优化"><a href="#2-元素移动优化" class="headerlink" title="2. 元素移动优化"></a>2. 元素移动优化</h3><p>在数组头部插入元素时，所有现有元素都需要向后移动一个位置。为了减少内存拷贝的开销，系统可能会使用高效的内存拷贝函数（如 <code>memmove</code>）来移动元素。<code>memmove</code> 函数在处理重叠内存区域时比 <code>memcpy</code> 更安全和高效。</p>
<h3 id="3-数据结构优化"><a href="#3-数据结构优化" class="headerlink" title="3. 数据结构优化"></a>3. 数据结构优化</h3><p>尽管 <code>NSMutableArray</code> 主要使用动态数组来实现，但底层可能会结合使用其他数据结构（如链表）来优化特定操作的性能。例如，为了优化头部插入操作，系统可能会在特定情况下使用双向链表或者其他更适合插入操作的结构。</p>
<h3 id="4-缓存局部性"><a href="#4-缓存局部性" class="headerlink" title="4. 缓存局部性"></a>4. 缓存局部性</h3><p><code>NSMutableArray</code> 可能会利用缓存局部性来提高性能。通过将相邻的元素存储在接近的内存地址上，可以提高缓存命中率，从而提高内存访问速度。</p>
<h3 id="5-并发处理优化"><a href="#5-并发处理优化" class="headerlink" title="5. 并发处理优化"></a>5. 并发处理优化</h3><p>虽然 <code>NSMutableArray</code> 本身不是线程安全的，但在一些多线程环境中，系统可能会使用锁、原子操作或者其他并发控制机制来优化并发访问的性能。</p>
<p>总的来说，虽然我们无法确切知道 <code>NSMutableArray</code> 的内部优化细节，但可以推测它会采用一些常见的优化策略来提升性能。了解这些优化策略有助于我们在开发过程中做出更好的性能优化决策。</p>
<h2 id="9-Tagged-Pointer"><a href="#9-Tagged-Pointer" class="headerlink" title="9.Tagged Pointer"></a>9.Tagged Pointer</h2><h3 id="Tagged-Pointer-的基本原理"><a href="#Tagged-Pointer-的基本原理" class="headerlink" title="Tagged Pointer 的基本原理"></a>Tagged Pointer 的基本原理</h3><p><code>Tagged Pointer</code> 的基本原理是利用指针的高位位元来存储数据，而不是使用这些位元来存储内存地址。具体来说：</p>
<ul>
<li>在 64 位系统中，指针有 64 位，其中通常只有低 48 位用于存储内存地址，高 16 位未被使用。</li>
<li><code>Tagged Pointer</code> 技术利用这些未使用的高位位元来存储数据。</li>
</ul>
<h3 id="如何识别-Tagged-Pointer"><a href="#如何识别-Tagged-Pointer" class="headerlink" title="如何识别 Tagged Pointer"></a>如何识别 Tagged Pointer</h3><p>在 Objective-C 中，<code>Tagged Pointer</code> 使用最高位（最高位为 1）来标识是否是 <code>Tagged Pointer</code>。例如：</p>
<ul>
<li><code>0x8000000000000000</code>：最高位为 1，表示这是一个 <code>Tagged Pointer</code>。</li>
<li><code>0x0000000000000000</code>：最高位为 0，表示这是一个普通的指针。</li>
</ul>
<h3 id="Tagged-Pointer-的数据存储"><a href="#Tagged-Pointer-的数据存储" class="headerlink" title="Tagged Pointer 的数据存储"></a>Tagged Pointer 的数据存储</h3><p><code>Tagged Pointer</code> 可以存储多种类型的数据，包括：</p>
<ul>
<li><strong>小整数</strong>：直接在指针中存储整数值。</li>
<li><strong>小浮点数</strong>：直接在指针中存储浮点数值。</li>
<li><strong>小字符串</strong>：直接在指针中存储字符串数据。</li>
</ul>
<h2 id="10-NSString-存储在哪里，引用计数存储哪里？"><a href="#10-NSString-存储在哪里，引用计数存储哪里？" class="headerlink" title="10.NSString 存储在哪里，引用计数存储哪里？"></a>10.NSString 存储在哪里，引用计数存储哪里？</h2><h3 id="1-常量字符串"><a href="#1-常量字符串" class="headerlink" title="1. 常量字符串"></a>1. 常量字符串</h3><p>常量字符串是指在代码中直接使用的字符串字面量，例如：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString *str = @&quot;Hello, World!&quot;;</span><br></pre></td></tr></table></figure>
<p>这些字符串字面量通常会被存储在程序的只读数据段（Read-Only Data Segment）中。这意味着它们在编译时已经确定，并且在程序运行时不会被修改。它们的内存分配通常是由编译器在编译时完成的。</p>
<h3 id="2-动态字符串"><a href="#2-动态字符串" class="headerlink" title="2. 动态字符串"></a>2. 动态字符串</h3><p>动态字符串是指在程序运行时生成或拼接的字符串，例如：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSString *str1 = [NSString stringWithFormat:@&quot;Hello, %@&quot;, @&quot;World&quot;];</span><br><span class="line">NSString *str2 = [str1 mutableCopy];</span><br></pre></td></tr></table></figure>
<p>这些字符串是在程序运行时动态分配内存的。它们通常存储在堆（Heap）中，并由 <code>NSString</code> 和 <code>NSMutableString</code> 的内部实现来管理。</p>
<h3 id="3-内存管理"><a href="#3-内存管理" class="headerlink" title="3. 内存管理"></a>3. 内存管理</h3><p>在 Objective-C 中，内存管理主要通过引用计数（Reference Counting）来完成。<code>NSString</code> 对象也遵循这一规则：</p>
<ul>
<li><strong>ARC（Automatic Reference Counting）</strong>: 在使用 ARC 的情况下，编译器会自动插入内存管理代码，负责增加和减少引用计数。</li>
<li><strong>手动内存管理（MRC）</strong>: 在不使用 ARC 的情况下，开发者需要手动管理内存，通过 <code>retain</code>、<code>release</code> 和 <code>autorelease</code> 方法来管理引用计数。</li>
</ul>
<h3 id="4-内部实现"><a href="#4-内部实现" class="headerlink" title="4. 内部实现"></a>4. 内部实现</h3><p><code>NSString</code> 是一个抽象类，其具体实现有多个子类，这些子类优化了不同类型的字符串存储和操作。常见的子类包括：</p>
<ul>
<li><strong><code>__NSCFConstantString</code></strong>: 用于存储常量字符串。</li>
<li><strong><code>__NSCFString</code></strong>: 一般用于动态创建的不可变字符串。</li>
<li><strong><code>NSMutableString</code></strong>: 用于可变字符串。</li>
</ul>
<p>在实际运行时，<code>NSString</code> 对象的具体存储位置和方式可能会因为优化而有所不同。例如，短字符串可能会被存储在栈上，以提高性能。</p>
<h3 id="5-字符串缓存"><a href="#5-字符串缓存" class="headerlink" title="5. 字符串缓存"></a>5. 字符串缓存</h3><p>为了提高性能，<code>NSString</code> 类可能会使用一些内部缓存机制。例如，常量字符串可能会被缓存，以避免重复分配内存。这种优化在底层是由 <code>Core Foundation</code> 框架实现的。</p>
<h3 id="6-Foundation-框架与-Core-Foundation"><a href="#6-Foundation-框架与-Core-Foundation" class="headerlink" title="6. Foundation 框架与 Core Foundation"></a>6. Foundation 框架与 Core Foundation</h3><p><code>NSString</code> 是 Foundation 框架的一部分，但其底层实现依赖于 Core Foundation 中的 <code>CFString</code>。<code>CFString</code> 提供了字符串操作的底层实现，而 <code>NSString</code> 则是在其基础上提供了面向对象的接口。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>常量字符串</strong>: 存储在程序的只读数据段中。</li>
<li><strong>动态字符串</strong>: 在程序运行时存储在堆中。</li>
<li><strong>内存管理</strong>: 通过引用计数管理，无论是 ARC 还是 MRC。</li>
<li><strong>内部实现</strong>: 由多个子类优化不同类型的字符串，底层依赖于 Core Foundation 的 <code>CFString</code>。</li>
</ul>
<h2 id="11-dealloc-流程"><a href="#11-dealloc-流程" class="headerlink" title="11.dealloc 流程"></a>11.dealloc 流程</h2><h2 id="12-避免哈希碰撞的几种方法？"><a href="#12-避免哈希碰撞的几种方法？" class="headerlink" title="12.避免哈希碰撞的几种方法？"></a>12.避免哈希碰撞的几种方法？</h2><h3 id="1-更好的哈希函数"><a href="#1-更好的哈希函数" class="headerlink" title="1. 更好的哈希函数"></a>1. 更好的哈希函数</h3><p>选择一个更好的哈希函数可以极大地减少哈希碰撞的可能性。一个好的哈希函数应具有以下特性：</p>
<ul>
<li><strong>均匀性</strong>：能够将输入数据均匀地分布到哈希表的各个位置。</li>
<li><strong>确定性</strong>：相同的输入总是产生相同的哈希值。</li>
<li><strong>高效性</strong>：计算哈希值的时间复杂度应尽可能低。</li>
</ul>
<p>常见的哈希函数包括：</p>
<ul>
<li><strong>MD5</strong></li>
<li><strong>SHA-1</strong></li>
<li><strong>SHA-256</strong></li>
</ul>
<p>在某些特定场景下，自定义的哈希函数也可能是一个有效的选择。</p>
<h3 id="2-增大哈希表的大小"><a href="#2-增大哈希表的大小" class="headerlink" title="2. 增大哈希表的大小"></a>2. 增大哈希表的大小</h3><p>通过增大哈希表的大小，可以减少哈希碰撞的概率。哈希表的大小通常是一个素数，这样可以更均匀地分布哈希值。</p>
<h3 id="3-链地址法（Separate-Chaining）"><a href="#3-链地址法（Separate-Chaining）" class="headerlink" title="3. 链地址法（Separate Chaining）"></a>3. 链地址法（Separate Chaining）</h3><p>链地址法是处理哈希碰撞的一种常见方法。每个哈希表的槽（bucket）都包含一个链表（或其他数据结构），用于存储具有相同哈希值的多个元素。</p>
<h3 id="4-开放定址法（Open-Addressing）"><a href="#4-开放定址法（Open-Addressing）" class="headerlink" title="4. 开放定址法（Open Addressing）"></a>4. 开放定址法（Open Addressing）</h3><p>开放定址法通过在发生碰撞时寻找下一个空闲槽来存储元素。常见的开放定址法包括线性探测、二次探测和双重散列。</p>
<h4 id="线性探测"><a href="#线性探测" class="headerlink" title="线性探测"></a>线性探测</h4><p>线性探测在发生碰撞时，按固定步长（通常为 1）依次探测下一个槽，直到找到空闲槽为止。</p>
<h4 id="二次探测"><a href="#二次探测" class="headerlink" title="二次探测"></a>二次探测</h4><p>二次探测在发生碰撞时，按二次方序列探测下一个槽。</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index = (index + i^2) % self.size</span><br></pre></td></tr></table></figure>
<h4 id="双重散列"><a href="#双重散列" class="headerlink" title="双重散列"></a>双重散列</h4><p>双重散列使用两个不同的哈希函数来计算探测序列。</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index = (hash1(key) + i * hash2(key)) % self.size</span><br></pre></td></tr></table></figure>
<h3 id="5-再哈希法（Rehashing）"><a href="#5-再哈希法（Rehashing）" class="headerlink" title="5. 再哈希法（Rehashing）"></a>5. 再哈希法（Rehashing）</h3><p>再哈希法在发生碰撞时，使用另一个哈希函数重新计算哈希值，直到找到空闲槽为止。</p>
<h3 id="6-动态调整哈希表大小"><a href="#6-动态调整哈希表大小" class="headerlink" title="6. 动态调整哈希表大小"></a>6. 动态调整哈希表大小</h3><p>在哈希表负载因子（Load Factor）达到一定阈值时，动态调整哈希表的大小。负载因子是已存储元素数量与哈希表大小的比值。当负载因子过高时，增大哈希表的大小并重新哈希所有元素。</p>
<h2 id="13-mach-o-了解吗？存储的方法信息可以无用代码检测？段迁移？"><a href="#13-mach-o-了解吗？存储的方法信息可以无用代码检测？段迁移？" class="headerlink" title="13.mach-o 了解吗？存储的方法信息可以无用代码检测？段迁移？"></a>13.mach-o 了解吗？存储的方法信息可以无用代码检测？段迁移？</h2><p>Mach-O（Mach Object 文件格式）是 macOS 和 iOS 操作系统上使用的一种文件格式，用于可执行文件、目标代码、动态库、内核转储等。Mach-O 格式提供了一种灵活且强大的方式来描述程序的结构，支持多种架构（如 x86_64、arm64）和多种类型的文件（如可执行文件、动态库）。以下是关于 Mach-O 文件格式的详细介绍：</p>
<h3 id="Mach-O-文件的基本结构"><a href="#Mach-O-文件的基本结构" class="headerlink" title="Mach-O 文件的基本结构"></a>Mach-O 文件的基本结构</h3><p>Mach-O 文件由多个部分组成，每个部分都有特定的用途和结构。主要部分包括：</p>
<ol>
<li><strong>Header（头部）</strong>：包含文件的基本信息，如文件类型、CPU 架构、加载命令数量等。</li>
<li><strong>Load Commands（加载命令）</strong>：描述文件的各个部分如何加载到内存中。这些命令包括段的描述、动态库的引用、符号表的位置等。</li>
<li><strong>Segments（段）</strong>：包含实际的代码和数据。每个段包含多个 section（节），每个节存储特定类型的数据，如代码节、数据节、符号表等。</li>
<li><strong>Sections（节）</strong>：段的子部分，存储不同类型的数据，如可执行代码、只读数据、可写数据等。</li>
</ol>
<h3 id="详细结构"><a href="#详细结构" class="headerlink" title="详细结构"></a>详细结构</h3><h4 id="1-Header（头部）"><a href="#1-Header（头部）" class="headerlink" title="1. Header（头部）"></a>1. Header（头部）</h4><p>头部是 Mach-O 文件的开始部分，包含文件的基本信息。头部的结构定义如下：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct mach_header &#123;</span><br><span class="line">    uint32_t magic;          // 魔数，标识文件格式</span><br><span class="line">    cpu_type_t cputype;      // CPU 类型</span><br><span class="line">    cpu_subtype_t cpusubtype;// CPU 子类型</span><br><span class="line">    uint32_t filetype;       // 文件类型（如可执行文件、动态库）</span><br><span class="line">    uint32_t ncmds;          // 加载命令的数量</span><br><span class="line">    uint32_t sizeofcmds;     // 所有加载命令的总大小</span><br><span class="line">    uint32_t flags;          // 标志位</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="2-Load-Commands（加载命令）"><a href="#2-Load-Commands（加载命令）" class="headerlink" title="2. Load Commands（加载命令）"></a>2. Load Commands（加载命令）</h4><p>加载命令描述文件的各个部分如何加载到内存中。常见的加载命令包括：</p>
<ul>
<li><strong>LC_SEGMENT</strong>：描述一个段。</li>
<li><strong>LC_SYMTAB</strong>：描述符号表的位置。</li>
<li><strong>LC_DYSYMTAB</strong>：描述动态符号表的位置。</li>
<li><strong>LC_LOAD_DYLIB</strong>：描述需要加载的动态库。</li>
</ul>
<p>每个加载命令的基本结构如下：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct load_command &#123;</span><br><span class="line">    uint32_t cmd;      // 加载命令的类型</span><br><span class="line">    uint32_t cmdsize;  // 加载命令的大小</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="3-Segments（段）"><a href="#3-Segments（段）" class="headerlink" title="3. Segments（段）"></a>3. Segments（段）</h4><p>段是 Mach-O 文件中的主要数据部分，每个段包含多个节。常见的段包括：</p>
<ul>
<li><strong>__TEXT</strong>：包含可执行代码和只读数据。</li>
<li><strong>__DATA</strong>：包含可写数据。</li>
<li><strong>__LINKEDIT</strong>：包含符号表和其他链接信息。</li>
</ul>
<p>段的基本结构如下：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct segment_command &#123;</span><br><span class="line">    uint32_t cmd;            // LC_SEGMENT</span><br><span class="line">    uint32_t cmdsize;        // 加载命令的大小</span><br><span class="line">    char segname[16];        // 段的名称</span><br><span class="line">    uint32_t vmaddr;         // 段在虚拟内存中的地址</span><br><span class="line">    uint32_t vmsize;         // 段的大小</span><br><span class="line">    uint32_t fileoff;        // 段在文件中的偏移</span><br><span class="line">    uint32_t filesize;       // 段在文件中的大小</span><br><span class="line">    vm_prot_t maxprot;       // 段的最大保护</span><br><span class="line">    vm_prot_t initprot;      // 段的初始保护</span><br><span class="line">    uint32_t nsects;         // 段中节的数量</span><br><span class="line">    uint32_t flags;          // 段的标志</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="4-Sections（节）"><a href="#4-Sections（节）" class="headerlink" title="4. Sections（节）"></a>4. Sections（节）</h4><p>节是段的子部分，存储具体类型的数据。每个节的基本结构如下：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct section &#123;</span><br><span class="line">    char sectname[16];       // 节的名称</span><br><span class="line">    char segname[16];        // 段的名称</span><br><span class="line">    uint32_t addr;           // 节在虚拟内存中的地址</span><br><span class="line">    uint32_t size;           // 节的大小</span><br><span class="line">    uint32_t offset;         // 节在文件中的偏移</span><br><span class="line">    uint32_t align;          // 节的对齐</span><br><span class="line">    uint32_t reloff;         // 重定位表的偏移</span><br><span class="line">    uint32_t nreloc;         // 重定位表的数量</span><br><span class="line">    uint32_t flags;          // 节的标志</span><br><span class="line">    uint32_t reserved1;      // 保留字段</span><br><span class="line">    uint32_t reserved2;      // 保留字段</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Mach-O-文件类型"><a href="#Mach-O-文件类型" class="headerlink" title="Mach-O 文件类型"></a>Mach-O 文件类型</h3><p>Mach-O 文件有多种类型，主要包括：</p>
<ul>
<li><strong>MH_EXECUTE</strong>：可执行文件。</li>
<li><strong>MH_DYLIB</strong>：动态库。</li>
<li><strong>MH_BUNDLE</strong>：可加载的代码包。</li>
<li><strong>MH_OBJECT</strong>：目标文件。</li>
<li><strong>MH_DYLINKER</strong>：动态链接器。</li>
</ul>
<h3 id="使用工具查看-Mach-O-文件"><a href="#使用工具查看-Mach-O-文件" class="headerlink" title="使用工具查看 Mach-O 文件"></a>使用工具查看 Mach-O 文件</h3><p>macOS 提供了一些工具来查看和分析 Mach-O 文件：</p>
<ul>
<li><p>otool</p>
<p>：用于显示 Mach-O 文件的头部、段、节、符号表等信息。</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">otool -hV MyApp.app/MyApp  # 显示头部信息</span><br><span class="line">otool -L MyApp.app/MyApp   # 显示动态库依赖</span><br><span class="line">otool -tV MyApp.app/MyApp  # 显示反汇编代码</span><br></pre></td></tr></table></figure>
</li>
<li><p>nm</p>
<p>：用于显示 Mach-O 文件中的符号表。</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nm MyApp.app/MyApp</span><br></pre></td></tr></table></figure>
</li>
<li><p>dyldinfo</p>
<p>：用于显示动态链接相关信息。</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dyldinfo -all MyApp.app/MyApp</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>Mach-O 是 macOS 和 iOS 上使用的一种复杂而灵活的文件格式，用于描述可执行文件、动态库等。它通过头部、加载命令、段和节组织数据，支持多种文件类型和 CPU 架构。理解 Mach-O 文件格式有助于进行底层调试、性能优化和安全分析。macOS 提供了一些工具，如 <code>otool</code> 和 <code>nm</code>，可以用来查看和分析 Mach-O 文件的结构和内容。</p>
<h2 id="14-脚本检测未使用代码原理"><a href="#14-脚本检测未使用代码原理" class="headerlink" title="14.脚本检测未使用代码原理"></a>14.脚本检测未使用代码原理</h2><h2 id="15-Render-渲染流程"><a href="#15-Render-渲染流程" class="headerlink" title="15.Render 渲染流程"></a>15.Render 渲染流程</h2><p>iOS 渲染流程是一个复杂且高效的过程，它负责将应用的界面呈现到屏幕上。理解这个流程有助于优化应用的性能和用户体验。以下是 iOS 渲染流程的概要：</p>
<h3 id="1-应用层（Application-Layer）"><a href="#1-应用层（Application-Layer）" class="headerlink" title="1. 应用层（Application Layer）"></a>1. 应用层（Application Layer）</h3><p>应用层是 iOS 应用的最上层，包括应用的逻辑、UI 视图控制器（UIViewController）、视图（UIView）等。开发者主要在这一层进行开发。</p>
<h3 id="2-Core-Animation"><a href="#2-Core-Animation" class="headerlink" title="2. Core Animation"></a>2. Core Animation</h3><p>Core Animation 是 iOS 渲染的核心技术，它负责管理和执行所有的动画和视图层次结构（Layer Tree）。Core Animation 使用双缓冲技术来确保动画的流畅性。主要包括以下几个组成部分：</p>
<ul>
<li><strong>Layer Tree</strong>: 由 <code>CALayer</code> 对象组成的层次结构，每个 <code>UIView</code> 对应一个 <code>CALayer</code>。</li>
<li><strong>Display Tree</strong>: 由 Core Animation 生成的用于实际显示内容的树。</li>
<li><strong>Render Tree</strong>: 用于渲染的最终树，由 Core Animation 发送给渲染服务器（Render Server）。</li>
</ul>
<h3 id="3-渲染服务器（Render-Server）"><a href="#3-渲染服务器（Render-Server）" class="headerlink" title="3. 渲染服务器（Render Server）"></a>3. 渲染服务器（Render Server）</h3><p>渲染服务器是一个独立的进程，负责接收来自 Core Animation 的 Render Tree，并将其转换为 GPU 可以理解的指令。渲染服务器会将这些指令发送给 GPU 进行实际的渲染。</p>
<h3 id="4-GPU-渲染"><a href="#4-GPU-渲染" class="headerlink" title="4. GPU 渲染"></a>4. GPU 渲染</h3><p>GPU（图形处理单元）接收到渲染指令后，会执行以下操作：</p>
<ol>
<li><strong>顶点着色（Vertex Shading）</strong>: 处理顶点数据，包括位置、颜色、纹理等信息。</li>
<li><strong>图元组装（Primitive Assembly）</strong>: 将顶点连接成图元（如三角形）。</li>
<li><strong>光栅化（Rasterization）</strong>: 将图元转换为片元（Pixel）。</li>
<li><strong>片元着色（Fragment Shading）</strong>: 计算每个片元的颜色和其他属性。</li>
<li><strong>帧缓存操作（Frame Buffer Operations）</strong>: 将最终的片元数据写入帧缓存（Frame Buffer）。</li>
</ol>
<h3 id="5-显示层（Display-Layer）"><a href="#5-显示层（Display-Layer）" class="headerlink" title="5. 显示层（Display Layer）"></a>5. 显示层（Display Layer）</h3><p>最终的帧缓存数据会被传递到显示层，由显示层将其显示在屏幕上。iOS 使用 VSync（垂直同步）信号来协调显示更新，以确保屏幕刷新和渲染同步，避免画面撕裂。</p>
<h3 id="渲染流程的详细步骤"><a href="#渲染流程的详细步骤" class="headerlink" title="渲染流程的详细步骤"></a>渲染流程的详细步骤</h3><ol>
<li><strong>视图更新（View Update）</strong>:<ul>
<li>应用程序修改视图或图层属性（如位置、大小、颜色等）。</li>
<li><code>UIView</code> 的属性变化会触发 <code>CALayer</code> 的相应变化。</li>
</ul>
</li>
<li><strong>布局和显示（Layout and Display）</strong>:<ul>
<li><code>UIView</code> 布局系统会重新计算视图的布局。</li>
<li><code>CALayer</code> 会根据视图的变化更新自己的属性。</li>
</ul>
</li>
<li><strong>Core Animation 动画处理（Core Animation Animation Handling）</strong>:<ul>
<li>Core Animation 会将动画应用到相关的 <code>CALayer</code> 上。</li>
<li>根据动画时间轴生成 Display Tree。</li>
</ul>
</li>
<li><strong>Render Tree 生成（Render Tree Generation）</strong>:<ul>
<li>Core Animation 从 Display Tree 生成 Render Tree。</li>
<li>Render Tree 包含了所有需要渲染的信息。</li>
</ul>
</li>
<li><strong>Render Server 渲染（Render Server Rendering）</strong>:<ul>
<li>Core Animation 将 Render Tree 发送给渲染服务器。</li>
<li>渲染服务器将 Render Tree 转换为 GPU 指令。</li>
</ul>
</li>
<li><strong>GPU 渲染（GPU Rendering）</strong>:<ul>
<li>GPU 执行顶点着色、图元组装、光栅化、片元着色和帧缓存操作。</li>
<li>渲染结果存储在帧缓存中。</li>
</ul>
</li>
<li><strong>显示更新（Display Update）</strong>:<ul>
<li>帧缓存内容通过显示层显示在屏幕上。</li>
<li>VSync 信号确保显示更新和屏幕刷新同步。</li>
</ul>
</li>
</ol>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p>理解 iOS 渲染流程有助于优化应用性能，以下是一些常见的优化策略：</p>
<ol>
<li><strong>减少布局计算和视图层次结构的复杂度</strong>。</li>
<li><strong>使用合适的图层类型（如 <code>CAShapeLayer</code>、<code>CATextLayer</code>）</strong>。</li>
<li><strong>避免频繁的视图更新和动画</strong>。</li>
<li><strong>使用异步绘制技术（如 <code>drawRect:</code> 方法）</strong>。</li>
<li><strong>避免不必要的离屏渲染（Offscreen Rendering）</strong>。</li>
</ol>
<p>通过这些优化策略，可以减少 CPU 和 GPU 的负担，提高应用的流畅性和响应速度。</p>
<h2 id="16-UIView-动画和-CAAnimation-动画有什么联系？"><a href="#16-UIView-动画和-CAAnimation-动画有什么联系？" class="headerlink" title="16.UIView 动画和 CAAnimation 动画有什么联系？"></a>16.UIView 动画和 CAAnimation 动画有什么联系？</h2><p>虽然 <code>UIView</code> 动画和 <code>CAAnimation</code> 动画在使用上有区别，但它们的底层机制是有联系的。<code>UIView</code> 动画实际上是对 <code>CAAnimation</code> 的封装和简化。当你使用 <code>UIView</code> 动画时，UIKit 会在内部创建相应的 <code>CAAnimation</code> 对象，并将其添加到视图的 <code>CALayer</code> 上。</p>
<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UIView.animate(withDuration: 1.0, animations: &#123;</span><br><span class="line">    myView.alpha = 0.0</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>上面的代码等价于：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let animation = CABasicAnimation(keyPath: &quot;opacity&quot;)</span><br><span class="line">animation.fromValue = 1.0</span><br><span class="line">animation.toValue = 0.0</span><br><span class="line">animation.duration = 1.0</span><br><span class="line">myView.layer.add(animation, forKey: &quot;opacityAnimation&quot;)</span><br><span class="line">myView.layer.opacity = 0.0</span><br></pre></td></tr></table></figure>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p><code>UIView</code> 动画是对 <code>CAAnimation</code> 的封装，提供了更高层次的接口，使得简单动画的实现更加便捷，而 <code>CAAnimation</code> 提供了更强大的功能和更精细的控制，适合复杂的动画需求。在实际开发中，可以根据具体的动画需求选择合适的动画方式。</p>
<h2 id="17-项目亮点"><a href="#17-项目亮点" class="headerlink" title="17.项目亮点"></a>17.项目亮点</h2>
        </div>
        
        <div class="level is-size-7 is-uppercase">
            <div class="level-start">
                <div class="level-item">
                    <span class="is-size-6 has-text-grey has-mr-7">#</span>
                    <a class="has-link-grey -link" href="/tags/百融云创/">百融云创</a>, <a class="has-link-grey -link" href="/tags/面试/">面试</a>
                </div>
            </div>
        </div>
        
        
        
    </div>
</div>





<div class="card card-transparent">
    <div class="level post-navigation is-flex-wrap is-mobile">
        
        
        <div class="level-end">
            <a class="level level-item has-link-grey  article-nav-next" href="/OC语法/">
                <span class="level-item">OC语法</span>
                <i class="level-item fas fa-chevron-right"></i>
            </a>
        </div>
        
    </div>
</div>


</div>
                
                
            </div>
        </div>
    </section>
    <footer class="footer">
    <div class="container">
        <div class="level">
            <div class="level-start has-text-centered-mobile">
                <a class="footer-logo is-block has-mb-6" href="/">
                
                    <img src="/images/logo-2.png" alt="百融云创面试题" height="28">
                
                </a>
                <p class="is-size-7">
                &copy; 2024 SOSOWIKI&nbsp;
                All rights reserved.
                
                </p>
            </div>
            <div class="level-end">
            
            </div>
        </div>
    </div>
</footer>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script>
<script>moment.locale("zh-CN");</script>

<script>
var IcarusThemeSettings = {
    article: {
        highlight: {
            clipboard: true,
            fold: 'unfolded'
        }
    }
};
</script>


    <script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script>



    
    
    
    <script src="/js/animation.js"></script>
    

    
    
    
    <script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script>
    <script src="/js/gallery.js" defer></script>
    

    
    

<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update
            my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        });
    });
</script>


    
    
<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    MathJax.Hub.Config({
        'HTML-CSS': {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
});
</script>

    
    

<a id="back-to-top" title="回到顶端" href="javascript:;">
    <i class="fas fa-chevron-up"></i>
</a>
<script src="/js/back-to-top.js" defer></script>


    
    

    
    
    
    

    
    
    
    
    


<script src="/js/main.js" defer></script>

    
    <div class="searchbox ins-search">
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="搜索公司、题目、关键字" />
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: '文章',
                PAGES: '页面',
                CATEGORIES: '分类',
                TAGS: '标签',
                UNTITLED: '关于',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js" defer></script>
<link rel="stylesheet" href="/css/search.css">
<link rel="stylesheet" href="/css/insight.css">
    
</body>
</html>