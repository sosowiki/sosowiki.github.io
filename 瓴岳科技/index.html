<!DOCTYPE html>
<html  lang="zh">
<head>
    <meta charset="utf-8" />

<meta name="generator" content="Hexo 3.8.0" />

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<title>瓴岳科技 - SOSOWIKI</title>


    <meta name="description" content="瓴岳科技">
<meta name="keywords" content="面试,瓴岳科技">
<meta property="og:type" content="article">
<meta property="og:title" content="瓴岳科技">
<meta property="og:url" content="http://soso.wiki/瓴岳科技/index.html">
<meta property="og:site_name" content="SOSOWIKI">
<meta property="og:description" content="瓴岳科技">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://soso.wiki/images/og_image.png">
<meta property="og:updated_time" content="2024-08-07T07:39:54.396Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="瓴岳科技">
<meta name="twitter:description" content="瓴岳科技">
<meta name="twitter:image" content="http://soso.wiki/images/og_image.png">







<link rel="icon" href="/images/favicon.jpeg">


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.7.2/css/bulma.css">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.1/css/all.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css">


    
    
    
    <style>body>.footer,body>.navbar,body>.section{opacity:0}</style>
    

    
    
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css">
    

    
    

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css">


    
    
    
    

<link rel="stylesheet" href="/css/back-to-top.css">


    
    

    
    
<script>
var _hmt = _hmt || [];
(function() {
    var hm = document.createElement("script");
    hm.src = "//hm.baidu.com/hm.js?b07e5a4ee78cf8302e7e2cf5b9db7f2c";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
})();
</script>

    
    

    
    
<link rel="stylesheet" href="/css/progressbar.css">
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

    
    
    


<link rel="stylesheet" href="/css/style.css">
</head>
<body class="is-1-column">
    <nav class="navbar navbar-main">
    <div class="container">
        <div class="navbar-brand is-flex-center">
            <a class="navbar-item navbar-logo" href="/">
            
                <img src="/images/logo-2.png" alt="瓴岳科技" height="28">
            
            </a>
        </div>
        <div class="navbar-menu">
            
            <div class="navbar-start">
                
                <a class="navbar-item"
                href="/">首页</a>
                
                <a class="navbar-item"
                href="/archives">归档</a>
                
                <a class="navbar-item"
                href="/tags">标签</a>
                
                <a class="navbar-item"
                href="/about">关于</a>
                
            </div>
            
            <div class="navbar-end">
                
                
                
                <a class="navbar-item search" title="搜索" href="javascript:;">
                    <i class="fas fa-search"></i>
                </a>
                
            </div>
        </div>
    </div>
</nav>
    
    <section class="section">
        <div class="container">
            <div class="columns">
                <div class="column is-12 has-order-2 column-main"><div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2024-08-05T03:00:00.000Z">2024-08-05</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/面试题/">面试题</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    38 分钟 读完 (大约 5774 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                瓴岳科技
            
        </h1>
        <div class="content">
            <p>瓴岳科技<br><a id="more"></a></p>
<p>1.SDK 体积优化</p>
<p>2.webView 加载速度优化，H5 怎么加载本地 JS/图片资源</p>
<p>3.线上监控，卡顿、内存</p>
<p>4.Runloop 有几个 mode？</p>
<p>5.项目里有用到常驻线程吗？</p>
<p>6.KVO 原理</p>
<p>7.IMP、selector、SEL 含义和区别</p>
<p>8.消息转发机制的优劣，和直接调用相比</p>
<p>9.点击界面上的一个按钮，发生了什么？</p>
<p>10.SQLite3 和 Realm 的区别？</p>
<p>11.Category 和 Extension 的区别</p>
<p>12.Block 的本质，结构体里有哪些东西？内存管理</p>
<p>13.为什么要在主线程刷新 UI</p>
<p>14.Swift 中 Result 类型</p>
<p>15.二叉树的翻转</p>
<p><a href="https://leetcode.cn/problems/invert-binary-tree/" target="_blank" rel="noopener">226. 翻转二叉树</a></p>
<h2 id="参考答案"><a href="#参考答案" class="headerlink" title="参考答案"></a>参考答案</h2><p>(GPT)</p>
<h2 id="1-SDK体积优化"><a href="#1-SDK体积优化" class="headerlink" title="1.SDK体积优化"></a>1.SDK体积优化</h2><p>优化iOS SDK体积对于提升应用性能、减少下载时间以及节省用户设备存储空间都非常重要。以下是一些有效的方法来优化iOS SDK的体积：</p>
<h3 id="1-移除不必要的架构"><a href="#1-移除不必要的架构" class="headerlink" title="1. 移除不必要的架构"></a>1. 移除不必要的架构</h3><ul>
<li><p>只保留所需的架构：在构建SDK时，移除不必要的架构，例如x86_64和i386（模拟器架构），只保留arm64（实际设备架构）。</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lipo -remove x86_64 YourSDK.framework/YourSDK -o YourSDK.framework/YourSDK</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-减少资源文件"><a href="#2-减少资源文件" class="headerlink" title="2. 减少资源文件"></a>2. 减少资源文件</h3><ul>
<li><strong>移除未使用的资源</strong>：移除未使用的图片、音频、视频等资源文件。</li>
<li><strong>压缩资源文件</strong>：使用工具（如ImageOptim）压缩图片文件，使用合适的编码格式压缩音频和视频文件。</li>
</ul>
<h3 id="3-使用符号表压缩"><a href="#3-使用符号表压缩" class="headerlink" title="3. 使用符号表压缩"></a>3. 使用符号表压缩</h3><ul>
<li><p>压缩符号表：通过strip工具压缩符号表以减少二进制文件的体积。</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strip -S YourSDK.framework/YourSDK</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="4-代码优化"><a href="#4-代码优化" class="headerlink" title="4. 代码优化"></a>4. 代码优化</h3><ul>
<li><strong>移除未使用代码</strong>：通过代码分析工具（如Xcode的静态分析功能）查找并移除未使用的代码。</li>
<li><strong>模块化</strong>：将SDK拆分成多个模块，只在需要时引入特定模块。</li>
</ul>
<h3 id="5-使用Swift-Package-Manager"><a href="#5-使用Swift-Package-Manager" class="headerlink" title="5. 使用Swift Package Manager"></a>5. 使用Swift Package Manager</h3><ul>
<li><strong>Swift Package Manager (SPM)</strong>：使用SPM来管理和分发SDK，可以显著减少SDK的体积，因为SPM只会下载和编译所需的代码。</li>
</ul>
<h3 id="6-动态库-vs-静态库"><a href="#6-动态库-vs-静态库" class="headerlink" title="6. 动态库 vs 静态库"></a>6. 动态库 vs 静态库</h3><ul>
<li><strong>选择合适的库类型</strong>：在某些情况下，使用动态库（.dylib或.framework）可以减少整体应用的体积，因为它们可以被多个应用共享。</li>
</ul>
<h3 id="7-编译优化"><a href="#7-编译优化" class="headerlink" title="7. 编译优化"></a>7. 编译优化</h3><ul>
<li><p>优化编译设置：在Xcode中，确保在Release配置下选择优化选项（如-Oz）以减少代码体积。</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Build Settings -&gt; Optimization Level -&gt; Optimize for Size [-Oz]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="8-引用第三方库优化"><a href="#8-引用第三方库优化" class="headerlink" title="8. 引用第三方库优化"></a>8. 引用第三方库优化</h3><ul>
<li><strong>移除未使用的第三方库</strong>：确保只包含那些在SDK中实际使用的第三方库。</li>
<li><strong>使用轻量级的第三方库</strong>：选择功能相同但体积更小的第三方库。</li>
</ul>
<h3 id="9-符号混淆"><a href="#9-符号混淆" class="headerlink" title="9. 符号混淆"></a>9. 符号混淆</h3><ul>
<li><strong>符号混淆</strong>：使用符号混淆工具（如llvm-obfuscator）混淆符号表以减少符号表大小和提高代码安全性。</li>
</ul>
<p>通过以上方法，您可以显著减少iOS SDK的体积，从而提升用户体验和应用的整体性能。</p>
<h2 id="2-webView加载速度优化，H5怎么加载本地JS-图片资源"><a href="#2-webView加载速度优化，H5怎么加载本地JS-图片资源" class="headerlink" title="2.webView加载速度优化，H5怎么加载本地JS/图片资源"></a>2.webView加载速度优化，H5怎么加载本地JS/图片资源</h2><p><a href="https://blog.cnbang.net/tech/3477/" target="_blank" rel="noopener">移动 H5 首屏秒开优化方案探讨</a></p>
<p><a href="https://tech.meituan.com/2017/06/09/webviewperf.html" target="_blank" rel="noopener">WebView性能、体验分析与优化</a></p>
<h2 id="3-线上监控，卡顿、内存"><a href="#3-线上监控，卡顿、内存" class="headerlink" title="3.线上监控，卡顿、内存"></a>3.线上监控，卡顿、内存</h2><h2 id="4-Runloop有几个mode？"><a href="#4-Runloop有几个mode？" class="headerlink" title="4.Runloop有几个mode？"></a>4.Runloop有几个mode？</h2><p>最常用的模式主要是以下几个：</p>
<ul>
<li><code>NSDefaultRunLoopMode</code> / <code>kCFRunLoopDefaultMode</code></li>
<li><code>UITrackingRunLoopMode</code></li>
<li><code>NSRunLoopCommonModes</code> / <code>kCFRunLoopCommonModes</code></li>
</ul>
<h2 id="5-项目里有用到常驻线程吗？"><a href="#5-项目里有用到常驻线程吗？" class="headerlink" title="5.项目里有用到常驻线程吗？"></a>5.项目里有用到常驻线程吗？</h2><h2 id="6-KVO原理"><a href="#6-KVO原理" class="headerlink" title="6.KVO原理"></a>6.KVO原理</h2><h3 id="KVO-基本概念"><a href="#KVO-基本概念" class="headerlink" title="KVO 基本概念"></a>KVO 基本概念</h3><p>KVO 允许对象观察另一个对象的某个属性，当该属性发生变化时，观察者会收到通知。通常，KVO 的使用分为以下几个步骤：</p>
<ol>
<li><strong>注册观察者</strong>：使用 <code>addObserver:forKeyPath:options:context:</code> 方法注册观察者。</li>
<li><strong>实现回调方法</strong>：实现 <code>observeValueForKeyPath:ofObject:change:context:</code> 方法来处理属性变化。</li>
<li><strong>移除观察者</strong>：使用 <code>removeObserver:forKeyPath:</code> 方法移除观察者。</li>
</ol>
<h3 id="KVO-工作原理"><a href="#KVO-工作原理" class="headerlink" title="KVO 工作原理"></a>KVO 工作原理</h3><p>KVO 的实现主要依赖于 Objective-C 的运行时机制，具体步骤如下：</p>
<ol>
<li><strong>动态创建子类</strong><br>当你为某个对象的某个属性注册观察者时，Objective-C 运行时会动态创建该对象的一个子类（通常以 <code>NSKVONotifying_</code> 为前缀），并将该对象的类指针（<code>isa</code> 指针）指向这个新创建的子类。</li>
<li><strong>重写属性的 setter 方法</strong><br>在这个新创建的子类中，Objective-C 运行时会重写被观察属性的 setter 方法。例如，如果你观察的是 <code>name</code> 属性，KVO 会重写 <code>setName:</code> 方法。</li>
<li><strong>通知观察者</strong><br>在重写的 setter 方法中，KVO 会插入一些钩子代码，在属性值变更前后调用 <code>willChangeValueForKey:</code> 和 <code>didChangeValueForKey:</code> 方法。这些方法用于通知观察者属性即将改变和已经改变。</li>
<li><strong>调用观察者的回调方法</strong><br><code>didChangeValueForKey:</code> 方法会触发 KVO 通知机制，最终调用观察者的 <code>observeValueForKeyPath:ofObject:change:context:</code> 方法。</li>
</ol>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li><strong>移除观察者</strong>：在对象释放之前，一定要移除所有的观察者，否则会导致崩溃。</li>
<li><strong>线程安全</strong>：KVO 通知是同步的，意味着属性的 setter 方法会在观察者的回调方法完成之后才返回。确保观察者的回调方法是线程安全的非常重要。</li>
<li><strong>KVO-compliant</strong>：确保属性遵循 KVO 协议，即通过 setter 方法（而不是直接修改实例变量）来改变属性的值。</li>
<li><strong>自动和手动通知</strong>：默认情况下，KVO 是自动通知的。你也可以通过重写 <code>automaticallyNotifiesObserversForKey:</code> 方法来禁用自动通知，并手动调用 <code>willChangeValueForKey:</code> 和 <code>didChangeValueForKey:</code>。</li>
</ol>
<h2 id="7-IMP、selector、SEL含义和区别"><a href="#7-IMP、selector、SEL含义和区别" class="headerlink" title="7.IMP、selector、SEL含义和区别"></a>7.IMP、selector、SEL含义和区别</h2><ol>
<li><strong>SEL（selector）</strong><ul>
<li><code>SEL</code> 或 <code>selector</code> 是方法的唯一标识符。</li>
<li>在编译时，编译器会将方法名称映射为一个 <code>SEL</code> 类型的选择器。</li>
<li>选择器用于在运行时查找方法的实现。</li>
</ul>
</li>
<li><strong>IMP</strong><ul>
<li><code>IMP</code> 是一个函数指针，指向方法的实际实现。</li>
<li>当你发送消息给对象时，运行时系统会根据 <code>SEL</code> 找到对应的 <code>IMP</code>，然后调用它。</li>
<li>直接调用 <code>IMP</code> 可以略过消息传递机制，提高性能。</li>
</ul>
</li>
</ol>
<h2 id="8-消息转发机制的优劣，和直接调用相比"><a href="#8-消息转发机制的优劣，和直接调用相比" class="headerlink" title="8.消息转发机制的优劣，和直接调用相比"></a>8.消息转发机制的优劣，和直接调用相比</h2><ol>
<li><strong>性能</strong><ul>
<li><strong>直接调用方法</strong>：最快，因为编译器在编译时已经确定了方法的实现。</li>
<li><strong>消息传递机制</strong>：稍慢，因为需要在运行时查找方法的实现。</li>
<li><strong>消息转发机制</strong>：最慢，因为涉及多个步骤来处理未知消息。</li>
</ul>
</li>
<li><strong>灵活性</strong><ul>
<li><strong>直接调用方法</strong>：灵活性最低，因为方法实现是静态绑定的。</li>
<li><strong>消息传递机制</strong>：灵活性较高，可以在运行时动态查找和调用方法。</li>
<li><strong>消息转发机制</strong>：灵活性最高，可以在运行时动态处理未知消息，甚至可以将消息转发给其他对象。</li>
</ul>
</li>
<li><strong>使用场景</strong><ul>
<li><strong>直接调用方法</strong>：适用于性能关键的代码，方法实现是确定的。</li>
<li><strong>消息传递机制</strong>：适用于需要一些动态特性的代码。</li>
<li><strong>消息转发机制</strong>：适用于需要高度动态性和灵活性的代码，例如代理模式、消息路由等。</li>
</ul>
</li>
</ol>
<h2 id="9-点击界面上的一个按钮，发生了什么？"><a href="#9-点击界面上的一个按钮，发生了什么？" class="headerlink" title="9.点击界面上的一个按钮，发生了什么？"></a>9.点击界面上的一个按钮，发生了什么？</h2><h3 id="响应者链（Responder-Chain）"><a href="#响应者链（Responder-Chain）" class="headerlink" title="响应者链（Responder Chain）"></a>响应者链（Responder Chain）</h3><p>响应者链是一个由 <code>UIResponder</code> 对象组成的链条，这些对象可以响应和处理事件。<code>UIView</code>, <code>UIViewController</code>, <code>UIWindow</code>, 以及 <code>UIApplication</code> 都是 <code>UIResponder</code> 的子类。</p>
<h4 id="事件传递和响应者链"><a href="#事件传递和响应者链" class="headerlink" title="事件传递和响应者链"></a>事件传递和响应者链</h4><ol>
<li><strong>触摸事件的产生</strong>：当用户点击屏幕时，硬件会捕捉到这个触摸事件，并将其传递给 iOS 系统。</li>
<li><strong>创建 UIEvent 对象</strong>：iOS 系统会将触摸数据封装成一个 <code>UIEvent</code> 对象。</li>
<li><strong>事件传递给 UIWindow</strong>：系统会将这个 <code>UIEvent</code> 传递给应用的主 <code>UIWindow</code>。</li>
<li><strong>找到第一响应者</strong>：<code>UIWindow</code> 会调用 <code>hitTest:withEvent:</code> 方法，从视图层次结构中找出最合适的视图来处理这个触摸事件。这个视图成为第一响应者。</li>
<li><strong>事件传递给 UIView</strong>：触摸事件会被传递给找到的视图（通常是一个 <code>UIButton</code>），并调用其 <code>touchesBegan:withEvent:</code>, <code>touchesMoved:withEvent:</code>, <code>touchesEnded:withEvent:</code> 方法来处理具体的触摸事件。</li>
</ol>
<h3 id="手势识别器的优先级"><a href="#手势识别器的优先级" class="headerlink" title="手势识别器的优先级"></a>手势识别器的优先级</h3><p>手势识别器（Gesture Recognizer）在 iOS 的事件处理机制中具有较高的优先级。具体来说，手势识别器会先接收到触摸事件，并尝试识别是否是自己关心的手势。如果手势识别器识别成功，那么它会处理该事件并阻止事件继续传递给响应者链。</p>
<h3 id="具体的事件传递顺序"><a href="#具体的事件传递顺序" class="headerlink" title="具体的事件传递顺序"></a>具体的事件传递顺序</h3><ol>
<li><strong>触摸事件产生</strong>：用户触摸屏幕，触摸事件被硬件捕获并传递给 iOS 系统。</li>
<li><strong>创建 UIEvent 对象</strong>：iOS 系统将触摸数据封装成一个 <code>UIEvent</code> 对象。</li>
<li><strong>事件传递给 UIWindow</strong>：系统将此 <code>UIEvent</code> 对象传递给应用的主 <code>UIWindow</code>。</li>
<li><strong>手势识别器检测</strong>：<code>UIWindow</code> 会先将触摸事件传递给视图层次结构中相关视图的手势识别器。如果有手势识别器检测到手势并识别成功，那么该手势识别器会处理该事件，并阻止事件继续传递。</li>
<li><strong>事件传递给响应者链</strong>：如果手势识别器没有处理该事件，那么事件将按照响应者链的机制传递。响应者链会从最合适的视图开始处理触摸事件，调用相关的 <code>touchesBegan:withEvent:</code>, <code>touchesMoved:withEvent:</code>, <code>touchesEnded:withEvent:</code> 方法。</li>
</ol>
<h2 id="10-SQLite3和Realm的区别？"><a href="#10-SQLite3和Realm的区别？" class="headerlink" title="10.SQLite3和Realm的区别？"></a>10.SQLite3和Realm的区别？</h2><h3 id="1-数据库类型"><a href="#1-数据库类型" class="headerlink" title="1. 数据库类型"></a>1. 数据库类型</h3><ul>
<li><strong>SQLite3</strong>: SQLite 是一个轻量级的关系型数据库管理系统，遵循 SQL 标准。它使用 SQL 语言进行数据操作，支持复杂的查询和事务处理。</li>
<li><strong>Realm</strong>: Realm 是一个面向对象的数据库，旨在简化数据存储和查询过程。它不使用 SQL，而是通过对象模型进行数据操作。</li>
</ul>
<h3 id="2-数据模型"><a href="#2-数据模型" class="headerlink" title="2. 数据模型"></a>2. 数据模型</h3><ul>
<li><strong>SQLite3</strong>: 使用关系型数据模型，数据存储在表中，表包含行和列。数据操作通过 SQL 查询语句完成。</li>
<li><strong>Realm</strong>: 使用面向对象的数据模型，数据存储在对象中。你可以直接通过对象属性进行查询和操作，这使得代码更加直观和简洁。</li>
</ul>
<h3 id="3-性能"><a href="#3-性能" class="headerlink" title="3. 性能"></a>3. 性能</h3><ul>
<li><strong>SQLite3</strong>: 通常在处理非常复杂的查询或需要高度自定义的查询时性能较好。SQLite3 的性能可能会受到 SQL 查询复杂性的影响。</li>
<li><strong>Realm</strong>: 由于其设计面向移动设备，通常在读写性能上表现优异，尤其是对于常见的、简单的查询操作。Realm 还提供了对多线程的支持，以提高并发性能。</li>
</ul>
<h3 id="4-数据迁移"><a href="#4-数据迁移" class="headerlink" title="4. 数据迁移"></a>4. 数据迁移</h3><ul>
<li><strong>SQLite3</strong>: 数据库迁移通常需要手动编写 SQL 脚本来修改表结构，这可能会比较繁琐。</li>
<li><strong>Realm</strong>: 提供了内置的数据迁移机制，可以通过代码来定义迁移步骤，这使得数据迁移过程更加方便和安全。</li>
</ul>
<h3 id="5-易用性"><a href="#5-易用性" class="headerlink" title="5. 易用性"></a>5. 易用性</h3><ul>
<li><strong>SQLite3</strong>: 由于使用 SQL 语言，开发者需要了解 SQL 语法和关系型数据库的基本概念。数据模型的改变通常需要手动修改表结构。</li>
<li><strong>Realm</strong>: 提供了面向对象的 API，使用起来更加直观。开发者不需要学习 SQL，只需操作对象模型即可。</li>
</ul>
<h3 id="6-数据同步"><a href="#6-数据同步" class="headerlink" title="6. 数据同步"></a>6. 数据同步</h3><ul>
<li><strong>SQLite3</strong>: 本身不提供数据同步功能。如果需要在不同设备间同步数据，通常需要额外的服务器支持。</li>
<li><strong>Realm</strong>: 提供了 Realm Cloud 服务，可以实现数据的实时同步和离线访问，适合需要多设备数据同步的应用。</li>
</ul>
<h3 id="7-文件大小和存储方式"><a href="#7-文件大小和存储方式" class="headerlink" title="7. 文件大小和存储方式"></a>7. 文件大小和存储方式</h3><ul>
<li><strong>SQLite3</strong>: 数据存储在单个文件中，文件大小会随着数据量的增加而增加。SQLite3 支持多种数据类型和存储格式。</li>
<li><strong>Realm</strong>: 数据也存储在单个文件中，但由于其高效的存储格式和压缩机制，通常文件大小较小。Realm 对于对象模型的存储进行了优化，减少了数据的冗余。</li>
</ul>
<h3 id="8-加密和安全性"><a href="#8-加密和安全性" class="headerlink" title="8. 加密和安全性"></a>8. 加密和安全性</h3><ul>
<li><strong>SQLite3</strong>: 支持加密，但需要使用第三方库（如 SQLCipher）来实现。</li>
<li><strong>Realm</strong>: 内置支持加密，可以方便地加密整个数据库文件，提高数据安全性。</li>
</ul>
<h3 id="9-多平台支持"><a href="#9-多平台支持" class="headerlink" title="9. 多平台支持"></a>9. 多平台支持</h3><ul>
<li><strong>SQLite3</strong>: 支持几乎所有的平台，包括 iOS、Android、Windows、Linux 等。因为其广泛的支持和成熟度，SQLite 是一个非常可靠的选择。</li>
<li><strong>Realm</strong>: 也支持多平台，包括 iOS、Android、React Native 等。Realm 提供的 API 在不同平台上保持一致性，便于跨平台开发。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>SQLite3</strong>: 适合需要复杂查询、事务处理和高度自定义的应用，尤其是那些开发者已经熟悉 SQL 语言的情况。</li>
<li><strong>Realm</strong>: 适合需要高性能、简单易用和面向对象的数据存储解决方案，特别是移动应用开发。</li>
</ul>
<h2 id="11-Category和Extension的区别"><a href="#11-Category和Extension的区别" class="headerlink" title="11.Category和Extension的区别"></a>11.Category和Extension的区别</h2><table>
<thead>
<tr>
<th>特性</th>
<th>Category</th>
<th>Extension</th>
</tr>
</thead>
<tbody>
<tr>
<td>定义和用途</td>
<td>为现有类添加方法</td>
<td>在实现文件中添加私有方法和属性</td>
</tr>
<tr>
<td>实例变量</td>
<td>不能添加</td>
<td>可以添加</td>
</tr>
<tr>
<td>访问控制</td>
<td>方法是公开的</td>
<td>方法和属性是私有的</td>
</tr>
<tr>
<td>编译时机</td>
<td>动态加载，在运行时添加</td>
<td>编译时添加，类定义的一部分</td>
</tr>
<tr>
<td>使用场景</td>
<td>将类的方法划分到多个文件，为系统类添加方法</td>
<td>在实现文件中定义私有方法和属性，提高封装性</td>
</tr>
</tbody>
</table>
<h2 id="12-Block的本质，结构体里有哪些东西？内存管理"><a href="#12-Block的本质，结构体里有哪些东西？内存管理" class="headerlink" title="12.Block的本质，结构体里有哪些东西？内存管理"></a>12.Block的本质，结构体里有哪些东西？内存管理</h2><h3 id="Block-的本质"><a href="#Block-的本质" class="headerlink" title="Block 的本质"></a>Block 的本质</h3><p>在底层，<code>Block</code> 是一个封装了函数指针、捕获变量及其他相关信息的结构体。可以通过 Clang 提供的编译器选项 <code>-rewrite-objc</code> 将 Objective-C 代码转换为纯 C++ 代码，来查看 <code>Block</code> 的具体实现。</p>
<p>例如，以下是一个简单的 <code>Block</code> 声明和使用：</p>
<figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">void</span> (^simpleBlock)(<span class="hljs-keyword">void</span>) = ^&#123;</span><br><span class="line">    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"This is a simple block"</span>);</span><br><span class="line">&#125;;</span><br><span class="line">simpleBlock();</span><br></pre></td></tr></table></figure>
<p>使用 <code>-rewrite-objc</code> 将其转换为 C++ 代码后，可以看到 <code>Block</code> 的底层实现。</p>
<h3 id="Block-的结构体"><a href="#Block-的结构体" class="headerlink" title="Block 的结构体"></a>Block 的结构体</h3><p>在底层，<code>Block</code> 是一个结构体，通常包含以下几个部分：</p>
<ol>
<li><strong>isa 指针</strong>：指向 <code>Block</code> 的类对象，用于实现 Objective-C 的动态特性。</li>
<li><strong>flags</strong>：标志位，指示 <code>Block</code> 的一些特性（如是否需要复制、是否包含捕获变量等）。</li>
<li><strong>reserved</strong>：保留字段，通常用于内存对齐。</li>
<li><strong>invoke 指针</strong>：指向实际执行 <code>Block</code> 代码的函数指针。</li>
<li><strong>descriptor 指针</strong>：指向 <code>Block</code> 的描述信息，包括 <code>Block</code> 的大小、拷贝和释放函数等。</li>
<li><strong>捕获变量</strong>：如果 <code>Block</code> 捕获了外部变量，这些变量会被存储在结构体中。</li>
</ol>
<p>具体的结构体定义可能如下所示：</p>
<figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">block_impl</span> &#123;</span></span><br><span class="line">    <span class="hljs-keyword">void</span> *isa;</span><br><span class="line">    <span class="hljs-keyword">int</span> flags;</span><br><span class="line">    <span class="hljs-keyword">int</span> reserved;</span><br><span class="line">    <span class="hljs-keyword">void</span> (*invoke)(<span class="hljs-keyword">void</span> *, ...);</span><br><span class="line">    <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">block_descriptor</span> *<span class="hljs-title">descriptor</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">block_descriptor</span> &#123;</span></span><br><span class="line">    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> reserved;</span><br><span class="line">    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> size;</span><br><span class="line">    <span class="hljs-keyword">void</span> (*copy)(<span class="hljs-keyword">void</span> *dst, <span class="hljs-keyword">void</span> *src);</span><br><span class="line">    <span class="hljs-keyword">void</span> (*dispose)(<span class="hljs-keyword">void</span> *src);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Block-的内存管理"><a href="#Block-的内存管理" class="headerlink" title="Block 的内存管理"></a>Block 的内存管理</h3><p><code>Block</code> 的内存管理涉及到以下几个方面：</p>
<ol>
<li><strong>栈上的 Block</strong>：默认情况下，<code>Block</code> 是在栈上分配的。这意味着它的生命周期是有限的，当超出其作用域时，<code>Block</code> 会被销毁。如果试图在作用域外使用该 <code>Block</code>，会导致崩溃。</li>
<li><strong>堆上的 Block</strong>：为了让 <code>Block</code> 在作用域外仍然有效，可以将其复制到堆上。可以使用 <code>Block_copy</code> 函数或 <code>^</code> 运算符来实现这一点。在 ARC 环境下，直接赋值给 <code>__strong</code> 类型的变量时，<code>Block</code> 会自动复制到堆上。</li>
<li><strong>捕获变量的内存管理</strong>：<code>Block</code> 可以捕获其作用域中的变量，包括自动变量（局部变量）和静态变量。捕获变量的内存管理取决于变量的类型：<ul>
<li>对于自动变量，<code>Block</code> 会将其值拷贝到 <code>Block</code> 的结构体中。</li>
<li>对于对象类型的变量，<code>Block</code> 会对其进行 <code>retain</code> 操作（在 ARC 下），以确保 <code>Block</code> 的生命周期内变量仍然有效。</li>
</ul>
</li>
</ol>
<h2 id="13-为什么要在主线程刷新UI"><a href="#13-为什么要在主线程刷新UI" class="headerlink" title="13.为什么要在主线程刷新UI"></a>13.为什么要在主线程刷新UI</h2><p>在 iOS 和 macOS 开发中，所有的 UI 更新必须在主线程（也称为主队列）上执行。以下是为什么需要在主线程刷新 UI 的几个原因：</p>
<h3 id="1-UIKit-和-AppKit-的线程安全性"><a href="#1-UIKit-和-AppKit-的线程安全性" class="headerlink" title="1. UIKit 和 AppKit 的线程安全性"></a>1. UIKit 和 AppKit 的线程安全性</h3><ul>
<li>单线程设计：<ul>
<li>UIKit（iOS 的 UI 框架）和 AppKit（macOS 的 UI 框架）是设计为非线程安全的。它们的大多数 API 都假定是在主线程上调用的。</li>
<li>这是因为 UI 操作通常涉及到大量复杂的内部状态管理和绘图操作，确保所有这些操作在一个单一线程上可以避免并发问题。</li>
</ul>
</li>
</ul>
<h3 id="2-数据一致性和线程同步"><a href="#2-数据一致性和线程同步" class="headerlink" title="2. 数据一致性和线程同步"></a>2. 数据一致性和线程同步</h3><ul>
<li>数据一致性：<ul>
<li>如果多个线程同时操作 UI 组件，可能会导致不一致的 UI 状态。例如，一个线程正在修改视图的属性，而另一个线程正在试图渲染视图，这可能会导致崩溃或未定义行为。</li>
</ul>
</li>
<li>线程同步：<ul>
<li>多线程操作 UI 需要额外的同步机制来防止并发访问冲突。使用主线程可以简化这种同步需求，使代码更容易维护和理解。</li>
</ul>
</li>
</ul>
<h3 id="3-事件处理模型"><a href="#3-事件处理模型" class="headerlink" title="3. 事件处理模型"></a>3. 事件处理模型</h3><ul>
<li>事件循环：<ul>
<li>iOS 和 macOS 应用程序的主线程运行一个事件循环，处理用户交互、定时器、网络响应等各种事件。UI 更新也是事件循环的一部分。</li>
<li>通过将所有 UI 操作放在主线程上，确保了事件处理的顺序性和一致性。</li>
</ul>
</li>
</ul>
<h3 id="4-用户体验"><a href="#4-用户体验" class="headerlink" title="4. 用户体验"></a>4. 用户体验</h3><ul>
<li>平滑的 UI 动画和响应：<ul>
<li>在主线程上更新 UI 可以确保动画的平滑性和用户交互的及时响应。如果在后台线程更新 UI，可能会导致动画卡顿或延迟响应，影响用户体验。</li>
</ul>
</li>
<li>避免死锁：<ul>
<li>主线程上的操作是顺序执行的，这降低了发生死锁的风险。如果尝试在后台线程进行复杂的 UI 操作，可能会导致线程间的资源争用和死锁。</li>
</ul>
</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>在主线程刷新 UI 是为了确保 UIKit 和 AppKit 的线程安全性、保持数据一致性和简化线程同步、遵循事件处理模型以及提供更好的用户体验。通过理解和遵循这些原则，可以避免许多潜在的并发问题和性能瓶颈，从而构建更稳定和高效的应用程序。</p>
<h2 id="14-Swift中Result类型"><a href="#14-Swift中Result类型" class="headerlink" title="14.Swift中Result类型"></a>14.Swift中Result类型</h2><p>在 Swift 中，<code>Result</code> 类型是一种用于表示操作结果的枚举，能够明确地表达成功和失败的情况。它的引入使得错误处理更加简洁和明确，特别是在异步操作和函数返回值中。</p>
<h3 id="Result-类型的定义"><a href="#Result-类型的定义" class="headerlink" title="Result 类型的定义"></a><code>Result</code> 类型的定义</h3><p><code>Result</code> 类型是一个泛型枚举，有两个可能的值：</p>
<ul>
<li><code>.success(Value)</code>：表示操作成功，并包含成功时的返回值。</li>
<li><code>.failure(Error)</code>：表示操作失败，并包含失败时的错误。</li>
</ul>
<p>以下是 <code>Result</code> 类型的定义：</p>
<figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Result</span>&lt;<span class="hljs-title">Success</span>, <span class="hljs-title">Failure</span>: <span class="hljs-title">Error</span>&gt; </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">case</span> success(<span class="hljs-type">Success</span>)</span><br><span class="line">    <span class="hljs-keyword">case</span> failure(<span class="hljs-type">Failure</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用-Result-类型"><a href="#使用-Result-类型" class="headerlink" title="使用 Result 类型"></a>使用 <code>Result</code> 类型</h3><h4 id="定义一个返回-Result-类型的函数"><a href="#定义一个返回-Result-类型的函数" class="headerlink" title="定义一个返回 Result 类型的函数"></a>定义一个返回 <code>Result</code> 类型的函数</h4><p>假设我们有一个函数，用于从服务器获取数据，该函数可以成功返回数据，也可能因为网络错误而失败：</p>
<figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">NetworkError</span>: <span class="hljs-title">Error</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">case</span> badURL</span><br><span class="line">    <span class="hljs-keyword">case</span> requestFailed</span><br><span class="line">    <span class="hljs-keyword">case</span> unknown</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fetchData</span><span class="hljs-params">(from urlString: String, completion: <span class="hljs-params">(Result&lt;Data, NetworkError&gt;)</span></span></span> -&gt; <span class="hljs-type">Void</span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> url = <span class="hljs-type">URL</span>(string: urlString) <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        completion(.failure(.badURL))</span><br><span class="line">        <span class="hljs-keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-type">URLSession</span>.shared.dataTask(with: url) &#123; data, response, error <span class="hljs-keyword">in</span></span><br><span class="line">        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-number">_</span> = error &#123;</span><br><span class="line">            completion(.failure(.requestFailed))</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> data = data &#123;</span><br><span class="line">            completion(.success(data))</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            completion(.failure(.unknown))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.resume()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="调用并处理-Result"><a href="#调用并处理-Result" class="headerlink" title="调用并处理 Result"></a>调用并处理 <code>Result</code></h4><p>调用 <code>fetchData</code> 函数，并处理返回的 <code>Result</code>：</p>
<figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fetchData(from: <span class="hljs-string">"https://example.com"</span>) &#123; result <span class="hljs-keyword">in</span></span><br><span class="line">    <span class="hljs-keyword">switch</span> result &#123;</span><br><span class="line">    <span class="hljs-keyword">case</span> .success(<span class="hljs-keyword">let</span> data):</span><br><span class="line">        <span class="hljs-comment">// 处理成功情况</span></span><br><span class="line">        <span class="hljs-built_in">print</span>(<span class="hljs-string">"Data received: \(data)"</span>)</span><br><span class="line">    <span class="hljs-keyword">case</span> .failure(<span class="hljs-keyword">let</span> error):</span><br><span class="line">        <span class="hljs-comment">// 处理失败情况</span></span><br><span class="line">        <span class="hljs-keyword">switch</span> error &#123;</span><br><span class="line">        <span class="hljs-keyword">case</span> .badURL:</span><br><span class="line">            <span class="hljs-built_in">print</span>(<span class="hljs-string">"Bad URL"</span>)</span><br><span class="line">        <span class="hljs-keyword">case</span> .requestFailed:</span><br><span class="line">            <span class="hljs-built_in">print</span>(<span class="hljs-string">"Request failed"</span>)</span><br><span class="line">        <span class="hljs-keyword">case</span> .unknown:</span><br><span class="line">            <span class="hljs-built_in">print</span>(<span class="hljs-string">"Unknown error"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Result-类型的便利方法"><a href="#Result-类型的便利方法" class="headerlink" title="Result 类型的便利方法"></a><code>Result</code> 类型的便利方法</h3><p>Swift 提供了一些便利方法来处理 <code>Result</code> 类型，包括 <code>map</code>、<code>flatMap</code>、<code>mapError</code> 和 <code>flatMapError</code>。</p>
<h4 id="map-方法"><a href="#map-方法" class="headerlink" title="map 方法"></a><code>map</code> 方法</h4><p><code>map</code> 方法可以将 <code>Result</code> 中的成功值转换为另一种类型：</p>
<figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">Int</span>, <span class="hljs-type">NetworkError</span>&gt; = .success(<span class="hljs-number">42</span>)</span><br><span class="line"><span class="hljs-keyword">let</span> stringResult = result.<span class="hljs-built_in">map</span> &#123; value <span class="hljs-keyword">in</span></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">"The answer is \(value)"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// stringResult 是 Result&lt;String, NetworkError&gt;.success("The answer is 42")</span></span><br></pre></td></tr></table></figure>
<h4 id="flatMap-方法"><a href="#flatMap-方法" class="headerlink" title="flatMap 方法"></a><code>flatMap</code> 方法</h4><p><code>flatMap</code> 方法用于将 <code>Result</code> 中的成功值转换为另一个 <code>Result</code>：</p>
<figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">Int</span>, <span class="hljs-type">NetworkError</span>&gt; = .success(<span class="hljs-number">42</span>)</span><br><span class="line"><span class="hljs-keyword">let</span> newResult = result.flatMap &#123; value <span class="hljs-keyword">in</span></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">String</span>, <span class="hljs-type">NetworkError</span>&gt;.success(<span class="hljs-string">"The answer is \(value)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// newResult 是 Result&lt;String, NetworkError&gt;.success("The answer is 42")</span></span><br></pre></td></tr></table></figure>
<h4 id="mapError-方法"><a href="#mapError-方法" class="headerlink" title="mapError 方法"></a><code>mapError</code> 方法</h4><p><code>mapError</code> 方法用于将 <code>Result</code> 中的错误值转换为另一种错误类型：</p>
<figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">Int</span>, <span class="hljs-type">NetworkError</span>&gt; = .failure(.badURL)</span><br><span class="line"><span class="hljs-keyword">let</span> newResult = result.mapError &#123; error <span class="hljs-keyword">in</span></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-type">MyCustomError</span>.networkError(error)</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// newResult 是 Result&lt;Int, MyCustomError&gt;.failure(.networkError(.badURL))</span></span><br></pre></td></tr></table></figure>
<h4 id="flatMapError-方法"><a href="#flatMapError-方法" class="headerlink" title="flatMapError 方法"></a><code>flatMapError</code> 方法</h4><p><code>flatMapError</code> 方法用于将 <code>Result</code> 中的错误值转换为另一个 <code>Result</code>：</p>
<figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> result: <span class="hljs-type">Result</span>&lt;<span class="hljs-type">Int</span>, <span class="hljs-type">NetworkError</span>&gt; = .failure(.badURL)</span><br><span class="line"><span class="hljs-keyword">let</span> newResult = result.flatMapError &#123; error <span class="hljs-keyword">in</span></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">Int</span>, <span class="hljs-type">MyCustomError</span>&gt;.failure(.networkError(error))</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// newResult 是 Result&lt;Int, MyCustomError&gt;.failure(.networkError(.badURL))</span></span><br></pre></td></tr></table></figure>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p><code>Result</code> 类型在 Swift 中提供了一种优雅的方式来处理可能成功或失败的操作。通过明确地表达成功和失败的情况，<code>Result</code> 类型使得代码更加易读和可维护。借助 <code>map</code>、<code>flatMap</code>、<code>mapError</code> 和 <code>flatMapError</code> 等便利方法，可以更方便地处理 <code>Result</code> 类型的值。使用 <code>Result</code> 类型可以更好地管理错误处理，特别是在异步操作中。</p>
<h2 id="15-二叉树的翻转"><a href="#15-二叉树的翻转" class="headerlink" title="15.二叉树的翻转"></a>15.二叉树的翻转</h2><p><a href="https://leetcode.cn/problems/invert-binary-tree/" target="_blank" rel="noopener">226. 翻转二叉树</a></p>
<p>递归：</p>
<figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> invertTree = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">const</span> left = invertTree(root.left);</span><br><span class="line">    <span class="hljs-keyword">const</span> right = invertTree(root.right);</span><br><span class="line">    root.left = right;</span><br><span class="line">    root.right = left;</span><br><span class="line">    <span class="hljs-keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>迭代：</p>
<figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> invertTree = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">let</span> stack = [];</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="hljs-keyword">while</span> (stack.length) &#123;</span><br><span class="line">        <span class="hljs-keyword">let</span> node = stack.pop();</span><br><span class="line">        <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) &#123;</span><br><span class="line">            stack.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) &#123;</span><br><span class="line">            stack.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">let</span> temp = node.left;</span><br><span class="line">        node.left = node.right;</span><br><span class="line">        node.right = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

        </div>
        
        <div class="level is-size-7 is-uppercase">
            <div class="level-start">
                <div class="level-item">
                    <span class="is-size-6 has-text-grey has-mr-7">#</span>
                    <a class="has-link-grey -link" href="/tags/瓴岳科技/">瓴岳科技</a>, <a class="has-link-grey -link" href="/tags/面试/">面试</a>
                </div>
            </div>
        </div>
        
        
        
    </div>
</div>





<div class="card card-transparent">
    <div class="level post-navigation is-flex-wrap is-mobile">
        
        <div class="level-start">
            <a class="level level-item has-link-grey  article-nav-prev" href="/度小满/">
                <i class="level-item fas fa-chevron-left"></i>
                <span class="level-item">度小满</span>
            </a>
        </div>
        
        
        <div class="level-end">
            <a class="level level-item has-link-grey  article-nav-next" href="/去哪儿网/">
                <span class="level-item">去哪儿网</span>
                <i class="level-item fas fa-chevron-right"></i>
            </a>
        </div>
        
    </div>
</div>


</div>
                
                
            </div>
        </div>
    </section>
    <footer class="footer">
    <div class="container">
        <div class="level">
            <div class="level-start has-text-centered-mobile">
                <a class="footer-logo is-block has-mb-6" href="/">
                
                    <img src="/images/logo-2.png" alt="瓴岳科技" height="28">
                
                </a>
                <p class="is-size-7">
                &copy; 2025 SOSOWIKI&nbsp;
                All rights reserved.
                
                </p>
            </div>
            <div class="level-end">
            
            </div>
        </div>
    </div>
</footer>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script>
<script>moment.locale("zh-CN");</script>

<script>
var IcarusThemeSettings = {
    article: {
        highlight: {
            clipboard: true,
            fold: 'unfolded'
        }
    }
};
</script>


    <script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script>



    
    
    
    <script src="/js/animation.js"></script>
    

    
    
    
    <script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script>
    <script src="/js/gallery.js" defer></script>
    

    
    

<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update
            my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        });
    });
</script>


    
    
<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    MathJax.Hub.Config({
        'HTML-CSS': {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
});
</script>

    
    

<a id="back-to-top" title="回到顶端" href="javascript:;">
    <i class="fas fa-chevron-up"></i>
</a>
<script src="/js/back-to-top.js" defer></script>


    
    

    
    
    
    

    
    
    
    
    


<script src="/js/main.js" defer></script>

    
    <div class="searchbox ins-search">
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="搜索公司、题目、关键字" />
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: '文章',
                PAGES: '页面',
                CATEGORIES: '分类',
                TAGS: '标签',
                UNTITLED: '关于',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js" defer></script>
<link rel="stylesheet" href="/css/search.css">
<link rel="stylesheet" href="/css/insight.css">
    
</body>
</html>