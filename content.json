{"pages":[{"title":"","text":"","link":"/about/index.html"},{"title":"分类","text":"","link":"/categories/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}],"posts":[{"title":"iOS 面试技术点","text":"iOS 面试技术点 问题 期望 NSDicationary 的本质 理解哈希表，知道其遍历不是顺序的 ARC下内存泄漏的原因，循环引用时如何发生以及如何避免 理解ARC的机制从而知道内存泄漏的产生，并知道循环引用是如何产生和避免 常见的导致程序崩溃的原因 知道崩溃的原因本质是僵尸内存或指向错误，能够在实际开发中避免 使用多线程的几种方式 知道NSThread、NSOperationQueue和GCD三种多线程实现方式并能简单介绍应用实例，尤其要熟悉GCD的使用 如何实现一个单例 能够大体说出单例的实现原理，实现方法多多益善，能讲出各个实现方法的优缺点最好 NSArray和NSSet的区别以及使用时机 能够理解顺序表和集合的概念 NSInteger和int的区别 能知道NSInteger的位长大于等于int，考察对基础数据类型的理解 NSDictionary的快速构建方法以及注意事项 能够知道NSDictionary的快速构建方法，尤其要知道不可传nil的指针 介绍一下Autolayout和Autoresizing 考察对两种布局方法的理解，能够答题说出它们的原理 对象及ViewController的生命周期 对ViewController的生命周期有所了解 线程锁的几种使用方式 至少知道NSLock和synchronized，能够了解semaphore、递归锁、条件锁和分布锁可加分 block的使用以及注意事项 实际使用过block以及知道如何避免循环引用 strong、weak、retain、unsafe_unretain、assign、copy的区别以及使用场景 能够说出各个修饰符的作用 数据持久化的几种方式、应用场景和优缺点 至少知道NSUserDefault和Plist、文件三种保存方式，知道sqlite或CoreData可加分 如何进行一个http协议的网络请求 能够知道NSURLConnection或NSURLSession的使用方式 简介应用的生命周期 能够知道应用的生命周期，每个周期的回调是在什么时机 NSNotification的使用及注意事项 能够理解NSNotification的广播机制、传参以及避免key覆盖 NSUserDefault使用时应该注意什么 能够知道NSUserDefault本质是保存到plist文件，以及对象要实现NSCoder协议 OC Runtime介绍 对Objective-C的底层能够有自己的正确理解 OC Runloop介绍 对Objective-C的底层能够有自己的正确理解 Category的本质 对Objective-C的底层能够有自己的正确理解 函数式编程和ReactiveCocoa 对Objective-C的底层能够有自己的正确理解 block的实现原理 对Objective-C的底层能够有自己的正确理解 对Cocoa中UITableView、UILabel等组件的实现原理有自己的理解 能够通过组件的表象看到本质，考察编程经验和推导能力 介绍UIView的组成 能够对UIView有深入理解 介绍CoreGraphics、CoreAnimation、CoreText的技术架构及简单使用 能够熟悉和理解iOS开发中常用的Core系列库，能熟练使用它们 介绍Xcode的Build Settings和Build Phases中常用的设置 能够基本知道iOS项目的编译过程 一个iOS项目的大体编译、链接以及运行过程 能够基本知道iOS项目的编译过程 介绍Cocoapods（或其它包管理工具）的实现思路 能够基本知道iOS项目的编译过程 如何使用Xcode进行调试和排错 知道如何调试和排错 介绍Instruments中常用的功能 能够使用工具进行性能分析和监控 MVVM模式介绍及其优缺点","link":"/iOS面试技术点/"},{"title":"ofo面试题","text":"ofo面试题 1、block 的底层实现? 2、block 的类型有哪几种? 3、你碰到的 block 的循环引用? 4、为什么你在用 Masonry , AFNetworking 的 block 回调不需要对 self 进行 __weak? 5、出现野指针的情况大概有哪些？ 6、Swift 里的闭包和 OC 的 block 的区别。 7、Sqlite 使用的时候需要注意什么。","link":"/ofo面试题/"},{"title":"一点资讯面试题","text":"一点资讯面试题 一面1.Flutter 与原生怎么交互 2.Flutter 跳转原生页面，原生跳转 Flutter 页面怎么实现？ 3.Widget、StatefulWidget、StatelessWidget 区别 4.Flutter 的三棵树（Widget 树等） 5.setState 实现源码看过吗？内部实现原理 6.KVO 实现原理 7.Runtime 流程，怎么避免方法找不到的闪退 8.数组插入空安全怎么实现的？交换方法写在哪里？为什么不写在 initialize 里？ 9.两个分类里同名方法执行哪个？ 10.isa 指针的指向，isa 的结构 11.__block 的原理，全局变量需要捕获吗？ 12.闪退率，Flutter 的闪退怎么监控？ 13.做过哪些优化？FPS 优化，启动优化，安装包大小优化 14.做过哪些组件？ 15.字符串反转 二面1.autoreleasepool 什么时候释放 2.deviceId 怎么确保唯一性 3.微信 Mac 端登录为什么要做成扫描二维码的方式？怎么实现的？ 4.个人优缺点，未来规划，看机会原因 5.怎么学习一门新技术 三面1.介绍项目，项目 DAU 2.心跳包是自己实现的吗？心跳包停掉有没有遇到过？ 3.有没有 offer，觉得一点的优势跟不足，其他一些私人问题","link":"/一点资讯面试题/"},{"title":"乐为金融面试题","text":"乐为金融面试题 1、说一下系统框架和生命周期。 2、系统存储空间有哪些？全局变量区、栈、堆、代码区 3、栈区是用来放什么的？ 4、栈是什么结构？链表是什么结构？ 5、进程和线程有啥关系？进程是不是一个App？ 6、说一下 MVC、MVVM 7、你了解的设计模式？ 8、你做过的内存优化有哪些？ 9、说一下 AFN/SDWebImage 10、做直播、聊天，了解长连接是什么实现的吗？ 11、面向对象的三个特性？封装是什么？多态是什么？ 12、你用 OC 开发还是 Swift 开发？Swift 有什么优势？","link":"/乐为金融面试题/"},{"title":"京东面试题","text":"京东面试题 1、AFNetworking 是如何实现多线程的。 2、如何自己控制 AFNetWorking 的多线程，如果解决上传多张图片引起的内存剧增的问题。 3、模块化的实现过程。 4、自动化测试。 5、数据库的升级（当前数据库不能满足业务了，1.0-&gt;2.0-&gt;3.0…..）。","link":"/京东面试题/"},{"title":"人人车面试题","text":"人人车面试题 一面1.了解哪些设计模式 2.MVVM 解决什么问题 3.性能优化 4.内存管理的理解 autoreleasePool 的结构，一个 autoreleasePoolPage 的大小 5.weak 的原理 6.class 的结构，cache 的结构，bucket_t 的结构，方法查找的顺序，是逐个遍历吗？ 7.关联对象存在哪里 8.Category 的加载流程 9.Runtime 的应用，动态方法解析里返回 YES，但是并没有添加方法，会怎么样？ 10.三次握手与四次挥手，四次挥手后会立马断开连接吗 11.Swift 解包方式 12.Swift 中计算属性和存储属性的区别 13.Swift 类和结构体的区别，使用属性的写法上的区别 14.数组和链表的区别 15.快速排序，快排时间复杂度 二面介绍项目 1.webView 与 H5 交互，拦截协议 url 有长度限制，有安全问题，可能会被抓包，JSBridge 2.埋点 埋点保存/删除数据的时机 内存里的最大容量，收到内存警告 上报网络请求发送失败后的处理，埋点的补偿机制 3.支付 4.页面 A push B A willDisappear didDisappear B willAppear didAppear 的执行顺序 5.Person 类继承自 NSObject 类，没有实现 age 方法。两个实例 p1,p2，怎么让 p1 响应 age 方法，p2 不响应 age 方法。 6.消息发送机制和消息转发。 7.KVO 的实现原理 8.多个分类实现了同一个方法，查找顺序 9.Swift 的 String 为什么设计成值类型？ 安全，copy，快速 10.设计 LRU 最近最少使用","link":"/人人车面试题/"},{"title":"全民短视频面试题","text":"全民短视频面试题 1、@property 属性关键字 2、GCD 3、Runtime 底层 4、Runloop 底层实现、线程跟 Runloop 的关系 5、AFNetworking 内部结构和实现原理。 6、怎么避免崩溃，像数组字典崩溃等 7、友盟分析闪退的具体步骤，怎么定位到闪退的代码位置 8、安全攻防 9、https 证书配置 10、自动化测试 11、有没有做过单元测试","link":"/全民短视频面试题/"},{"title":"十点读书面试题","text":"十点读书面试题 1、MRC 和 ARC，自动释放池 AutoreleasePool 和 ARC 的关系？ 2、直播是用的 rmtp 协议吗？rmtp 说一下？ 3、聊天用的什么？web Socket 了解吗？HTTP 属于哪一层？web socket 属于哪一层？ 4、copy 和 MutableCopy ？从可变不可变和深浅拷贝两个层面说一下区别？ 5、NSString 用 copy 和用 Strong 有什么区别？ 6、内存优化？ 7、weak 和 unown 的区别？ 8、协议继承什么？继承 NSObjectProtocol 和继承自某个 class 有什么区别？ 9、Swift 是运行时语言吗？Swift 怎么用 OC 的运行时特性？","link":"/十点读书面试题/"},{"title":"墨迹天气面试题","text":"墨迹天气面试题 一面1.Swift 与 OC 方法调用的区别 2.方法查找的过程，Runtime 消息机制，怎么避免无法识别的方法选择器的闪退？ 3.Runtime 的应用 4.Category 和本类的同名方法执行哪个 5.线上卡顿怎么监测，监测原理 Runloop 6.做过哪些优化 7.多线程用的多吗？线程同步有哪些方案？锁的效率从高到低说一下 8.打印结果 1234567891011121314151617181920- (void)viewDidLoad { [super viewDidLoad]; dispatch_sync(dispatch_get_main_queue(), ^{ NSLog(@\"0\"); }); dispatch_async(dispatch_get_main_queue(), ^{ NSLog(@\"1\"); }); dispatch_async(dispatch_get_global_queue(0, 0), ^{ NSLog(@\"2\"); }); dispatch_sync(dispatch_get_global_queue(0, 0), ^{ NSLog(@\"3\"); }); NSLog(@\"4\");} 9.Flutter 遇到过什么问题，图片列表滑动把不在屏幕上显示的内容干掉(复用)会有什么问题吗，优化方案 10.个人规划 二面1.Flutter 的状态管理 2.Flutter 布局，Expanded 和 Flex 布局的区别 3.InheritedWidget 用过吗？stream 用过吗？ 4.Flutter 动画 5.webView 与 H5 交互，为什么没有考虑注册的方式，加载一个 H5 页面经历了哪些步骤？ 6.HTTPS 增加了哪些流程？DNS 的过程 7.长链接，了解 webSocket 吗 8.直播推流的过程 9.内存管理，类的属性 p.name = @”zhangsan”; 和方法里的变量 NSString *name = @”zhangsan”; 分别存在哪里？ 10.交换方法 11.Category 的本质 12.多线程，线程同步都有哪些方法，值为1的信号量和互斥锁有什么区别 13.算法：一个 int 数组，查找第 K 个大的数。 二面1.介绍项目亮点 2.数据和链表区别 3.方法查找过程 4.frame bounds 区别，UIView、CALayer，动画 5.block __block 6.内存优化 查找内存泄露 7.锁 自旋锁使用场景 互斥锁和信号量区别 8.方法交换是怎么交换的，注意点 9.链表是否有环 10.flutter 的状态管理 11.命令式编程与响应式编程","link":"/墨迹天气面试题/"},{"title":"太一云面试题","text":"太一云面试题 1、@property 属性的修饰符？String 为什么用 copy ？String 能不能用 strong ？NSMutableString 能不能用 Strong？ 2、单例的本质？项目里怎么用的单例？ 3、说一下 KVO，说一下通知，通知属不属于观察者模式？ 4、说一下 GCD 的同步、异步。GCD 你是怎么用的？ 5、说一下内存管理。MRC 了解吗？ARC 下系统是怎么自动加 retain、release 的？ 6、了解 AutoreleasePool 吗？如果不写 autorelease，对象会被添加到 Pool 里吗？ 7、了解 Socket 吗？","link":"/太一云面试题/"},{"title":"好未来面试题","text":"好未来面试题 一面1、说一下optional。（？ ！ ？？ 几种解包方式 if let、guard、？？等） 2、说一下闭包。 3、比较代理、通知、KVO？这三个谁的效率最高，谁的效率最低？( KVO 效率最低，因为 Runtime ） 4、NSString 和 String 的区别？（ String 是值类型，NSString 是引用类型） 5、Swift 跟 OC 的区别？（ OC 是动态的语言，Swift 是静态的语言）OC 是面向对象的，Swift 呢？（面向对象、面向协议、响应式编程）解释一下面向协议编程？ 6、说一下 MRC ？自动释放池？自动释放池什么时候释放？（我说 drain ） 7、说一下多线程？（我提到了 dispatch_once 单例） 8、分别用 OC 和 Swift 手写一下单例。（ Swift 的单例我忘记写 static 了，但是经提醒立马说出来了） 9、SnaptKit 内部看过吗？ 10、链式语法的实现。 UIView.top.equalTo().offSet(10) UIView.left.equalTo().offSet(10) 为什么能写成UIView.top.left.offSet(10) 二面主要是手写算法题： 1、用两个栈实现队列。 2、从扑克牌中抽出5张，写一个方法判断是不是顺子。（如34567）大小王是万能的，可以替代任意数字。 三面项目经理 四面HR","link":"/好未来面试题/"},{"title":"好未来面试题及答案","text":"好未来面试题 1. 一面1、说一下optional。?! ?? 是什么意思？有几种解包方式？解包方式：if let、guard、!强制解包、?? 等。 ?! ?? let a = b ?? c 如果b不为nil，则a = b;否则a = c; 2、说一下闭包。闭包是能够读取其他函数内部变量的函数，可以理解成定义在一个函数内部的函数。 可以用typealias起别名 1234typealias testBlock = (String) -&gt; Voidlet aaa: testBlock = {str in print(str)} 值捕获 闭包可以捕获上下文中的常量和变量 逃逸闭包 当一个闭包作为参数传入函数中，这个闭包需要等函数执行结束返回后执行，这种情况就称作这个闭包在函数中逃逸。在涉及异步操作时经常用到，特别是网络请求后要进行请求成功后的回调时，闭包就要逃逸掉，这时就要在闭包形参前加上@escaping关键字。 3、比较代理、通知、KVO？这三个谁的效率最高，谁的效率最低？KVO 效率最低，因为使用到了 Runtime。 代理效率最高，因为是一对一。 4、NSString 和 String 的区别？String 是值类型，NSString 是引用类型。 5、Swift 跟 OC 的区别？OC 是面向对象的，Swift 呢？（面向对象、面向协议、响应式编程）解释一下面向协议编程？OC 是动态的语言，Swift 是静态的语言。 6、说一下 MRC ？自动释放池？自动释放池什么时候释放？iOS 在主线程的Runloop中注册了2个Observer 第1个Observer监听了kCFRunLoopEntry事件，会调用objc_autoreleasePoolPush() 第2个Observer 监听了kCFRunLoopBeforeWaiting事件，会调用objc_autoreleasePoolPop()、objc_autoreleasePoolPush() 监听了kCFRunLoopBeforeExit事件，会调用objc_autoreleasePoolPop() 7、说一下多线程？NSThread NSOperation GCD 8、分别用 OC 和 Swift 手写一下单例。单例模式在创建过程中，要保证实例变量只被创建一次。在整个开发中需要特别注意线程安全，即使在多线程情况下，依然只初始化一次变量。 12345678+ (instanceType)sharedManager { static Manager *sharedManager = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ sharedManager = [[Manager alloc] init]; }); return sharedManager;} 在 Swift 中，let 关键字已经保证了实例变量不会被修改，所以单例的创建就简单很多：1234class Manager { static let shared = Manager(); private init() {}} 9、SnaptKit 内部看过吗？10、链式语法的实现。UIView.top.equalTo().offSet(10) UIView.left.equalTo().offSet(10) 为什么能写成UIView.top.left.offSet(10) ？ block 返回 self 自身，例如： 123456789// 当前类是ViewController类 block 返回类对象 类对象就可以继续调用 test 方法了- (ViewController *(^)(int))test{ ViewController *(^block)(int i) = ^ViewController *(int i){ NSLog(@\"%d\",i); return self; }; return block;} 调用的时候就可以这样写： 1self.test(1).test(2).test(3); 链条的执行顺序 self 调用 test 方法 test 方法返回 block block 得到小括号中的参数 并执行 block 中的代码 block 返回对象 对象接着调用 test 方法 实际应用中 test 可以是任何这种格式的方法 OC中链式语法的使用及原理 2. 二面主要是手写算法题： 1、用两个栈实现队列。123456789101112131415var inStack = [];var outStack = [];function push(node){ inStack.push(node);}function pop(){ if (outStack.length == 0) { while(inStack.length != 0) { outStack.push(inStack.pop()); } } return outStack.pop();} 2、从扑克牌中抽出5张，写一个方法判断是不是顺子。（如34567）大小王是万能的，可以替代任意数字。剑指 Offer 61. 扑克牌中的顺子 1234567891011121314var isStraight = function(nums) { let repeat = new Set(); let max = 0, min = 14; for (let i = 0; i &lt; nums.length; i++) { if (nums[i] == 0) continue; // 跳过大小王 max = Math.max(max, nums[i]); // 最大牌 min = Math.min(min, nums[i]); // 最小牌 if (repeat.has(nums[i])) { return false; } repeat.add(nums[i]); } return max - min &lt; 5; // 最大牌 - 最小牌 &lt; 5 则可构成顺子}; 3. 三面项目经理聊项目 4. 四面HR问了很多问题，包括个人优缺点，闲暇时间会做什么，在前公司3年的成长等等。","link":"/好未来面试题及答案/"},{"title":"平安面试题","text":"平安面试题 1.什么是多态？具体在项目中怎么用的？ 2.说一下组件化开发（业务组件非UI组件）； 3.调用未实现的方法会发生什么，然后通过什么可以进行处理？消息转发的具体流程？消息转发流程在实际中的应用？ 4.KVO 的原理？ 5.分类的底层实现？ 6.App 启动优化？热启动&amp;冷启动，具体优化？ 7.Vue 的双向绑定？ 8.说一下你对 Runloop 的理解，Runloop 的应用？ 9.项目中具体是怎么用的多线程？ 10.bug 管理工具？bug 率，日活？ 11.项目中你的职责所在？ 12.是否读过 SDWebImage，AFNetworking 底层？","link":"/平安面试题/"},{"title":"开果科技面试题","text":"开果科技面试题 一面1、卡顿原因、解决办法。为什么透明视图不如不透明视图？ 2、闪退原因、监测、过程。友盟是怎么捕获闪退的？从一个事件到闪退发生了什么？ 3、图片的压缩，从600k到500k，不能设置固定压缩比，应该怎么做？压缩图片，压缩图片实际压缩的是哪些东西？加载超大图；图片在计算机中的存储形式；10M的图片加载到内存中是多大？大图是怎么加载的？ 图像文件存储的都是每一个像素对应的颜色值。 4、字典的本质？哈希表原理？ 哈希表。 5、链表和数组，哪个容易找到地址？ 数组。 在内存中，数组是一块连续的区域。插入和删除数据效率低。随机读取效率很高，因为数组是连续的，知道每一个数据的内存地址，可以直接找到给地址的数据。 链表增加和删除数据很容易。查找数据时效率低，因为不具有随机访问性。 6、列表有好多页，某一页和后边加载的一页中有相同的数据，怎么处理？ 7、动态库和静态库的区别。 8、设计模式。 二面(电话面试)1、什么时候开始接触 iOS？怎么学的iOS？ 2、公司多少人？什么项目？ 3、你会选择什么样的公司？ 4、数据库（SQLite/Realm）是怎么保证线程安全的？ 5、UserDeafaults 系统做了哪些优化？为什么可以在主线程上去做存取？如果让你实现，方法已经是同步的方法了，你会怎么处理？ 6、+load 和 +initialize 方法什么时候会调用，+load 和 +initialize 方法、main 方法这三个的调用顺序。 7、@class 和 #import 在编译的时候有哪些区别？ 8、JSON 转 Model 你用的是什么？MJExtension 字典转模型的具体步骤？拿到字典了，第一步做什么，第二步做什么？ 9、WebView 跟 JS 是怎么交互的？ 10、WebView 怎么存 cookie？ 11、A-&gt;B-&gt;C-&gt;D 从D返回到B。说几个不同的实现思路。 方案1：for 循环 self.navigationController.viewControllers 判断某个控制器是否是 B 如果是就 popToViewController:B。 方案2：self.navigationController.viewControllers 是一个不可变数组，可以赋值给一个可变的数组，然后把 C 移除，然后再赋值给 viewControllers。 其他方案：提示不一定要 push，present出来的怎么弄？ 12、二分查找。 13、深拷贝与浅拷贝，某个值得改变可能会影响原始值，那是深拷贝还是浅拷贝？ 14、性能优化？图片加载到 UIImageView 上经过了哪些过程？ 15、Label 怎么多行显示。 16、Button有哪些状态？ 17、dispatch_group_notify 是在哪个线程上？","link":"/开果科技面试题/"},{"title":"微店面试题","text":"微店面试题 1. 一面1、说项目里的有价值的东西？ 2、HTTPS 过程是怎么样的？非对称加密 3、Swift 中逃逸闭包和非逃逸闭包的区别？ 4、属性用 copy 关键字，是深拷贝还是浅拷贝？深拷贝和浅拷贝的区别？ 5、SDWebImage 的缓存机制？LRU 内部原理？下载完成图片后，是先存到内存、磁盘后，才显示到界面上吗？ 6、AFN 用到了 NSOperation、GCD，说一下内部 Operation 相关的？Manager？ 7、GCD 内部实现？ 8、约束 left/right 和 leading/trailing 的区别？约束报黄怎么解决？ 9、KVO 的原理？具体 NSObject 的两个方法？ 10、消息转发流程？使用场景？ 11、数据库减字段怎么容错？ 12、有没有打包过私有库？ 13、从点击 App 的图标到 App 启动，说一下这个过程？+load 发生在什么时候？ 14、用什么管理第三方库？CocoaPods 中的 .lock 文件存储了什么信息？ 15、说一下一个项目的架构？ 16、组件化？ 17、手写冒泡排序算法？算法复杂度？ 2. 二面1、项目介绍，开发人员分工？购物车本地化如果加入购物车的价格变了怎么处理的？ 2、写一下其中一个项目的项目架构？写一下用到的第三方库。 3、项目用什么管理的？CocoaPods 指定版本号带 ~ 跟不带 ~各有什么含义？ 4、AFN 实现原理？发10个网络请求，AFN 内部是怎么处理的？ 5、SDWebImage 是怎么加载图片的？用的是 Get 还是 Post ？如果让你实现，你会选择 Get 还是 Post ？ 6、HTTPS 流程是怎么样的？（画一下客户端、服务器的时序图） 7、加密算法，对称加密和非对称加密？ 8、如何理解 OC 是动态语言？ 9、Runtime？用 Runtime 做过什么？ 10、Runloop？内部实现原理？跟自己写个 for 循环有没有区别？ 11、内存管理？内存优化？ 12、卡顿？ 13、多线程？用 GCD 实现同步多个异步调用（a，b），然后再同步执行（c，d） 14、从点击 App 图标，到显示界面流程？ 15、组件化？ 16、编译过程？某一个东西是属于哪一步骤的？ 17、微信支付流程（客户端、微信 SDK 、自己服务器、微信服务器时序图） 18、RN、Week？内部是怎么用 JS 调用原生的？ 19、日志记录？ 20、遇到的闪退？Bug？ 21、竞争同一个资源？ 22、进程线程与 App 的关系。 23、Git rebase","link":"/微店面试题及答案/"},{"title":"必要商城面试题","text":"必要商城面试题 1.项目搭建都做了哪些？2.有没有做过解耦？参考链接：iOS组件化（四）-代码解耦合 iOS组件化从零开始 3.路由怎么实现传值的？参考链接：iOS组件化（五）-组件间调用 4.项目优化？ 安装包大小优化 性能优化 启动优化 防崩溃 5.防崩溃处理？runtime 交换方法 6.cell 加载图片的优化？7.项目难点？8.数据传递除了加密以外，怎么保证数据安全？ 使用数字证书锁定来保证不被中间人拦截，将服务器返回的数据和我的本地证书进行对比，确保是从服务器返回回来的。 使用 https 协议请求网页，post 来请求网页数据，保证用户的账号密码不被被人获取到。 使用苹果自己的 SSKeyChain 钥匙串，将用户的账号密码保存在钥匙串中。 参考链接：iOS开发，让数据更安全的几个加密方式 9.原生与 H5 的交互？WKWebView 和 UIWebView 的区别？10.Cocopods 怎么管理自己的第三方库？11.除了 MVC 有没有了解过别的设计模式？12.方法交换原理？方法交换，交换的是方法的实现。","link":"/必要商城面试题/"},{"title":"快狗打车面试题","text":"快狗打车面试题 1.dart 语法 .. 是什么意思 2.怎么封装一个 Flutter 组件来让原生调用 3.用的网络请求库是哪个？Flutter 怎么抓包 4.state 的生命周期 5.buildContext 是接口、协议还是什么？ 6.Widget 是什么 7.父子 widget 之间怎么传值，父 widget 怎么管理子 widget 的状态，怎么局部刷新？ 8.同步可以使用 try catch 来捕获异常，带 Future 的异步方法的异常怎么捕获 9.单链表反转有几种方法，你觉得你的方法是最优的吗？ 10.快速排序，轴点能不能用中间的一个数，怎么优化快排","link":"/快狗打车面试题/"},{"title":"恒天财富面试题","text":"恒天财富面试题 一面1.KVO 的实现原理 2.Category 的底层结构，Category 能添加成员变量吗？为什么？ 3.load 和 initialize 的区别？initialize 的调用顺序？ 4.Block 为什么用 copy？Block 的类型？Block 的结构 5.Runtime 的消息流程 6.说说你了解的 Runloop 7.项目亮点 8.怎么实现 webView 秒开 H5 9.项目优化 二面（前端负责人）1.打开一个 App，首页关掉网络后还可以显示一些内容，怎么实现的，有落地吗？ 2.webView 跟 H5 交互方式？是 url scheme 吗？Bridge 用了吗 3.从加载 H5 到界面显示出来这段时间的白屏发生了什么？ 4.打开一个示例 App，webView 加载 H5 秒开？离线包了解吗？行业解决方案 5.Vue 的生命周期 6.v-if 的作用 7.父子组件怎么传值？ 8.知道 vuex 吗？ 三面（后端负责人）1.介绍项目模块，项目分工 2.安卓 App 提示更新，更新一半退出再进来，从头下载了。断点续传怎么做？ 3.查看药店首页，白屏 loading 时间长怎么优化？ 4.webView 白屏怎么优化？ 5.做过哪些具体的优化 6.除了埋点还有什么方式排查问题？不能复现的问题怎么查？ 四面（部门负责人） HR","link":"/恒天财富面试题/"},{"title":"搜狐面试题","text":"搜狐面试题 1.介绍一个印象深刻的项目，遇到过什么问题，怎么解决的。 组件化为什么没有用一个通用的字典来接收页面参数，这样不是更通用？ webView 交互协议怎么制定的？H5 从原生拿返回值怎么实现的？ 2.做过哪些优化 3.你觉得你最擅长哪方面？比如 UI、架构啥的 4.微博详情页（内容、转发、评论）让你来做，你会怎么实现？从外层到内层用什么控件，具体实现。 5.算法题 有一个产品发布了多个版本，它遵循以下规则：假如某个版本崩溃了，则后面的所有版本都会崩溃。 举个例子：一个产品假如有5个版本，其中第1-3版本都是正常的，但是第4个版本崩溃了，那么第5个版本（最新版本）一定也崩溃，第4个版本被称为第一个崩溃版本。 现在已知一个产品有n个版本，而且有一个检查算法func isBadVersion(version:Int) -&gt; Bool 可以判断一个版本是否崩溃，假设这个产品的最新版本崩溃了，求第一个崩溃的版本。 思路：本质上是有重复数字的升序数组的二分查找 1234567891011121314151617function search( nums , target ) { let start = 0 if(!nums.length) return -1; let left = 0, right = nums.length - 1; while(left &lt;= right) { let mid = Math.floor((left + right) / 2); if(target == nums[mid]) { while(mid != 0 &amp;&amp; nums[mid - 1] == nums[mid]) mid--; // 找到第一个数 return mid; } else if(target &lt; nums[mid]) { right = mid - 1; } else { left = mid + 1; } } return -1;} 6.想实现一个图片，删除后撤销删除，你会用什么数据结构来怎么实现？","link":"/搜狐面试题/"},{"title":"新浪乐居面试题","text":"新浪乐居面试题 笔试题笔试题 一面1、类方法和实例方法有什么区别？ 2、用封装的类方法去请求网络会有什么问题？ 3、说一下单例。单例的作用是什么？为什么不能多次创建对象？ 4、说一下 ARC、MRC，有什么区别？有啥优缺点？ 5、自动释放池的使用场景？耗内存时需要加到池子里。 6、沙盒目录除了 Documents 还有啥？Cache 和 Temp 有什么区别？ SDWebImage 是在 Library 下的 Caches 里 7、项目里用地图了吗？如果用系统的地图会有一个问题，电量急速下降，遇到过这个问题吗？ 8、都有哪些可能循环引用？ 9、说一下从网络请求回来的数据怎么存？数据持久化的方法。数据库是存在沙盒的哪个目录？我说在 Documents 中。 10、assign 与 weak 区别？ 11、笔试题19的答案为什么是2、5？ 12、说一下冒泡排序的思路？ 13、GCD 需要注意什么？我说了一下使用场景。 14、Runtime、Runloop 了解吗？Runloop 有哪些 Mode？说一下 CommonMode ？ 15、最后一个问题：类似简历 右上角是图片（宽高已知） 左边是一段文字 文字会包裹着图片，问实现思路？ 说了三个思路：（1）计算一下上边 label 宽高，左边用一个 label 显示，下边多余的字也用另一个 label 显示。 （2）YYText 可能有处理办法，算是第三方。 （3）他提示底层一点的，我说绘制。 二面1、了解项目，问在公司干啥。 2、AutoLayout 和 Masonry 有什么区别？ 3、面向对象在 OC 中的体现？封装、继承、多态。你觉得最主要的是面向对象的哪个特性？ 4、你对 H5、原生交互的看法。我说了实现方式后，他说不要实现细节，就你的看法。我又说了阿里是大前端，他说不要说阿里，你的看法呢？我说活动页用H5，其他用原生，可能效率高。 5、Block 和 delegate 的使用场景差异？ 6、你觉得开发一个项目难点在哪儿？ 7、其他问题：薪水能商量吗？有什么要问我的？","link":"/新浪乐居面试题/"},{"title":"普华商学院面试题","text":"普华商学院面试题 1.怎么学的 iOS？ 2.连击动画实现？（队列、线程） 3.直播底层技术？ 4.封装网络请求怎么封装的？详细的需要考虑的东西 5.runtime 找不到这个方法怎么能够不报错？在动态方法解析那个方法里具体怎么写？runtime 有哪些应用？ 6.类的本质 结构体里边有哪些东西？ 7.数据存储有哪些？ 8.runloop timer runloop 底层是什么？ 9.timer 怎么防止循环引用？在哪里停掉 timer？didDisappearer里行不行？除了 timer 还有哪些可以实现定时器？CADispalyLink 10.delegate 用什么修饰符？用 asign 行不行？weak 是怎么把指针置为 nil 的？ 11.tableView cell 里有图片 页面滑动时 SDWebImage 有没有处理 在滑动时不加载 停止滑动时加载 它是怎么做到的？ 12.高度缓存有没有做？ 13.你对加班怎么看？","link":"/普华商学院面试题/"},{"title":"朗播网面试题","text":"朗播网面试题 机试题 1、图片轮播是怎么做的？ 2、缓存图片用的什么？（SDWebImage）说一下 SD 的缓存机制？ 3、SD 缓存满了，是怎么清理的？ 4、从磁盘取出，从内存取出，显示到界面上，这个过程发生了什么？ 5、移动一个图片，比如从左边移动到右边，CPU/GPU 做了什么？谁的贡献大一点？ 6、数据结构跟算法，单链表反转 7、只遍历，用数组还是链表好？ 8、大数据排序？怎么合并拆分的小段的？ 9、淘汰算法？","link":"/朗播网面试题/"},{"title":"核桃编程面试题","text":"核桃编程面试题 1.消息发送和消息转发的过程 2.KVO 的原理 3.能不能动态添加成员变量 4.分类为啥不能添加成员变量 5.说一下 HTTPS 和 TCP、UDP 6.说一下项目亮点 7.方法交换注意什么 8.链表反转 9.NSNumber 怎么进行优化的，数据存储哪里 10.GCD 和 NSOperation 各自的优点 11.Runtime 的应用","link":"/核桃编程面试题/"},{"title":"棵朵面试题","text":"棵朵面试题 1、结构体和类有什么区别？ 2、NSString 和 String 有什么区别？ 3、?? 是什么意思？ ? 是什么意思？ ! 是什么意思？ 4、说一下 @property， weak 和 assign 有什么区别？weak 能不能修饰非 OC 的对象？ 5、MutableCopy 和 copy ，即深拷贝和浅拷贝有什么区别？ 6、NS、CA、CF、UI 分别属于哪个框架？ 7、多线程有没有自己开辟过线程？ 8、从服务器得到5个图片链接，5张图片展示到一个页面上，截图分享到微信？怎么保证5张图全部加载出来了再去截图分享？ 9、JS 与 OC 交互，点击 H5 某个地方跳转到购物车，点击某个地方跳转到详情页，点击某个地方跳转到订单页，跳转到指定的页面你现在用的是判断的跳转类型，如果新增了一种，怎么能不发版完成需求？ 10、你用 swift 开发用没用过 VIPER 架构模式？","link":"/棵朵面试题/"},{"title":"滴滴笔试题","text":"滴滴笔试题 笔试题0.姓名？日期。 1.C语言实现字符串反转：void reverse(char *str, int length) {} 2.实现一个字符串数组去重函数。 3.描述OC中对象的实现原理。 4.编写代码，实现 NSObject 中添加一个属性 p1 5.KVO 的实现原理和注意事项。 6.下面的代码有哪些问题？ 123456789101112131415@interface Demo : NSObject@property (nonatomic, assign) BOOL *p1;@property (nonatomic, strong) NSString *p2;@end@implementation Demo@dynamic p1;- (void)setP2:(NSString *)p2;{ self.p1 = YES; self.p2 = p2;}@end 7.JS 和 Native 的通讯方式。 8.网络5层模型是哪5层？ 9.把t1表中 name 为 mike 的记录中 status 值改为1 10.常用的 Linux 命令。 11.用过的包/库管理工具。","link":"/滴滴笔试题/"},{"title":"滴滴面试题","text":"滴滴面试题 笔试题笔试题 滴滴一面看了一下笔试题的答案，第一题 C 语言字符串反转打印了一下 1、说一下你觉得项目中遇到了什么印象深刻的问题，你是怎么解决的？ 2、大学里学了哪些课？信息管理与信息系统专业是哪个学院的？ 3、项目里的网络请求用到了网络5层模型的哪些，TCP/IP 属于哪一层？HTTP 呢？ 4、你觉得自己是什么级别的？优势和不足主要是哪方面？ 5、GCD 平时项目里怎么用的？我提到了回到主线程操作 UI 需要 dispatch_get_mainQueue 6、为什么操作 UI 需要在主线程？ 7、哪些是你独立开发的项目？ 8、问了一下上家公司的情况 9、之后有什么打算？ 10、上家薪资多少？你还有啥想问的吗？ 滴滴二面1、自定义封装控件需要注意什么？有什么规范？ 2、说一下你了解的设计模式。 3、数据库怎么优化？我说数据量大的话加索引提升查询效率。问其他优化呢？比如数据库大小有没有做过优化？ 4、内存优化是怎么做的？我提到了内存泄漏。什么情况会发生内存泄漏？ 5、App 启动时间优化？ 6、视图做过哪些优化，我提了 TableView。那就以 TableView 说一下优化了哪些方面？ 7、AFNetworking 内部是怎么样的一个过程？ 8、你还有什么想问我的？","link":"/滴滴面试题/"},{"title":"登云美业面试题","text":"登云美业面试题 1、@porperty 系统自动帮我们做了什么？如果后边的括号里啥都不写，系统默认的是哪三个？哪些用 copy ？为什么 String 用 copy ？为什么 block 用 copy ？ 2、单例的本质是什么？怎么用的？ 3、封装了什么自定义控件？ 4、说一下 MVC、MVVM 5、多线程都有哪些？项目里哪里用到了 GCD ？ 6、说一下 RuntimeKNFather : NSObjectKNSon : KNFather在 KNSon 中的 init 方法里打印 NSLog [self class] [super class]KNSon alloc init 之后打印结果是什么？ 7、AFN 内部看过吗？AFN 封装了吗？ 8、说一下 SDWebImage 缓存机制 9、Instruments 你们项目什么周期用？用它的哪些功能？ 10、京东的某个页面是怎么做的 涉及到 tableView 的 contentSize 变化。 11、项目里跑马灯怎么实现的？ 12、TouchID 是怎么做的？ 13、KeyChain 保存密码你们是啥时候保存的，保存的密码加密了吗？ 14、JS 交互是怎么做的？ 15、人脸识别 SDK 封装了吗？ 16、个推消息有没有做缓存？App 在前台、后台、杀死这三种状态下怎么处理的？ 17、项目里你觉得哪里最有收获？","link":"/登云美业面试题/"},{"title":"百度面试题","text":"百度面试题 百度一面1.APP 优化2.列表快速滑动不需要加载的图片怎么处理3.cell 加载大图4.异步绘制5.交换方法6.圆角的处理7.监听子线程处理 UI 事件 百度二面1.项目经验介绍（问 RTMP 协议，UDP 主动丢包策略）2.项目中遇到什么难点3.为什么要制作动态库 系统动态库会影响启动时间吗4.HTTPS ( CA 证书验证流程)5.Category 原理6.异步发送通知 (NSNotificationQueue)7.算法 参考答案百度一面1.APP 优化 iOS 保持界面流畅的技巧 启动优化 安装包大小优化：正经分析iOS包大小优化 2.列表快速滑动不需要加载的图片怎么处理目前有些第三方微博客户端（比如 VVebo、墨客等），使用了一种方式来避免高速滑动时 Cell 的绘制过程，相关实现见这个项目：VVeboTableViewDemo。它的原理是，当滑动时，松开手指后，立刻计算出滑动停止时 Cell 的位置，并预先绘制那个位置附近的几个 Cell，而忽略当前滑动中的 Cell。这个方法比较有技巧性，并且对于滑动性能来说提升也很大，唯一的缺点就是快速滑动中会出现大量空白内容。如果你不想实现比较麻烦的异步绘制但又想保证滑动的流畅性，这个技巧是个不错的选择。 3.cell 加载大图 分片比例裁剪方式。参考苹果给出的 demo,利用 CGImageCreateWithImageInRect 截取原图对应位置的内容,再通过 CGContextDrawImage 渲染到指定位置; 利用 CATiledLayer 层级的API,自动进行绘制; 参考链接：iOS 大图显示解决办法 4.异步绘制 5.交换方法6.圆角的处理优化方式1 ：使用贝塞尔曲线 UIBezierPath 和 Core Graphics 框架画出一个圆角 1234567891011UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(100,100,100,100)];imageView.image = [UIImage imageNamed:@\"myImg\"];//开始对imageView进行画图UIGraphicsBeginImageContextWithOptions(imageView.bounds.size,NO,1.0);//使用贝塞尔曲线画出一个圆形图[[UIBezierPath bezierPathWithRoundedRect:imageView.boundscornerRadius:imageView.frame.size.width]addClip];[imageView drawRect:imageView.bounds];imageView.image=UIGraphicsGetImageFromCurrentImageContext();//结束画图UIGraphicsEndImageContext();[self.view addSubview:imageView]; 参考链接：iOS 圆角优化实现代码 7.监听子线程处理 UI 事件[CALayer display] 百度二面1.项目经验介绍（问 RTMP 协议，UDP 主动丢包策略）2.项目中遇到什么难点3.为什么要制作动态库 系统动态库会影响启动时间吗 库类型 优点 缺点 静态库 1. 目标程序没有外部依赖，直接就可以运行。2. 效率教动态库高。 1. 会使用目标程序的体积增大。 动态库 1. 不需要拷贝到目标程序中，不会影响目标程序的体积。 2. 同一份库可以被多个程序使用（因为这个原因，动态库也被称作共享库）。 3. 编译时才载入的特性，也可以让我们随时对库进行替换，而不需要重新编译代码。实现动态更新 1. 动态载入会带来一部分性能损失(可以忽略不计） 2. 动态库也会使得程序依赖于外部环境。如果环境缺少动态库或者库的版本不正确，就会导致程序无法运行（Linux lib not found 错误）。 参考链接：iOS动态库、静态库及使用场景、方式 4.HTTPS (CA 证书验证流程)数字证书认证机构的业务流程 服务器的运营人员向第三方机构 CA 提交公钥、组织信息、个人信息(域名)等信息并申请认证; CA 通过线上、线下等多种手段验证申请者提供信息的真实性，如组织是否存在、企业是否合法，是否拥有域名的所有权等; 如信息审核通过，CA 会向申请者签发认证文件-证书。证书包含以下信息：申请者公钥、申请者的组织信息和个人信息、签发机构 CA的信息、有效时间、证书序列号等信息的明文，同时包含一个签名。 其中签名的产生算法：首先，使用散列函数计算公开的明文信息的信息摘要，然后，采用 CA 的私钥对信息摘要进行加密，密文即签名; 【数字签名生成的过程】 客户端 Client 向服务器 Server 发出请求时，Server 返回证书文件; 客户端 Client 读取证书中的相关的明文信息，采用相同的散列函数计算得到信息摘要，然后，利用对应 CA 的公钥解密签名数据，对比证书的信息摘要，如果一致，则可以确认证书的合法性，即服务器的公开密钥是值得信赖的。【校验数字签名的过程】 客户端还会验证证书相关的域名信息、有效时间等信息; 客户端会内置信任 CA 的证书信息(包含公钥)，如果 CA 不被信任，则找不到对应 CA 的证书，证书也会被判定非法。 参考链接：经得住拷问的HTTPS原理解析 5.Category 原理6.异步发送通知 (NSNotificationQueue)参考链接：iOS中的NSNotification 7.算法","link":"/百度面试题/"},{"title":"美团优选面试题2及答案","text":"美团优选面试题2 介绍值得说的项目 1.打印结果1234567- (void)someMethod { int i = 10; dispatch_async(dispatch_get_main_queue(), ^{ NSLog(@\"%d\",i); }); i = 20;} 10 1234567- (void)someMethod { static int i = 10; dispatch_async(dispatch_get_main_queue(), ^{ NSLog(@\"%d\",i); }); i = 20;} 20 1234567- (void)someMethod { __block int i = 10; dispatch_async(dispatch_get_main_queue(), ^{ NSLog(@\"%d\",i); }); i = 20;} 20 1234567- (void)someMethod { int i = 10; dispatch_sync(dispatch_get_main_queue(), ^{ NSLog(@\"%d\",i); }); i = 20;} 10 2.+load 和 initialize 的区别？+load 的调用时机1.调用方式 (1) load 是根据函数地址直接调用。 (2) initialize 是通过 objc_msgSend 调用。 2.调用时刻(什么时候会调用) (1) load 是 runtime 加载类、分类的时候调用(只会调用一次) (2) initialize 是类第一次接收到消息的时候调用，每一个类只会 initialize 一次(父类的 initialize 方法可能会被调用多次)。 3.App 启动 pre-main 做了什么事情1.加载 dyld 到 App 进程（dyld 首先读取 mach-o Header 和 load commands，接着就知道了这个可执行文件依赖的动态库）2.加载动态库（包括所依赖的所有动态库）3.Rebase &amp; Bind (使用了ASLR地址空间布局随机化和 Code Sign 来保证应用的安全，Rebase 修正内部指针指向，Bind 修正外部指针指向)4.初始化 Objective-C Runtime （Runtime 维护了一张映射类名与类的全局表，当加载一个 dylib 时，把类的信息注册到这个全局表中，也会把 Category 中的方法注册到对应的类中）5.Initializers 其他初始化代码6.dyld 调用 main() 函数，main() 函数调用 UIApplicationMain(),程序启动。 4.KVO 的实现原理。 利用 Runtime API 动态生成一个子类，并且让 instance 对象的 isa 指向这个全新的子类 当修改 instance 对象的属性时，会调用 Foundation 的 _NSSetXXXValueAndNotify 函数willChangeValueForKey:父类原来的 setterdidChangeValueForKey:内部会触发监听器（Oberser）的监听方法(observeValueForKeyPath:ofObject:change:context:） 5.KVC 的实现原理，是直接访问成员变量赋值吗？按照 setKey:、_setKey: 顺序查找方法，找到方法调用。没找到继续。 查看 accessInstanceVariablesDirectly 方法的返回值。如果是 YES 继续。 按照_key、_isKey、key、isKey顺序查找成员变量。找到了直接赋值。 没找到成员变量：调用 setValue:forUndefinedKey: 并抛出异常NSUnknownKeyException 6.autoreleasepool 什么时候释放？ 子线程使用了 autorelease 后，如果当前线程没有 AutorelesepoolPage 的话，代码执行顺序为 autorelease -&gt; autoreleaseFast -&gt; autoreleaseNoPage。在 autoreleaseNoPage 方法中，会创建一个 hotPage ，然后调用page-&gt;add(obj) 。也就是说即使这个线程没有 AutorelesepoolPage ，使用了 autorelease 对象时也会 new 一个 AutoreleasepoolPage 出来管理 autorelese 对象。 子线程的 autoreleasepool 是在线程销毁的时候释放的。 7.Category 添加一个属性系统做了什么？怎么添加属性？为什么不能添加成员变量。关联对象存在哪里？Category 里写了和类相同的方法会怎么样？声明了 set 和 get 方法。 实现关联对象技术的核心对象有 AssociationsManager：关联对象存储在全局的统一的一个 AssociationsManager 中 AssociationsHashMap：key 为对象，value 为 ObjectAssociationMap ObjectAssociationMap：key 为关联对象的 key，value 为 ObjcAssociation ObjcAssociation：存储 policy 和 value 会先找到分类里的方法执行。 8.isa 指向，元类对象 isa 指向哪里？NSObject 的 isa 指向哪里？为什么要设计类、元类？isa 的结构 元类对象的 isa 指向基类的元类对象。NSObject 的 isa 指向它本身。 在 arm64 架构之前，isa 就是一个普通的指针，存储着 Class、Meta-Class 对象的内存地址 从 arm64 架构开始，对 isa 进行了优化，变成了一个共用体（union）结构，还使用位域来存储更多的信息 nonpointer0：代表普通的指针，存储着 Class、Meta-Class对象的内存地址1：代表优化过，使用位域存储更多的信息 has_assoc是否有设置过关联对象，如果没有，释放时会更快 has_cxx_dtor是否有 C++ 的析构函数（.cxx_destruct），如果没有，释放时会更快 shiftcls存储着 Class、Meta-Class 对象的内存地址信息 magic用于在调试时分辨对象是否未完成初始化 weakly_referenced是否有被弱引用指向过，如果没有，释放时会更快 deallocating对象是否正在释放 extra_rc里面存储的值是引用计数器减1 has_sidetable_rc引用计数器是否过大无法存储在 isa 中如果为1，那么引用计数会存储在一个叫 SideTable 的类的属性中 9.有做过卡顿检测吗？Runloop 检测卡顿怎么知道是哪个方法卡？方法卡了多长时间？10.有做闪退监测吗？bugly 是怎么实现的？crash 率是多少？crash 率是怎么算出来的？crash 率 = 崩溃次数 / 活跃设备数 11.两两交换链表中的结点实现反转单向链表的函数。如 1-&gt;2-&gt;3-&gt;4 反转后变成 2-&gt;1-&gt;4-&gt;3 LeetCode题目链接：两两交换链表中的节点 1234567891011121314var swapPairs = function(head) { let dummyNode = new ListNode(0); dummyNode.next = head; let temp = dummyNode; while (temp.next != null &amp;&amp; temp.next.next != null) { let head1 = temp.next; let head2 = temp.next.next; temp.next = head2; head1.next = head2.next; head2.next = head1; temp = head1; } return dummyNode.next;}; 有什么想问我的？","link":"/美团优选面试题2/"},{"title":"美团面试题","text":"美团面试题 1、Block 的底层原理，结构，内存以及需要注意的地方。 2、图片渲染，一张 png/jpg 格式的图片渲染到页面上显示有哪些流程。png 和 jpg 的区别。png 一定是无损的吗？ 3、Runtime。 4、Runloop 的结构和循环流程，用 Runloop 做过什么事情。 5、多线程，NSOperationQueue 和 GCD 的区别。用多线程做过什么事情。线程安全的问题。加锁有几种方式。 6、NSURLSession 和 NSURLConnection 的区别， NSURLConnection 是怎么封装的。CFNetwork。 7、做过什么动画。 8、HTTPS 的工作原理，和 HTTP 的区别。RSA 加密原理。 9、网络层级，TCP 和 UDP 的区别。 10、SDWebImage 的框架结构，缓存机制。 11、Git 的 rebase 的原理。Git 流程。 12、对组件化的了解，组件化是为了解决什么问题。 13、JSPatch 的原理。 14、单例是为了处理什么问题而使用的，单例和全局变量的区别。 15、对设计模式的掌握。 16、分层打印二叉树。","link":"/美团面试题/"},{"title":"美团面试题2及答案","text":"美团面试题2 1.gcd, block,__block, static2.程序启动时执行了什么3.runloop: 如何让一个 block 只在子线程runloop 上执行4.autorelease 对象何时释放，主线程，子线程分别如何释放5.isa指向的内存布局6.如何定义一个只存在于栈的对象7.线上卡顿监控8.crash 触发流程，涉及的底层系统调用9.链表反转： 1-&gt;2-&gt;3-&gt;4 反转为 2-&gt;1-&gt;4-&gt;3","link":"/美团面试题2/"},{"title":"美团面试题及答案","text":"美团面试题 1、Block 的底层原理，结构，内存以及需要注意的地方。block本质上也是一个OC对象，它内部也有个isa指针。block是封装了函数调用以及函数调用环境的OC对象。 block类型 环境 NSGlobalBlock 没有访问auto变量 NSStackBlock 访问了auto变量 NSMallocBlock NSStackBlock调用了copy 2、图片渲染，一张 png/jpg 格式的图片渲染到页面上显示有哪些流程。png 和 jpg 的区别。png 一定是无损的吗？图片渲染的过程: 读取文件 -&gt; 计算frame -&gt;图片解码 -&gt;解码后通过数据总线交给GPU -&gt;GPU获取图片frame后进行顶点变换计算 -&gt;光栅化 -&gt;根据纹理坐标获取每一个像素点的颜色值 -&gt; 交给帧缓冲区 -&gt;渲染到屏幕上 iOS中图片渲染的流程 iOS 保持界面流畅的技巧 iOS图形原理与离屏渲染 3、Runtime。OC中的方法调用其实都是转成了objc_msgSend函数的调用，给receiver（方法调用者）发送了一条消息（selector方法名）objc_msgSend底层有3大阶段消息发送（当前类、父类中查找）、动态方法解析、消息转发 具体应用利用关联对象（AssociatedObject）给分类添加属性遍历类的所有成员变量（修改textfield的占位文字颜色、字典转模型、自动归档解档）交换方法实现（交换系统的方法）利用消息转发机制解决方法找不到的异常问题 4、Runloop 的结构和循环流程，用 Runloop 做过什么事情。01、通知Observers：进入Loop02、通知Observers：即将处理Timers03、通知Observers：即将处理Sources04、处理Blocks05、处理Source0（可能会再次处理Blocks）06、如果存在Source1，就跳转到第8步07、通知Observers：开始休眠（等待消息唤醒）08、通知Observers：结束休眠（被某个消息唤醒）01&gt; 处理Timer02&gt; 处理GCD Async To Main Queue03&gt; 处理Source109、处理Blocks10、根据前面的执行结果，决定如何操作01&gt; 回到第02步02&gt; 退出Loop11、通知Observers：退出Loop 控制线程生命周期（线程保活） 解决NSTimer在滑动时停止工作的问题 监控应用卡顿 性能优化 5、多线程，NSOperationQueue 和 GCD 的区别。用多线程做过什么事情。线程安全的问题。加锁有几种方式。dispatch_after dispatch_group dispatch_barrier dispatch_once OSSpinLockos_unfair_lockpthread_mutexdispatch_semaphoredispatch_queue(DISPATCH_QUEUE_SERIAL)NSLockNSRecursiveLockNSConditionNSConditionLock@synchronized 6、NSURLSession 和 NSURLConnection 的区别， NSURLConnection 是怎么封装的。CFNetwork。7、做过什么动画。8、HTTPS 的工作原理，和 HTTP 的区别。RSA 加密原理。9、网络层级，TCP 和 UDP 的区别。 TCP UDP 面向连接 面向数据报 可靠传输 不可靠传输 传输效率低 传输效率高 10、SDWebImage 的框架结构，缓存机制。11、Git 的 rebase 的原理。Git 流程。12、对组件化的了解，组件化是为了解决什么问题。13、JSPatch 的原理。14、单例是为了处理什么问题而使用的，单例和全局变量的区别。15、对设计模式的掌握。16、分层打印二叉树。","link":"/美团面试题及答案/"},{"title":"腰果公考面试题","text":"腰果公考面试题 笔试：1、NSTimer 受滑动影响 2、深拷贝、浅拷贝？ 3、assign 与 weak 区别？ 4、内存管理？ 5、[self class] [super class] 算法：1、数组去重？ 2、已知一个生成 0-6 随机数的函数，写一个生成 0-9 随机数的函数。 3、从数组中找到所有 3 个数和为 0 的组合，如 [0,-1,1] 面试题：笔试题问一遍 1、assign 与 weak 区别？weak 内部实现原理？如果让你自己实现 weak？ 2、深浅拷贝在可变与不可变时具体说一下。 3、NSTimer 受滑动影响 4、快速排序？ 5、判断 [[]] 前后括号对应 6、GCD 的 API 7、实现单例？怎么保证 alloc init 时也只创建一次或者调用不了 alloc init 确保单例的唯一？ 8、圆角的优化？出现问题的原因？离屏渲染？ 9、Masonry 链式调用的原理？ 10、微信支付流程 11、富文本？ 12、block 循环引用怎么个循环引用？","link":"/腰果公考面试题/"},{"title":"苏宁面试题","text":"苏宁面试题 1. 笔试题1.1 冒泡排序Objective-C 实现如下：1234567891011121314- (void)bubbleSort:(NSMutableArray *)array { for (int i = 0; i &lt; array.count; i++) { for (int j = 0; j &lt; array.count-1-i; j++) { NSInteger left = [array[j] integerValue]; NSInteger right = [array[j+1] integerValue]; if (left &lt; right) { [array exchangeObjectAtIndex:j withObjectAtIndex:j+1]; } } } NSLog(@&quot;%@&quot;,array);} 参考链接：【算法】冒泡排序 1.2 二分查找Swift实现如下：123456789101112131415func binarySearch&lt;T: comparable&gt;(_a: [T], key: T) -&gt; Int? { var lowerBound = 0 var upperBound = a.count while lowerBound &lt; upperBound { let midIndex = lowerBound + (upperBound - lowerBound) / 2 if a[midIndex] == key { return midIndex } else if a[midIndex] &lt; key { lowerBound = midIndex + 1 } else { upperBound = midIndex } } return nil} 参考链接：【算法】二分查找 1.3 合并两个数组去重参考链接：【算法】合并两个数组并去重 1.4 两个大数相加参考链接：大数相加算法 2. 一面2.1 SDWebImage 的缓存机制？LRU 说一下。SDWebImage加载图片拿到url会先把url的MD5值作为key从内存中查找，如果内存中有，则直接取图片显示；如果内存中没有，会从磁盘中查找。磁盘中没有，会走下载流程。LRU 最近最少使用。缓存容量满时，会先清理最近最少的缓存。 2.2 数据库升级，比如从 1.0 升级到 2.0，增加了字段。做好兼容处理。 2.3 性能优化2.3.1 优化启动时间 将一些耗时操作延迟执行。比如SDK的初始化，界面的创建。 不能延迟执行的，尽量放到后台执行。比如数据读取，原始 JSON 数据转对象，日志发送。 减少动态库、合并动态库，定期清理不必要的动态库。 减少类、分类的数量，合并Category和功能类似的类。删除不必要的方法和类、分类。 将不必须在+load中做的事延时到+initialize中。 2.3.2 减少CPU、GPU资源消耗 cell复用，header、footer复用。 尽量把view设置不透明。 减少视图的层级。 尽量避免调整视图层次、添加和移除视图。 合理选择加载图片的方式，UIImage imageNamed: ImageAssets 用于多个地方重复使用，UIImage imageWithContentsOfFile 一般用在图片数据很大，一般不需要多次使用的情况。 图片大小最好和UIImageView的大小相同。 不要阻塞主线程，耗时操作放在子线程进行。 懒加载。 缓存，缓存图片SDWebImage，缓存行高，NSCache缓存。 复用高开销对象NSDateFormatter和NSCalendar。 减少离屏渲染，优化圆角、阴影。 使用正确的数据存储。 2.3.3 内存优化 减少内存泄漏。 降低内存使用峰值。 懒加载。 灵活运用图片和文件加载。 拉长文件处理机制，逐步处理文件。 2.3.4 耗电优化耗电功率是个比较综合的指标，影响因素很多。密集的网络请求，长链接，密集的CPU操作（比如大量的复杂计算）都会使耗电功率增加。网络状况（流畅的Wi-Fi还是信号不好的3G）都会影响。 优化网络。 减少、压缩网络数据。 若多次网络请求结果相同，尽量使用缓存。 网络不可用时，不进行网络请求。 优化CPU、GPU消耗。 优化I/O操作，使用dispatch_io。 定位优化 尽量降低定位精度，如不要使用精度最高的KCLLocationAccuracyBest。 如果只是需要快速确定用户位置，用 CLLocationManager 的 requestLocation 方法定位，定位完成后，定位硬件会自动断电。 2.4 Git 开发流程。 master develop dev-xx 具体开发人员分支 开发完成后发起PR。项目提审打Tag 2.5 微信登录流程。注册微信的AppKey与AppSecret。使用微信SDK方法调起微信，回调拿到一些参数，把包含openId等协定好的参数传给服务器，由服务器判断该用户是否注册过，如果注册过，返回登录成功后的用户相关信息。 2.6 WebView 与 JS 交互。H5调用原生采用拦截协议的方式。执行JS方法：evaluateScript也可以使用JSBridge等方式。 2.7 说一下Runloop，苹果设计 Runloop 的初衷是什么？Runloop 运行循环。让线程在有任务的时候忙任务，没任务的时候休眠。参考链接：【iOS 开发】RunLoop 总结 2.8 Delegate代理用assign修饰。 2.9 GCD参考链接：GCD 的 API 2.10 深拷贝与浅拷贝深拷贝是拷贝整个对象。浅拷贝只拷贝对象的指针。copy用于修饰NSArray、NSDictionary、NSString。如果=右边赋值的对象是可变的，copy是深拷贝，拷贝对象的本身。如果赋值的对象是不可变的，copy是浅拷贝，只拷贝对象的指针。用copy和用strong的区别？用copy更安全，避免赋的值是可变的。如果能确保赋的值是不可变的，那么用strong和用copy都是浅拷贝，copy只是多了一个判断，判断可变还是不可变，其他是一样的。NSMutableArray、NSMutableDictionary用Strong修饰，如果用copy，就会拷贝一份，变成不可变的，如果增删数据，就会发生错误。 2.11 进程间通信URL Schemes 2.12 线程间通信，两个线程怎么切换？performSelectorOnThread 2.13 多态多态（Polymorphism）按字面的意思就是“多种状态”。在面向对象语言中，接口的多种不同的实现方式即为多态。子类继承父类后，子类重写父类的方法，实现多态。 2.14 HTTP 三次握手，四次挥手。3. 二面3.1 有没有复杂点的页面。3.2 （这个部门是做智能硬件的）蓝牙有哪些API。3.3 播放音频，展示音频的曲线，具体怎么做？4. 三面","link":"/苏宁面试题及答案/"},{"title":"货拉拉面试题","text":"货拉拉面试题 一面1.Vue 用过哪些指令 2.v-model 有没有遇到过什么问题？数组里的对象赋值后 UI 未更新，需要使用 set 方法的原因是什么？ 3.Vue 双向绑定是怎么实现的 4.说一下你对 Flutter 的理解，使用过哪些 Widget 5.Flutter 除了拆分组件还有什么方法能够使代码结构更清晰 6.Flutter 有没有跟原生交互的部分，有没有涉及双引擎/单引擎的问题 7.Masonry 和 SnapKit 的选择 8.做过哪些优化 9.说一下装饰模式 10.对 MVVM 的理解，什么情况下会选择 MVVM 11.多线程的几种实现方法如何选择，除了使用 dispatch_semaphore，还有什么更好用的方法来解决网络请求依赖，嵌套地狱的问题 12.Git 的使用，项目里有哪些分支 二面1.介绍最熟悉的项目，遇到的问题 2.项目架构 3.启动耗时，启动过程，启动优化 4.安装包大小优化，优化后的安装包大小有多大 5.图片加载优化 6.性能优化，内存、CPU 峰值多少，使用哪些工具分析性能 7.项目稳定性 crash率，有哪些闪退的问题 8.对象的内存结构 9.了解哪些设计模式 10.7层/5层网络模型，TCP/UDP 区别，TCP 的连接过程 11.Vue 的生命周期 12.介绍一个熟悉的排序算法 13.设计一个下载文件的需求（可能是多个文件，可能用到线程池；边下载边读取） 三面（HR）1.主要的工作，遇到的挑战，最有成就感的事情，举个例子 2.管理的做的好的地方，有待改进的地方 3.其他家的机会到哪个阶段了，各个公司的比较 4.对货拉拉的意向高吗，对货拉拉的了解 5.选择一家公司比较看重哪些","link":"/货拉拉面试题/"},{"title":"达达面试题","text":"达达面试题 1.深拷贝、浅拷贝区别。数组里放对象，copy 数组，是深拷贝还是浅拷贝？数组里对象的指针是一样的吗？ 浅拷贝：指针拷贝，不会创建一个新的对象。对指向对象的指针拷贝，产生一个新的指向对象的指针。两个指针指向同一个对象。对象的引用计数+1； 深拷贝：内容拷贝，会创建一个新的对象。深拷贝就是拷贝地址中的内容。 深拷贝和浅拷贝的本质是内存地址是否相同。 copy 可变数组是深拷贝。copy 不可变数组是浅拷贝。数组里对象的指针是一样的。 copy mutableCopy NSString NSString 浅拷贝 NSMutableString 深拷贝 NSMutableString NSString 深拷贝 NSMutableString 深拷贝 NSArray NSArray 浅拷贝 NSMutableArray 深拷贝 NSMutableArray NSArray 深拷贝 NSMutableArray 深拷贝 NSDictionary NSDictionary 浅拷贝 NSMutableDictionary 深拷贝 NSMutableDictionary NSDictionary 深拷贝 NSMutableDictionary 深拷贝 2.布局使用 Masony 还是 Xib3.StatefulWidget、StatelessWidget 区别 Widget 是部分界面的不可变的描述信息。 StatelessWidget 和 StatefulWidget 没有本质区别，他们的所有属性都是不可变的。它们都没法更新，除非用一个新的 Widget 去替换它们。 StatefulWidget 拥有一个可变的 State。 StatefulWidget 和 StatelessWidget 的区别在于可变的 State。本质区别是能否自我重新构建（self rebuild）。 参考链接：简书-StatelessWidget和StatefulWidget的区别 4.UITableView、UICollectionView 的调用流程区别5.常用的 pod 命令pod init: 创建 Podfile 文件。 pod install：会根据 podfile.lock 文件中指定的 pod 依赖库的版本去拉去项目的 pod 依赖库。 pod install --no-repo-update: 协作开发时使用此命令可以根据 podfile.lock 文件限制第三方库的版本。 pod update：这个命令会检查 podfile.lock 文件中的 pod 依赖库的版本，并进行更新，会重新生成一个 podfile.lock 文件。 pod repo add NAME URL[branch] ：添加 pod 源。 pod search：搜索可以使用的 pod 依赖库。 pod list：列出所有项目依赖仓库中的 pod 依赖库。 pod repo：用来管理 pod 依赖仓库的地址。 pod spec：管理 pod 规范。 pod env：来打印出 pod 的环境，一般是 podfile 文件中的内容。 pod cache：管理 cocoapod 的缓存：可以用来清空内存，也可以用来查看每个 pod 库的缓存。 制作私有库使用 pod lib create [仓库名]：在本地创建一个基于 pod 模板的 git 仓库。 pod lib lint：pod 本地库验证，验证 .podspec 文件是否有错。 pod repo add NAME URL[branch]：添加自己的 pod 仓库。 pod spec lint：pod 远程库验证。 pod repo add xxx https://gitxxxx ：放置 spec 文件的 git 仓库地址，给自己添加私有仓库。 pod repo push 索引库名 podspec文件名：命令执行会先将 pod 索引添加到本地的索引库，然后会自动推送到远程的索引库。 1234567891011121314151617181920Commands: + cache Manipulate the CocoaPods cache + deintegrate Deintegrate CocoaPods from your project + env Display pod environment + init Generate a Podfile for the current directory + install Install project dependencies according to versions from a Podfile.lock + ipc Inter-process communication + lib Develop pods + list List pods + outdated Show outdated project dependencies + plugins Show available CocoaPods plugins + repo Manage spec-repositories + search Search for pods + setup Setup the CocoaPods environment + spec Manage pod specs + trunk Interact with the CocoaPods API (e.g. publishing new specs) + try Try a Pod! + update Update outdated project dependencies and create new Podfile.lock 6.图文混排有没有做过，有没有内存、性能问题参考链接：简书-iOS开发之富文本(图文混排) 7.写过哪些脚本，有没有写过函数，按顺序执行的函数。bugly、Fastlane、切换 SDK 配置文件 参考链接：菜鸟教程- Shell 教程 8.闪退捕获，Flutter 错误捕获1234567891011121314151617181920212223void main() { // Flutter framework 异常捕获 FlutterError.onError = (FlutterErrorDetails details) { bool isDebugMode = false; assert(() { isDebugMode = true; return true; }()); if (isDebugMode) { FlutterError.dumpErrorToConsole(details); } else { //profile,release两个模式下下捕捉异常信息 reportFrameworkError(details); } }; // 其他类型异常 runZoned( () =&gt; runAutoSizeApp(MyApp(), width: 375, height: 667), onError: (dynamic ex, StackTrace stack) { reportError(ex, stack); }, ); } 参考链接：Flutter异常捕捉原理和异常上报 9.埋点是怎么做的？页面上的某一个 view 的停留时长怎么统计？10.性能优化、图片加载优化、安装包大小优化做了啥，没用到的代码或图片有写脚本来检查吗？ 未使用的代码可以用 AppCode 来检测。 未使用的图片可以用 LSUnusedResources 来检测。 12.界面渲染流程、UIView 渲染流程，有没有做过异步绘制？ 13.解决遇到的线程问题描述一下，在子线程刷新 UI 会怎么样？14.有没有做过组件模块化？","link":"/达达面试题/"},{"title":"闲徕互娱面试题","text":"闲徕互娱面试题 1.ViewController 的生命周期 从控制器 A 跳转到 B 两个控制器里方法的调用顺序 loadView viewDidLoad viewWillAppear viewDidAppear viewWillDisappear viewDidDisappear 2.MVC 具体流程 3.GCD 哪些地方用到了？ 4.webView 与 JS 交互，是哪个代理方法？ 5.NSTimer 创建方法里有哪些参数？里边的 self 是强引用还是弱引用？怎么避免循环引用？ 6.Notification 注册通知方法里有哪些参数？里边传入的 self 是强引用还是弱引用？怎么使用的通知？（注册、销毁、发送在哪里写的） 7.数据持久化你都哪些地方用了？ 8.UserDefaults 中存了什么东西？ 9.Runtime 底层看过没有？isa 指向哪里？比如 NSString 这个对象的 isa 指针指向哪里？ 10.Runtime 你用到过的地方或者你知道的哪些第三方库用到了，怎么用的？json 转Model 怎么用的 runtime？ 11.RunLoop 你在哪儿用的？RunLoop 与线程的关系。 12.SDWebImage 你用过哪些功能？ 13.Instruments 你用过哪些功能？ 14.某个页面你是怎么布局的？（直播首页）","link":"/闲徕互娱面试题/"},{"title":"首汽租车面试题","text":"首汽租车面试题 1.什么是野指针？什么情况下会野指针？ 2.打印结果： 12345678- (void)testWeak { id obj1 = @\"12131\"; __weak id obj2 = obj1; id obj3 = [NSObject new]; __weak id obj4 = [[NSObject alloc] init]; NSLog(@\"obj1:%@ obj2:%@ obj3:%@ obj4:%@\",obj1,obj2,obj3,obj4);} 3.子类怎么重写父类的属性？问题简化怎么重写一个类的属性？只重写set方法可以吗？ 4.了解哪些设计模式？单例有哪些不好的地方？ 5.说一下响应者链 6.Masonry 链式调用的实现，实现一个控制器，属性的链式调用（手写） 7.打印结果： 12345678910111213141516- (void)testGCD { dispatch_queue_t queue = dispatch_queue_create(\"testqueue\", DISPATCH_QUEUE_SERIAL); dispatch_async(queue, ^{ NSLog(@\"1\"); dispatch_async(queue, ^{ NSLog(@\"2\"); dispatch_sync(queue, ^{ NSLog(@\"3\"); }); NSLog(@\"4\"); }); NSLog(@\"5\"); });} 8.项目亮点或难点","link":"/首汽租车面试题/"},{"title":"链表算法题","text":"链表算法题（ JavaScript 实现） 反转链表123456789101112function ReverseList(pHead){ let prev = null; let curr = pHead; while (curr) { const next = curr.next; curr.next = prev; prev = curr; curr = next; } return prev;} 两两交换链表中的节点1234567891011121314var swapPairs = function(head) { let dummyNode = new ListNode(0); dummyNode.next = head; let temp = dummyNode; while (temp.next != null &amp;&amp; temp.next.next != null) { let head1 = temp.next; let head2 = temp.next.next; temp.next = head2; head1.next = head2.next; head2.next = head1; temp = head1; } return dummyNode.next;}; 判断链表中是否有环123456789101112131415function hasCycle( head ) { if (head == null) { return false; } let slow = head; let fast = head; while (fast.next &amp;&amp; fast.next.next) { slow = slow.next; fast = fast.next.next; if (slow == fast) { return true; } } return false;} 环的入口结点1234567891011121314151617function detectCycle( head ) { if (!head) return null; let slow = head, fast = head; while(fast.next &amp;&amp; fast.next.next) { fast = fast.next.next slow = slow.next if (slow == fast) { var a = head; while (slow != a) { a = a.next slow = slow.next } return a; } } return null;} 链表中倒数第 k 个结点1234567891011121314151617181920212223function FindKthToTail( pHead , k ) { let length = getLength(pHead); if (length &lt; k) { return null; } let i = length - k; let p = pHead; while (i &gt; 0) { p = p.next; i--; } return p;}var getLength = function( pHead ) { let p = pHead; let length = 0; while (p != null) { p = p.next; length++; } return length;} 删除链表的倒数第 n 个节点1234567891011121314151617181920212223242526function removeNthFromEnd( head , n ) { let length = getLength(head); if (length &lt; n) { return null; } let i = length - n; let dummy = new ListNode(0); dummy.next = head; let p = dummy; while (i &gt; 0) { p = p.next; i--; } p.next = p.next.next; return dummy.next;}var getLength = function ( head ) { let length = 0; let p = head; while (p != null) { p = p.next; length ++; } return length;} 删除有序链表中重复的元素1234567891011function deleteDuplicates( head ) { let p = head; while (p != null &amp;&amp; p.next != null) { if (p.val == p.next.val) { p.next = p.next.next; } else { p = p.next; } } return head;} 交叉链表找交点123456789101112function FindFirstCommonNode(pHead1, pHead2){ if (pHead1 == null || pHead2 == null) { return null; } let p1 = pHead1, p2 = pHead2; while (p1 != p2) { p1 = p1 == null ? pHead2 : p1.next; p2 = p2 == null ? pHead1 : p2.next; } return p1;} 合并两个有序链表123456789101112131415161718192021function mergeTwoLists( l1 , l2 ) { let newHead = new ListNode(-1); let p = newHead; while(l1 != null &amp;&amp; l2 != null) { if (l1.val &lt; l2.val) { p.next = l1; l1 = l1.next; } else { p.next = l2; l2 = l2.next; } p = p.next; } if (l1 != null) { p.next = l1; } if (l2 != null) { p.next = l2; }; return newHead.next;}","link":"/链表算法题/"},{"title":"高思教育笔试题","text":"高思教育笔试题 笔试题（部分）3.下面代码输出什么？ 1234567int a = 0;void (^foo)(void) = ^{ a = 1; NSLog(@\"inner a=%d\",a);};foo();NSLog(@\"outer a=%@\",a); 4.下面代码输出什么？ 123456789- (void)viewDidLoad{ [super viewDidLoad]; NSLog(@\"1\"); dispatch_sync(dispatch_get_main_queue(),^{ NSLog(@\"2\"); }); NSLog(@\"3\");} 5.什么情况使用 weak 关键字，相比 assign 有什么不同？ 6.@property 中有哪些属性关键字？/ @property 后面可以有哪些修饰符？ 7.@synthesize 和 @dynamic 分别有什么作用？ 8.什么时候会报 unrecognized selector 的异常？ 9.能否想编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？ 10.如何用 GCD 同步若干异步调用？dispatch_barrier_async 的作用是什么？ 11.如何手动触发一个 value 的 KVO 12.Native 的 Web（WK/UI）控件和 js 的交互是如何实现的？（nativejs） 13.JavaScriptCore 框架中，native 如何调用 js？反之，js如何调用native？ 14.有阅读 Weex、ReactNative 或者 Cordova 框架的描述其一即可。","link":"/高思教育笔试题/"},{"title":"高思教育面试题","text":"高思教育面试题 笔试题笔试题 一面1、@property 本质是什么？NSString 为什么用 Copy，用 Strong 行不行？ 2、block 为什么用 copy ？ 3、block 和代理你用的哪个多？各有什么特点？ 4、GCD 的两个队列（串行、并行）有了解吗？从字面意思看，你觉得这俩哪个效率高，哪个占空间 5、类似网易新闻那种滑动切换页面你是怎么做的？我说是一个 scrollView，点击按钮后滚动到指定的 index。他说的顶部按钮是3个，如果是30个呢，会有什么问题？他说如果1个页面占用5M，30个页面就占用5x30M，会有内存问题，怎么解决这个问题？我说看过别人写的，用的是子控制器，把这些页面加到当前控制器的子控制器中。（现在想想我也是这么做的。。但是没说是这么做） 6、AFN内部看过吗？AFN的5个模块。 大概这时候问，你觉得自己是什么级别的？ 7、说一下响应者链。 8、一个约束题。 9、项目不忙的时候做过什么优化？他说发现过什么问题？他说那考虑用什么替换定时器呢？ 还做过什么优化？ 10、野指针是啥？如果又有其他指针指向了这块内存，会怎么样 12、斐波那切数列 0 1 2 3 4 5… 1 1 2 3 5 8 13 21 求n f(n) = f(n-1) + f(n-2) 复试1、怎么学的 iOS ？为什么没搞 Java 2、介绍公司情况，人员规模，介绍项目 3、说一下项目中遇到的问题，怎么解决的？ 4、说一下内存管理，怎么检测内存泄漏的？ 5、你用 OC 开发还是 Swift ？你觉得两者有啥不同？ 6、金融 App 应该有一些安全措施吧？你们是怎么做的？ 7、TCP 和 UDP 有啥区别？ 8、TCP 几次握手？过程是怎么样的？ 9、Post 请求和 Get 请求有啥区别？ 10、数据持久化都有哪些？ 11、AFN 的实现原理？SDWebImage 的实现原理？哪些存在内存，哪些存在磁盘？ 12、两个网络请求有依赖关系时，怎么处理的？ 13、同步、异步 串行、并行 14、几张图合成一张图 15、说一下 Runloop 16、KVO 的实现原理 17、不使用中间变量 实现交换两个数 swap(a, b) 18、copy 关键字修饰什么？ 19、类的私有属性，怎么设置属性值？我答了 KVC 他提到了 Runtime 20、有没有做过音频的处理？类似唱吧把原唱关掉。 21、动画了解的怎么样？ 22、了解 ARKit 吗？ 23、数据结构和算法你怎么样？冒泡排序，选择排序？","link":"/高思教育面试题/"},{"title":"字节跳动面试题","text":"字节跳动面试题 1.retain strong 区别在声明 block 时，retain 相当于 assign，strong 相当于 copy，block一般使用 copy 2.NSClassFromString 原理反射方法系统Foundation框架为我们提供了一些方法反射的 API，我们可以通过这些 API 执行将字符串转为SEL等操作。由于OC语言的动态性，这些操作都是发生在运行时的。 123456789// SEL和字符串转换FOUNDATION_EXPORT NSString *NSStringFromSelector(SEL aSelector);FOUNDATION_EXPORT SEL NSSelectorFromString(NSString *aSelectorName);// Class和字符串转换FOUNDATION_EXPORT NSString *NSStringFromClass(Class aClass);FOUNDATION_EXPORT Class __nullable NSClassFromString(NSString *aClassName);// Protocol和字符串转换FOUNDATION_EXPORT NSString *NSStringFromProtocol(Protocol *proto) NS_AVAILABLE(10_5, 2_0);FOUNDATION_EXPORT Protocol * __nullable NSProtocolFromString(NSString *namestr) NS_AVAILABLE(10_5, 2_0); 常用判断方法在NSObject类中为我们提供了一些基础方法，用来做一些判断操作，这些方法都是发生在运行时动态判断的。 12345678// 当前对象是否这个类或其子类的实例- (BOOL)isKindOfClass:(Class)aClass;// 当前对象是否是这个类的实例- (BOOL)isMemberOfClass:(Class)aClass;// 当前对象是否遵守这个协议- (BOOL)conformsToProtocol:(Protocol *)aProtocol;// 当前对象是否实现这个方法- (BOOL)respondsToSelector:(SEL)aSelector; 参考链接：iOS反射机制 3.http协议版本1、HTTP 0.9 ：（1）只接受GET一种请求方法，没有在通信中指定版本号，且不支持请求头； （2）此外该版本也不支持POST方法，因此客户端无法向服务器传递太多信息； 2、HTTP 1.0：（1）支持POST、GET、HEAD三种方法； （2）规定浏览器与服务器之间只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求； 3、HTTP 1.1：（1）新增了五种请求方法：PUT、DELETE、CONNECT、TRACE、OPTIONS； （2）HTTP 1.1 在Request消息头里头多了一个Host域，便于一台WEB服务器上可以在同一个IP地址和端口号上使用不同的主机名来创建多个虚拟WEB站点； （3）长连接 （4）缓存策略不同 （5）在HTTP/1.1中新增了24个状态响应码：100-199 用于指定客户端应相应的某些动作。200-299 用于表示请求成功。300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。400-499 用于指出客户端的错误。500-599 用于支持服务器错误。 4、HTTP 2.0 二进制传输：http 1.x 的解析是基于文本，http2的解析是基于二进制； 多路复用 header压缩 服务端推送 4.http code 206 401206 Partial Content 最后一条会话返回了HTTP/206 “Partial Content”响应.这种响应是在客户端表明自己只需要目标URL上的部分资源的时候返回的.这种情况经常发生在客户端继续请求一个未完成的下载的时候(通常是当客户端加载一个体积较大的嵌入文件,比如视频或PDF文件),或者是客户端尝试实现带宽遏流的时候。 你可以通过Range请求头辨认出一个部分内容请求.该请求头表明了客户端需要请求资源的哪一部分。 401错误原因：用户没有访问权限，需要进行身份认证。 http 常见的错误码2XX 成功 · 200 OK，表示从客户端发来的请求在服务器端被正确处理 · 204 No content，表示请求成功，但响应报文不含实体的主体部分 · 206 Partial Content，进行范围请求 3XX 重定向 · 301 moved permanently，永久性重定向，表示资源已被分配了新的 URL · 302 found，临时性重定向，表示资源临时被分配了新的 URL · 303 see other，表示资源存在着另一个 URL，应使用 GET 方法丁香获取资源 · 304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况 · 307 temporary redirect，临时重定向，和302含义相同 4XX 客户端错误 · 400 bad request，请求报文存在语法错误 · 401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息 · 403 forbidden，表示对请求资源的访问被服务器拒绝 · 404 not found，表示在服务器上没有找到请求的资源 5XX 服务器错误 · 500 internal sever error，表示服务器端在执行请求时发生了错误 · 503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求 5.为什么三次握手，四次挥手6.dispatch_async(queue,block);会不会开线程除了主队列，其他队列都开线程。 7.二叉树中和为某一值的路径LeetCode题目链接：剑指 Offer 34. 二叉树中和为某一值的路径 123456789101112131415161718class Solution { LinkedList&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) { recur(root, sum); return res; } void recur(TreeNode root, int tar) { if(root == null) return; path.add(root.val); tar -= root.val; if(tar == 0 &amp;&amp; root.left == null &amp;&amp; root.right == null) res.add(new LinkedList(path)); recur(root.left, tar); recur(root.right, tar); path.removeLast(); }} 8.Runtime9.UIView 绘制过程UIView的绘制原理 当我们调用 UIView 的 setNeedsDisplay 方法以后,实际上并没有立刻发生当前视图的绘制工作,而是在之后的某一时机才会进行当前视图的绘制 。为什么没有立刻发生当前视图的绘制工作？（因为到当前 runloop 将要结束的时候,才会开始介入到UI视图的绘制流程中） 当调用 UIView 的 setNeedsDisplay 后 系统会立刻调用 view 的 layer 的同名方法 [view.layer setNeedsDisplay] ,之后相当于在 layer 上面打上了一个脏标记 然后再当前 runloop 将要结束的时候,才会调用 CALayer 的 display 函数方法，然后才进入到当前视图的真正绘制工作的流程当中 CALayer 的 display 方法,在内部会首先判断 layer 的 delegate 是否响应 displayLayer 这个方法 若不响应,则系统开始绘制流程 若响应,则开始异步绘制 系统绘制流程 首先 CALayer 内部会创建一个 CGContextRef ,在 drawRect 方法中,可以通过上下文堆栈当中的取出这个 context，拿到的就是当前控件或者说视图的上下文或者说是 backing store 然后 layer 会判断它是否有代理，若没有,则调用 CALayer 的 drawInContext。 若有则调用代理方法,然后做当前视图的绘制工作（这一步发生在系统内部当中）,再在合适的时机,基于 drawRect 回调方法, drawRect 默认操作是什么都不做,而之所以有这个接口,就是为了让我们在系统绘制之上,可以做些自定义的绘制工作。 最后再由 CALayer 上传对应的 backing store 给 GPU,这里的 backing store 我们可以理解为位图。 异步绘制流程 左侧是主队列，右侧是全局并发队列 假如在某一时机调用了 setNeedsDiaplay 方法后 在当前 runloop 将要结束的时候,会有系统调用视图所对应 layer 的 display 方法 如果代理实现了 displayLayer 方法,会调用这个代理的 displayLayer 这个方法 然后通过子线程的切换,我们会在子线程中去做位图的绘制，此时主线程可以去做些其他的工作 然后再回到主队列中,提交这个位图,设置给 CALayer 的 contents 属性 子线程的绘制 通过 CGBitmapContextCreat 方法,来创建一个位图的上下文 通过 CoreGraphic 的相关 API,可以做当前 UI 控件的一些绘制工作 之后通过 CGBitmapContextCreatImage 方法,根据所绘制的上下文,生成一张 CGImage 图片 最后回到主队列中，将该 CGImage 图片设置为 CALayer 的 contents 参考链接：UI绘制原理&amp;系统/异步绘制流程 UIView的绘制原理及优化 10.autoreleasepool 子线程使用了 autorelease 后，如果当前线程没有 AutorelesepoolPage 的话，代码执行顺序为 autorelease -&gt; autoreleaseFast -&gt; autoreleaseNoPage。在 autoreleaseNoPage 方法中，会创建一个 hotPage ，然后调用page-&gt;add(obj) 。也就是说即使这个线程没有 AutorelesepoolPage ，使用了 autorelease 对象时也会 new 一个 AutoreleasepoolPage 出来管理 autorelese 对象。 子线程的 autoreleasepool 是在线程销毁的时候释放的。 11.VC生命周期，viewWillDisappear 和 viewDidDisappear 之间会不会调用view 的 layoutpush 会调用，pop 不会调用 12345678910111 push 22-[2 loadView]2-[2 viewDidLoad]1-[1 viewWillDisappear:]2-[2 viewWillAppear:]2-[2 viewWillLayoutSubviews]2-[2 viewDidLayoutSubviews]1-[1 viewWillLayoutSubviews]1-[1 viewDidLayoutSubviews]1-[1 viewDidDisappear:]2-[2 viewDidAppear:] 12.autorelease 调用 release 会立即销毁吗13.GCD能不能取消任务 dispatch_block_cancel 定义外部变量，用于标记block是否需要取消 参考链接：如何取消GCD任务","link":"/字节跳动面试题/"},{"title":"小米面试题及答案","text":"小米面试题 1.说说你了解的设计模式。说说你了解的设计原则。设计模式的六大原则1、开闭原则（Open Close Principle） 开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。 2、里氏代换原则（Liskov Substitution Principle） 里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。 3、依赖倒转原则（Dependence Inversion Principle） 这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。 4、接口隔离原则（Interface Segregation Principle） 这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。 5、迪米特法则，又称最少知道原则（Demeter Principle） 最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。 6、合成复用原则（Composite Reuse Principle） 合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。 设计模式装饰模式：在不改变原封装的前提下，为对象动态添加新功能的模式。在 Objective-C 中，它的实现形式为 Category 和 Delegation；在 Swift 中，它的实现形式为 Extension 和 Delegation。 观察者模式：通知、KVO 备忘录模式：保存对象当前的状态，并在日后可以恢复的模式。用 UserDefaults 来读写，同时配合栈可以存储一系列状态。它经常用于初始化、重启、App 前后台状态改变等场景。 工厂模式 单例模式 2.什么是队列？同步异步是什么？GCD与NSOperation的相同与不同，使用场景。GCD的队列可以分为2大类型并发队列（Concurrent Dispatch Queue） 可以让多个任务并发（同时）执行（自动开启多个线程同时执行任务） 并发功能只有在异步（dispatch_async）函数下才有效 串行队列（Serial Dispatch Queue） 让任务一个接着一个地执行（一个任务执行完毕后，再执行下一个任务） 同步和异步主要影响：能不能开启新的线程 同步：在当前线程中执行任务，不具备开启新线程的能力 异步：在新的线程中执行任务，具备开启新线程的能力 并发和串行主要影响：任务的执行方式 并发：多个任务并发（同时）执行 串行：一个任务执行完毕后，再执行下一个任务 并发队列 手动创建的串行队列 主队列 同步（sync） 没有开启新线程，串行执行任务 没有开启新线程，串行执行任务 没有开启新线程，串行执行任务 异步（async） 有开启新线程，并发执行任务 有开启新线程，串行执行任务 没有开启新线程，串行执行任务 使用sync函数往当前串行队列中添加任务，会卡住当前的串行队列（产生死锁） 3.Block，本质，指针引用，值引用，变量捕获（static和auto），__weak __block12345NSMutableArray *array = nil;void(^Block)(void) = ^{ array = [NSMutableArray array];};Block(); 有什么问题？局部变量是值捕获，不能在block内部修改。 12345NSMutableArray *array = [NSMutableArray array];void(^Block)(void) = ^{ [array addObject:\"1\"];};Block(); 有什么问题？没问题，可以添加元素 4.交叉链表找交点123456789101112function FindFirstCommonNode(pHead1, pHead2){ if (pHead1 == null || pHead2 == null) { return null; } let p1 = pHead1, p2 = pHead2; while (p1 != p2) { p1 = p1 == null ? pHead2 : p1.next; p2 = p2 == null ? pHead1 : p2.next; } return p1;} 5.性能优化，启动优化性能优化 cell复用，header、footer复用。 尽量把view设置不透明。 减少视图的层级。 尽量避免调整视图层次、添加和移除视图。 合理选择加载图片的方式，UIImage imageNamed: ImageAssets 用于多个地方重复使用，UIImage imageWithContentsOfFile 一般用在图片数据很大，一般不需要多次使用的情况。 图片大小最好和UIImageView的大小相同。 不要阻塞主线程，耗时操作放在子线程进行。 懒加载。 缓存，缓存图片SDWebImage，缓存行高，NSCache缓存。 复用高开销对象NSDateFormatter和NSCalendar。 减少离屏渲染，优化圆角、阴影。 使用正确的数据存储。 启动优化 将一些耗时操作延迟执行。比如SDK的初始化，界面的创建。 不能延迟执行的，尽量放到后台执行。比如数据读取，原始 JSON 数据转对象，日志发送。 减少动态库、合并动态库，定期清理不必要的动态库。 减少类、分类的数量，合并Category和功能类似的类。删除不必要的方法和类、分类。 将不必须在+load中做的事延时到+initialize中。 6.谈谈https 一个HTTPS请求实际上包含了两次HTTP传输： 1）客户端发起一个http请求，连接到服务器的443端口。 2）服务端把自己的信息以数字证书的形式返回给客户端（证书内容有密钥公钥，网站地址，证书颁发机构，失效日期等）。证书中有一个公钥来加密信息，私钥由服务器持有。 3）验证证书的合法性 客户端收到服务器的响应后会先验证证书的合法性（证书中包含的地址与正在访问的地址是否一致，证书是否过期）。 4）生成随机密码（RSA签名） 如果验证通过，或用户接受了不受信任的证书，浏览器就会生成一个随机的对称密钥（session key）并用公钥加密，让服务端用私钥解密，解密后就用这个对称密钥进行传输了，并且能够说明服务端确实是私钥的持有者。 5）生成对称加密算法 验证完服务端身份后，客户端生成一个对称加密的算法和对应密钥，以公钥加密之后发送给服务端。此时被黑客截获也没用，因为只有服务端的私钥才可以对其进行解密。之后客户端与服务端可以用这个对称加密算法来加密和解密通信内容了。 6）客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器。 7）服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。 8）然后服务器将加密后的密文发送给客户端。 9）客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成。 7.说说响应链能够响应触摸事件的例如UIView，UIButton，UIViewController，UIApplication，Appdelegate等都继承自UIResponder类，一个页面上通常会有许许多多个这种类型的对象，都可以对点击事件作出响应。为了避免冲突，这就需要有一个先后顺序，也就是响应的优先级。Hit-Testing的目的就是找到具有最高优先级的响应对象。寻找的具体流程如下： UIApplication首先将事件队列中的事件取出，传递给窗口对象。如果有多个窗口，则优先询问windows数组的最后一个窗口。 如果窗口不能响应事件，则将事件传递给倒数第二个窗口，以此类推。如果窗口能够响应事件，则再依次询问该窗口的子视图。 重复步骤2。 若视图的所有子视图均不是最佳响应者，则自身就是最合适的响应者。另外需要注意的是，一下几种状态的视图无法响应事件： 不允许交互的视图：userInteractionEnabled = NO 隐藏的视图：hidden = YES 透明度alpha&lt;0.01的视图 怎么样验证一下上面所说的Hit-Testing的顺序呢，看一下UIView的API，里面会有一个hitTest：withEvent：方法，这个方法的主要作用就是查询并返回事件在当前视图中的响应者，每个被询问到的视图对象都会调用这个方法来返回当前视图层的响应者。 如果当前视图无法响应事件，则返回nil。 如果当前视图可以响应事件，但子视图不能响应事件，则返回自身作为当前视图的响应者。 如果当前视图可以响应事件，同时有子视图可以响应事件，则返回该子视图作为当前视图的响应者。 8.你知道哪些锁？（自旋锁，互斥锁）使用场景都有哪些？os_unfair_lockOSSpinLockdispatch_semaphorepthread_mutexNSLockNSConditionpthread_mutex(recursive)NSRecursiveLockNSConditionLock@synchronized 线程同步","link":"/小米面试题/"},{"title":"滴滴出行面试题及答案","text":"滴滴出行面试题 1. 笔试题0.姓名？日期。1.C语言实现字符串反转：void reverse(char *str, int length) {}123456789101112131415void reverse(char *str, int length) { char *start, *end, t; start = str; end = &amp;str[length - 1]; while(start &lt; end) { t = *start; *start = *end; *end = t; start++; end--; } for (int i = 0; str[i]; i++) { printf(\"%c\",str[i]); }} 2.实现一个字符串数组去重函数。123456789101112var str_arr = [\"b\",\"c\",1,\"a\", 3,\"v\", \"2\",\"e\", \"6\",\"g\", \"9\", \"arr\",9, \"hello\",\",6\", \"9\", \"1\", 2, 6, \"b\", \"c\"];function unique(arr) { var map = {}, array = []; for (var i = 0; i &lt; arr.length; i++) { var key = arr[i] + typeof arr[i]; if (map[key] == null) { map[key] = true; array.push(arr[i]); } } return array;} 3.描述OC中对象的实现原理。12345@interface NSObject { Class isa;}@endtypedef struct objc_class *Class; NSObject对象内部存放了一个名叫isa的指针，指向了一个结构体struct objc_class 一个NSObject对象占用多少内存？ 1）系统分配了16字节给NSObject对象（通过malloc_size函数可以获得） 2）NSObject对象内部只使用了8个字节的空间，用来存放isa指针变量（64位系统下，可以通过class_getInstanceSize函数获得） 4.编写代码，实现 NSObject 中添加一个属性 p112345678910111213141516171819202122@interface NSObject (TestProperty)@property (nonatomic, copy) NSString *p1;@end #import &quot;NSObject+TestProperty.h&quot;#import &lt;objc/runtime.h&gt;@implementation NSObject (TestProperty)- (void)setP1:(NSString *)p1 { objc_setAssociatedObject(self, @selector(p1), p1, OBJC_ASSOCIATION_RETAIN_NONATOMIC);}- (NSString *)p1 { objc_getAssociatedObject(self, @selector(p1));}@end 5.KVO 的实现原理和注意事项。1) 利用RuntimeAPI动态生成一个子类，并且让instance对象的isa指向这个全新的子类2) 当修改instance对象的属性时，会调用Foundation的_NSSetXXXValueAndNotify函数 1234willChangeValueForKey:父类原来的setterdidChangeValueForKey:内部会触发监听器（Oberser）的监听方法( observeValueForKeyPath:ofObject:change:context:） 注意事项：需要调用set方法触发KVO 6.下面的代码有哪些问题？123456789101112131415@interface Demo : NSObject@property (nonatomic, assign) BOOL *p1;@property (nonatomic, strong) NSString *p2;@end@implementation Demo@dynamic p1;- (void)setP2:(NSString *)p2;{ self.p1 = YES; self.p2 = p2;}@end BOOL p1不应该带*。 self.p2 = p2; 调用set方法死循环。 p1没有set方法。 p2最好用copy修饰。 7.JS 和 Native 的通讯方式。方法一：拦截URL 方法二：注册OC与JS方法 12345678910111213141516171819202122232425262728- （void）webViewDidFinishLoad:(UIWebView *)webView { // 获取当前网页的标题 NSString *titleStr = [webView stringByEvaluatingJavaScriptFromString:@&quot;document.title&quot;]; NSLog(@&quot;%@&quot;,titleStr); // 还可以直接调用js定义的方法 // 比如getShareUrl()为js端定义好的方法，返回值为分享的url // 我们就可以通过调用这个方法在returnStr中拿到js返回的分享地址 NSString *returnStr = [webView stringByEvaluatingJavaScriptFromString:@&quot;getShareUrl()&quot;]; NSLog(@&quot;%@&quot;,returnStr); // 还可以为js端提供完整的原生方法供其调用（记得导入#import ） JSContext *context = [webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;]; // 可以定义供js调用的方法, testMethod为js调用的方法名 context[@&quot;testMethod&quot;] = ^() { dispatch_async(dispatch_get_main_queue(), ^{ UIAlertView *alert = [[UIAlertView alloc]initWithTitle:@&quot;&quot; message:@&quot;js调用方法&quot; delegate:nil cancelButtonTitle:@&quot;取消&quot; otherButtonTitles:nil, nil]; [alert show]; }); }; 方法三：桥接机制 OC和JS交互的桥接机制，主要包含3个类，JS端window.WebViewJavascriptBridge，OC端WebViewJavascriptBridge和WebViewJavascriptBridgeBase。 桥接类支持JS调用OC方法，OC调用JS方法。JS调用OC通过重定向url并取handlerName来调用，OC调用JS通过stringByEvaluatingJavaScriptFromString调用。 8.网络5层模型是哪5层？应用层、传输层、网络层、数据链路层、物理层 9.把t1表中 name 为 mike 的记录中 status 值改为11update t1 set status = 1 where name = mike 10.常用的 Linux 命令。cd 进入指定的目录 cd .. 返回上一级目录 ls 查看当前目录下的所有的目录与文件名 touch filename 表示创建一个文件 mkdir dirname 表示创建一个目录 rm filename 表示删除一个文件 rm -rf dirname 表示删除该目录及其所有的子级目录一起删掉 ctrl+c 强制终止，不会终止进程 sudo 以管理员身份运行上一个命令 :q 退出 :q! 强制退出 :wq 保存并退出 11.用过的包/库管理工具。CocoaPods 2. 一面1、说一下你觉得项目中遇到了什么印象深刻的问题，你是怎么解决的？2、大学里学了哪些课？信息管理与信息系统专业是哪个学院的？3、项目里的网络请求用到了网络5层模型的哪些，TCP/IP 属于哪一层？HTTP 呢？TCP/IP属于传输层 HTTP属于应用层 4、你觉得自己是什么级别的？优势和不足主要是哪方面？5、GCD 平时项目里怎么用的？dispatch_get_mainQueue：获取主线程 dispatch_sync：同步操作 dispatch_group：线程同步 dispatch_barrier：多读单写 dispatch_semaphore：加锁，控制并发数 dispatch_once：只执行一次 dispatch_after：延时执行 6、为什么操作 UI 需要在主线程？因为UIKit不是线程安全的。如果不在主线程中操作UI，可能会造成如下的情况：（1）两个线程同时设置同一个背景图片，那么很有可能因为当前图片被释放了两次而导致应用崩溃。（2）两个线程同时设置同一个UIView的背景颜色，那么很有可能渲染显示的是颜色A，而此时在UIView逻辑树上的背景颜色属性为B。（3）两个线程同时操作view的树形结构：在线程A中for循环遍历并操作当前View的所有subView，然后此时线程B中将某个subView直接删除，这就导致了错乱还可能导致应用崩溃。虽然，iOS4之后苹果将大部分绘图的方法和诸如 UIColor 和 UIFont 这样的类改写为了线程安全可用，但是仍然强烈建议将UI操作保证在主线程中执行。 7、哪些是你独立开发的项目？8、问了一下上家公司的情况9、之后有什么打算？10、上家薪资多少？你还有啥想问的吗？3. 二面1、自定义封装控件需要注意什么？有什么规范？ 头文件尽量不要过多引入其他的类,解耦合 如果使用了第三方框架, 不要在头文件引入改类 切记, 不要暴露第三方组件的任何属性,枚举等等 定义该类的常量,方便修改 尽量不要引入其他项目中的类,除了一些必要的分类,业务类尽量不要引入 Frame布局 使用分类 UIView+Helper 尽量不要暴露成员变量或者属性,除非有必要, 其余情况最好提供接口进行操作. 注意属性的可读。 封装的工具类 注意如果是分类可以实现的尽量迁移到分类中, 并且命名 最好以dd_ 开头, 例如-(void)dd_layoutWithDirection:(DDImageDirection)imageDirection ,之所以这样是因为,OC没有命名空间,后加载的分类可以覆盖掉前面的同名方法. 而且一旦和系统方法重名将造成巨大的bug 注意 驼峰命名原则,类,协议,代理属性，命名首字母大写,最好添加DD类前缀 2、说一下你了解的设计模式。设计模式的六大原则1、开闭原则（Open Close Principle） 开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。 2、里氏代换原则（Liskov Substitution Principle） 里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。 3、依赖倒转原则（Dependence Inversion Principle） 这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。 4、接口隔离原则（Interface Segregation Principle） 这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。 5、迪米特法则，又称最少知道原则（Demeter Principle） 最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。 6、合成复用原则（Composite Reuse Principle） 合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。 设计模式装饰模式、工厂模式、单例模式、观察者模式、备忘录模式。 3、数据库怎么优化？我说数据量大的话加索引提升查询效率。问其他优化呢？比如数据库大小有没有做过优化？（1）根据服务层面：配置mysql性能优化参数； （2）从系统层面增强mysql的性能：优化数据表结构、字段类型、字段索引、分表，分库、读写分离等等。 （3）从数据库层面增强性能：优化SQL语句，合理使用字段索引。 （4）从代码层面增强性能：使用缓存和NoSQL数据库方式存储，如MongoDB/Memcached/Redis来缓解高并发下数据库查询的压力。 （5）减少数据库操作次数，尽量使用数据库访问驱动的批处理方法。 （6）不常使用的数据迁移备份，避免每次都在海量数据中去检索。 （7）提升数据库服务器硬件配置，或者搭建数据库集群。 （8）编程手段防止SQL注入：使用JDBC PreparedStatement按位插入或查询；正则表达式过滤（非法字符串过滤）； 4、内存优化是怎么做的？什么情况会发生内存泄漏？ 减少内存泄漏。 降低内存使用峰值。 懒加载。 灵活运用图片和文件加载。 拉长文件处理机制，逐步处理文件。 5、App 启动时间优化？ 将一些耗时操作延迟执行。比如SDK的初始化，界面的创建。 不能延迟执行的，尽量放到后台执行。比如数据读取，原始 JSON 数据转对象，日志发送。 减少动态库、合并动态库，定期清理不必要的动态库。 减少类、分类的数量，合并Category和功能类似的类。删除不必要的方法和类、分类。 将不必须在+load中做的事延时到+initialize中。 6、视图做过哪些优化，我提了 TableView。那就以 TableView 说一下优化了哪些方面？ cell复用，header、footer复用。 尽量把view设置不透明。 减少视图的层级。 尽量避免调整视图层次、添加和移除视图。 合理选择加载图片的方式，UIImage imageNamed: ImageAssets 用于多个地方重复使用，UIImage imageWithContentsOfFile 一般用在图片数据很大，一般不需要多次使用的情况。 图片大小最好和UIImageView的大小相同。 不要阻塞主线程，耗时操作放在子线程进行。 懒加载。 缓存，缓存图片SDWebImage，缓存行高，NSCache缓存。 复用高开销对象NSDateFormatter和NSCalendar。 减少离屏渲染，优化圆角、阴影。 使用正确的数据存储。 7、AFNetworking 内部是怎么样的一个过程？8、你还有什么想问我的？","link":"/滴滴出行面试题及答案/"},{"title":"猿辅导面试题","text":"猿辅导面试题 1.@[]; 加入 nil 会闪退吗会闪退，报错： 1-[__NSPlaceholderArray initWithObjects:count:]: attempt to insert nil object from objects[4] 2.array[i] 会不会走 objectAtIndex会走。 array[i] 如果数组越界，会崩溃报错： 1[__NSArrayI objectAtIndexedSubscript:]: index 6 beyond bounds [0 .. 4]' 3.信号量 3 个网络接口返回执行 4有些时候，我们需要阻塞发送请求的线程，比如在多个请求回调后统一操作的需求，而这些请求之间并没有顺序关系，且这些接口都会另开线程进行网络请求的。一般地，这种多线程完成后进行统一操作的需求都会使用队列组(dispatch_group_t)来完成，但是由于是异步请求，没等其异步回调之后，请求的线程就结束了，为此，就需要使用信号量来阻塞住发请求的线程。实现代码如下： 12345678dispatch_async(queue, 0), ^{ dispatch_semaphore_t sema = dispatch_semaphore_create(0); [网络请求:^{ //请求回调 dispatch_semaphore_signal(sema); }]; dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER);}); 这样，请求的线程就可以等到回调结束后再结束了，再配合队列组就能完成上述的需求。这种技巧可用于以下场景： 多个请求结束后统一操作 多个请求顺序执行 4.hook delelgate 方法参考链接：iOS hook delegate 5.交换方法传入参数 为什么需要先 addMethod12345678910111213141516171819+ (void)exchangeInstanceMethodWithSelfClass:(Class)selfClass originalSelector:(SEL)originalSelector swizzledSelector:(SEL)swizzledSelector { Method originalMethod = class_getInstanceMethod(selfClass, originalSelector); Method swizzledMethod = class_getInstanceMethod(selfClass, swizzledSelector); BOOL didAddMethod = class_addMethod(selfClass, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); if (didAddMethod) { class_replaceMethod(selfClass, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); } else { method_exchangeImplementations(originalMethod, swizzledMethod); }} 防止影响父类的方法。 init 方法并不是 Person 类本身的实例（对象）方法，而是父类 NSObject 的方法。由于 Person 本身没有该方法，所以 class_getInstanceMethod 获取到的方法是通过 Person 的 superclass 指针从 NSObject 类中获取到了 init 这个方法。 method_exchangeImplementations 操作将 NSObject 的 init 方法的实现与 Person 类的 yxc_init 方法的实现进行互换了，这时候调用 init 方法实际上是调用了 yxc_init 方法。 创建一个 Person 对象时，调用 init 方法，运行时会去查找 yxc_init 的实现，因为 yxc_init 方法是 Person 自身的方法，所以查找到了直接调用。（消息发送机制） 而创建一个 NSObject 对象时，调用 init 方法，运行时去查找 yxc_init 方法的时候，NSObject 是没有这个方法，这个方法存在于 Person 类中，所以查找完毕，还是找不到这个方法，就抛异常了。 正确的 hook 做法是，先将 init 方法添加到 Person 类中，如果这个类当前有这个方法（而不是父类），则不添加，直接 exchange，否则添加了 init 方法，然后再将 yxc_init 方法的实现设置成 init 方法的实现。 参考链接：iOS Runtime 黑魔法方法交换(Method swizzling) 6.关联对象有几种策略，如何实现 weak在关联对象释放的时候，调用objc_setAssociatedObject(object, key, nil, OBJC_ASSOCIATION_ASSIGN)这样就把宿主对象的该 key 的关联对象清除了，外部读这个 key 的关联对象就是 nil 1234567891011extern void objc_setWeakAssociatedObject(id _Nonnull object, const void * _Nonnull key, id _Nullable value);void objc_setWeakAssociatedObject(id _Nonnull object, const void * _Nonnull key, id _Nullable value) { if (value) { //__weak typeof(object) weakObj = object; [value hc_doSthWhenDeallocWithBlock:^(NSObject *__unsafe_unretained _Nonnull target) { objc_setAssociatedObject(object, key, nil, OBJC_ASSOCIATION_ASSIGN); // clear association }]; } objc_setAssociatedObject(object, key, value, OBJC_ASSOCIATION_ASSIGN); // call system imp} 参考链接：OC-AssociatedObject原理及weak关联对象的实现 7.响应者链 button 超出父视图一半能否响应点击事件超出父视图的部分不能响应，在父视图内的部分可以响应。 如何扩大按钮的点击范围？ 可以重写 button 的 pointInside: 方法 12345678- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event { // 当前btn的大小 CGRect btnBounds = self.bounds; // 扩大按钮的点击范围，改为负值 btnBounds = CGRectInset(btnBounds, -15, -15); // 若点击的点在新的bounds里，就返回YES return CGRectContainsPoint(btnBounds, point);} 8.离屏渲染，为什么会触发参考链接：知乎-关于iOS离屏渲染的深入研究 简书-iOS离屏渲染产生的原因 9.判断当前任务在哪个 queue 中dispatch_queue_get_label 参考链接：判断代码在哪个队列中运行 10.SDWebImage 内存缓存怎么实现的参考链接：iOS-SDWebImage缓存机制 11.json 转 model，Runtime 能否获取到自定义属性的类型class_copyPropertyList可以获取到属性列表 property_getName可以获取到属性名 property_getAttributes可以获取到成员类型 12.tableView 快速滑动 卡顿发生可能原因1.提前计算并缓存好高度，因为 heightForRow 最频繁的调用。 - (UITableViewCell)tableView:(UITableView)tableView cellForRowAtIndexPath:(NSIndexPath*)indexPath; 2.异步绘制，遇到复杂界面，性能瓶颈时，可能是突破口。 3.滑动时按需加载，这个在大量图片展示，网络加载时，很管用。（SDWebImage 已经实现异步加载）。 4.重用 cells。 5.如果 cell 内显示得内容来自 web，使用异步加载，缓存结果请求。当 cell 中的部分 View 是非常独立的，并且不便于重用的，而且“体积”非常小，在内存可控的前提下，我们完全可以将这些 view 缓存起来。当然也是缓存在模型中。 6.少用或不用透明图层，使用不透明视图。对于不透明的 View，设置 opaque 为 YES，这样在绘制该 View 时，就不需要考虑被 View 覆盖的其他内容（尽量设置 Cell 的 view 为 opaque，避免 GPU 对 Cell 下面的内容也进行绘制） 7.减少 subViews。分析 Cell 结构，尽可能的将 相同内容的抽取到一种样式 Cell 中，前面已经提到了 Cell 的重用机制，这样就能保证 UITbaleView 要显示多少内容，真正创建出的 Cell 可能只比屏幕显示的 Cell 多一点。虽然 Cell 的’体积’可能会大点，但是因为 Cell 的数量不会很多，完全可以接受的 8.少用 addView 给 cell 动态添加 view，可以初始化的时候就添加，然后通过 hide 控制是否显示。 13.括号算法LeetCode 题目链接：括号生成 14.CocoaPods 缓存存在哪里，pod install 执行~/Library/Caches/Cocoapods","link":"/猿辅导面试题/"},{"title":"百度知道面试题","text":"百度知道面试题 一面1.属性关键字，在 ARC、MRC下分别用什么关键字，copy 修饰 NSString，可变字符串用什么修饰？block 用什么修饰？能不能用 strong 修饰？assign 能修饰对象吗？unsafe_unretain 有什么作用？ 2.block，有几种 block，__weak __block，__block 修改局部变量的值原理，只把局部变量变成结构体就可以了吗？ 3.多线程都用过哪些？NSOperation 了解吗？GCD 怎么开一个线程 4.什么是死锁，举例说明为什么会死锁 5.内存都有哪些区域？哪些是在栈上，哪些是在堆上？局部变量存在哪里？ 6.+load 父类、子类调用顺序？分类的 +load 会调用吗？项目里有用到 +load 吗？initialize 7.Category 实现了本类的同名方法，有没有办法来调用本类的方法？ 8.单链表是否有环 9.两个链表是否相交（怎么判断是否相交？怎么找交点） 10.两个字符串的最长相同子串的长度 二面1.较难定位的 Crash 怎么定位？怎么判断是 OOM 导致的 Crash 还是其他导致的 Crach？ 2.Jenkins+Fastlane 实现 CI，自动化的流程除了打包还能做什么？ 3.Flutter 和原生开发你觉得有什么差异 4.HTTPDNS，使用和不使用有什么区别？有什么好处？ 5.通知是同步的还是异步的，异步的通知什么时候会发出去，通知的原理，通知如何存储，多次添加通知，多次移除通知会有问题吗？ 6.屏幕显示的流程，CPU/GPU，离屏渲染是什么？光栅化的过程 7.安装包大小优化做了哪些？段迁移了解吗？ 8.App 启动系统做了哪些事情，怎么优化启动速度 9.tableView 滑动流畅性优化 10.从点击屏幕到响应事件的流程 11.UIView 和 CALayer 的关系，为什么要这么设计 12.autoreleasePool 的原理，设计成双向链表有什么好处 13.最有成就感的项目，组件化的好处 14.如果 Code Review，你会关注哪些东西？ 15.相对其他团队成员的优势 16.分享会怎么做，如果听众有 PM/测试，会怎么分享 17.团队里有成员不是特别优秀，怎么把控进度 18.了解百度的技术职级吗？你觉得自己是T几？ 参考答案一面1.属性关键字，在 ARC、MRC下分别用什么关键字，copy 修饰 NSString，可变字符串用什么修饰？block 用什么修饰？能不能用 strong 修饰？assign 能修饰对象吗？unsafe_unretain 有什么作用？ 2.block，有几种 block，__weak __block，__block 修改局部变量的值原理，只把局部变量变成结构体就可以了吗？ 3.多线程都用过哪些？NSOperation 了解吗？GCD 怎么开一个线程 4.什么是死锁，举例说明为什么会死锁 死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。 四个必要条件 互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。 请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。 不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。 环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。 举例： 123456- (void)viewDidLoad { [super viewDidLoad]; dispatch_sync(dispatch_get_main_queue(), ^{ NSLog(@\"1\"); });} dispatch_sync 同步，阻塞当前线程，即阻塞主线程。block 又在等主线程里的 viewDidLoad 执行完，从而形成了主线程等待主线程，造成死锁。 参考链接：百度百科-死锁 5.内存都有哪些区域？哪些是在栈上，哪些是在堆上？局部变量存在哪里？ 代码段 数据段 栈 堆 内核区 栈区：局部变量和实参 堆区：OC 中使用 new 方法创建的对象 6.+load 父类、子类调用顺序？分类的 +load 会调用吗？项目里有用到 +load 吗？initialize先调用父类，后调用子类，再调用分类。 +load 调用顺序 1.先调用类的 +load 按照编译先后顺序调用（先编译，先调用） 调用子类的 +load 之前会先调用父类的 +load 2.再调用分类的 +load 按照编译先后顺序调用（先编译，先调用） +initialize方法会在类第一次接收到消息时调用。+initialize 调用顺序： 先调用父类的+initialize，再调用子类的+initialize (先初始化父类，再初始化子类，每个类只会初始化1次) 7.Category 实现了本类的同名方法，有没有办法来调用本类的方法？Category 实现了本类的同名方法，会调用 Category 的同名方法。 8.单链表是否有环123456789101112131415function hasCycle( head ) { if (head == null) { return false; } let slow = head; let fast = head; while (fast.next &amp;&amp; fast.next.next) { slow = slow.next; fast = fast.next.next; if (slow == fast) { return true; } } return false;} 9.两个链表是否相交（怎么判断是否相交？怎么找交点）1234567891011121314151617function FindFirstCommonNode(pHead1, pHead2){ let mySet = new Set(); let p1 = pHead1; while (p1) { mySet.add(p1); p1 = p1.next; } let p2 = pHead2; while (p2) { if (mySet.has(p2)) { return p2; } p2 = p2.next; } return null;} 10.两个字符串的最长相同子串的长度题目链接：NC127 最长公共子串 123456789101112131415function LCS( str1 , str2 ) { if (str1.length &gt; str2.length) { [str1, str2] = [str2, str1]; } let res = \"\"; let len = 0; for (let i = 0; i &lt; str1.length; i++) { let temp = str1.slice(i-len,i+1); if (str2.indexOf(temp) !== -1) { res = temp; len++; } } return res;} 二面1.较难定位的 Crash 怎么定位？怎么判断是 OOM 导致的 Crash 还是其他导致的 Crach？ 2.Jenkins+Fastlane 实现 CI，自动化的流程除了打包还能做什么？ 3.Flutter 和原生开发你觉得有什么差异 4.HTTPDNS，使用和不使用有什么区别？有什么好处？ 5.通知是同步的还是异步的，异步的通知什么时候会发出去，通知的原理，通知如何存储，多次添加通知，多次移除通知会有问题吗？ 6.屏幕显示的流程，CPU/GPU，离屏渲染是什么？光栅化的过程 7.安装包大小优化做了哪些？段迁移了解吗？ 8.App 启动系统做了哪些事情，怎么优化启动速度 9.tableView 滑动流畅性优化 10.从点击屏幕到响应事件的流程 11.UIView 和 CALayer 的关系，为什么要这么设计 12.autoreleasePool 的原理，设计成双向链表有什么好处 13.最有成就感的项目，组件化的好处 14.如果 Code Review，你会关注哪些东西？ 15.相对其他团队成员的优势 16.分享会怎么做，如果听众有 PM/测试，会怎么分享 17.团队里有成员不是特别优秀，怎么把控进度 18.了解百度的技术职级吗？你觉得自己是T几？","link":"/百度知道面试题/"},{"title":"美团优选面试题及答案","text":"美团优选面试题 技术栈是怎么选择的？为什么选择Flutter，没有选择RN Flutter 与 React Native 的对比分析 1.链表环的入口结点（限制15分钟）算法1：遍历链表，使用Set去存一下 1234567891011function detectCycle( head ) { const visited = new Set(); while (head != null) { if (visited.has(head)) { return head; } visited.add(head); head = head.next; } return null;} 算法2：快慢指针 1234567891011121314151617function detectCycle( head ) { if (!head) return null; let slow = head, fast = head; while(fast.next &amp;&amp; fast.next.next) { fast = fast.next.next slow = slow.next if (slow == fast) { var a = head; while (slow != a) { a = a.next slow = slow.next } return a; } } return null;} 2.首页的轮播图，滑动主区域 timer会不会停止？Timer会停止。因为滑动时Runloop的mode由原来的DefaultMode切换到了UITrackingRunLoopMode。同一时间只能有一种mode。 解决方法其一是将timer加入到NSRunloopCommonModes中。其二是将timer放到另一个线程中，然后开启另一个线程的runloop，这样可以保证与主线程互不干扰，而现在主线程正在处理页面滑动。示例代码如下： 1234567// 方法1[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];// 方法2dispatch_async(dispatch_get_global_queue(0, 0), ^{timer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(repeat:) userInfo:nil repeats:true];[[NSRunLoop currentRunLoop] run];}); 3.滑动屏幕，从响应者的角度和手势的角度来分析系统做了什么事情从手指触摸屏幕，触摸事件的传递大概经历了3个阶段，系统响应阶段–&gt;SpringBoard.app处理阶段–&gt;前台App处理阶段，大致的流程如下图： 起始阶段 cpu处于睡眠阶段，等待事件发生 手指触摸屏幕 系统响应阶段 屏幕感应到触摸事件，并将感应到的事件传递给IOKit(用来操作硬件和驱动的框架) IOKit.framework封装整个触摸事件为IOHIDEvent对象，直接通过mach port(Mach属于硬件层，仅提供了诸如处理器调度、IPC进程通信等非常少量的基础服务。)转发给SpringBoard.app。 SpringBoard.app处理阶段 SpringBoard.app的主线程Runloop收到IOKit.framework转发来的消息苏醒，并触发对应mach port的Source1回调__IOHIDEventSystemClientQueueCallback()。 如果SpringBoard.app监测到有App在前台(记为xxx.app)，SpringBoard.app再通过mach port转发给xxx.app，如果SpringBoard.app监测到前台没有App运行，则SpringBoard.app进入App内部响应阶段，触发自身主线程runloop的Source0时间源的回调。 SpringBoard.app是一个系统进程，可以理解为桌面系统，可以统一管理和分发系统接收到的触摸事件。 App内部响应阶段 前台App主线程Runloop收到SpringBoard.app转发来的消息而苏醒，并触发对应mach port的Source1回调__IOHIDEventSystemClientQueueCallback()。 Source1回调内部，触发Source0回调__UIApplicationHandleEventQueue() Source0回调内部，封装IOHIDEvent为UIEvent。 Source0回调内部，调用UIApplication的sendEvent:方法，将UIEvent传给UIWindow，接下来就是寻找最佳响应者的过程，也就是命中测试hit-testing。 寻找到最佳响应者后，接下来就是事件在响应链中的传递和响应了。需要注意的是，事件除了可以被响应者处理之外，还有可能被手势识别器或者target-action捕捉并处理，这涉及到一个优先级的问题。如果触摸事件在响应链中没有找到能够响应该事件的对象，最终将被释放。 事件被处理或者释放之后，runloop如果没有其他事件进行处理，将会再次进入休眠状态。 寻找事件的最佳响应者(Hit-Testing)能够响应触摸事件的例如UIView，UIButton，UIViewController，UIApplication，Appdelegate等都继承自UIResponder类，一个页面上通常会有许许多多个这种类型的对象，都可以对点击事件作出响应。为了避免冲突，这就需要有一个先后顺序，也就是响应的优先级。Hit-Testing的目的就是找到具有最高优先级的响应对象。寻找的具体流程如下： UIApplication首先将事件队列中的事件取出，传递给窗口对象。如果有多个窗口，则优先询问windows数组的最后一个窗口。 如果窗口不能响应事件，则将事件传递给倒数第二个窗口，以此类推。如果窗口能够响应事件，则再依次询问该窗口的子视图。 重复步骤2。 若视图的所有子视图均不是最佳响应者，则自身就是最合适的响应者。另外需要注意的是，一下几种状态的视图无法响应事件： 不允许交互的视图：userInteractionEnabled = NO 隐藏的视图：hidden = YES 透明度alpha&lt;0.01的视图 怎么样验证一下上面所说的Hit-Testing的顺序呢，看一下UIView的API，里面会有一个hitTest：withEvent：方法，这个方法的主要作用就是查询并返回事件在当前视图中的响应者，每个被询问到的视图对象都会调用这个方法来返回当前视图层的响应者。 如果当前视图无法响应事件，则返回nil。 如果当前视图可以响应事件，但子视图不能响应事件，则返回自身作为当前视图的响应者。 如果当前视图可以响应事件，同时有子视图可以响应事件，则返回该子视图作为当前视图的响应者。 参考链接：iOS触摸事件处理 扩展阅读：UIButton在执行动画的时候,点击事件不响应的解决办法 4.网络请求回来后，回到主线程刷新UI，为什么有时候会延迟？主线程的RunLoop可能当时在处理的任务比较重，需要执行完后再执行刷新UI操作。 5.performSelector了解吗？performSelector:afterDelay:怎么确保执行的线程不被销毁。[self performSelector:@selector(test) withObject:nil afterDelay:.0]实际在runloop里面，是一个定时器，但是因为在子线程，runloop是默认没有开启的。 performSelector:afterDelay:之后开启runloop，即[[NSRunLoop currentRunLoop] run];。 port的生命周期结束，runloop也没了，那怎么保证runloop没销毁？ 在子线程调用方法前去开启Runloop。 6.谈谈autorelease和autoreleasepoolautorelease的基本用法 1) 会将对象放到一个自动释放池中 2) 当自动释放池被销毁时，会对池子里面的所有对象做一次release操作 3) 会返回对象本身 4) 调用完autorelease方法后，对象的计数器不变 autorelease的具体使用方法 生成并持有NSAutoreleasePool对象 调用已分配对象的autorelease实例方法 销毁NSAutoreleasePool对象 NSAutoreleasePool对象生存周期相当于C语言的局部变量作用域，对所有调用过autorelease的实例方法的对象，在销毁NSAutoreleasePool对象时，都将调用release实例方法，即实例对象调用release方法。 当对象调用了autorelease方法是实现实际大致可以理解为是调用的NSAutoreleasePool调用了类方法addObject 1234- (void)autorelease { [NSAutoreleasePool addObject: self];} AutoreleasePoolApp启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是_wrapRunLoopWithAutoreleasePoolHandler()。 第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。 第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush()释放旧的池并创建新池； Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。 7.student类在读书方法里加代码，不改变原方法可以使用 Runtime 或者子类。 iOS系统中有没有用类似的方法实现？KVO 8.KVO实现原理，KVO打印实例对象的class为什么能够做到还是原本类。1) 利用RuntimeAPI动态生成一个子类，并且让instance对象的isa指向这个全新的子类2) 当修改instance对象的属性时，会调用Foundation的_NSSetXXXValueAndNotify函数 1234willChangeValueForKey:父类原来的setterdidChangeValueForKey:内部会触发监听器（Oberser）的监听方法( observeValueForKeyPath:ofObject:change:context:） 注意事项：需要调用set方法触发KVO 实现了class方法，返回了父类。 9.http get和post区别Get是安全的、幂等的、可缓存的、Get参数一般拼接在url的query参数里，有长度限制。 Post是不安全的、非幂等的、不可缓存的，Post的参数一般放在请求体里，相对安全。 https的过程？ 一个HTTPS请求实际上包含了两次HTTP传输： 1）客户端发起一个http请求，连接到服务器的443端口。 2）服务端把自己的信息以数字证书的形式返回给客户端（证书内容有密钥公钥，网站地址，证书颁发机构，失效日期等）。证书中有一个公钥来加密信息，私钥由服务器持有。 3）验证证书的合法性 客户端收到服务器的响应后会先验证证书的合法性（证书中包含的地址与正在访问的地址是否一致，证书是否过期）。 4）生成随机密码（RSA签名） 如果验证通过，或用户接受了不受信任的证书，浏览器就会生成一个随机的对称密钥（session key）并用公钥加密，让服务端用私钥解密，解密后就用这个对称密钥进行传输了，并且能够说明服务端确实是私钥的持有者。 5）生成对称加密算法 验证完服务端身份后，客户端生成一个对称加密的算法和对应密钥，以公钥加密之后发送给服务端。此时被黑客截获也没用，因为只有服务端的私钥才可以对其进行解密。之后客户端与服务端可以用这个对称加密算法来加密和解密通信内容了。 6）客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器。 7）服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。 8）然后服务器将加密后的密文发送给客户端。 9）客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成。 https是绝对的安全吗？怎么保证安全性？不是，可以被抓包。 抓包的原理？Charles作用其实相当于拦截器，当客户端和服务器通信时，Charles其实会先接收到服务器的证书，但是它会自己生成一个证书发送给客户端(不管是Web端或App应用)，也就是说它不仅仅是拦截，甚至还可以修改。 由于Charles更改了证书，所以如果你是使用的Web浏览器，需要导入相应的Charles证书，否则校验不通过会给出安全警告，必须安装Charles的证书后才能进行正常访问。 1) Charles拦截客户端的请求。 2) 服务器向“客户端”（实际上是Charles）返回服务器的CA证书 3) Charles拦截服务器的响应，获取服务器证书公钥，然后自己制作一张证书，将服务器证书替换后发送给客户端。（这一步，Charles拿到了服务器证书的公钥） 4) 客户端接收到“服务器”（实际上是Charles）的证书后，生成一个对称密钥，用Charles的公钥加密，发送给“服务器”（Charles） 5) Charles拦截客户端的响应，用自己的私钥解密对称密钥，然后用服务器证书公钥加密，发送给服务器。（这一步，Charles拿到了对称密钥） 6) 服务器用自己的私钥解密对称密钥，向“客户端”（Charles）发送响应 7) Charles拦截服务器的响应，替换成自己的证书后发送给客户端 至此，连接建立，Charles拿到了服务器证书的公钥和客户端与服务器协商的对称密钥，之后就可以解密或者修改加密的报文了。 Charles作为“中间人代理”，拿到了服务器证书公钥和 HTTPS 连接的对称密钥，前提是客户端选择信任并安装Charles的CA证书，否则客户端就会“报警”并中止连接。这样看来，HTTPS还是很安全的。 怎么避免被抓包？判断是否有代理，如果有， 1）可以取消本次的网络请求。 2）可以取消掉代理，直连服务端。 校验证书、不使用http，使用更底层的协议。","link":"/美团优选面试题及答案/"},{"title":"豆瓣面试题","text":"豆瓣面试题 1.是在大学里学的 iOS 吗？怎么学的 iOS？2.判断2个单链表是否交叉,实现代码,如果有交叉找出交叉点。方法一：哈希表法 遍历链表 A 并将每个结点的地址/引用存储在哈希表中。然后检查链表 B 中的每一个结点 bi是否在哈希表中。若在，则 bi为相交结点。 12345678910111213141516var getIntersectionNode = function(headA, headB) { let mySet = new Set(); let curr = headA; while (curr != null) { mySet.add(curr); curr = curr.next; } curr = headB; while (curr != null) { if (mySet.has(curr)) { return curr; } curr = curr.next; } return null;}; 方法二：双指针法 1234567891011var getIntersectionNode = function(headA, headB) { if (headA == null || headB == null) { return null; } let pA = headA, pB = headB; while (pA != pB) { pA = pA == null ? headB : pA.next; pB = pB == null ? headA : pB.next; } return pA;}; 3.说一下 @property 属性修饰符，block 为什么用 copy ？weak 的实现原理？atomic 怎么保证安全？怎么解决读写安全？@property 什么都不写 基本数据类型默认修饰符是 atomic, readWrite, assign 对象类型默认修饰符是 atomic, readWrite, strong block 为什么用 copy？ 如果是全局静态 block 的话，它直到程序结束的时候，才会被被释放。但是我们实际操作中基本上不会使用到不访问外部变量的 block。 如果是保存在栈中的 block，它会随着函数调用结束被销毁。从而导致我们在执行一个包含 block 的函数之后，就无法再访问这个 block。因为（函数结束，函数栈就销毁了，存在函数里面的 block 也就没有了），我们再使用 block 时，就会产生空指针异常。 如果是堆中的 block，也就是 copy 修饰的 block。他的生命周期就是随着对象的销毁而结束的。只要对象不销毁，我们就可以调用的到在堆中的 block。 这就是为什么我们要用 copy 来修饰 block。因为不用 copy 修饰的访问外部变量的 block，只在他所在的函数被调用的那一瞬间可以使用。之后就消失了。 weak 的实现原理 参考链接：iOS 底层解析weak的实现原理 atomic 怎么保证安全？ 属性声明为atomic时，在该属性在调用getter和setter方法时，会加上同步锁，即在属性在调用getter和setter方法时，保证同一时刻只能有一个线程调用属性的读/写方法。保证了读和写的过程是可靠的。但并不能保证数据一定是可靠的。 怎么解决读写安全？ dispatch_barrier_async pthread_rwlock：读写锁 4.OSSPinLock 为什么不用了？系统维护了 5 个不同的线程优先级/QoS: background，utility，default，user-initiated，user-interactive。高优先级线程始终会在低优先级线程前执行，一个线程不会受到比它更低优先级线程的干扰。这种线程调度算法会产生潜在的优先级反转问题，从而破坏了 spin lock。 具体来说，如果一个低优先级的线程获得锁并访问共享资源，这时一个高优先级的线程也尝试获得这个锁，它会处于 spin lock 的忙等状态从而占用大量 CPU。此时低优先级线程无法与高优先级线程争夺 CPU 时间，从而导致任务迟迟完不成、无法释放 lock。这并不只是理论上的问题，libobjc 已经遇到了很多次这个问题了，于是苹果的工程师停用了 OSSpinLock。 参考链接：不再安全的 OSSpinLock 5.同时请求两张图片，之后合成一张图 dispatch_group 配合 dispatch_semaphore dispatch_group dispatch_enter dispatch_leave dispatch_barrier 还有其他的方式吗？只使用 dispatch_semphore 和 dispatch_async 怎么实现？ 6.Runloop 有哪些使用场景？ 控制线程生命周期，实现常驻线程。 TableView 延迟加载图片。滑动时不调用赋值图片的方法，等滑动完毕切换到 NSDefaultRunLoopMode 时才调用。 1[self.img performSelector:@selector(setImage:) withObject:image afterDelay:0 inModes:[NSDefaultRunLoopMode]]; 解决 NSTimer 在滑动时停止的问题。 监测 RunLoop 的状态监测应用卡顿。 7.子线程怎么销毁？换一种问法，常驻线程怎么销毁？NSPort 的生命周期怎么控制？12345678- (void)_stopThread { self.isRun = NO; // 停止当前线程的Runloop CFRunLoopStop(CFRunLoopGetCurrent()); self.innerThread = nil;} 参考链接：iOS RunLoop 常驻线程简化实现 8.说一下响应者链。有三个视图 A、B、C 依次被添加到 self.view 上，frame 相同，复写 C 的 pointInSide 方法缩小范围，点击 C 的边缘 C 会响应吗？C 不响应的话，B 会响应吗？点击 C 的边缘 C 不会响应，B 会响应。 9.组件是怎么拆分的？组件化是怎么传值的？组件的注册是写在哪里的？写在 +load 会不会有性能问题？怎么解决？参考链接：iOS组件化方案 10.了解 HTTPDNS 吗？询问的操作是谁去问？本层-&gt;上层-&gt;上上层 使用HTTP（HTTPS）协议绕过运营商的 Local DNS，避免域名劫持，也更准确地判断客户端地区和运营商，得到更精准的解析结果； HTTPDNS 能够直接得到客户端的出口网关 IP，从而更准确地判断客户端地区和运营商，得到更精准的解析结果； 参考链接：HTTPDNS 11.性能优化，tableView 怎么缓存行高？高度存在哪儿？key 是什么？横竖屏怎么缓存行高？一个页面大概率不会横屏，缓存横竖屏两份行高是不是有些浪费，怎么去处理行高？tableView 怎么控制缓存数量，比如最大1000条数据的缓存量。提前计算好cell的高度,缓存在相应的数据源模型中。cellHeight 12.加载大图，地图这种大图怎么加载优化？系统 API 的原理是什么？ 分片比例裁剪方式。参考苹果给出的 demo,利用 CGImageCreateWithImageInRect 截取原图对应位置的内容,再通过 CGContextDrawImage 渲染到指定位置; 利用 CATiledLayer 层级的API,自动进行绘制; 参考链接：iOS 大图显示解决办法 13.项目怎么分工的？你负责什么？有没有什么值得说的点？H5 与原生交互有什么经验分享吗？怎么给 webView 加载的页面发的网络请求统一加上 header？14.AFN 早期版本为什么要使用常驻线程？怎么统一设置 header？1[requestSerializer setValue:value forHTTPHeaderField:httpHeaderField]; 15.RN 和 Flutter 的底层实现有什么区别？在 Android 和 iOS 上，默认情况下 Flutter 和 React Native 都需要一个原生平台的 Activity / ViewController 支持，且在原生层面属于一个“单页面应用”，而它们之间最大的不同点其实在于 UI 构建 ： React Native ： React Native 是一套 UI 框架，默认情况下 React Native 会在 Activity 下加载 JS 文件，然后运行在 JavaScriptCore 中解析 Bundle 文件布局，最终堆叠出一系列的原生控件进行渲染。 简单来说就是 通过写 JS 代码配置页面布局，然后 React Native 最终会解析渲染成原生控件，如 &lt;View&gt; 标签对应 ViewGroup/UIView ，&lt;ScrollView&gt; 标签对应 ScrollView/UIScrollView ，&lt;Image&gt; 标签对应 ImageView/UIImageView 等。 Flutter ： 如果说 React Native 是为开发者做了平台兼容，那 Flutter 则更像是为开发者屏蔽平台的概念。 Flutter 中绝大部分的 Widget 都与平台无关， 开发者基于 Framework 开发 App ，而 Framework 运行在 Engine 之上，由 Engine 进行适配和跨平台支持。这个跨平台的支持过程，其实就是将 Flutter UI 中的 Widget “数据化” ，然后通过 Engine 上的 Skia 直接绘制到屏幕上 。 参考链接：Flutter 与 React Native 的对比分析 16.平时怎么学习 iOS？上家公司的离职原因，未来规划，有没有要问我的？","link":"/豆瓣面试题/"}],"tags":[{"name":"面试","slug":"面试","link":"/tags/面试/"},{"name":"技术点","slug":"技术点","link":"/tags/技术点/"},{"name":"ofo","slug":"ofo","link":"/tags/ofo/"},{"name":"一点资讯","slug":"一点资讯","link":"/tags/一点资讯/"},{"name":"乐为金融","slug":"乐为金融","link":"/tags/乐为金融/"},{"name":"京东","slug":"京东","link":"/tags/京东/"},{"name":"58","slug":"58","link":"/tags/58/"},{"name":"人人车","slug":"人人车","link":"/tags/人人车/"},{"name":"全民短视频","slug":"全民短视频","link":"/tags/全民短视频/"},{"name":"十点读书","slug":"十点读书","link":"/tags/十点读书/"},{"name":"墨迹天气","slug":"墨迹天气","link":"/tags/墨迹天气/"},{"name":"太一云","slug":"太一云","link":"/tags/太一云/"},{"name":"好未来","slug":"好未来","link":"/tags/好未来/"},{"name":"平安","slug":"平安","link":"/tags/平安/"},{"name":"开果","slug":"开果","link":"/tags/开果/"},{"name":"面试题","slug":"面试题","link":"/tags/面试题/"},{"name":"微店","slug":"微店","link":"/tags/微店/"},{"name":"必要商城","slug":"必要商城","link":"/tags/必要商城/"},{"name":"快狗打车","slug":"快狗打车","link":"/tags/快狗打车/"},{"name":"恒天财富","slug":"恒天财富","link":"/tags/恒天财富/"},{"name":"搜狐","slug":"搜狐","link":"/tags/搜狐/"},{"name":"狐友","slug":"狐友","link":"/tags/狐友/"},{"name":"普华商学院","slug":"普华商学院","link":"/tags/普华商学院/"},{"name":"朗播网","slug":"朗播网","link":"/tags/朗播网/"},{"name":"核桃编程","slug":"核桃编程","link":"/tags/核桃编程/"},{"name":"棵朵","slug":"棵朵","link":"/tags/棵朵/"},{"name":"滴滴","slug":"滴滴","link":"/tags/滴滴/"},{"name":"笔试题","slug":"笔试题","link":"/tags/笔试题/"},{"name":"登云美业","slug":"登云美业","link":"/tags/登云美业/"},{"name":"百度","slug":"百度","link":"/tags/百度/"},{"name":"美团","slug":"美团","link":"/tags/美团/"},{"name":"美团优选","slug":"美团优选","link":"/tags/美团优选/"},{"name":"腰果公考","slug":"腰果公考","link":"/tags/腰果公考/"},{"name":"苏宁","slug":"苏宁","link":"/tags/苏宁/"},{"name":"货拉拉","slug":"货拉拉","link":"/tags/货拉拉/"},{"name":"达达","slug":"达达","link":"/tags/达达/"},{"name":"京东到家","slug":"京东到家","link":"/tags/京东到家/"},{"name":"闲徕互娱","slug":"闲徕互娱","link":"/tags/闲徕互娱/"},{"name":"首汽租车","slug":"首汽租车","link":"/tags/首汽租车/"},{"name":"首汽","slug":"首汽","link":"/tags/首汽/"},{"name":"算法","slug":"算法","link":"/tags/算法/"},{"name":"链表","slug":"链表","link":"/tags/链表/"},{"name":"高思教育","slug":"高思教育","link":"/tags/高思教育/"},{"name":"字节跳动","slug":"字节跳动","link":"/tags/字节跳动/"},{"name":"小米","slug":"小米","link":"/tags/小米/"},{"name":"猿辅导","slug":"猿辅导","link":"/tags/猿辅导/"},{"name":"百度知道","slug":"百度知道","link":"/tags/百度知道/"},{"name":"豆瓣","slug":"豆瓣","link":"/tags/豆瓣/"}],"categories":[{"name":"面试题","slug":"面试题","link":"/categories/面试题/"}]}