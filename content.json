{"pages":[{"title":"","text":"职场已读乱回 :root { --dark-gray-start: #2D2F33; --dark-gray-end: #1A1A1A; --white-collar-blue-start: #6C8EB4; --white-collar-blue-end: #B4C7E7; --slacker-orange-start: #F4B183; --slacker-orange-end: #F8C471; --overachiever-red-start: #FF6666; --overachiever-red-end: #FF9999; --gold: #FFD700; } body { margin: 0; padding: 0; background: linear-gradient(var(--dark-gray-start), var(--dark-gray-end)); height: 100vh; overflow: hidden; user-select: none; } h1 { font-family: Arial, sans-serif; font-size: 48px; color: white; text-align: center; margin-top: 50px; position: relative; text-shadow: 0 0 10px var(--gold), 0 0 20px var(--gold), 0 0 30px var(--gold); animation: glitch 1s infinite alternate; border: 5px solid white; padding: 10px; display: inline-block; left: 50%; transform: translateX(-50%); position: relative; box-shadow: 0 0 10px var(--gold); } @keyframes glitch { 0% { transform: translateX(-50%) skewX(0deg); text-shadow: 0 0 10px var(--gold), 0 0 20px var(--gold), 0 0 30px var(--gold); } 20% { transform: translateX(-50%) skewX(10deg); text-shadow: -5px 0 var(--white-collar-blue-start), 5px 0 var(--overachiever-red-start); } 40% { transform: translateX(-50%) skewX(-10deg); text-shadow: -5px 0 var(--slacker-orange-start), 5px 0 var(--white-collar-blue-start); } 60% { transform: translateX(-50%) skewX(5deg); text-shadow: -5px 0 var(--overachiever-red-start), 5px 0 var(--slacker-orange-start); } 80% { transform: translateX(-50%) skewX(-5deg); text-shadow: -5px 0 var(--white-collar-blue-start), 5px 0 var(--overachiever-red-start); } 100% { transform: translateX(-50%) skewX(0deg); text-shadow: 0 0 10px var(--gold), 0 0 20px var(--gold), 0 0 30px var(--gold); } } .message { position: absolute; top: -50px; padding: 10px; border-radius: 10px; font-size: 16px; display: flex; align-items: center; min-width: 100px; justify-content: center; } .message::before { content: ''; display: inline-block; width: 20px; height: 20px; margin-right: 5px; } .white-collar { background: linear-gradient(var(--white-collar-blue-start), var(--white-collar-blue-end)); } .white-collar::before { background: url('data:image/svg+xml;utf8,'); } .slacker { background: linear-gradient(var(--slacker-orange-start), var(--slacker-orange-end)); } .slacker::before { background: url('data:image/svg+xml;utf8,'); } .overachiever { background: linear-gradient(var(--overachiever-red-start), var(--overachiever-red-end)); } .overachiever::before { background: url('data:image/svg+xml;utf8,'); } .catch-area { position: absolute; bottom: 20px; width: 200px; height: 50px; background: rgba(255, 255, 255, 0.2); backdrop-filter: blur(10px); border-radius: 10px; box-shadow: 0 0 10px rgba(255, 255, 255, 0.3); } .catch-area::after { content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: inherit; filter: blur(10px); opacity: 0.5; z-index: -1; animation: trail 0.5s infinite; } @keyframes trail { 0% { transform: translateX(0); opacity: 0.5; } 100% { transform: translateX(10px); opacity: 0; } } .particle-effect { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: none; } .particle { position: absolute; width: 5px; height: 5px; background: var(--gold); border-radius: 50%; animation: particle 1s ease-out forwards; } @keyframes particle { 0% { transform: translate(0, 0); opacity: 1; } 100% { transform: translate(var(--x), var(--y)); opacity: 0; } } .prompt { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0, 0, 0, 0.7); color: white; padding: 20px; border-radius: 10px; font-size: 24px; display: none; } 职场已读乱回 功德+1 const messages = [ \"嗯嗯，知道了。\", \"好的，安排一下。\", \"行，我看看。\", \"没问题，稍后处理。\", \"收到，马上跟进。\", \"了解，会处理的。\", \"好嘞，这就办。\", \"可以，我来弄。\", \"晓得，等我弄。\", \"明白，着手处理。\" ]; const messageTypes = ['white-collar', 'slacker', 'overachiever']; const catchArea = document.getElementById('catchArea'); const particleEffect = document.getElementById('particleEffect'); const prompt = document.getElementById('prompt'); const messageElements = []; let score = 0; let isPerformanceMode = window.innerWidth < 768; document.addEventListener('mousemove', (e) => { const x = e.clientX - catchArea.offsetWidth / 2; catchArea.style.left = Math.min( Math.max(x, 0), window.innerWidth - catchArea.offsetWidth ) + 'px'; }); document.addEventListener('touchmove', (e) => { e.preventDefault(); const touch = e.touches[0]; const x = touch.clientX - catchArea.offsetWidth / 2; catchArea.style.left = Math.min( Math.max(x, 0), window.innerWidth - catchArea.offsetWidth ) + 'px'; }, { passive: false }); document.addEventListener('keydown', (e) => { const speed = 20; const currentLeft = parseInt(catchArea.style.left || 0); if (e.key === 'ArrowLeft') { catchArea.style.left = Math.max(0, currentLeft - speed) + 'px'; } else if (e.key === 'ArrowRight') { catchArea.style.left = Math.min( window.innerWidth - catchArea.offsetWidth, currentLeft + speed ) + 'px'; } }); function createMessage() { const message = document.createElement('div'); message.classList.add('message'); const randomMessage = messages[Math.floor(Math.random() * messages.length)]; const randomType = messageTypes[Math.floor(Math.random() * messageTypes.length)]; message.classList.add(randomType); message.textContent = randomMessage; message.style.left = Math.random() * (window.innerWidth - 100) + 'px'; document.body.appendChild(message); messageElements.push(message); } function moveMessages() { messageElements.forEach((message, index) => { const rect = message.getBoundingClientRect(); if (rect.bottom < window.innerHeight) { message.style.top = (rect.top + 3) + 'px'; if (isCollision(message, catchArea)) { catchMessage(message, index); } } else { removeMessage(message, index); } }); } function isCollision(element1, element2) { const rect1 = element1.getBoundingClientRect(); const rect2 = element2.getBoundingClientRect(); return ( rect1.left < rect2.right && rect1.right > rect2.left && rect1.bottom > rect2.top && rect1.top < rect2.bottom ); } function catchMessage(message, index) { playSound(); showParticleEffect(); showPrompt(); removeMessage(message, index); score++; } function playSound() { const audioContext = new (window.AudioContext || window.webkitAudioContext)(); const oscillator = audioContext.createOscillator(); const gainNode = audioContext.createGain(); oscillator.type = 'sine'; oscillator.frequency.setValueAtTime(300, audioContext.currentTime); gainNode.gain.setValueAtTime(0.5, audioContext.currentTime); oscillator.connect(gainNode); gainNode.connect(audioContext.destination); oscillator.start(); oscillator.stop(audioContext.currentTime + 0.2); } function showParticleEffect() { particleEffect.style.display = 'block'; for (let i = 0; i < (isPerformanceMode ? 10 : 50); i++) { const particle = document.createElement('div'); particle.classList.add('particle'); const angle = Math.random() * 2 * Math.PI; const distance = Math.random() * 200; const x = Math.cos(angle) * distance; const y = Math.sin(angle) * distance; particle.style.setProperty('--x', `${x}px`); particle.style.setProperty('--y', `${y}px`); particle.style.left = window.innerWidth / 2 + 'px'; particle.style.top = window.innerHeight / 2 + 'px'; particleEffect.appendChild(particle); setTimeout(() => { particle.remove(); }, 1000); } setTimeout(() => { particleEffect.style.display = 'none'; }, 1000); } function showPrompt() { prompt.style.display = 'block'; setTimeout(() => { prompt.style.display = 'none'; }, 1000); } function removeMessage(message, index) { message.remove(); messageElements.splice(index, 1); } function gameLoop() { if (Math.random() < 0.01) { createMessage(); } moveMessages(); requestAnimationFrame(gameLoop); } gameLoop();","link":"/game.html"},{"title":"","text":"欢迎投稿：swift@88.com","link":"/about/index.html"},{"title":"分类","text":"","link":"/categories/index.html"},{"title":"标签","text":"","link":"/tags/index.html"},{"title":"","text":"可爱 2048 游戏 body { background-color: #faf8ef; font-family: Arial, sans-serif; display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 100vh; margin: 0; } #header { display: flex; justify-content: space-between; align-items: center; width: 90%; max-width: 500px; color: #776e65; } h1 { margin: 0; } #score-board { display: flex; gap: 10px; } #score, #high-score { background-color: #bbada0; color: white; padding: 5px 10px; border-radius: 5px; } #game-board { display: grid; grid-template-columns: repeat(4, 1fr); grid-template-rows: repeat(4, 1fr); gap: 10px; background-color: #bbada0; padding: 10px; border-radius: 5px; width: 90%; max-width: 500px; margin: 20px 0; } .cell { background-color: rgba(238, 228, 218, 0.35); border-radius: 5px; aspect-ratio: 1/1; } .tile { width: 100%; height: 100%; background-size: cover; border-radius: 5px; } #game-rules { text-align: left; color: #776e65; width: 90%; max-width: 500px; font-size: 14px; } #win-modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); align-items: center; justify-content: center; } #win-modal-content { background-color: white; padding: 20px; border-radius: 5px; text-align: center; } 可爱 2048 游戏 得分: 0 最高分: 0 游戏规则：使用键盘方向键（上、下、左、右）控制卡片移动，相同的卡片会合并成一个数值更大的卡片，目标是合并出数值为 2048 的卡片。 恭喜你已经合并了一只宇宙无敌最可爱的猫咪 确认 const gameBoard = document.getElementById('game-board'); const winModal = document.getElementById('win-modal'); const scoreElement = document.getElementById('score'); const highScoreElement = document.getElementById('high-score'); const images = { 2: 'https://p9-flow-imagex-sign.byteimg.com/ocean-cloud-tos/image_generation/df099f209335f8b25e1d4ab9ce2867ff_1741677321668230149.png~tplv-a9rns2rl98-image.png?rk3s=25bff839&x-expires=1773213321&x-signature=reNM%2F907NNX7Rc%2BE4FflYbWaRKo%3D', 4: 'https://p9-flow-imagex-sign.byteimg.com/ocean-cloud-tos/image_generation/322b9826909d14458d22e0931fd06aac_1741677330491084517.png~tplv-a9rns2rl98-image.png?rk3s=25bff839&x-expires=1773213330&x-signature=a1ptVuhTOwjrpRZSdnL%2FUKYV9MY%3D', 8: 'https://p3-flow-imagex-sign.byteimg.com/ocean-cloud-tos/image_generation/1a563d103b7496a5b9eb365ff9ea58bd_1741677409407029394.png~tplv-a9rns2rl98-image.png?rk3s=25bff839&x-expires=1773213409&x-signature=L0drmZ0N1Z2%2BjUD9g9gcP0Nn7TM%3D', 16: 'https://p3-flow-imagex-sign.byteimg.com/ocean-cloud-tos/image_generation/f51aebc9e6d5eee19fc026e3f1070185_1741677412756659826.png~tplv-a9rns2rl98-image.png?rk3s=25bff839&x-expires=1773213412&x-signature=%2F%2FMLyi7m%2Bu%2Fo%2F%2FTQeYqmUWeDtLQ%3D', 32: 'https://p3-flow-imagex-sign.byteimg.com/ocean-cloud-tos/image_generation/8693822e52091fd6896366ae4e922bc2_1741677429462075923.png~tplv-a9rns2rl98-image.png?rk3s=25bff839&x-expires=1773213429&x-signature=tLOJO0F5DKTLStoKnja6l2fr%2FOg%3D', 64: 'https://p3-flow-imagex-sign.byteimg.com/ocean-cloud-tos/image_generation/5fbb02d79c0f16f69ec86ea7a83d7e36_1741677431738410576.png~tplv-a9rns2rl98-image.png?rk3s=25bff839&x-expires=1773213431&x-signature=Ry8L%2FkXszOCFFHkMeIdKm6Ktg%2FQ%3D', 128: 'https://p3-flow-imagex-sign.byteimg.com/ocean-cloud-tos/image_generation/f2c91103fc53286b5d481390c12d665f_1741677444595987213.png~tplv-a9rns2rl98-image.png?rk3s=25bff839&x-expires=1773213444&x-signature=X5AHPsnNLXS25hlANqlvTtpSQmc%3D', 256: 'https://p9-flow-imagex-sign.byteimg.com/ocean-cloud-tos/image_generation/9f4e790544e519f8c110d2c73e7b03bf_1741677446066399364.png~tplv-a9rns2rl98-image.png?rk3s=25bff839&x-expires=1773213446&x-signature=DmV9R3QrONwWz%2F4fUnoceUjiU8E%3D', 512: 'https://p3-flow-imagex-sign.byteimg.com/ocean-cloud-tos/image_generation/8f72db8a79741930894920bc8faced83_1741677458934448994.png~tplv-a9rns2rl98-image.png?rk3s=25bff839&x-expires=1773213458&x-signature=YxMhmlrT%2FY7brkyal9u5oaifd3g%3D', 1024: 'https://p3-flow-imagex-sign.byteimg.com/ocean-cloud-tos/image_generation/f565fa57b977fa953208f7a2b4edd839_1741677459756646895.png~tplv-a9rns2rl98-image.png?rk3s=25bff839&x-expires=1773213459&x-signature=r0bBAR7T7NVF3dyu1aGI%2FlWfR4w%3D', 2048: 'https://p3-flow-imagex-sign.byteimg.com/ocean-cloud-tos/image_generation/dbb80e7d3948b8af02664915eeee38d2_1741677502512862779.png~tplv-a9rns2rl98-image.png?rk3s=25bff839&x-expires=1773213502&x-signature=Bv%2FEdGFqr%2Bq47a8g1D4KiU9XYqQ%3D' }; let board = [ [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0] ]; let score = 0; let highScore = localStorage.getItem('highScore')? parseInt(localStorage.getItem('highScore')) : 0; highScoreElement.textContent = `最高分: ${highScore}`; function createBoard() { gameBoard.innerHTML = ''; for (let i = 0; i < 4; i++) { for (let j = 0; j < 4; j++) { const cell = document.createElement('div'); cell.classList.add('cell'); if (board[i][j]!== 0) { const tile = document.createElement('div'); tile.classList.add('tile'); tile.style.backgroundImage = `url(${images[board[i][j]]})`; cell.appendChild(tile); } gameBoard.appendChild(cell); } } scoreElement.textContent = `得分: ${score}`; } function addRandomTile() { const emptyCells = []; for (let i = 0; i < 4; i++) { for (let j = 0; j < 4; j++) { if (board[i][j] === 0) { emptyCells.push({ i, j }); } } } if (emptyCells.length > 0) { const randomIndex = Math.floor(Math.random() * emptyCells.length); const { i, j } = emptyCells[randomIndex]; board[i][j] = Math.random() < 0.9? 2 : 4; } } function mergeTiles(row) { let newRow = row.filter(tile => tile!== 0); for (let i = 0; i < newRow.length - 1; i++) { if (newRow[i] === newRow[i + 1]) { newRow[i] *= 2; score += newRow[i]; if (newRow[i] === 2048) { showWinModal(); } newRow[i + 1] = 0; } } newRow = newRow.filter(tile => tile!== 0); while (newRow.length < 4) { newRow.push(0); } return newRow; } function moveLeft() { let moved = false; for (let i = 0; i < 4; i++) { const oldRow = [...board[i]]; board[i] = mergeTiles(board[i]); if (oldRow.join(',')!== board[i].join(',')) { moved = true; } } if (moved) { addRandomTile(); } updateScore(); createBoard(); } function moveRight() { let moved = false; for (let i = 0; i < 4; i++) { const oldRow = [...board[i]]; const reversedRow = board[i].slice().reverse(); const newReversedRow = mergeTiles(reversedRow); board[i] = newReversedRow.reverse(); if (oldRow.join(',')!== board[i].join(',')) { moved = true; } } if (moved) { addRandomTile(); } updateScore(); createBoard(); } function moveUp() { let moved = false; for (let j = 0; j < 4; j++) { const column = []; for (let i = 0; i < 4; i++) { column.push(board[i][j]); } const oldColumn = [...column]; const newColumn = mergeTiles(column); for (let i = 0; i < 4; i++) { board[i][j] = newColumn[i]; } if (oldColumn.join(',')!== newColumn.join(',')) { moved = true; } } if (moved) { addRandomTile(); } updateScore(); createBoard(); } function moveDown() { let moved = false; for (let j = 0; j < 4; j++) { const column = []; for (let i = 0; i < 4; i++) { column.push(board[i][j]); } const oldColumn = [...column]; const reversedColumn = column.slice().reverse(); const newReversedColumn = mergeTiles(reversedColumn); const newColumn = newReversedColumn.reverse(); for (let i = 0; i < 4; i++) { board[i][j] = newColumn[i]; } if (oldColumn.join(',')!== newColumn.join(',')) { moved = true; } } if (moved) { addRandomTile(); } updateScore(); createBoard(); } function handleKeyPress(event) { switch (event.key) { case 'ArrowLeft': moveLeft(); break; case 'ArrowRight': moveRight(); break; case 'ArrowUp': moveUp(); break; case 'ArrowDown': moveDown(); break; } } function showWinModal() { winModal.style.display = 'flex'; } function closeWinModal() { winModal.style.display = 'none'; } function updateScore() { if (score > highScore) { highScore = score; highScoreElement.textContent = `最高分: ${highScore}`; localStorage.setItem('highScore', highScore); } scoreElement.textContent = `得分: ${score}`; } window.addEventListener('keydown', handleKeyPress); addRandomTile(); addRandomTile(); createBoard();","link":"/custom/game.html"}],"posts":[{"title":"二叉树算法题","text":"二叉树算法题（ JavaScript 实现） 二叉树的中序遍历递归： 12345678910111213var inorderTraversal = function(root) { let res = [] const inorder = function(root) { if (!root) { return; } inorder(root.left); res.push(root.val); inorder(root.right); } inorder(root); return res;}; 迭代： 12345678910111213141516var inorderTraversal = function(root) { const res = []; const stack = []; let cur = root; while (stack.length || cur) { if (cur) { stack.push(cur); cur = cur.left; } else { cur = stack.pop(); res.push(cur.val); cur = cur.right; } } return res;}; 二叉树的层序遍历1234567891011121314151617181920212223var levelOrder = function(root) { const res = [], queue = []; queue.push(root); if (root === null) { return res; } while (queue.length) { let curLevel = []; let length = queue.length; for (let i = 0; i &lt; length; i++) { let node = queue.shift(); curLevel.push(node.val); if (node.left) { queue.push(node.left); } if (node.right) { queue.push(node.right); } } res.push(curLevel); } return res;}; 二叉树的最大深度123456var maxDepth = function(root) { if (!root) { return 0; } return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;}; 翻转二叉树12345678910var invertTree = function(root) { if (!root) { return null; } let left = invertTree(root.left); let right = invertTree(root.right); root.left = right; root.right = left; return root;}; 二叉树的直径1234567891011121314var diameterOfBinaryTree = function(root) { let ans = 1; function getDepth(root) { if (!root) { return 0; } let left = getDepth(root.left); let right = getDepth(root.right); ans = Math.max(ans, left + right + 1); return Math.max(left, right) + 1; } getDepth(root); return ans - 1;};","link":"/2024-08-29-二叉树算法题/"},{"title":"天眼查","text":"天眼查 1.通用化技术提升迭代效率 2.降低三方 App 接入成本 3.SDK 体积优化，为什么用 Masonry 会增加体积 4.加载速度优化，怎么统计的？多个请求并发怎么处理的？ 5.引用计数，isa 里都有什么？weak 的实现？对象的释放流程 6.方法交换交换的是什么？ 7.SDWebImage加载url的流程，三级缓存，清除缓存 7.block 的变量捕获，为什么用__block可以修改局部变量的值 8.找出代码里有问题的地方，可变数组用 copy 修饰，调用添加元素方法会发生什么？能不能上报、拦截闪退？线程不安全怎么处理？常用的加锁方式，区别？ 9.删除链表的倒数第 N 个结点 参考答案1.通用化技术提升迭代效率 2.降低三方 App 接入成本 3.SDK 体积优化，为什么用 Masonry 会增加体积 4.加载速度优化，怎么统计的？多个请求并发怎么处理的？ 5.引用计数，isa 里都有什么？weak 的实现？对象的释放流程，怎么判断是否有弱引用 isa nonpointer 0，代表普通的指针，存储着Class、Meta-Class对象的内存地址1，代表优化过，使用位域存储更多的信息 has_assoc 是否有设置过关联对象，如果没有，释放时会更快 has_cxx_dtor 是否有C++的析构函数（.cxx_destruct），如果没有，释放时会更快 shiftcls 存储着Class、Meta-Class对象的内存地址信息 magic 用于在调试时分辨对象是否未完成初始化 weakly_referenced 是否有被弱引用指向过，如果没有，释放时会更快 deallocating 对象是否正在释放 extra_rc 里面存储的值是引用计数器减1 has_sidetable_rc 引用计数器是否过大无法存储在isa中如果为1，那么引用计数会存储在一个叫SideTable的类的属性中 6.方法交换交换的是什么？ 7.block 的变量捕获，为什么用__block可以修改局部变量的值 8.找出代码里有问题的地方，可变数组用 copy 修饰，调用添加元素方法会发生什么？能不能上报、拦截闪退？线程不安全怎么处理？常用的加锁方式，区别？ 9.删除链表的倒数第 N 个结点 1234567891011121314151617181920212223242526272829/** * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */var removeNthFromEnd = function(head, n) { let length = getLength(head); let i = length - n; let dummyNode = new ListNode(); dummyNode.next = head; let p = dummyNode; while (i &gt; 0) { p = p.next; i--; } p.next = p.next.next; return dummyNode.next;};var getLength = function(head) { let length = 0; let p = head; while (p) { length++; p = p.next; } return length;}","link":"/2024-08-29-天眼查/"},{"title":"转转","text":"转转 一面： 1.活动页组件化，JSON 结构，跳转区分 Scheme 和 HTTP 是谁来处理的？ 2.加载速度优化 3.检测无用代码是检测的 mach-o 的无用类还是方法？ 4.多个请求完成后通知除了 GCD 还有什么方法？ 5.webView 和原生的交互，设计一个监听原生页面声明周期，通知 H5，（有些需要监听，有些不需要监听） 6.webView 加载速度优化，项目里用到的 7.组件化怎么划分的模块，分层 8.内存管理，项目里常见的循环引用，为什么用 NSProxy，和 NSObject 区别 二面： 1.介绍项目亮点 2.设计原生与 Flutter/H5 交互 上中下三层 3.iOS 和 H5 交互方法，优缺点 4.具体规划，目前待遇，offer，期望薪资 参考答案一面： 1.活动页组件化，JSON 结构，跳转区分 Scheme 和 HTTP 是谁来处理的？ 2.加载速度优化 3.检测无用代码是检测的 mach-o 的无用类还是方法？ 4.多个请求完成后通知除了 GCD 还有什么方法？ 5.webView 和原生的交互，设计一个监听原生页面声明周期，通知 H5，（有些需要监听，有些不需要监听） 6.webView 加载速度优化，项目里用到的 7.组件化怎么划分的模块，分层 （1）Accessories App附属品 Watch、Extension、Widget （2）Business 业务组件 文库、网盘、性能监控、付费咨询、Feed、搜索等 （3）Interface 接口层 （4）Underlays 服务组件 搜索工具、Feed通用业务，天气通用数据组件等 （5）Services 服务组件 IM、Talos、Performance、UBC、AFX等 （6）Basics 基础组件 BDPDevice、Cocoa（BBAFoundation、BBAUIKit、BDPWindow、BDPAppearance、AFX）、Network （7）Vendors 三方库 AFNetworking、SDWebImage、YYModel等 8.内存管理，项目里常见的循环引用，为什么用 NSProxy，和 NSObject 区别 NSProxy 主要用于代理和消息转发，它提供了一个机制来实现不直接处理方法调用的对象。 NSObject 是所有 Objective-C 对象的基础类，提供了对象管理和通用功能的实现。 通常情况下，如果你需要实现一种代理模式或远程调用，NSProxy 是合适的选择。如果你在创建一个普通的对象，NSObject 是你通常会继承的类。 二面： 1.介绍项目亮点 2.设计原生与 Flutter/H5 交互 上中下三层 3.iOS 和 H5 交互方法，优缺点 4.具体规划，目前待遇，offer，期望薪资 📘 iOS 面试通关手册（组件化 / H5 / 性能 / 架构） 🧩 一面核心题目详解1. 活动页组件化，JSON 结构，跳转区分 Scheme 和 HTTP 是谁来处理的？答案要点： JSON 描述跳转目标（如 URL、pageId、params） RouterManager/Navigator 统一解析 URL，决定打开方式： 12345if ([url.scheme isEqualToString:@\"http\"] || [url.scheme isEqualToString:@\"https\"]) { // 打开 WebView} else if ([url.scheme isEqualToString:@\"app\"]) { // 原生跳转} 分离跳转逻辑与页面结构，便于动态配置与热更新。 2. 加载速度优化优化方式： 首屏优化：异步加载、骨架屏占位、按需加载 图片优化：压缩、缓存（SDWebImage）、懒加载 数据优化：合并请求、接口聚合、GZIP 压缩 离线缓存：预加载 HTML、JS Bundle、资源包 网络优化：HTTP2、多路复用、CDN 配置 3. 检测无用代码是检测 Mach-O 的类还是方法？答法： 都可以，通过静态分析： LinkMap 文件分析未被引用的符号 Clang 插桩、Swift Demangle 查看未调用的方法 Mach-O 是最终产物，反映“未被链接进二进制”的部分 4. 多请求完成通知除了 GCD，还有什么？方案： NSOperationQueue + addDependency Promise/Future：PromiseKit、Combine、RxSwift KVO 监听属性变化，触发 UI 更新 Dispatch Semaphore：手动控制信号 5. WebView 与原生交互，监听页面生命周期通知 H5设计： 原生页面生命周期调用 JS 通知： 1[webView evaluateJavaScript:@\"window.onNativeLifeCycle('viewDidAppear')\"] JS 注册： 123window.onNativeLifeCycle = function(state) { if (state === 'viewDidAppear') { /* 处理 */ }} 可配置控制哪些生命周期需要同步（如通过 JSBridge 参数指定） 6. WebView 加载速度优化（项目中用到的）方法： 离线资源包（JS/CSS/HTML）打包在本地 WKWebView 复用池（WebViewPool）减少初始化开销 设置 cachePolicy，合理使用缓存 禁用插件（如 JS 插件、自动检测）提高启动速度 7. 组件化怎么划分模块 / 分层？推荐结构： Base 层：网络、工具类、日志、配置 UI 层：通用 UI 组件（按钮、卡片、弹窗） Biz 层：独立业务模块（登录、支付、商城） Service 层：统一服务（埋点、权限、推送） Protocol 层：各模块之间解耦协议 关键词： 解耦、高内聚、低耦合、模块隔离、可热更新 8. 内存管理：循环引用、NSProxy 与 NSObject 区别常见循环引用： Timer 持有控制器 Block 捕获 self delegate 强引用 NSProxy 使用： 中转代理（如 NSTimer）：1NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:1 target:[WeakProxy proxyWithTarget:self] selector:@selector(run) userInfo:nil repeats:YES]; 与 NSObject 区别： NSProxy 是消息转发专用，不继承 NSObject，无默认行为 NSObject 有默认的内存管理 / KVO / 响应链 🚀 二面核心题目详解1. 项目亮点介绍答题建议： 选一个“有挑战/成果”的模块深入讲： 比如：活动页组件化、加载优化、自研 Bridge 桥接方案 体现技术落地、团队协作、提效效果 2. 原生与 Flutter/H5 交互设计（上下三层）三层架构： 上层：业务 API（login、pay、share） 中层：Bridge 协议定义、参数统一封装（JSON） 底层：Native 实现，JS 调用处理、回调、权限判断等 3. iOS 与 H5 交互方法及优缺点 方法 优点 缺点 evaluateJavaScript 简单直接 无回调、不安全 WKScriptMessageHandler 安全规范、结构清晰 配置繁琐，不适合高频交互 URL Scheme 拦截 通用性强 参数受限、安全差 4. 当前待遇 &amp; 期望薪资建议答法： 当前总包/薪资范围 期望平台成长 + 技术深度 +回报匹配 可接受一定灵活性，但看重发展潜力","link":"/2024-09-03-转转/"},{"title":"美团面试题","text":"美团面试题 1.Runtime 2.Runloop 3.内存管理 4.组件化 5.Flutter 6.前端 7.iOS 引用计数和 GC 的区别 参考链接：简书-垃圾回收和自动引用计数 8.算法（二叉树最大深度） LeetCode 题目链接：二叉树的最大深度 12345678910111213var max = function(a, b) { if (a &gt; b) { return a; } return b;}var maxDepth = function(root) { if (root == null) { return 0; } return max(maxDepth(root.left), maxDepth(root.right)) + 1;};","link":"/2021-07-12-美团面试题/"},{"title":"ofo面试题","text":"ofo面试题 1、block 的底层实现? 2、block 的类型有哪几种? 3、你碰到的 block 的循环引用? 4、为什么你在用 Masonry , AFNetworking 的 block 回调不需要对 self 进行 __weak? 5、出现野指针的情况大概有哪些？ 6、Swift 里的闭包和 OC 的 block 的区别。 7、Sqlite 使用的时候需要注意什么。","link":"/ofo面试题/"},{"title":"一点资讯面试题","text":"一点资讯面试题 一面1.Flutter 与原生怎么交互 2.Flutter 跳转原生页面，原生跳转 Flutter 页面怎么实现？ 3.Widget、StatefulWidget、StatelessWidget 区别 4.Flutter 的三棵树（Widget 树等） 5.setState 实现源码看过吗？内部实现原理 6.KVO 实现原理 7.Runtime 流程，怎么避免方法找不到的闪退 8.数组插入空安全怎么实现的？交换方法写在哪里？为什么不写在 initialize 里？ 9.两个分类里同名方法执行哪个？ 10.isa 指针的指向，isa 的结构 11.__block 的原理，全局变量需要捕获吗？ 12.闪退率，Flutter 的闪退怎么监控？ 13.做过哪些优化？FPS 优化，启动优化，安装包大小优化 14.做过哪些组件？ 15.字符串反转 二面1.autoreleasepool 什么时候释放 2.deviceId 怎么确保唯一性 3.微信 Mac 端登录为什么要做成扫描二维码的方式？怎么实现的？ 4.个人优缺点，未来规划，看机会原因 5.怎么学习一门新技术 三面1.介绍项目，项目 DAU 2.心跳包是自己实现的吗？心跳包停掉有没有遇到过？ 3.有没有 offer，觉得一点的优势跟不足，其他一些私人问题","link":"/一点资讯面试题/"},{"title":"iOS 面试技术点","text":"iOS 面试技术点 问题 期望 NSDicationary 的本质 理解哈希表，知道其遍历不是顺序的 ARC下内存泄漏的原因，循环引用时如何发生以及如何避免 理解ARC的机制从而知道内存泄漏的产生，并知道循环引用是如何产生和避免 常见的导致程序崩溃的原因 知道崩溃的原因本质是僵尸内存或指向错误，能够在实际开发中避免 使用多线程的几种方式 知道NSThread、NSOperationQueue和GCD三种多线程实现方式并能简单介绍应用实例，尤其要熟悉GCD的使用 如何实现一个单例 能够大体说出单例的实现原理，实现方法多多益善，能讲出各个实现方法的优缺点最好 NSArray和NSSet的区别以及使用时机 能够理解顺序表和集合的概念 NSInteger和int的区别 能知道NSInteger的位长大于等于int，考察对基础数据类型的理解 NSDictionary的快速构建方法以及注意事项 能够知道NSDictionary的快速构建方法，尤其要知道不可传nil的指针 介绍一下Autolayout和Autoresizing 考察对两种布局方法的理解，能够答题说出它们的原理 对象及ViewController的生命周期 对ViewController的生命周期有所了解 线程锁的几种使用方式 至少知道NSLock和synchronized，能够了解semaphore、递归锁、条件锁和分布锁可加分 block的使用以及注意事项 实际使用过block以及知道如何避免循环引用 strong、weak、retain、unsafe_unretain、assign、copy的区别以及使用场景 能够说出各个修饰符的作用 数据持久化的几种方式、应用场景和优缺点 至少知道NSUserDefault和Plist、文件三种保存方式，知道sqlite或CoreData可加分 如何进行一个http协议的网络请求 能够知道NSURLConnection或NSURLSession的使用方式 简介应用的生命周期 能够知道应用的生命周期，每个周期的回调是在什么时机 NSNotification的使用及注意事项 能够理解NSNotification的广播机制、传参以及避免key覆盖 NSUserDefault使用时应该注意什么 能够知道NSUserDefault本质是保存到plist文件，以及对象要实现NSCoder协议 OC Runtime介绍 对Objective-C的底层能够有自己的正确理解 OC Runloop介绍 对Objective-C的底层能够有自己的正确理解 Category的本质 对Objective-C的底层能够有自己的正确理解 函数式编程和ReactiveCocoa 对Objective-C的底层能够有自己的正确理解 block的实现原理 对Objective-C的底层能够有自己的正确理解 对Cocoa中UITableView、UILabel等组件的实现原理有自己的理解 能够通过组件的表象看到本质，考察编程经验和推导能力 介绍UIView的组成 能够对UIView有深入理解 介绍CoreGraphics、CoreAnimation、CoreText的技术架构及简单使用 能够熟悉和理解iOS开发中常用的Core系列库，能熟练使用它们 介绍Xcode的Build Settings和Build Phases中常用的设置 能够基本知道iOS项目的编译过程 一个iOS项目的大体编译、链接以及运行过程 能够基本知道iOS项目的编译过程 介绍Cocoapods（或其它包管理工具）的实现思路 能够基本知道iOS项目的编译过程 如何使用Xcode进行调试和排错 知道如何调试和排错 介绍Instruments中常用的功能 能够使用工具进行性能分析和监控 MVVM模式介绍及其优缺点","link":"/iOS面试技术点/"},{"title":"乐为金融面试题","text":"乐为金融面试题 1、说一下系统框架和生命周期。 2、系统存储空间有哪些？全局变量区、栈、堆、代码区 3、栈区是用来放什么的？ 4、栈是什么结构？链表是什么结构？ 5、进程和线程有啥关系？进程是不是一个App？ 6、说一下 MVC、MVVM 7、你了解的设计模式？ 8、你做过的内存优化有哪些？ 9、说一下 AFN/SDWebImage 10、做直播、聊天，了解长连接是什么实现的吗？ 11、面向对象的三个特性？封装是什么？多态是什么？ 12、你用 OC 开发还是 Swift 开发？Swift 有什么优势？","link":"/乐为金融面试题/"},{"title":"人人车面试题","text":"人人车面试题 一面1.了解哪些设计模式 2.MVVM 解决什么问题 3.性能优化 4.内存管理的理解 autoreleasePool 的结构，一个 autoreleasePoolPage 的大小 5.weak 的原理 6.class 的结构，cache 的结构，bucket_t 的结构，方法查找的顺序，是逐个遍历吗？ 7.关联对象存在哪里 8.Category 的加载流程 9.Runtime 的应用，动态方法解析里返回 YES，但是并没有添加方法，会怎么样？ 10.三次握手与四次挥手，四次挥手后会立马断开连接吗 11.Swift 解包方式 12.Swift 中计算属性和存储属性的区别 13.Swift 类和结构体的区别，使用属性的写法上的区别 14.数组和链表的区别 15.快速排序，快排时间复杂度 二面介绍项目 1.webView 与 H5 交互，拦截协议 url 有长度限制，有安全问题，可能会被抓包，JSBridge 2.埋点 埋点保存/删除数据的时机 内存里的最大容量，收到内存警告 上报网络请求发送失败后的处理，埋点的补偿机制 3.支付 4.页面 A push B A willDisappear didDisappear B willAppear didAppear 的执行顺序 5.Person 类继承自 NSObject 类，没有实现 age 方法。两个实例 p1,p2，怎么让 p1 响应 age 方法，p2 不响应 age 方法。 6.消息发送机制和消息转发。 7.KVO 的实现原理 8.多个分类实现了同一个方法，查找顺序 9.Swift 的 String 为什么设计成值类型？ 安全，copy，快速 10.设计 LRU 最近最少使用","link":"/人人车面试题/"},{"title":"全民短视频面试题","text":"全民短视频面试题 1、@property 属性关键字 2、GCD 3、Runtime 底层 4、Runloop 底层实现、线程跟 Runloop 的关系 5、AFNetworking 内部结构和实现原理。 6、怎么避免崩溃，像数组字典崩溃等 7、友盟分析闪退的具体步骤，怎么定位到闪退的代码位置 8、安全攻防 9、https 证书配置 10、自动化测试 11、有没有做过单元测试","link":"/全民短视频面试题/"},{"title":"十点读书面试题","text":"十点读书面试题 1、MRC 和 ARC，自动释放池 AutoreleasePool 和 ARC 的关系？ 2、直播是用的 rmtp 协议吗？rmtp 说一下？ 3、聊天用的什么？web Socket 了解吗？HTTP 属于哪一层？web socket 属于哪一层？ 4、copy 和 MutableCopy ？从可变不可变和深浅拷贝两个层面说一下区别？ 5、NSString 用 copy 和用 Strong 有什么区别？ 6、内存优化？ 7、weak 和 unown 的区别？ 8、协议继承什么？继承 NSObjectProtocol 和继承自某个 class 有什么区别？ 9、Swift 是运行时语言吗？Swift 怎么用 OC 的运行时特性？","link":"/十点读书面试题/"},{"title":"墨迹天气面试题","text":"墨迹天气面试题 一面1.Swift 与 OC 方法调用的区别 2.方法查找的过程，Runtime 消息机制，怎么避免无法识别的方法选择器的闪退？ 3.Runtime 的应用 4.Category 和本类的同名方法执行哪个 5.线上卡顿怎么监测，监测原理 Runloop 6.做过哪些优化 7.多线程用的多吗？线程同步有哪些方案？锁的效率从高到低说一下 8.打印结果 1234567891011121314151617181920- (void)viewDidLoad { [super viewDidLoad]; dispatch_sync(dispatch_get_main_queue(), ^{ NSLog(@\"0\"); }); dispatch_async(dispatch_get_main_queue(), ^{ NSLog(@\"1\"); }); dispatch_async(dispatch_get_global_queue(0, 0), ^{ NSLog(@\"2\"); }); dispatch_sync(dispatch_get_global_queue(0, 0), ^{ NSLog(@\"3\"); }); NSLog(@\"4\");} 9.Flutter 遇到过什么问题，图片列表滑动把不在屏幕上显示的内容干掉(复用)会有什么问题吗，优化方案 10.个人规划 二面1.Flutter 的状态管理 2.Flutter 布局，Expanded 和 Flex 布局的区别 3.InheritedWidget 用过吗？stream 用过吗？ 4.Flutter 动画 5.webView 与 H5 交互，为什么没有考虑注册的方式，加载一个 H5 页面经历了哪些步骤？ 6.HTTPS 增加了哪些流程？DNS 的过程 7.长链接，了解 webSocket 吗 8.直播推流的过程 9.内存管理，类的属性 p.name = @”zhangsan”; 和方法里的变量 NSString *name = @”zhangsan”; 分别存在哪里？ 10.交换方法 11.Category 的本质 12.多线程，线程同步都有哪些方法，值为1的信号量和互斥锁有什么区别 13.算法：一个 int 数组，查找第 K 个大的数。 二面1.介绍项目亮点 2.数据和链表区别 3.方法查找过程 4.frame bounds 区别，UIView、CALayer，动画 5.block __block 6.内存优化 查找内存泄露 7.锁 自旋锁使用场景 互斥锁和信号量区别 8.方法交换是怎么交换的，注意点 9.链表是否有环 10.flutter 的状态管理 11.命令式编程与响应式编程","link":"/墨迹天气面试题/"},{"title":"元石","text":"元石 一面： 项目 1.SSE 怎么实现逐字打印效果，event来了个卡片，怎么保证顺序？ 2.三方接入成本为什么还需要5人日？toast这种是不是SDK实现好点，担心增加体积可以用subPackage 3.SDK体积优化 4.加载速度优化 5.活动页组件化 6.卡顿监控，能获取到卡顿的堆栈吗？ 7.组件化能不在+load注册吗？attribute注册了解吗？ 算法： 1.39. 组合总和 2.合并两个有序链表 二面： 1.通用化技术提升迭代效率，scheme和动态化，设计scheme需要有哪些注意点 2.白屏率怎么统计？ 3.活动页组件化 4.RN跟Flutter的对比 5.SSE实现打字机效果，对SSE的了解，切换前后台，怎么断点续传 6.算法：反转数 输入int 返回int 边界条件、能运行","link":"/元石/"},{"title":"京东面试题","text":"京东面试题 1、AFNetworking 是如何实现多线程的。 2、如何自己控制 AFNetWorking 的多线程，如果解决上传多张图片引起的内存剧增的问题。 3、模块化的实现过程。 4、自动化测试。 5、数据库的升级（当前数据库不能满足业务了，1.0-&gt;2.0-&gt;3.0…..）。","link":"/京东面试题/"},{"title":"太一云面试题","text":"太一云面试题 1、@property 属性的修饰符？String 为什么用 copy ？String 能不能用 strong ？NSMutableString 能不能用 Strong？ 2、单例的本质？项目里怎么用的单例？ 3、说一下 KVO，说一下通知，通知属不属于观察者模式？ 4、说一下 GCD 的同步、异步。GCD 你是怎么用的？ 5、说一下内存管理。MRC 了解吗？ARC 下系统是怎么自动加 retain、release 的？ 6、了解 AutoreleasePool 吗？如果不写 autorelease，对象会被添加到 Pool 里吗？ 7、了解 Socket 吗？","link":"/太一云面试题/"},{"title":"好未来面试题","text":"好未来面试题 一面1、说一下optional。（？ ！ ？？ 几种解包方式 if let、guard、？？等） 2、说一下闭包。 3、比较代理、通知、KVO？这三个谁的效率最高，谁的效率最低？( KVO 效率最低，因为 Runtime ） 4、NSString 和 String 的区别？（ String 是值类型，NSString 是引用类型） 5、Swift 跟 OC 的区别？（ OC 是动态的语言，Swift 是静态的语言）OC 是面向对象的，Swift 呢？（面向对象、面向协议、响应式编程）解释一下面向协议编程？ 6、说一下 MRC ？自动释放池？自动释放池什么时候释放？（我说 drain ） 7、说一下多线程？（我提到了 dispatch_once 单例） 8、分别用 OC 和 Swift 手写一下单例。（ Swift 的单例我忘记写 static 了，但是经提醒立马说出来了） 9、SnaptKit 内部看过吗？ 10、链式语法的实现。 UIView.top.equalTo().offSet(10) UIView.left.equalTo().offSet(10) 为什么能写成UIView.top.left.offSet(10) 二面主要是手写算法题： 1、用两个栈实现队列。 2、从扑克牌中抽出5张，写一个方法判断是不是顺子。（如34567）大小王是万能的，可以替代任意数字。 三面项目经理 四面HR","link":"/好未来面试题/"},{"title":"好未来面试题及答案","text":"好未来面试题 1. 一面1、说一下optional。?! ?? 是什么意思？有几种解包方式？解包方式：if let、guard、!强制解包、?? 等。 ?! ?? let a = b ?? c 如果b不为nil，则a = b;否则a = c; 2、说一下闭包。闭包是能够读取其他函数内部变量的函数，可以理解成定义在一个函数内部的函数。 可以用typealias起别名 1234typealias testBlock = (String) -&gt; Voidlet aaa: testBlock = {str in print(str)} 值捕获 闭包可以捕获上下文中的常量和变量 逃逸闭包 当一个闭包作为参数传入函数中，这个闭包需要等函数执行结束返回后执行，这种情况就称作这个闭包在函数中逃逸。在涉及异步操作时经常用到，特别是网络请求后要进行请求成功后的回调时，闭包就要逃逸掉，这时就要在闭包形参前加上@escaping关键字。 3、比较代理、通知、KVO？这三个谁的效率最高，谁的效率最低？KVO 效率最低，因为使用到了 Runtime。 代理效率最高，因为是一对一。 4、NSString 和 String 的区别？String 是值类型，NSString 是引用类型。 5、Swift 跟 OC 的区别？OC 是面向对象的，Swift 呢？（面向对象、面向协议、响应式编程）解释一下面向协议编程？OC 是动态的语言，Swift 是静态的语言。 6、说一下 MRC ？自动释放池？自动释放池什么时候释放？iOS 在主线程的Runloop中注册了2个Observer 第1个Observer监听了kCFRunLoopEntry事件，会调用objc_autoreleasePoolPush() 第2个Observer 监听了kCFRunLoopBeforeWaiting事件，会调用objc_autoreleasePoolPop()、objc_autoreleasePoolPush() 监听了kCFRunLoopBeforeExit事件，会调用objc_autoreleasePoolPop() 7、说一下多线程？NSThread NSOperation GCD 8、分别用 OC 和 Swift 手写一下单例。单例模式在创建过程中，要保证实例变量只被创建一次。在整个开发中需要特别注意线程安全，即使在多线程情况下，依然只初始化一次变量。 12345678+ (instanceType)sharedManager { static Manager *sharedManager = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ sharedManager = [[Manager alloc] init]; }); return sharedManager;} 在 Swift 中，let 关键字已经保证了实例变量不会被修改，所以单例的创建就简单很多：1234class Manager { static let shared = Manager(); private init() {}} 9、SnaptKit 内部看过吗？10、链式语法的实现。UIView.top.equalTo().offSet(10) UIView.left.equalTo().offSet(10) 为什么能写成UIView.top.left.offSet(10) ？ block 返回 self 自身，例如： 123456789// 当前类是ViewController类 block 返回类对象 类对象就可以继续调用 test 方法了- (ViewController *(^)(int))test{ ViewController *(^block)(int i) = ^ViewController *(int i){ NSLog(@\"%d\",i); return self; }; return block;} 调用的时候就可以这样写： 1self.test(1).test(2).test(3); 链条的执行顺序 self 调用 test 方法 test 方法返回 block block 得到小括号中的参数 并执行 block 中的代码 block 返回对象 对象接着调用 test 方法 实际应用中 test 可以是任何这种格式的方法 OC中链式语法的使用及原理 2. 二面主要是手写算法题： 1、用两个栈实现队列。123456789101112131415var inStack = [];var outStack = [];function push(node){ inStack.push(node);}function pop(){ if (outStack.length == 0) { while(inStack.length != 0) { outStack.push(inStack.pop()); } } return outStack.pop();} 2、从扑克牌中抽出5张，写一个方法判断是不是顺子。（如34567）大小王是万能的，可以替代任意数字。剑指 Offer 61. 扑克牌中的顺子 1234567891011121314var isStraight = function(nums) { let repeat = new Set(); let max = 0, min = 14; for (let i = 0; i &lt; nums.length; i++) { if (nums[i] == 0) continue; // 跳过大小王 max = Math.max(max, nums[i]); // 最大牌 min = Math.min(min, nums[i]); // 最小牌 if (repeat.has(nums[i])) { return false; } repeat.add(nums[i]); } return max - min &lt; 5; // 最大牌 - 最小牌 &lt; 5 则可构成顺子}; 3. 三面项目经理聊项目 4. 四面HR问了很多问题，包括个人优缺点，闲暇时间会做什么，在前公司3年的成长等等。","link":"/好未来面试题及答案/"},{"title":"平安面试题","text":"平安面试题 1.什么是多态？具体在项目中怎么用的？ 2.说一下组件化开发（业务组件非UI组件）； 3.调用未实现的方法会发生什么，然后通过什么可以进行处理？消息转发的具体流程？消息转发流程在实际中的应用？ 4.KVO 的原理？ 5.分类的底层实现？ 6.App 启动优化？热启动&amp;冷启动，具体优化？ 7.Vue 的双向绑定？ 8.说一下你对 Runloop 的理解，Runloop 的应用？ 9.项目中具体是怎么用的多线程？ 10.bug 管理工具？bug 率，日活？ 11.项目中你的职责所在？ 12.是否读过 SDWebImage，AFNetworking 底层？","link":"/平安面试题/"},{"title":"开果科技面试题","text":"开果科技面试题 一面1、卡顿原因、解决办法。为什么透明视图不如不透明视图？ 2、闪退原因、监测、过程。友盟是怎么捕获闪退的？从一个事件到闪退发生了什么？ 3、图片的压缩，从600k到500k，不能设置固定压缩比，应该怎么做？压缩图片，压缩图片实际压缩的是哪些东西？加载超大图；图片在计算机中的存储形式；10M的图片加载到内存中是多大？大图是怎么加载的？ 图像文件存储的都是每一个像素对应的颜色值。 4、字典的本质？哈希表原理？ 哈希表。 5、链表和数组，哪个容易找到地址？ 数组。 在内存中，数组是一块连续的区域。插入和删除数据效率低。随机读取效率很高，因为数组是连续的，知道每一个数据的内存地址，可以直接找到给地址的数据。 链表增加和删除数据很容易。查找数据时效率低，因为不具有随机访问性。 6、列表有好多页，某一页和后边加载的一页中有相同的数据，怎么处理？ 7、动态库和静态库的区别。 8、设计模式。 二面(电话面试)1、什么时候开始接触 iOS？怎么学的iOS？ 2、公司多少人？什么项目？ 3、你会选择什么样的公司？ 4、数据库（SQLite/Realm）是怎么保证线程安全的？ 5、UserDeafaults 系统做了哪些优化？为什么可以在主线程上去做存取？如果让你实现，方法已经是同步的方法了，你会怎么处理？ 6、+load 和 +initialize 方法什么时候会调用，+load 和 +initialize 方法、main 方法这三个的调用顺序。 7、@class 和 #import 在编译的时候有哪些区别？ 8、JSON 转 Model 你用的是什么？MJExtension 字典转模型的具体步骤？拿到字典了，第一步做什么，第二步做什么？ 9、WebView 跟 JS 是怎么交互的？ 10、WebView 怎么存 cookie？ 11、A-&gt;B-&gt;C-&gt;D 从D返回到B。说几个不同的实现思路。 方案1：for 循环 self.navigationController.viewControllers 判断某个控制器是否是 B 如果是就 popToViewController:B。 方案2：self.navigationController.viewControllers 是一个不可变数组，可以赋值给一个可变的数组，然后把 C 移除，然后再赋值给 viewControllers。 其他方案：提示不一定要 push，present出来的怎么弄？ 12、二分查找。 13、深拷贝与浅拷贝，某个值得改变可能会影响原始值，那是深拷贝还是浅拷贝？ 14、性能优化？图片加载到 UIImageView 上经过了哪些过程？ 15、Label 怎么多行显示。 16、Button有哪些状态？ 17、dispatch_group_notify 是在哪个线程上？","link":"/开果科技面试题/"},{"title":"必要商城面试题","text":"必要商城面试题 1.项目搭建都做了哪些？2.有没有做过解耦？参考链接：iOS组件化（四）-代码解耦合 iOS组件化从零开始 3.路由怎么实现传值的？参考链接：iOS组件化（五）-组件间调用 4.项目优化？ 安装包大小优化 性能优化 启动优化 防崩溃 5.防崩溃处理？runtime 交换方法 6.cell 加载图片的优化？7.项目难点？8.数据传递除了加密以外，怎么保证数据安全？ 使用数字证书锁定来保证不被中间人拦截，将服务器返回的数据和我的本地证书进行对比，确保是从服务器返回回来的。 使用 https 协议请求网页，post 来请求网页数据，保证用户的账号密码不被被人获取到。 使用苹果自己的 SSKeyChain 钥匙串，将用户的账号密码保存在钥匙串中。 参考链接：iOS开发，让数据更安全的几个加密方式 9.原生与 H5 的交互？WKWebView 和 UIWebView 的区别？10.Cocopods 怎么管理自己的第三方库？11.除了 MVC 有没有了解过别的设计模式？12.方法交换原理？方法交换，交换的是方法的实现。","link":"/必要商城面试题/"},{"title":"微店面试题","text":"微店面试题 1. 一面1、说项目里的有价值的东西？ 2、HTTPS 过程是怎么样的？非对称加密 3、Swift 中逃逸闭包和非逃逸闭包的区别？ 4、属性用 copy 关键字，是深拷贝还是浅拷贝？深拷贝和浅拷贝的区别？ 5、SDWebImage 的缓存机制？LRU 内部原理？下载完成图片后，是先存到内存、磁盘后，才显示到界面上吗？ 6、AFN 用到了 NSOperation、GCD，说一下内部 Operation 相关的？Manager？ 7、GCD 内部实现？ 8、约束 left/right 和 leading/trailing 的区别？约束报黄怎么解决？ 9、KVO 的原理？具体 NSObject 的两个方法？ 10、消息转发流程？使用场景？ 11、数据库减字段怎么容错？ 12、有没有打包过私有库？ 13、从点击 App 的图标到 App 启动，说一下这个过程？+load 发生在什么时候？ 14、用什么管理第三方库？CocoaPods 中的 .lock 文件存储了什么信息？ 15、说一下一个项目的架构？ 16、组件化？ 17、手写冒泡排序算法？算法复杂度？ 2. 二面1、项目介绍，开发人员分工？购物车本地化如果加入购物车的价格变了怎么处理的？ 2、写一下其中一个项目的项目架构？写一下用到的第三方库。 3、项目用什么管理的？CocoaPods 指定版本号带 ~ 跟不带 ~各有什么含义？ 4、AFN 实现原理？发10个网络请求，AFN 内部是怎么处理的？ 5、SDWebImage 是怎么加载图片的？用的是 Get 还是 Post ？如果让你实现，你会选择 Get 还是 Post ？ 6、HTTPS 流程是怎么样的？（画一下客户端、服务器的时序图） 7、加密算法，对称加密和非对称加密？ 8、如何理解 OC 是动态语言？ 9、Runtime？用 Runtime 做过什么？ 10、Runloop？内部实现原理？跟自己写个 for 循环有没有区别？ 11、内存管理？内存优化？ 12、卡顿？ 13、多线程？用 GCD 实现同步多个异步调用（a，b），然后再同步执行（c，d） 14、从点击 App 图标，到显示界面流程？ 15、组件化？ 16、编译过程？某一个东西是属于哪一步骤的？ 17、微信支付流程（客户端、微信 SDK 、自己服务器、微信服务器时序图） 18、RN、Week？内部是怎么用 JS 调用原生的？ 19、日志记录？ 20、遇到的闪退？Bug？ 21、竞争同一个资源？ 22、进程线程与 App 的关系。 23、Git rebase","link":"/微店面试题及答案/"},{"title":"快狗打车面试题","text":"快狗打车面试题 1.dart 语法 .. 是什么意思 2.怎么封装一个 Flutter 组件来让原生调用 3.用的网络请求库是哪个？Flutter 怎么抓包 4.state 的生命周期 5.buildContext 是接口、协议还是什么？ 6.Widget 是什么 7.父子 widget 之间怎么传值，父 widget 怎么管理子 widget 的状态，怎么局部刷新？ 8.同步可以使用 try catch 来捕获异常，带 Future 的异步方法的异常怎么捕获 9.单链表反转有几种方法，你觉得你的方法是最优的吗？ 10.快速排序，轴点能不能用中间的一个数，怎么优化快排","link":"/快狗打车面试题/"},{"title":"恒天财富面试题","text":"恒天财富面试题 一面1.KVO 的实现原理 2.Category 的底层结构，Category 能添加成员变量吗？为什么？ 3.load 和 initialize 的区别？initialize 的调用顺序？ 4.Block 为什么用 copy？Block 的类型？Block 的结构 5.Runtime 的消息流程 6.说说你了解的 Runloop 7.项目亮点 8.怎么实现 webView 秒开 H5 9.项目优化 二面（前端负责人）1.打开一个 App，首页关掉网络后还可以显示一些内容，怎么实现的，有落地吗？ 2.webView 跟 H5 交互方式？是 url scheme 吗？Bridge 用了吗 3.从加载 H5 到界面显示出来这段时间的白屏发生了什么？ 4.打开一个示例 App，webView 加载 H5 秒开？离线包了解吗？行业解决方案 5.Vue 的生命周期 6.v-if 的作用 7.父子组件怎么传值？ 8.知道 vuex 吗？ 三面（后端负责人）1.介绍项目模块，项目分工 2.安卓 App 提示更新，更新一半退出再进来，从头下载了。断点续传怎么做？ 3.查看药店首页，白屏 loading 时间长怎么优化？ 4.webView 白屏怎么优化？ 5.做过哪些具体的优化 6.除了埋点还有什么方式排查问题？不能复现的问题怎么查？ 四面（部门负责人） HR","link":"/恒天财富面试题/"},{"title":"新浪乐居面试题","text":"新浪乐居面试题 笔试题笔试题 一面1、类方法和实例方法有什么区别？ 2、用封装的类方法去请求网络会有什么问题？ 3、说一下单例。单例的作用是什么？为什么不能多次创建对象？ 4、说一下 ARC、MRC，有什么区别？有啥优缺点？ 5、自动释放池的使用场景？耗内存时需要加到池子里。 6、沙盒目录除了 Documents 还有啥？Cache 和 Temp 有什么区别？ SDWebImage 是在 Library 下的 Caches 里 7、项目里用地图了吗？如果用系统的地图会有一个问题，电量急速下降，遇到过这个问题吗？ 8、都有哪些可能循环引用？ 9、说一下从网络请求回来的数据怎么存？数据持久化的方法。数据库是存在沙盒的哪个目录？我说在 Documents 中。 10、assign 与 weak 区别？ 11、笔试题19的答案为什么是2、5？ 12、说一下冒泡排序的思路？ 13、GCD 需要注意什么？我说了一下使用场景。 14、Runtime、Runloop 了解吗？Runloop 有哪些 Mode？说一下 CommonMode ？ 15、最后一个问题：类似简历 右上角是图片（宽高已知） 左边是一段文字 文字会包裹着图片，问实现思路？ 说了三个思路：（1）计算一下上边 label 宽高，左边用一个 label 显示，下边多余的字也用另一个 label 显示。 （2）YYText 可能有处理办法，算是第三方。 （3）他提示底层一点的，我说绘制。 二面1、了解项目，问在公司干啥。 2、AutoLayout 和 Masonry 有什么区别？ 3、面向对象在 OC 中的体现？封装、继承、多态。你觉得最主要的是面向对象的哪个特性？ 4、你对 H5、原生交互的看法。我说了实现方式后，他说不要实现细节，就你的看法。我又说了阿里是大前端，他说不要说阿里，你的看法呢？我说活动页用H5，其他用原生，可能效率高。 5、Block 和 delegate 的使用场景差异？ 6、你觉得开发一个项目难点在哪儿？ 7、其他问题：薪水能商量吗？有什么要问我的？","link":"/新浪乐居面试题/"},{"title":"普华商学院面试题","text":"普华商学院面试题 1.怎么学的 iOS？ 2.连击动画实现？（队列、线程） 3.直播底层技术？ 4.封装网络请求怎么封装的？详细的需要考虑的东西 5.runtime 找不到这个方法怎么能够不报错？在动态方法解析那个方法里具体怎么写？runtime 有哪些应用？ 6.类的本质 结构体里边有哪些东西？ 7.数据存储有哪些？ 8.runloop timer runloop 底层是什么？ 9.timer 怎么防止循环引用？在哪里停掉 timer？didDisappearer里行不行？除了 timer 还有哪些可以实现定时器？CADispalyLink 10.delegate 用什么修饰符？用 asign 行不行？weak 是怎么把指针置为 nil 的？ 11.tableView cell 里有图片 页面滑动时 SDWebImage 有没有处理 在滑动时不加载 停止滑动时加载 它是怎么做到的？ 12.高度缓存有没有做？ 13.你对加班怎么看？","link":"/普华商学院面试题/"},{"title":"朗播网面试题","text":"朗播网面试题 机试题 1、图片轮播是怎么做的？ 2、缓存图片用的什么？（SDWebImage）说一下 SD 的缓存机制？ 3、SD 缓存满了，是怎么清理的？ 4、从磁盘取出，从内存取出，显示到界面上，这个过程发生了什么？ 5、移动一个图片，比如从左边移动到右边，CPU/GPU 做了什么？谁的贡献大一点？ 6、数据结构跟算法，单链表反转 7、只遍历，用数组还是链表好？ 8、大数据排序？怎么合并拆分的小段的？ 9、淘汰算法？","link":"/朗播网面试题/"},{"title":"搜狐面试题","text":"搜狐面试题 1.介绍一个印象深刻的项目，遇到过什么问题，怎么解决的。 组件化为什么没有用一个通用的字典来接收页面参数，这样不是更通用？ webView 交互协议怎么制定的？H5 从原生拿返回值怎么实现的？ 2.做过哪些优化 3.你觉得你最擅长哪方面？比如 UI、架构啥的 4.微博详情页（内容、转发、评论）让你来做，你会怎么实现？从外层到内层用什么控件，具体实现。 5.算法题 有一个产品发布了多个版本，它遵循以下规则：假如某个版本崩溃了，则后面的所有版本都会崩溃。 举个例子：一个产品假如有5个版本，其中第1-3版本都是正常的，但是第4个版本崩溃了，那么第5个版本（最新版本）一定也崩溃，第4个版本被称为第一个崩溃版本。 现在已知一个产品有n个版本，而且有一个检查算法func isBadVersion(version:Int) -&gt; Bool 可以判断一个版本是否崩溃，假设这个产品的最新版本崩溃了，求第一个崩溃的版本。 思路：本质上是有重复数字的升序数组的二分查找 1234567891011121314151617function search( nums , target ) { let start = 0 if(!nums.length) return -1; let left = 0, right = nums.length - 1; while(left &lt;= right) { let mid = Math.floor((left + right) / 2); if(target == nums[mid]) { while(mid != 0 &amp;&amp; nums[mid - 1] == nums[mid]) mid--; // 找到第一个数 return mid; } else if(target &lt; nums[mid]) { right = mid - 1; } else { left = mid + 1; } } return -1;} 6.想实现一个图片，删除后撤销删除，你会用什么数据结构来怎么实现？","link":"/搜狐面试题/"},{"title":"核桃编程面试题","text":"核桃编程面试题 1.消息发送和消息转发的过程 2.KVO 的原理 3.能不能动态添加成员变量 4.分类为啥不能添加成员变量 5.说一下 HTTPS 和 TCP、UDP 6.说一下项目亮点 7.方法交换注意什么 8.链表反转 9.NSNumber 怎么进行优化的，数据存储哪里 10.GCD 和 NSOperation 各自的优点 11.Runtime 的应用","link":"/核桃编程面试题/"},{"title":"汽车之家","text":"汽车之家1.动态库和静态库的区别 2.网络优化 3.静态分析发现了哪些问题？ 4.加载速度优化 5.Crash 监测，野指针定位 .打印结果 123456789__block int a = 0; int(^aBlock)(int) = ^(int num) { a += num; if (a &lt; 5) { aBlock(a); } return a++; }; NSLog(@\"%d\", aBlock(1)); aBlock为什么是空？","link":"/汽车之家/"},{"title":"棵朵面试题","text":"棵朵面试题 1、结构体和类有什么区别？ 2、NSString 和 String 有什么区别？ 3、?? 是什么意思？ ? 是什么意思？ ! 是什么意思？ 4、说一下 @property， weak 和 assign 有什么区别？weak 能不能修饰非 OC 的对象？ 5、MutableCopy 和 copy ，即深拷贝和浅拷贝有什么区别？ 6、NS、CA、CF、UI 分别属于哪个框架？ 7、多线程有没有自己开辟过线程？ 8、从服务器得到5个图片链接，5张图片展示到一个页面上，截图分享到微信？怎么保证5张图全部加载出来了再去截图分享？ 9、JS 与 OC 交互，点击 H5 某个地方跳转到购物车，点击某个地方跳转到详情页，点击某个地方跳转到订单页，跳转到指定的页面你现在用的是判断的跳转类型，如果新增了一种，怎么能不发版完成需求？ 10、你用 swift 开发用没用过 VIPER 架构模式？","link":"/棵朵面试题/"},{"title":"滴滴笔试题","text":"滴滴笔试题 笔试题0.姓名？日期。 1.C语言实现字符串反转：void reverse(char *str, int length) {} 2.实现一个字符串数组去重函数。 3.描述OC中对象的实现原理。 4.编写代码，实现 NSObject 中添加一个属性 p1 5.KVO 的实现原理和注意事项。 6.下面的代码有哪些问题？ 123456789101112131415@interface Demo : NSObject@property (nonatomic, assign) BOOL *p1;@property (nonatomic, strong) NSString *p2;@end@implementation Demo@dynamic p1;- (void)setP2:(NSString *)p2;{ self.p1 = YES; self.p2 = p2;}@end 7.JS 和 Native 的通讯方式。 8.网络5层模型是哪5层？ 9.把t1表中 name 为 mike 的记录中 status 值改为1 10.常用的 Linux 命令。 11.用过的包/库管理工具。","link":"/滴滴笔试题/"},{"title":"滴滴面试题","text":"滴滴面试题 笔试题笔试题 滴滴一面看了一下笔试题的答案，第一题 C 语言字符串反转打印了一下 1、说一下你觉得项目中遇到了什么印象深刻的问题，你是怎么解决的？ 2、大学里学了哪些课？信息管理与信息系统专业是哪个学院的？ 3、项目里的网络请求用到了网络5层模型的哪些，TCP/IP 属于哪一层？HTTP 呢？ 4、你觉得自己是什么级别的？优势和不足主要是哪方面？ 5、GCD 平时项目里怎么用的？我提到了回到主线程操作 UI 需要 dispatch_get_mainQueue 6、为什么操作 UI 需要在主线程？ 7、哪些是你独立开发的项目？ 8、问了一下上家公司的情况 9、之后有什么打算？ 10、上家薪资多少？你还有啥想问的吗？ 滴滴二面1、自定义封装控件需要注意什么？有什么规范？ 2、说一下你了解的设计模式。 3、数据库怎么优化？我说数据量大的话加索引提升查询效率。问其他优化呢？比如数据库大小有没有做过优化？ 4、内存优化是怎么做的？我提到了内存泄漏。什么情况会发生内存泄漏？ 5、App 启动时间优化？ 6、视图做过哪些优化，我提了 TableView。那就以 TableView 说一下优化了哪些方面？ 7、AFNetworking 内部是怎么样的一个过程？ 8、你还有什么想问我的？","link":"/滴滴面试题/"},{"title":"登云美业面试题","text":"登云美业面试题 1、@porperty 系统自动帮我们做了什么？如果后边的括号里啥都不写，系统默认的是哪三个？哪些用 copy ？为什么 String 用 copy ？为什么 block 用 copy ？ 2、单例的本质是什么？怎么用的？ 3、封装了什么自定义控件？ 4、说一下 MVC、MVVM 5、多线程都有哪些？项目里哪里用到了 GCD ？ 6、说一下 RuntimeKNFather : NSObjectKNSon : KNFather在 KNSon 中的 init 方法里打印 NSLog [self class] [super class]KNSon alloc init 之后打印结果是什么？ 7、AFN 内部看过吗？AFN 封装了吗？ 8、说一下 SDWebImage 缓存机制 9、Instruments 你们项目什么周期用？用它的哪些功能？ 10、京东的某个页面是怎么做的 涉及到 tableView 的 contentSize 变化。 11、项目里跑马灯怎么实现的？ 12、TouchID 是怎么做的？ 13、KeyChain 保存密码你们是啥时候保存的，保存的密码加密了吗？ 14、JS 交互是怎么做的？ 15、人脸识别 SDK 封装了吗？ 16、个推消息有没有做缓存？App 在前台、后台、杀死这三种状态下怎么处理的？ 17、项目里你觉得哪里最有收获？","link":"/登云美业面试题/"},{"title":"百易图","text":"百易图1.内存管理，ARC、MRC，有没有遇到内存问题，怎么解决的，内存泄漏 2.了解的iOS中的设计模式，tableView用了什么设计模式？享元模式 3.MVVM怎么实现双向绑定 4.多线程，多个请求并发，请求回来后处理 5.加载速度优化，怎么优化的多次刷新 6.直播聊天室大量消息优化，送礼物怎么保证触达 7.500人群里抢红包的场景处理 8.swift类和结构体的区别 9.减少CPU占用的优化 参考答案 1.内存管理，ARC、MRC，有没有遇到内存问题，怎么解决的，内存泄漏 Tagged Pointer NSNumber、NSDate、NSString等小对象的存储，数据直接存储在指针中 引用计数来管理OC对象的内存 引用计数存储在 nonpointer 优化过的isa指针中，也可能存储在SideTable类中， SideTable { ​ spinlock_t slock; ​ RefcountMap refcnts; ​ weak_table_t weak_table; }; refcnts 是一个存放着对象引用计数的散列表 2.了解的iOS中的设计模式，tableView用了什么设计模式？ 在iOS开发中，UITableView 主要使用了一系列设计模式来实现其功能，包括但不限于以下几种设计模式： 1. 委托模式（Delegate）描述：通过将一个对象的某些职责委托给另一个对象来实现对象间的松耦合。 在 UITableView 中的应用： UITableView 使用委托模式来处理用户交互和配置特定行为。UITableViewDelegate 协议定义了一些方法，这些方法由委托对象（通常是视图控制器）实现，以响应用户操作（如行选择、行高设置等）。 2. 数据源模式（Data Source）描述：通过将数据访问和数据管理的职责委托给另一个对象来实现数据的解耦。 在 UITableView 中的应用： UITableView 使用数据源模式来提供数据。UITableViewDataSource 协议定义了一些方法，这些方法由数据源对象实现，以提供表格视图所需的数据（如单元格内容、行数等）。 3. 复用模式（Reuse）描述：通过对象的复用来提升性能和减少内存消耗。 在 UITableView 中的应用： UITableView 使用单元格复用机制来提高性能。通过 dequeueReusableCellWithIdentifier: 方法，表格视图可以复用已经创建的单元格，而不是每次都创建新的单元格。 4. MVC 模式（Model-View-Controller）描述：一种用于组织代码的架构模式，将应用的逻辑层、数据层和视图层分离。 在 UITableView 中的应用： UITableView 本身是视图层的一部分，数据源和委托对象（通常是视图控制器）负责处理数据层和逻辑层。这种分离使得代码更清晰、可维护性更高。 3.MVVM怎么实现双向绑定 4.多线程，多个请求并发，请求回来后处理 5.加载速度优化，怎么优化的多次刷新 6.直播聊天室大量消息优化，送礼物怎么保证触达 7.500人群里抢红包的场景处理 8.swift类和结构体的区别 9.减少CPU占用的优化","link":"/百易图/"},{"title":"百度面试题","text":"百度面试题 百度一面1.APP 优化2.列表快速滑动不需要加载的图片怎么处理3.cell 加载大图4.异步绘制5.交换方法6.圆角的处理7.监听子线程处理 UI 事件 百度二面1.项目经验介绍（问 RTMP 协议，UDP 主动丢包策略）2.项目中遇到什么难点3.为什么要制作动态库 系统动态库会影响启动时间吗4.HTTPS ( CA 证书验证流程)5.Category 原理6.异步发送通知 (NSNotificationQueue)7.算法 参考答案百度一面1.APP 优化 iOS 保持界面流畅的技巧 启动优化 安装包大小优化：正经分析iOS包大小优化 2.列表快速滑动不需要加载的图片怎么处理目前有些第三方微博客户端（比如 VVebo、墨客等），使用了一种方式来避免高速滑动时 Cell 的绘制过程，相关实现见这个项目：VVeboTableViewDemo。它的原理是，当滑动时，松开手指后，立刻计算出滑动停止时 Cell 的位置，并预先绘制那个位置附近的几个 Cell，而忽略当前滑动中的 Cell。这个方法比较有技巧性，并且对于滑动性能来说提升也很大，唯一的缺点就是快速滑动中会出现大量空白内容。如果你不想实现比较麻烦的异步绘制但又想保证滑动的流畅性，这个技巧是个不错的选择。 3.cell 加载大图 分片比例裁剪方式。参考苹果给出的 demo,利用 CGImageCreateWithImageInRect 截取原图对应位置的内容,再通过 CGContextDrawImage 渲染到指定位置; 利用 CATiledLayer 层级的API,自动进行绘制; 参考链接：iOS 大图显示解决办法 4.异步绘制 5.交换方法6.圆角的处理优化方式1 ：使用贝塞尔曲线 UIBezierPath 和 Core Graphics 框架画出一个圆角 1234567891011UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(100,100,100,100)];imageView.image = [UIImage imageNamed:@\"myImg\"];//开始对imageView进行画图UIGraphicsBeginImageContextWithOptions(imageView.bounds.size,NO,1.0);//使用贝塞尔曲线画出一个圆形图[[UIBezierPath bezierPathWithRoundedRect:imageView.boundscornerRadius:imageView.frame.size.width]addClip];[imageView drawRect:imageView.bounds];imageView.image=UIGraphicsGetImageFromCurrentImageContext();//结束画图UIGraphicsEndImageContext();[self.view addSubview:imageView]; 参考链接：iOS 圆角优化实现代码 7.监听子线程处理 UI 事件[CALayer display] 百度二面1.项目经验介绍（问 RTMP 协议，UDP 主动丢包策略）2.项目中遇到什么难点3.为什么要制作动态库 系统动态库会影响启动时间吗 库类型 优点 缺点 静态库 1. 目标程序没有外部依赖，直接就可以运行。2. 效率教动态库高。 1. 会使用目标程序的体积增大。 动态库 1. 不需要拷贝到目标程序中，不会影响目标程序的体积。 2. 同一份库可以被多个程序使用（因为这个原因，动态库也被称作共享库）。 3. 编译时才载入的特性，也可以让我们随时对库进行替换，而不需要重新编译代码。实现动态更新 1. 动态载入会带来一部分性能损失(可以忽略不计） 2. 动态库也会使得程序依赖于外部环境。如果环境缺少动态库或者库的版本不正确，就会导致程序无法运行（Linux lib not found 错误）。 参考链接：iOS动态库、静态库及使用场景、方式 4.HTTPS (CA 证书验证流程)数字证书认证机构的业务流程 服务器的运营人员向第三方机构 CA 提交公钥、组织信息、个人信息(域名)等信息并申请认证; CA 通过线上、线下等多种手段验证申请者提供信息的真实性，如组织是否存在、企业是否合法，是否拥有域名的所有权等; 如信息审核通过，CA 会向申请者签发认证文件-证书。证书包含以下信息：申请者公钥、申请者的组织信息和个人信息、签发机构 CA的信息、有效时间、证书序列号等信息的明文，同时包含一个签名。 其中签名的产生算法：首先，使用散列函数计算公开的明文信息的信息摘要，然后，采用 CA 的私钥对信息摘要进行加密，密文即签名; 【数字签名生成的过程】 客户端 Client 向服务器 Server 发出请求时，Server 返回证书文件; 客户端 Client 读取证书中的相关的明文信息，采用相同的散列函数计算得到信息摘要，然后，利用对应 CA 的公钥解密签名数据，对比证书的信息摘要，如果一致，则可以确认证书的合法性，即服务器的公开密钥是值得信赖的。【校验数字签名的过程】 客户端还会验证证书相关的域名信息、有效时间等信息; 客户端会内置信任 CA 的证书信息(包含公钥)，如果 CA 不被信任，则找不到对应 CA 的证书，证书也会被判定非法。 参考链接：经得住拷问的HTTPS原理解析 5.Category 原理6.异步发送通知 (NSNotificationQueue)参考链接：iOS中的NSNotification 7.算法","link":"/百度面试题/"},{"title":"美团优选面试题2及答案","text":"美团优选面试题2 介绍值得说的项目 1.打印结果1234567- (void)someMethod { int i = 10; dispatch_async(dispatch_get_main_queue(), ^{ NSLog(@\"%d\",i); }); i = 20;} 10 1234567- (void)someMethod { static int i = 10; dispatch_async(dispatch_get_main_queue(), ^{ NSLog(@\"%d\",i); }); i = 20;} 20 1234567- (void)someMethod { __block int i = 10; dispatch_async(dispatch_get_main_queue(), ^{ NSLog(@\"%d\",i); }); i = 20;} 20 1234567- (void)someMethod { int i = 10; dispatch_sync(dispatch_get_main_queue(), ^{ NSLog(@\"%d\",i); }); i = 20;} 10 2.+load 和 initialize 的区别？+load 的调用时机1.调用方式 (1) load 是根据函数地址直接调用。 (2) initialize 是通过 objc_msgSend 调用。 2.调用时刻(什么时候会调用) (1) load 是 runtime 加载类、分类的时候调用(只会调用一次) (2) initialize 是类第一次接收到消息的时候调用，每一个类只会 initialize 一次(父类的 initialize 方法可能会被调用多次)。 3.App 启动 pre-main 做了什么事情1.加载 dyld 到 App 进程（dyld 首先读取 mach-o Header 和 load commands，接着就知道了这个可执行文件依赖的动态库）2.加载动态库（包括所依赖的所有动态库）3.Rebase &amp; Bind (使用了ASLR地址空间布局随机化和 Code Sign 来保证应用的安全，Rebase 修正内部指针指向，Bind 修正外部指针指向)4.初始化 Objective-C Runtime （Runtime 维护了一张映射类名与类的全局表，当加载一个 dylib 时，把类的信息注册到这个全局表中，也会把 Category 中的方法注册到对应的类中）5.Initializers 其他初始化代码6.dyld 调用 main() 函数，main() 函数调用 UIApplicationMain(),程序启动。 4.KVO 的实现原理。 利用 Runtime API 动态生成一个子类，并且让 instance 对象的 isa 指向这个全新的子类 当修改 instance 对象的属性时，会调用 Foundation 的 _NSSetXXXValueAndNotify 函数willChangeValueForKey:父类原来的 setterdidChangeValueForKey:内部会触发监听器（Oberser）的监听方法(observeValueForKeyPath:ofObject:change:context:） 5.KVC 的实现原理，是直接访问成员变量赋值吗？按照 setKey:、_setKey: 顺序查找方法，找到方法调用。没找到继续。 查看 accessInstanceVariablesDirectly 方法的返回值。如果是 YES 继续。 按照_key、_isKey、key、isKey顺序查找成员变量。找到了直接赋值。 没找到成员变量：调用 setValue:forUndefinedKey: 并抛出异常NSUnknownKeyException 6.autoreleasepool 什么时候释放？ 子线程使用了 autorelease 后，如果当前线程没有 AutorelesepoolPage 的话，代码执行顺序为 autorelease -&gt; autoreleaseFast -&gt; autoreleaseNoPage。在 autoreleaseNoPage 方法中，会创建一个 hotPage ，然后调用page-&gt;add(obj) 。也就是说即使这个线程没有 AutorelesepoolPage ，使用了 autorelease 对象时也会 new 一个 AutoreleasepoolPage 出来管理 autorelese 对象。 子线程的 autoreleasepool 是在线程销毁的时候释放的。 7.Category 添加一个属性系统做了什么？怎么添加属性？为什么不能添加成员变量。关联对象存在哪里？Category 里写了和类相同的方法会怎么样？声明了 set 和 get 方法。 实现关联对象技术的核心对象有 AssociationsManager：关联对象存储在全局的统一的一个 AssociationsManager 中 AssociationsHashMap：key 为对象，value 为 ObjectAssociationMap ObjectAssociationMap：key 为关联对象的 key，value 为 ObjcAssociation ObjcAssociation：存储 policy 和 value 会先找到分类里的方法执行。 8.isa 指向，元类对象 isa 指向哪里？NSObject 的 isa 指向哪里？为什么要设计类、元类？isa 的结构 元类对象的 isa 指向基类的元类对象。NSObject 的 isa 指向它本身。 在 arm64 架构之前，isa 就是一个普通的指针，存储着 Class、Meta-Class 对象的内存地址 从 arm64 架构开始，对 isa 进行了优化，变成了一个共用体（union）结构，还使用位域来存储更多的信息 nonpointer0：代表普通的指针，存储着 Class、Meta-Class对象的内存地址1：代表优化过，使用位域存储更多的信息 has_assoc是否有设置过关联对象，如果没有，释放时会更快 has_cxx_dtor是否有 C++ 的析构函数（.cxx_destruct），如果没有，释放时会更快 shiftcls存储着 Class、Meta-Class 对象的内存地址信息 magic用于在调试时分辨对象是否未完成初始化 weakly_referenced是否有被弱引用指向过，如果没有，释放时会更快 deallocating对象是否正在释放 extra_rc里面存储的值是引用计数器减1 has_sidetable_rc引用计数器是否过大无法存储在 isa 中如果为1，那么引用计数会存储在一个叫 SideTable 的类的属性中 9.有做过卡顿检测吗？Runloop 检测卡顿怎么知道是哪个方法卡？方法卡了多长时间？10.有做闪退监测吗？bugly 是怎么实现的？crash 率是多少？crash 率是怎么算出来的？crash 率 = 崩溃次数 / 活跃设备数 11.两两交换链表中的结点实现反转单向链表的函数。如 1-&gt;2-&gt;3-&gt;4 反转后变成 2-&gt;1-&gt;4-&gt;3 LeetCode题目链接：两两交换链表中的节点 1234567891011121314var swapPairs = function(head) { let dummyNode = new ListNode(0); dummyNode.next = head; let temp = dummyNode; while (temp.next != null &amp;&amp; temp.next.next != null) { let head1 = temp.next; let head2 = temp.next.next; temp.next = head2; head1.next = head2.next; head2.next = head1; temp = head1; } return dummyNode.next;}; 有什么想问我的？","link":"/美团优选面试题2/"},{"title":"美团面试题","text":"美团面试题 1、Block 的底层原理，结构，内存以及需要注意的地方。 2、图片渲染，一张 png/jpg 格式的图片渲染到页面上显示有哪些流程。png 和 jpg 的区别。png 一定是无损的吗？ 3、Runtime。 4、Runloop 的结构和循环流程，用 Runloop 做过什么事情。 5、多线程，NSOperationQueue 和 GCD 的区别。用多线程做过什么事情。线程安全的问题。加锁有几种方式。 6、NSURLSession 和 NSURLConnection 的区别， NSURLConnection 是怎么封装的。CFNetwork。 7、做过什么动画。 8、HTTPS 的工作原理，和 HTTP 的区别。RSA 加密原理。 9、网络层级，TCP 和 UDP 的区别。 10、SDWebImage 的框架结构，缓存机制。 11、Git 的 rebase 的原理。Git 流程。 12、对组件化的了解，组件化是为了解决什么问题。 13、JSPatch 的原理。 14、单例是为了处理什么问题而使用的，单例和全局变量的区别。 15、对设计模式的掌握。 16、分层打印二叉树。","link":"/美团面试题/"},{"title":"美团面试题及答案","text":"美团面试题 1、Block 的底层原理，结构，内存以及需要注意的地方。block本质上也是一个OC对象，它内部也有个isa指针。block是封装了函数调用以及函数调用环境的OC对象。 block类型 环境 NSGlobalBlock 没有访问auto变量 NSStackBlock 访问了auto变量 NSMallocBlock NSStackBlock调用了copy 2、图片渲染，一张 png/jpg 格式的图片渲染到页面上显示有哪些流程。png 和 jpg 的区别。png 一定是无损的吗？图片渲染的过程: 读取文件 -&gt; 计算frame -&gt;图片解码 -&gt;解码后通过数据总线交给GPU -&gt;GPU获取图片frame后进行顶点变换计算 -&gt;光栅化 -&gt;根据纹理坐标获取每一个像素点的颜色值 -&gt; 交给帧缓冲区 -&gt;渲染到屏幕上 iOS中图片渲染的流程 iOS 保持界面流畅的技巧 iOS图形原理与离屏渲染 3、Runtime。OC中的方法调用其实都是转成了objc_msgSend函数的调用，给receiver（方法调用者）发送了一条消息（selector方法名）objc_msgSend底层有3大阶段消息发送（当前类、父类中查找）、动态方法解析、消息转发 具体应用利用关联对象（AssociatedObject）给分类添加属性遍历类的所有成员变量（修改textfield的占位文字颜色、字典转模型、自动归档解档）交换方法实现（交换系统的方法）利用消息转发机制解决方法找不到的异常问题 4、Runloop 的结构和循环流程，用 Runloop 做过什么事情。01、通知Observers：进入Loop02、通知Observers：即将处理Timers03、通知Observers：即将处理Sources04、处理Blocks05、处理Source0（可能会再次处理Blocks）06、如果存在Source1，就跳转到第8步07、通知Observers：开始休眠（等待消息唤醒）08、通知Observers：结束休眠（被某个消息唤醒）01&gt; 处理Timer02&gt; 处理GCD Async To Main Queue03&gt; 处理Source109、处理Blocks10、根据前面的执行结果，决定如何操作01&gt; 回到第02步02&gt; 退出Loop11、通知Observers：退出Loop 控制线程生命周期（线程保活） 解决NSTimer在滑动时停止工作的问题 监控应用卡顿 性能优化 5、多线程，NSOperationQueue 和 GCD 的区别。用多线程做过什么事情。线程安全的问题。加锁有几种方式。dispatch_after dispatch_group dispatch_barrier dispatch_once OSSpinLockos_unfair_lockpthread_mutexdispatch_semaphoredispatch_queue(DISPATCH_QUEUE_SERIAL)NSLockNSRecursiveLockNSConditionNSConditionLock@synchronized 6、NSURLSession 和 NSURLConnection 的区别， NSURLConnection 是怎么封装的。CFNetwork。7、做过什么动画。8、HTTPS 的工作原理，和 HTTP 的区别。RSA 加密原理。9、网络层级，TCP 和 UDP 的区别。 TCP UDP 面向连接 面向数据报 可靠传输 不可靠传输 传输效率低 传输效率高 10、SDWebImage 的框架结构，缓存机制。11、Git 的 rebase 的原理。Git 流程。12、对组件化的了解，组件化是为了解决什么问题。13、JSPatch 的原理。14、单例是为了处理什么问题而使用的，单例和全局变量的区别。15、对设计模式的掌握。16、分层打印二叉树。","link":"/美团面试题及答案/"},{"title":"美团面试题2及答案","text":"美团面试题2 1.gcd, block,__block, static2.程序启动时执行了什么3.runloop: 如何让一个 block 只在子线程runloop 上执行4.autorelease 对象何时释放，主线程，子线程分别如何释放5.isa指向的内存布局6.如何定义一个只存在于栈的对象7.线上卡顿监控8.crash 触发流程，涉及的底层系统调用9.链表反转： 1-&gt;2-&gt;3-&gt;4 反转为 2-&gt;1-&gt;4-&gt;3","link":"/美团面试题2/"},{"title":"腰果公考面试题","text":"腰果公考面试题 笔试：1、NSTimer 受滑动影响 2、深拷贝、浅拷贝？ 3、assign 与 weak 区别？ 4、内存管理？ 5、[self class] [super class] 算法：1、数组去重？ 2、已知一个生成 0-6 随机数的函数，写一个生成 0-9 随机数的函数。 3、从数组中找到所有 3 个数和为 0 的组合，如 [0,-1,1] 面试题：笔试题问一遍 1、assign 与 weak 区别？weak 内部实现原理？如果让你自己实现 weak？ 2、深浅拷贝在可变与不可变时具体说一下。 3、NSTimer 受滑动影响 4、快速排序？ 5、判断 [[]] 前后括号对应 6、GCD 的 API 7、实现单例？怎么保证 alloc init 时也只创建一次或者调用不了 alloc init 确保单例的唯一？ 8、圆角的优化？出现问题的原因？离屏渲染？ 9、Masonry 链式调用的原理？ 10、微信支付流程 11、富文本？ 12、block 循环引用怎么个循环引用？","link":"/腰果公考面试题/"},{"title":"自如面试题","text":"自如面试题 一面1.你觉得自己有什么优势？ 2.线程和进程的区别？ 3.线程间是怎么通信的？CPU是怎么处理线程的 4.同步串行队列会不会开线程？异步串行队列会不会开线程？ 5.GCD项目里有哪些地方用了 6.怎么保证网络传输的安全？MD5的加密规则，MD5可以破解吗？AES/RSA，RSA有长度限制吗？ 7.什么是死锁 8.做过哪些优化，什么是离屏渲染？ 9.网络有没有优化过 10.发一个网络请求经过了哪些步骤？有没有统计发起网络请求和接收网络请求的时长 11.三次握手和四次挥手 12.冷启动和热启动怎么区分？冷启动是指关机后首次打开App，热启动是指打开过App杀死后再打开。 13.什么是平衡二叉树？ 14.合并多个有序链表 二面1.介绍印象深刻的项目，遇到的问题，怎么解决的 2.webView 白屏除了证书问题还有什么情况可能会导致。 3.说一下对 Flutter 的了解。 4.多个 widget 之间怎么相互传值，正向反向。 5.说一下对 iOS 的理解。 6.Runtime 是怎么实现动态化的，其他语言也写一套汇编的逻辑能实现动态化吗？ 7.RunLoop 应用，卡顿检测，runloop 的 activity 之前切换时长多少你觉得是卡顿？runloop 和内存之前的相关知识，autoreleasepool 8.内存管理 9.编译后的结构添加不了成员变量了，如果想添加，有没有办法实现？一个类的成员变量在内存中是怎么存储的？怎么读取一个成员变量？有什么要注意的？给 NSNumber 赋值一个 NSString，正确使用 NSString 时会不会有什么问题。 10.组件化，路由模式，如果一个类被修改了，他的映射关系怎么及时维护？ 11.说一下你了解的设计模式，说一下工厂模式 12.讲一个你比较熟悉的框架 13.项目开发流程。有哪些地方可以提高效率 14.项目是怎么架构的 15.反转字符串，第一次反转一个 第二次反转两个 最后不够的全拿过来。 三面1.介绍项目 2.Flutter 开发遇到的问题 3.Vue 开发遇到的问题 赋值需要用set方法的原因 4.学习一门新知识的途径 5.有没有看过一些源码 6.从框架中你觉得有什么点印象深刻，从框架中有没有什么点应用到项目里 7.规划 考虑新公司看中哪些方面， 8.手里有没有offer offer上的入职时间 其他问项目中遇到过啥问题，怎么解决的。平时怎么学习相关知识的说说项目中的亮点，你在开发中担任的角色，你负责的模块 参考答案一面1.你觉得自己有什么优势？ 2.线程和进程的区别？ 3.线程间是怎么通信的？CPU是怎么处理线程的 4.同步串行队列会不会开线程？异步串行队列会不会开线程？ 5.GCD项目里有哪些地方用了 6.怎么保证网络传输的安全？MD5的加密规则，MD5可以破解吗？AES/RSA，RSA有长度限制吗？ 7.什么是死锁 8.做过哪些优化，什么是离屏渲染？ 9.网络有没有优化过 10.发一个网络请求经过了哪些步骤？有没有统计发起网络请求和接收网络请求的时长 11.三次握手和四次挥手 12.冷启动和热启动怎么区分？冷启动是指关机后首次打开App，热启动是指打开过App杀死后再打开。 13.什么是平衡二叉树？ 14.合并多个有序链表 二面1.介绍印象深刻的项目，遇到的问题，怎么解决的 2.webView 白屏除了证书问题还有什么情况可能会导致。 3.说一下对 Flutter 的了解。 4.多个 widget 之间怎么相互传值，正向反向。 5.说一下对 iOS 的理解。 6.Runtime 是怎么实现动态化的，其他语言也写一套汇编的逻辑能实现动态化吗？ 7.RunLoop 应用，卡顿检测，runloop 的 activity 之前切换时长多少你觉得是卡顿？runloop 和内存之前的相关知识，autoreleasepool 8.内存管理 9.编译后的结构添加不了成员变量了，如果想添加，有没有办法实现？一个类的成员变量在内存中是怎么存储的？怎么读取一个成员变量？有什么要注意的？给 NSNumber 赋值一个 NSString，正确使用 NSString 时会不会有什么问题。 10.组件化，路由模式，如果一个类被修改了，他的映射关系怎么及时维护？ 11.说一下你了解的设计模式，说一下工厂模式 12.讲一个你比较熟悉的框架 13.项目开发流程。有哪些地方可以提高效率 14.项目是怎么架构的 15.反转字符串，第一次反转一个 第二次反转两个 最后不够的全拿过来。 三面1.介绍项目 2.Flutter 开发遇到的问题 3.Vue 开发遇到的问题 赋值需要用set方法的原因 4.学习一门新知识的途径 5.有没有看过一些源码 6.从框架中你觉得有什么点印象深刻，从框架中有没有什么点应用到项目里 7.规划 考虑新公司看中哪些方面， 8.手里有没有offer offer上的入职时间 其他问项目中遇到过啥问题，怎么解决的。平时怎么学习相关知识的说说项目中的亮点，你在开发中担任的角色，你负责的模块","link":"/自如面试题/"},{"title":"苏宁面试题","text":"苏宁面试题 1. 笔试题1.1 冒泡排序Objective-C 实现如下：1234567891011121314- (void)bubbleSort:(NSMutableArray *)array { for (int i = 0; i &lt; array.count; i++) { for (int j = 0; j &lt; array.count-1-i; j++) { NSInteger left = [array[j] integerValue]; NSInteger right = [array[j+1] integerValue]; if (left &lt; right) { [array exchangeObjectAtIndex:j withObjectAtIndex:j+1]; } } } NSLog(@&quot;%@&quot;,array);} 参考链接：【算法】冒泡排序 1.2 二分查找Swift实现如下：123456789101112131415func binarySearch&lt;T: comparable&gt;(_a: [T], key: T) -&gt; Int? { var lowerBound = 0 var upperBound = a.count while lowerBound &lt; upperBound { let midIndex = lowerBound + (upperBound - lowerBound) / 2 if a[midIndex] == key { return midIndex } else if a[midIndex] &lt; key { lowerBound = midIndex + 1 } else { upperBound = midIndex } } return nil} 参考链接：【算法】二分查找 1.3 合并两个数组去重参考链接：【算法】合并两个数组并去重 1.4 两个大数相加参考链接：大数相加算法 2. 一面2.1 SDWebImage 的缓存机制？LRU 说一下。SDWebImage加载图片拿到url会先把url的MD5值作为key从内存中查找，如果内存中有，则直接取图片显示；如果内存中没有，会从磁盘中查找。磁盘中没有，会走下载流程。LRU 最近最少使用。缓存容量满时，会先清理最近最少的缓存。 2.2 数据库升级，比如从 1.0 升级到 2.0，增加了字段。做好兼容处理。 2.3 性能优化2.3.1 优化启动时间 将一些耗时操作延迟执行。比如SDK的初始化，界面的创建。 不能延迟执行的，尽量放到后台执行。比如数据读取，原始 JSON 数据转对象，日志发送。 减少动态库、合并动态库，定期清理不必要的动态库。 减少类、分类的数量，合并Category和功能类似的类。删除不必要的方法和类、分类。 将不必须在+load中做的事延时到+initialize中。 2.3.2 减少CPU、GPU资源消耗 cell复用，header、footer复用。 尽量把view设置不透明。 减少视图的层级。 尽量避免调整视图层次、添加和移除视图。 合理选择加载图片的方式，UIImage imageNamed: ImageAssets 用于多个地方重复使用，UIImage imageWithContentsOfFile 一般用在图片数据很大，一般不需要多次使用的情况。 图片大小最好和UIImageView的大小相同。 不要阻塞主线程，耗时操作放在子线程进行。 懒加载。 缓存，缓存图片SDWebImage，缓存行高，NSCache缓存。 复用高开销对象NSDateFormatter和NSCalendar。 减少离屏渲染，优化圆角、阴影。 使用正确的数据存储。 2.3.3 内存优化 减少内存泄漏。 降低内存使用峰值。 懒加载。 灵活运用图片和文件加载。 拉长文件处理机制，逐步处理文件。 2.3.4 耗电优化耗电功率是个比较综合的指标，影响因素很多。密集的网络请求，长链接，密集的CPU操作（比如大量的复杂计算）都会使耗电功率增加。网络状况（流畅的Wi-Fi还是信号不好的3G）都会影响。 优化网络。 减少、压缩网络数据。 若多次网络请求结果相同，尽量使用缓存。 网络不可用时，不进行网络请求。 优化CPU、GPU消耗。 优化I/O操作，使用dispatch_io。 定位优化 尽量降低定位精度，如不要使用精度最高的KCLLocationAccuracyBest。 如果只是需要快速确定用户位置，用 CLLocationManager 的 requestLocation 方法定位，定位完成后，定位硬件会自动断电。 2.4 Git 开发流程。 master develop dev-xx 具体开发人员分支 开发完成后发起PR。项目提审打Tag 2.5 微信登录流程。注册微信的AppKey与AppSecret。使用微信SDK方法调起微信，回调拿到一些参数，把包含openId等协定好的参数传给服务器，由服务器判断该用户是否注册过，如果注册过，返回登录成功后的用户相关信息。 2.6 WebView 与 JS 交互。H5调用原生采用拦截协议的方式。执行JS方法：evaluateScript也可以使用JSBridge等方式。 2.7 说一下Runloop，苹果设计 Runloop 的初衷是什么？Runloop 运行循环。让线程在有任务的时候忙任务，没任务的时候休眠。参考链接：【iOS 开发】RunLoop 总结 2.8 Delegate代理用assign修饰。 2.9 GCD参考链接：GCD 的 API 2.10 深拷贝与浅拷贝深拷贝是拷贝整个对象。浅拷贝只拷贝对象的指针。copy用于修饰NSArray、NSDictionary、NSString。如果=右边赋值的对象是可变的，copy是深拷贝，拷贝对象的本身。如果赋值的对象是不可变的，copy是浅拷贝，只拷贝对象的指针。用copy和用strong的区别？用copy更安全，避免赋的值是可变的。如果能确保赋的值是不可变的，那么用strong和用copy都是浅拷贝，copy只是多了一个判断，判断可变还是不可变，其他是一样的。NSMutableArray、NSMutableDictionary用Strong修饰，如果用copy，就会拷贝一份，变成不可变的，如果增删数据，就会发生错误。 2.11 进程间通信URL Schemes 2.12 线程间通信，两个线程怎么切换？performSelectorOnThread 2.13 多态多态（Polymorphism）按字面的意思就是“多种状态”。在面向对象语言中，接口的多种不同的实现方式即为多态。子类继承父类后，子类重写父类的方法，实现多态。 2.14 HTTP 三次握手，四次挥手。3. 二面3.1 有没有复杂点的页面。3.2 （这个部门是做智能硬件的）蓝牙有哪些API。3.3 播放音频，展示音频的曲线，具体怎么做？4. 三面","link":"/苏宁面试题及答案/"},{"title":"货拉拉面试题","text":"货拉拉面试题 一面1.Vue 用过哪些指令 2.v-model 有没有遇到过什么问题？数组里的对象赋值后 UI 未更新，需要使用 set 方法的原因是什么？ 3.Vue 双向绑定是怎么实现的 4.说一下你对 Flutter 的理解，使用过哪些 Widget 5.Flutter 除了拆分组件还有什么方法能够使代码结构更清晰 6.Flutter 有没有跟原生交互的部分，有没有涉及双引擎/单引擎的问题 7.Masonry 和 SnapKit 的选择 8.做过哪些优化 9.说一下装饰模式 10.对 MVVM 的理解，什么情况下会选择 MVVM 11.多线程的几种实现方法如何选择，除了使用 dispatch_semaphore，还有什么更好用的方法来解决网络请求依赖，嵌套地狱的问题 12.Git 的使用，项目里有哪些分支 二面1.介绍最熟悉的项目，遇到的问题 2.项目架构 3.启动耗时，启动过程，启动优化 4.安装包大小优化，优化后的安装包大小有多大 5.图片加载优化 6.性能优化，内存、CPU 峰值多少，使用哪些工具分析性能 7.项目稳定性 crash率，有哪些闪退的问题 8.对象的内存结构 9.了解哪些设计模式 10.7层/5层网络模型，TCP/UDP 区别，TCP 的连接过程 11.Vue 的生命周期 12.介绍一个熟悉的排序算法 13.设计一个下载文件的需求（可能是多个文件，可能用到线程池；边下载边读取） 三面（HR）1.主要的工作，遇到的挑战，最有成就感的事情，举个例子 2.管理的做的好的地方，有待改进的地方 3.其他家的机会到哪个阶段了，各个公司的比较 4.对货拉拉的意向高吗，对货拉拉的了解 5.选择一家公司比较看重哪些","link":"/货拉拉面试题/"},{"title":"链表算法题","text":"链表算法题（ JavaScript 实现） 反转链表123456789101112function reverseList(pHead){ let prev = null; let curr = pHead; while (curr) { const next = curr.next; curr.next = prev; prev = curr; curr = next; } return prev;} 两两交换链表中的节点1234567891011121314var swapPairs = function(head) { let dummyNode = new ListNode(0); dummyNode.next = head; let temp = dummyNode; while (temp.next != null &amp;&amp; temp.next.next != null) { let head1 = temp.next; let head2 = temp.next.next; temp.next = head2; head1.next = head2.next; head2.next = head1; temp = head1; } return dummyNode.next;}; 判断链表中是否有环123456789101112131415function hasCycle( head ) { if (head == null) { return false; } let slow = head; let fast = head; while (fast.next &amp;&amp; fast.next.next) { slow = slow.next; fast = fast.next.next; if (slow == fast) { return true; } } return false;} 环的入口结点1234567891011121314151617function detectCycle( head ) { if (!head) return null; let slow = head, fast = head; while(fast.next &amp;&amp; fast.next.next) { fast = fast.next.next slow = slow.next if (slow == fast) { var a = head; while (slow != a) { a = a.next slow = slow.next } return a; } } return null;} 链表中倒数第 k 个结点1234567891011121314151617181920212223function FindKthToTail( pHead , k ) { let length = getLength(pHead); if (length &lt; k) { return null; } let i = length - k; let p = pHead; while (i &gt; 0) { p = p.next; i--; } return p;}var getLength = function( pHead ) { let p = pHead; let length = 0; while (p != null) { p = p.next; length++; } return length;} 删除链表的倒数第 n 个节点1234567891011121314151617181920212223242526function removeNthFromEnd( head , n ) { let length = getLength(head); if (length &lt; n) { return null; } let i = length - n; let dummy = new ListNode(0); dummy.next = head; let p = dummy; while (i &gt; 0) { p = p.next; i--; } p.next = p.next.next; return dummy.next;}var getLength = function ( head ) { let length = 0; let p = head; while (p != null) { p = p.next; length ++; } return length;} 删除有序链表中重复的元素1234567891011function deleteDuplicates( head ) { let p = head; while (p != null &amp;&amp; p.next != null) { if (p.val == p.next.val) { p.next = p.next.next; } else { p = p.next; } } return head;} 交叉链表找交点123456789101112function FindFirstCommonNode(pHead1, pHead2){ if (pHead1 == null || pHead2 == null) { return null; } let p1 = pHead1, p2 = pHead2; while (p1 != p2) { p1 = p1 == null ? pHead2 : p1.next; p2 = p2 == null ? pHead1 : p2.next; } return p1;} 合并两个有序链表123456789101112131415161718192021function mergeTwoLists( l1 , l2 ) { let newHead = new ListNode(-1); let p = newHead; while(l1 != null &amp;&amp; l2 != null) { if (l1.val &lt; l2.val) { p.next = l1; l1 = l1.next; } else { p.next = l2; l2 = l2.next; } p = p.next; } if (l1 != null) { p.next = l1; } if (l2 != null) { p.next = l2; }; return newHead.next;}","link":"/链表算法题/"},{"title":"达达面试题","text":"达达面试题 1.深拷贝、浅拷贝区别。数组里放对象，copy 数组，是深拷贝还是浅拷贝？数组里对象的指针是一样的吗？ 浅拷贝：指针拷贝，不会创建一个新的对象。对指向对象的指针拷贝，产生一个新的指向对象的指针。两个指针指向同一个对象。对象的引用计数+1； 深拷贝：内容拷贝，会创建一个新的对象。深拷贝就是拷贝地址中的内容。 深拷贝和浅拷贝的本质是内存地址是否相同。 copy 可变数组是深拷贝。copy 不可变数组是浅拷贝。数组里对象的指针是一样的。 copy mutableCopy NSString NSString 浅拷贝 NSMutableString 深拷贝 NSMutableString NSString 深拷贝 NSMutableString 深拷贝 NSArray NSArray 浅拷贝 NSMutableArray 深拷贝 NSMutableArray NSArray 深拷贝 NSMutableArray 深拷贝 NSDictionary NSDictionary 浅拷贝 NSMutableDictionary 深拷贝 NSMutableDictionary NSDictionary 深拷贝 NSMutableDictionary 深拷贝 2.布局使用 Masony 还是 Xib3.StatefulWidget、StatelessWidget 区别 Widget 是部分界面的不可变的描述信息。 StatelessWidget 和 StatefulWidget 没有本质区别，他们的所有属性都是不可变的。它们都没法更新，除非用一个新的 Widget 去替换它们。 StatefulWidget 拥有一个可变的 State。 StatefulWidget 和 StatelessWidget 的区别在于可变的 State。本质区别是能否自我重新构建（self rebuild）。 参考链接：简书-StatelessWidget和StatefulWidget的区别 4.UITableView、UICollectionView 的调用流程区别5.常用的 pod 命令pod init: 创建 Podfile 文件。 pod install：会根据 podfile.lock 文件中指定的 pod 依赖库的版本去拉去项目的 pod 依赖库。 pod install --no-repo-update: 协作开发时使用此命令可以根据 podfile.lock 文件限制第三方库的版本。 pod update：这个命令会检查 podfile.lock 文件中的 pod 依赖库的版本，并进行更新，会重新生成一个 podfile.lock 文件。 pod repo add NAME URL[branch] ：添加 pod 源。 pod search：搜索可以使用的 pod 依赖库。 pod list：列出所有项目依赖仓库中的 pod 依赖库。 pod repo：用来管理 pod 依赖仓库的地址。 pod spec：管理 pod 规范。 pod env：来打印出 pod 的环境，一般是 podfile 文件中的内容。 pod cache：管理 cocoapod 的缓存：可以用来清空内存，也可以用来查看每个 pod 库的缓存。 制作私有库使用 pod lib create [仓库名]：在本地创建一个基于 pod 模板的 git 仓库。 pod lib lint：pod 本地库验证，验证 .podspec 文件是否有错。 pod repo add NAME URL[branch]：添加自己的 pod 仓库。 pod spec lint：pod 远程库验证。 pod repo add xxx https://gitxxxx ：放置 spec 文件的 git 仓库地址，给自己添加私有仓库。 pod repo push 索引库名 podspec文件名：命令执行会先将 pod 索引添加到本地的索引库，然后会自动推送到远程的索引库。 1234567891011121314151617181920Commands: + cache Manipulate the CocoaPods cache + deintegrate Deintegrate CocoaPods from your project + env Display pod environment + init Generate a Podfile for the current directory + install Install project dependencies according to versions from a Podfile.lock + ipc Inter-process communication + lib Develop pods + list List pods + outdated Show outdated project dependencies + plugins Show available CocoaPods plugins + repo Manage spec-repositories + search Search for pods + setup Setup the CocoaPods environment + spec Manage pod specs + trunk Interact with the CocoaPods API (e.g. publishing new specs) + try Try a Pod! + update Update outdated project dependencies and create new Podfile.lock 6.图文混排有没有做过，有没有内存、性能问题参考链接：简书-iOS开发之富文本(图文混排) 7.写过哪些脚本，有没有写过函数，按顺序执行的函数。bugly、Fastlane、切换 SDK 配置文件 参考链接：菜鸟教程- Shell 教程 8.闪退捕获，Flutter 错误捕获1234567891011121314151617181920212223void main() { // Flutter framework 异常捕获 FlutterError.onError = (FlutterErrorDetails details) { bool isDebugMode = false; assert(() { isDebugMode = true; return true; }()); if (isDebugMode) { FlutterError.dumpErrorToConsole(details); } else { //profile,release两个模式下下捕捉异常信息 reportFrameworkError(details); } }; // 其他类型异常 runZoned( () =&gt; runAutoSizeApp(MyApp(), width: 375, height: 667), onError: (dynamic ex, StackTrace stack) { reportError(ex, stack); }, ); } 参考链接：Flutter异常捕捉原理和异常上报 9.埋点是怎么做的？页面上的某一个 view 的停留时长怎么统计？10.性能优化、图片加载优化、安装包大小优化做了啥，没用到的代码或图片有写脚本来检查吗？ 未使用的代码可以用 AppCode 来检测。 未使用的图片可以用 LSUnusedResources 来检测。 12.界面渲染流程、UIView 渲染流程，有没有做过异步绘制？ 13.解决遇到的线程问题描述一下，在子线程刷新 UI 会怎么样？14.有没有做过组件模块化？","link":"/达达面试题/"},{"title":"高思教育笔试题","text":"高思教育笔试题 笔试题（部分）3.下面代码输出什么？ 1234567int a = 0;void (^foo)(void) = ^{ a = 1; NSLog(@\"inner a=%d\",a);};foo();NSLog(@\"outer a=%@\",a); 4.下面代码输出什么？ 123456789- (void)viewDidLoad{ [super viewDidLoad]; NSLog(@\"1\"); dispatch_sync(dispatch_get_main_queue(),^{ NSLog(@\"2\"); }); NSLog(@\"3\");} 5.什么情况使用 weak 关键字，相比 assign 有什么不同？ 6.@property 中有哪些属性关键字？/ @property 后面可以有哪些修饰符？ 7.@synthesize 和 @dynamic 分别有什么作用？ 8.什么时候会报 unrecognized selector 的异常？ 9.能否想编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？ 10.如何用 GCD 同步若干异步调用？dispatch_barrier_async 的作用是什么？ 11.如何手动触发一个 value 的 KVO 12.Native 的 Web（WK/UI）控件和 js 的交互是如何实现的？（nativejs） 13.JavaScriptCore 框架中，native 如何调用 js？反之，js如何调用native？ 14.有阅读 Weex、ReactNative 或者 Cordova 框架的描述其一即可。","link":"/高思教育笔试题/"},{"title":"闲徕互娱面试题","text":"闲徕互娱面试题 1.ViewController 的生命周期 从控制器 A 跳转到 B 两个控制器里方法的调用顺序 loadView viewDidLoad viewWillAppear viewDidAppear viewWillDisappear viewDidDisappear 2.MVC 具体流程 3.GCD 哪些地方用到了？ 4.webView 与 JS 交互，是哪个代理方法？ 5.NSTimer 创建方法里有哪些参数？里边的 self 是强引用还是弱引用？怎么避免循环引用？ 6.Notification 注册通知方法里有哪些参数？里边传入的 self 是强引用还是弱引用？怎么使用的通知？（注册、销毁、发送在哪里写的） 7.数据持久化你都哪些地方用了？ 8.UserDefaults 中存了什么东西？ 9.Runtime 底层看过没有？isa 指向哪里？比如 NSString 这个对象的 isa 指针指向哪里？ 10.Runtime 你用到过的地方或者你知道的哪些第三方库用到了，怎么用的？json 转Model 怎么用的 runtime？ 11.RunLoop 你在哪儿用的？RunLoop 与线程的关系。 12.SDWebImage 你用过哪些功能？ 13.Instruments 你用过哪些功能？ 14.某个页面你是怎么布局的？（直播首页）","link":"/闲徕互娱面试题/"},{"title":"首汽租车面试题","text":"首汽租车面试题 1.什么是野指针？什么情况下会野指针？ 2.打印结果： 12345678- (void)testWeak { id obj1 = @\"12131\"; __weak id obj2 = obj1; id obj3 = [NSObject new]; __weak id obj4 = [[NSObject alloc] init]; NSLog(@\"obj1:%@ obj2:%@ obj3:%@ obj4:%@\",obj1,obj2,obj3,obj4);} 3.子类怎么重写父类的属性？问题简化怎么重写一个类的属性？只重写set方法可以吗？ 4.了解哪些设计模式？单例有哪些不好的地方？ 5.说一下响应者链 6.Masonry 链式调用的实现，实现一个控制器，属性的链式调用（手写） 7.打印结果： 12345678910111213141516- (void)testGCD { dispatch_queue_t queue = dispatch_queue_create(\"testqueue\", DISPATCH_QUEUE_SERIAL); dispatch_async(queue, ^{ NSLog(@\"1\"); dispatch_async(queue, ^{ NSLog(@\"2\"); dispatch_sync(queue, ^{ NSLog(@\"3\"); }); NSLog(@\"4\"); }); NSLog(@\"5\"); });} 8.项目亮点或难点","link":"/首汽租车面试题/"},{"title":"高思教育面试题","text":"高思教育面试题 笔试题笔试题 一面1、@property 本质是什么？NSString 为什么用 Copy，用 Strong 行不行？ 2、block 为什么用 copy ？ 3、block 和代理你用的哪个多？各有什么特点？ 4、GCD 的两个队列（串行、并行）有了解吗？从字面意思看，你觉得这俩哪个效率高，哪个占空间 5、类似网易新闻那种滑动切换页面你是怎么做的？我说是一个 scrollView，点击按钮后滚动到指定的 index。他说的顶部按钮是3个，如果是30个呢，会有什么问题？他说如果1个页面占用5M，30个页面就占用5x30M，会有内存问题，怎么解决这个问题？我说看过别人写的，用的是子控制器，把这些页面加到当前控制器的子控制器中。（现在想想我也是这么做的。。但是没说是这么做） 6、AFN内部看过吗？AFN的5个模块。 大概这时候问，你觉得自己是什么级别的？ 7、说一下响应者链。 8、一个约束题。 9、项目不忙的时候做过什么优化？他说发现过什么问题？他说那考虑用什么替换定时器呢？ 还做过什么优化？ 10、野指针是啥？如果又有其他指针指向了这块内存，会怎么样 12、斐波那切数列 0 1 2 3 4 5… 1 1 2 3 5 8 13 21 求n f(n) = f(n-1) + f(n-2) 复试1、怎么学的 iOS ？为什么没搞 Java 2、介绍公司情况，人员规模，介绍项目 3、说一下项目中遇到的问题，怎么解决的？ 4、说一下内存管理，怎么检测内存泄漏的？ 5、你用 OC 开发还是 Swift ？你觉得两者有啥不同？ 6、金融 App 应该有一些安全措施吧？你们是怎么做的？ 7、TCP 和 UDP 有啥区别？ 8、TCP 几次握手？过程是怎么样的？ 9、Post 请求和 Get 请求有啥区别？ 10、数据持久化都有哪些？ 11、AFN 的实现原理？SDWebImage 的实现原理？哪些存在内存，哪些存在磁盘？ 12、两个网络请求有依赖关系时，怎么处理的？ 13、同步、异步 串行、并行 14、几张图合成一张图 15、说一下 Runloop 16、KVO 的实现原理 17、不使用中间变量 实现交换两个数 swap(a, b) 18、copy 关键字修饰什么？ 19、类的私有属性，怎么设置属性值？我答了 KVC 他提到了 Runtime 20、有没有做过音频的处理？类似唱吧把原唱关掉。 21、动画了解的怎么样？ 22、了解 ARKit 吗？ 23、数据结构和算法你怎么样？冒泡排序，选择排序？","link":"/高思教育面试题/"},{"title":"京东","text":"京东 一面： 1.SDK 体积优化 2.组件化 3.端到端监控，具体实现 4.YYModel 的实现原理，和 MJExtension 区别，为什么比 MJExtension 快？ 5.OOM 怎么排查 6.Facebook 出的异步渲染框架 AsyncDisplayKit 原理 7.样式字段很多，怎么和逻辑字段分开下发？ 8.跨端方案，Talos lite 9.怎么提升代码质量 10.设计模式：策略模式、中介者模式 11.打点 cell 50%展现时打点 打点规范，怎么快速找到某一个页面的所有点击点位 12.产品上的业务指标 13.读写安全，除了加锁还有哪些方法 14.算法：实现一个列表，复用，不卡顿，cell 上是多个文本 二面： 1.Flutter 与 iOS 交互方法？ 2.Flutter 的 UI 层在哪儿？RN 是原生控件 3.组件化的 Router 里的映射表什么时候生成？ 4.JSBridge 原理，前端 JS 有哪些异步方法？前端有哪些存储方法，localstorage有大小限制吗？ 5.iOS 打包流程，命令 Xcode build；Cocoapods 打包出来的第三方库是什么形式的？源码还是二进制？.a和.framework 有什么区别？ 6.接口监控 7.为什么用到动态库，动态库类型是什么 so？ 8.加载速度优化 9.SDK 体积优化 10.RN 的原理，怎么转成了原生控件？了解哪些动态化的方案？Weex、小程序等的区别 11.了解哪些性能优化，滑动流畅性的指标 12.深拷贝和浅拷贝的区别 13.App 启动流程，优化手段，main函数有哪些优化地方 14.发一个 Post 请求，怎么加快速度？Get 和 Post 请求区别，Get 可以将参数放在请求体吗？ 15.触摸屏幕流程 16.Swift 中 Class 和 Struct 区别，Struct 可以继承吗？ 17.堆和栈的区别 18.内存 isa 19.绘制流程 20.加载速度优化，各个阶段耗时有统计吗？网络的耗时在哪块儿？ 21.IM 的架构 22.IM 怎么保证消息的顺序 参考答案一面： 1.SDK体积优化 2.组件化 3.端到端监控，具体实现 4.OOM怎么排查 5.样式字段很多，怎么和逻辑字段分开下发？ 6.跨端方案，Talos lite 7.怎么提升代码质量 8.设计模式：策略模式、中介者模式 常见的23种设计模式包括： 创建型模式： 单例模式 (Singleton) 工厂方法模式 (Factory Method) 抽象工厂模式 (Abstract Factory) 建造者模式 (Builder) 原型模式 (Prototype) 结构型模式： 适配器模式 (Adapter) 桥接模式 (Bridge) 组合模式 (Composite) 装饰器模式 (Decorator) 外观模式 (Facade) 享元模式 (Flyweight) 代理模式 (Proxy) 行为型模式： 责任链模式 (Chain of Responsibility) 命令模式 (Command) 解释器模式 (Interpreter) 迭代器模式 (Iterator) 中介者模式 (Mediator) 存储器模式 (Memento) 观察者模式 (Observer) 状态模式 (State) 策略模式 (Strategy) 模板方法模式 (Template Method) 访问者模式 (Visitor) 中介者模式中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性，属于行为型模式。 中介者模式定义了一个中介对象来封装一系列对象之间的交互。中介者使各对象之间不需要显式地相互引用，从而使其耦合松散，且可以独立地改变它们之间的交互。 策略模式在策略模式（Strategy Pattern）中一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。 在策略模式定义了一系列算法或策略，并将每个算法封装在独立的类中，使得它们可以互相替换。通过使用策略模式，可以在运行时根据需要选择不同的算法，而不需要修改客户端代码。 在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。 9.打点 cell 50%展现时打点 可以使用UITableView的scrollViewDidScroll方法来检测cell的可见区域。具体步骤如下： 设置UITableViewDelegate: 确保你的视图控制器实现了UITableViewDelegate协议，并设置delegate。 计算可见区域: 在scrollViewDidScroll方法中，计算每个cell的可见区域，并检查它是否至少展现了50%。 打点逻辑: 根据计算结果进行打点操作，例如记录数据或发送网络请求。 示例代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#import \"ViewController.h\"@interface ViewController () &lt;UITableViewDelegate, UITableViewDataSource&gt;@property (weak, nonatomic) IBOutlet UITableView *tableView;@end@implementation ViewController- (void)viewDidLoad { [super viewDidLoad]; self.tableView.delegate = self; self.tableView.dataSource = self;}#pragma mark - UITableViewDataSource- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section { return 100; // 示例行数}- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath { UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@\"cell\" forIndexPath:indexPath]; cell.textLabel.text = [NSString stringWithFormat:@\"Row %ld\", (long)indexPath.row]; return cell;}#pragma mark - UIScrollViewDelegate- (void)scrollViewDidScroll:(UIScrollView *)scrollView { NSArray&lt;UITableViewCell *&gt; *visibleCells = [self.tableView visibleCells]; CGRect visibleRect; visibleRect.origin = self.tableView.contentOffset; visibleRect.size = self.tableView.bounds.size; for (UITableViewCell *cell in visibleCells) { CGRect cellRect = [self.tableView convertRect:cell.frame toView:self.tableView.superview]; CGRect intersection = CGRectIntersection(visibleRect, cellRect); CGFloat intersectionRatio = intersection.size.height / cellRect.size.height; if (intersectionRatio &gt;= 0.5) { NSIndexPath *indexPath = [self.tableView indexPathForCell:cell]; NSLog(@\"Cell at %ld is at least 50%% visible.\", (long)indexPath.row); // 打点逻辑，例如记录或发送请求 } }}@end 说明 计算可见区域：使用convertRect:toView:方法将cell的frame转换到superview的坐标系，然后计算交集区域。 检查比例：判断交集区域的高度与cell的总高度的比例是否大于或等于50%。 这个实现将确保在UITableView滚动时，对每个cell进行检查，并在其至少展现50%时执行打点操作。 打点规范，怎么快速找到某一个页面的所有点击点位 10.产品上的业务指标 11.读写安全，除了加锁还有哪些方法 12.算法：实现一个列表，复用，不卡顿，cell上是多个文本 二面： 1.Flutter 与 iOS 交互方法？ 2.Flutter 的 UI 层在哪儿？RN 是原生控件 3.组件化的 Router 里的映射表什么时候生成？ 4.JSBridge 原理 5.iOS 打包流程，命令 Xcode build；Cocoapods 打包出来的第三方库是什么形式的？源码还是二进制？.a和.framework 有什么区别？ CocoaPods 打包出来的第三方库可以是源码形式，也可以是二进制形式，取决于库的发布方式。 源码形式：大多数CocoaPods库以源码形式提供。这意味着CocoaPods会将库的源代码下载到你的项目中，并在构建时编译这些代码。 二进制形式：一些库提供二进制预编译版本，以减少编译时间和提高构建速度。在这种情况下，CocoaPods会下载预编译的二进制文件，而不是源码。 你可以在Podspec文件中检查库的具体形式，通常在source字段中定义了库的来源。如果是二进制库，Podspec会指定二进制文件的URL和相关配置。 .a和.framework是iOS开发中常见的两种二进制文件格式，分别代表静态库和动态库。它们的主要区别如下： .a（静态库）： 打包形式：静态库是一个归档文件，包含了多个编译好的目标文件（.o文件）。 链接方式：在编译时，静态库的代码会被直接链接到应用程序中。每次构建时，库的代码会被复制到最终的可执行文件中。 更新：如果静态库的代码有更新，必须重新编译整个应用程序。 体积：由于代码被复制到应用程序中，最终的应用包可能会较大。 .framework（动态库）： 打包形式：动态库是一个文件夹（包），包含库的二进制文件以及相关的资源文件（如头文件和配置文件）。它可以包含多个版本和资源。 链接方式：动态库在运行时被加载到内存中。应用程序在运行时与库链接，而不是在编译时。这样，多个应用程序可以共享同一个动态库。 更新：更新动态库只需替换库文件，不需要重新编译依赖于该库的应用程序。 体积：动态库的使用可以减少最终应用程序的体积，因为库的代码和资源在运行时被共享和加载。 简而言之，.a是静态库，编译时直接包含在应用中；.framework是动态库，在运行时动态加载和共享。 6.接口监控 7.为什么用到动态库，动态库类型是什么 so？ 8.加载速度优化 9.SDK 体积优化 10.RN 的原理，怎么转成了原生控件？了解哪些动态化的方案？Weex、小程序等的区别 11.了解哪些性能优化，滑动流畅性的指标 12.深拷贝和浅拷贝的区别 13.App 启动流程，优化手段，main函数有哪些优化地方 14.发一个 Post 请求，怎么加快速度？Get 和 Post 请求区别，Get 可以将参数放在请求体吗？ 15.触摸屏幕流程 16.Swift 中 Class 和 Struct 区别，Struct 可以继承吗？ 17.堆和栈的区别 18.内存 isa 19.绘制流程 20.加载速度优化，各个阶段耗时有统计吗？网络的耗时在哪块儿？ 21.IM 的架构 22.IM 怎么保证消息的顺序","link":"/2024-08-29-京东/"},{"title":"OC语法","text":"OC语法 面向对象一个NSObject对象占用多少内存系统分配了16个字节给NSObject对象（malloc_size）但NSObject对象内部只使用了8个字节的空间（class_getInstanceSize） 对象的isa指针指向哪里instance对象isa指向class对象调用对象方法时，通过isa指针找到类对象，找到对象方法实现进行调用class对象isa指向meta-class对象调用类方法时，通过isa指针找到元类对象，找到类方法的视线进行调用meta-class对象isa指向基类的meta-class对象 OC的类信息存放在哪里对象方法、属性、成员变量、协议信息，存放在class对象类方法存放在meta-class对象成员变量的具体值，存放在instance对象 KVOiOS用什么方式实现一个对象的KVO（KVO的本质是什么）利用runtime动态生成一个子类，并且让instance对象的isa指向该子类当修改instance对象的属性时，会调用Foundation的_NSSetXXXValueAndNotify函数willChangeValueForKey:父类原来的set方法didChangeValueForKey:内部会触发Observer的监听方法（observeValueForKeyPath:ofObject:change:context） 如何手动触发KVO手动调用willSetValueForKey:和didChangeValueForKey: 直接修改成员变量的值会触发KVO吗不会 通过KVC修改属性会触发KVO吗会 KVC的赋值和取值过程？赋值 先调用setA isA _age CategoryCategory的实现原理Category编译后的底层结构是struct category_t 里面存放分类的对象方法、类方法、属性、协议信息在程序运行时，runtime会将Category的数据，合并到类信息中（类对象、元类对象中） Category和Class Extension的区别是什么Class Extension在编译时数据就在类信息中Category是在运行时，将数据合并到类信息中 Categroy中有load方法吗？load方法是什么时候调用的？load方法能继承吗？有load方法load是在程序启动的时候，加载类、分类的时候调用load方法可以继承，但一般不会主动去调用load方法，都是让系统自动调用 load、initialize方法的区别？在Category中的调用顺序，出现继承时他们之间的调用过程？ Category能否添加成员变量？如果可以，如何给Category添加成员变量？不能直接给Category添加成员变量，但可以通过runtime实现Category有成员变量的效果 Objective-C的本质OC的本质底层都是C/C++代码，编译成了汇编语言、机器语言OC的面向对象是通过C/C++的结构体实现的 将OC代码转换成C/C++代码xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc OC源文件 -o 输出的CPP文件 一个OC对象在内存中的布局struct NSObject_IMPL { Class isa;} Class 即 objc_classclass、meta-class对象的本质结构都是struct objc_class 创建一个实例对象，至少需要多少内存class_getInstanceSize([NSObject class]); 创建一个实例对象，实际上分配了多少内存malloc_size(obj); 常见LLDB指令p 打印po 打印对象 读取内存memory read/数据格式字节数 内存地址x/数量格式字节数 内存地址 修改内存中的值memory write OC对象的分类instance对象（实例对象）、class对象（类对象）、meta-class对象（元类对象） class对象在内存中存储的信息主要包括isa指针superclass指针属性、对象方法、协议、成员变量 meta-class对象在内存中存储的信息isa指针superclass指针类方法 object_getClass([NSObject class]); 获取元类对象class_isMetaClass([NSObject class]); 查看Class是否是元类对象 instance的isa指向classclass的isa指向meta-classmeta-class的isa指向基类的meta-class class的superclass指向父类的class如果没有父类，superclass指针为nil meta-class的superclass指向父类的meta-class基类的meta-class的superclass指向基类的class isa指针isa通过&amp; ISA_MASK （位运算），得到真实地址12345678910111213141516171819202122232425262728293031struct objc_class { Class isa; Class superClass; cache_t cache; // 方法缓存 class_data_bits_t bits; // 用于获取具体的类信息}bits &amp; FAST_DATA_MASK得到class_rw_tclass_rw_t { uint32_t flags; uint32_t version; const class_ro_t *ro; method_list_t *methods; // 方法列表 property_list_t *properties; // 属性列表 const protocol_list_t *protocols; // 协议列表 Class firstSubClass; Class nextSiblingClass; char *demangledName;}class_ro_t { uint32_t flags; uint32_t instanceStart; uint32_t instanceSize; const char *name; // 类名 method_list_t *baseMethodList; protocol_list_t *baseProtocols; const ivar_list_t *ivars; // 成员变量列表 const uint8_t *weakIvarLayout; property_list_t *baseProperties;} KVCsetValue:forKey:原理按照setKey: _setKey:顺序查找方法，找到方法调用没找到方法，查看accessInstanceVariablesDirectly方法的返回值NO-&gt;调用setValue:forUndefinedKey: 并抛出异常NSUnknownKeyExceptionYES-&gt;按照_key _isKey key isKey顺序查找成员变量，找到后直接赋值，找不到报错 valueForKey:原理按照getKey、key、isKey、_key顺序查找方法，找到方法调用没找到方法，查看accessInstanceVariablesDirectly方法的返回值NO-&gt;调用valueForUndefinedKey: 并抛出异常NSUnknownKeyExceptionYES-&gt;按照_key、_isKey、key、isKey顺序查找成员变量，找到后直接取值 Caregory的底层结构12345678910111213141516struct category_t { const char *name; classref cls; struct method_list_t *instanceMethods; struct method_list_t *classMethods; struct protocol_list_t *protocols; struct property_list_t *instanceProperties; struct property_list_t *_classProperties; method_list_t *methodForMeta(bool isMeta) { if (isMeta) return classMethods; else return instanceMethods; } property_list_t *propertiesForMeta(bool isMeta, struct header_info *hi);} Category的加载处理过程1.通过Runtime加载某个类的所有Category数据2.把所有Category的方法、属性、协议数据，合并到一个大数组里，后面参与编译的Category数据，会在数组的前面3.将合并后的分类数据（方法、属性、协议），插入到类原来数据的前面 +load方法+load方法会在runtime加载类、分类时调用每个类、分类的+load方法，在程序运行过程中只调用一次 调用顺序：1.先调用类的+load，按照编译先后顺序调用（先编译，先调用），调用子类的+load之前会先调用父类的+load2.再调用分类的+load，按照编译先后顺序调用（先编译，先调用）123456789101._objc_Init2.load_images3.prepare_load_methodsschedule_class_loadadd_class_to_loadable_listadd_category_to_loadable_list4.call_load_methodscall_class_loadscall_category_loads(*load_method)(cls, SEL_load) +load方法时根据方法地址直接调用，并不是经过objc_msgSend函数调用 +initialize方法+initialize方法会在类第一次接收到消息时调用 调用顺序先调用父类的+initialize，再调用子类的+initialize先初始化父类，在初始化子类，每个类只会初始化一次1234567objc_msgSendclass_getInstanceMethodlookUpImpOrNillookUpImpOrForword_class_initializecallInitializeobjc_msgSend(cls, SEL_initialize) +initialize和+load区别+initialize是通过objc_msgSend进行调用如果子类没有实现+initialize，会调用父类的+initialize（所以父类的+initialize可能会被调用多次）如果分类实现了+initialize，就会覆盖类本身的+initialize调用 如何给分类添加成员变量？因为分类的底层结构限制，不能添加成员变量到分类，可以通过关联对象间接实现 添加关联对象12void objc_setAssociatedObject(id object, const void * key, id value, objc_AssociationPolicy policy) 获得关联对象1id objc_getAssociatedObject(id object, const void * key) 移除所有的关联对象1void objc_removeAssociatedObjects(id object) 关联对象的原理关联对象并不是存储在关联对象本身内存中关联对象存储在全局统一的一个AssociationsManager中设置关联对象为nil，就相当于移除关联对象 block的本质block本质上是一个OC对象，内部有个isa指针block是封装了函数调用以及函数调用环境的OC对象 block的变量捕获局部变量 auto 捕获到block内部 访问方式：值传递局部变量 static 捕获到block内部 访问方式：指针传递全局变量 不捕获 访问方式：直接访问 auto变量的捕获 block的类型block有3种类型，可以通过调用class方法或者isa指针查看具体类型，最终都是继承自NSBlock类型123__NSGlobalBlock__ (_NSConcreteGlobalBlock) 数据区域 .data区__NSStackBlock__ (_NSConcreteStackBlock) 栈区__NSMallocBlock__ (_NSConcreteMallocBlock) 堆区 123__NSGlobalBlock__ 没有访问auto变量__NSStackBlock__ 访问了auto变量__NSMallocBlock__ __NSStackBlock__调用了copy 调用copy后的结果123_NSConcreteStackBlock 程序的数据区域 复制效果：什么也不做_NSConcreteStackBlock 栈 复制效果：从栈复制到堆_NSConcreteMallocBlock 堆 复制效果：引用计数增加 block的copy在ARC下，编辑器会在下列情况自动将栈上的block拷贝到堆上：1.block作为函数返回值时2.将block赋值给强指针时3.block作为Cocoa API中方法名含有usingBlock的方法参数时4.block作为GCD API的方法参数时 MRC下block的建议写法：@property(copy, nonatomic) void (^block)(void); ARC下block的建议写法：@property(strong, nonatomic) void (^block)(void);@property(copy, nonatomic) void (^block)(void); 对象类型的auto变量当block内部访问了对象类型的auto变量时如果block在栈上，将不会对auto变量产生强引用 如果block被拷贝到堆上会调用block内部的copy函数copy函数内部会调用_Block_object_assign函数_Block_object_assign函数会根据auto变量的修饰符做出相应操作，形成强引用或弱引用 如果block从堆上移除会调用block内部的dispose函数dispose函数内部会调用_Block_object_dispose函数_Block_object_dispose函数会自动释放引用的auto变量（release） __block修饰符可以解决block内部无法修改auto变量值的问题不能修饰全局变量、静态变量编译器会把__block包装成一个对象 当block在栈上时，并不会对__block变量产生强引用 当block被copy到堆时会调用block内部的copy函数copy函数内部会调用_Block_object_assign函数_Block_object_assign函数会对__block变量形成强引用（retain） 当block从堆中移除时会调用block内部的dispose函数dispose函数内部会调用_Block_object_dispose函数_Block_object_dispose函数会自动释放引用的__block变量（release） __block的__forwarding指针 对象类型的auto变量、__block变量当block在栈上时，对它们都不会产生强引用 解决循环引用问题 - ARC用__weak、__unsafe_unretained解决用__block解决（必须要调用block） 解决循环引用问题 - MRC用__unsafe_unretained解决用__block解决(ARC时会retain，MRC时不会retain)","link":"/OC语法/"},{"title":"字节跳动面试题","text":"字节跳动面试题 1.retain strong 区别在声明 block 时，retain 相当于 assign，strong 相当于 copy，block一般使用 copy 2.NSClassFromString 原理反射方法系统Foundation框架为我们提供了一些方法反射的 API，我们可以通过这些 API 执行将字符串转为SEL等操作。由于OC语言的动态性，这些操作都是发生在运行时的。 123456789// SEL和字符串转换FOUNDATION_EXPORT NSString *NSStringFromSelector(SEL aSelector);FOUNDATION_EXPORT SEL NSSelectorFromString(NSString *aSelectorName);// Class和字符串转换FOUNDATION_EXPORT NSString *NSStringFromClass(Class aClass);FOUNDATION_EXPORT Class __nullable NSClassFromString(NSString *aClassName);// Protocol和字符串转换FOUNDATION_EXPORT NSString *NSStringFromProtocol(Protocol *proto) NS_AVAILABLE(10_5, 2_0);FOUNDATION_EXPORT Protocol * __nullable NSProtocolFromString(NSString *namestr) NS_AVAILABLE(10_5, 2_0); 常用判断方法在NSObject类中为我们提供了一些基础方法，用来做一些判断操作，这些方法都是发生在运行时动态判断的。 12345678// 当前对象是否这个类或其子类的实例- (BOOL)isKindOfClass:(Class)aClass;// 当前对象是否是这个类的实例- (BOOL)isMemberOfClass:(Class)aClass;// 当前对象是否遵守这个协议- (BOOL)conformsToProtocol:(Protocol *)aProtocol;// 当前对象是否实现这个方法- (BOOL)respondsToSelector:(SEL)aSelector; 参考链接：iOS反射机制 3.http协议版本1、HTTP 0.9 ：（1）只接受GET一种请求方法，没有在通信中指定版本号，且不支持请求头； （2）此外该版本也不支持POST方法，因此客户端无法向服务器传递太多信息； 2、HTTP 1.0：（1）支持POST、GET、HEAD三种方法； （2）规定浏览器与服务器之间只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求； 3、HTTP 1.1：（1）新增了五种请求方法：PUT、DELETE、CONNECT、TRACE、OPTIONS； （2）HTTP 1.1 在Request消息头里头多了一个Host域，便于一台WEB服务器上可以在同一个IP地址和端口号上使用不同的主机名来创建多个虚拟WEB站点； （3）长连接 （4）缓存策略不同 （5）在HTTP/1.1中新增了24个状态响应码：100-199 用于指定客户端应相应的某些动作。200-299 用于表示请求成功。300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。400-499 用于指出客户端的错误。500-599 用于支持服务器错误。 4、HTTP 2.0 二进制传输：http 1.x 的解析是基于文本，http2的解析是基于二进制； 多路复用 header压缩 服务端推送 4.http code 206 401206 Partial Content 最后一条会话返回了HTTP/206 “Partial Content”响应.这种响应是在客户端表明自己只需要目标URL上的部分资源的时候返回的.这种情况经常发生在客户端继续请求一个未完成的下载的时候(通常是当客户端加载一个体积较大的嵌入文件,比如视频或PDF文件),或者是客户端尝试实现带宽遏流的时候。 你可以通过Range请求头辨认出一个部分内容请求.该请求头表明了客户端需要请求资源的哪一部分。 401错误原因：用户没有访问权限，需要进行身份认证。 http 常见的错误码2XX 成功 · 200 OK，表示从客户端发来的请求在服务器端被正确处理 · 204 No content，表示请求成功，但响应报文不含实体的主体部分 · 206 Partial Content，进行范围请求 3XX 重定向 · 301 moved permanently，永久性重定向，表示资源已被分配了新的 URL · 302 found，临时性重定向，表示资源临时被分配了新的 URL · 303 see other，表示资源存在着另一个 URL，应使用 GET 方法丁香获取资源 · 304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况 · 307 temporary redirect，临时重定向，和302含义相同 4XX 客户端错误 · 400 bad request，请求报文存在语法错误 · 401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息 · 403 forbidden，表示对请求资源的访问被服务器拒绝 · 404 not found，表示在服务器上没有找到请求的资源 5XX 服务器错误 · 500 internal sever error，表示服务器端在执行请求时发生了错误 · 503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求 5.为什么三次握手，四次挥手6.dispatch_async(queue,block);会不会开线程除了主队列，其他队列都开线程。 7.二叉树中和为某一值的路径LeetCode题目链接：剑指 Offer 34. 二叉树中和为某一值的路径 123456789101112131415161718class Solution { LinkedList&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) { recur(root, sum); return res; } void recur(TreeNode root, int tar) { if(root == null) return; path.add(root.val); tar -= root.val; if(tar == 0 &amp;&amp; root.left == null &amp;&amp; root.right == null) res.add(new LinkedList(path)); recur(root.left, tar); recur(root.right, tar); path.removeLast(); }} 8.Runtime9.UIView 绘制过程UIView的绘制原理 当我们调用 UIView 的 setNeedsDisplay 方法以后,实际上并没有立刻发生当前视图的绘制工作,而是在之后的某一时机才会进行当前视图的绘制 。为什么没有立刻发生当前视图的绘制工作？（因为到当前 runloop 将要结束的时候,才会开始介入到UI视图的绘制流程中） 当调用 UIView 的 setNeedsDisplay 后 系统会立刻调用 view 的 layer 的同名方法 [view.layer setNeedsDisplay] ,之后相当于在 layer 上面打上了一个脏标记 然后再当前 runloop 将要结束的时候,才会调用 CALayer 的 display 函数方法，然后才进入到当前视图的真正绘制工作的流程当中 CALayer 的 display 方法,在内部会首先判断 layer 的 delegate 是否响应 displayLayer 这个方法 若不响应,则系统开始绘制流程 若响应,则开始异步绘制 系统绘制流程 首先 CALayer 内部会创建一个 CGContextRef ,在 drawRect 方法中,可以通过上下文堆栈当中的取出这个 context，拿到的就是当前控件或者说视图的上下文或者说是 backing store 然后 layer 会判断它是否有代理，若没有,则调用 CALayer 的 drawInContext。 若有则调用代理方法,然后做当前视图的绘制工作（这一步发生在系统内部当中）,再在合适的时机,基于 drawRect 回调方法, drawRect 默认操作是什么都不做,而之所以有这个接口,就是为了让我们在系统绘制之上,可以做些自定义的绘制工作。 最后再由 CALayer 上传对应的 backing store 给 GPU,这里的 backing store 我们可以理解为位图。 异步绘制流程 左侧是主队列，右侧是全局并发队列 假如在某一时机调用了 setNeedsDiaplay 方法后 在当前 runloop 将要结束的时候,会有系统调用视图所对应 layer 的 display 方法 如果代理实现了 displayLayer 方法,会调用这个代理的 displayLayer 这个方法 然后通过子线程的切换,我们会在子线程中去做位图的绘制，此时主线程可以去做些其他的工作 然后再回到主队列中,提交这个位图,设置给 CALayer 的 contents 属性 子线程的绘制 通过 CGBitmapContextCreat 方法,来创建一个位图的上下文 通过 CoreGraphic 的相关 API,可以做当前 UI 控件的一些绘制工作 之后通过 CGBitmapContextCreatImage 方法,根据所绘制的上下文,生成一张 CGImage 图片 最后回到主队列中，将该 CGImage 图片设置为 CALayer 的 contents 参考链接：UI绘制原理&amp;系统/异步绘制流程 UIView的绘制原理及优化 10.autoreleasepool 子线程使用了 autorelease 后，如果当前线程没有 AutorelesepoolPage 的话，代码执行顺序为 autorelease -&gt; autoreleaseFast -&gt; autoreleaseNoPage。在 autoreleaseNoPage 方法中，会创建一个 hotPage ，然后调用page-&gt;add(obj) 。也就是说即使这个线程没有 AutorelesepoolPage ，使用了 autorelease 对象时也会 new 一个 AutoreleasepoolPage 出来管理 autorelese 对象。 子线程的 autoreleasepool 是在线程销毁的时候释放的。 11.VC生命周期，viewWillDisappear 和 viewDidDisappear 之间会不会调用view 的 layoutpush 会调用，pop 不会调用 12345678910111 push 22-[2 loadView]2-[2 viewDidLoad]1-[1 viewWillDisappear:]2-[2 viewWillAppear:]2-[2 viewWillLayoutSubviews]2-[2 viewDidLayoutSubviews]1-[1 viewWillLayoutSubviews]1-[1 viewDidLayoutSubviews]1-[1 viewDidDisappear:]2-[2 viewDidAppear:] 12.autorelease 调用 release 会立即销毁吗13.GCD能不能取消任务 dispatch_block_cancel 定义外部变量，用于标记block是否需要取消 参考链接：如何取消GCD任务","link":"/字节跳动面试题/"},{"title":"度小满","text":"度小满 一面： 1.内存管理，内存泄漏，监测方法，解决办法 2.App启动流程，优化方法，查看每个阶段耗时的方法 Category和Extension区别，使用场景 Category可以添加属性吗？ 3.webView和原生交互，怎么提升webView加载速度？H5怎么加载本地的JS和图片资源？ 4.HTTP和HTTPS的区别，HTTPS怎么保证安全？GET和POST区别？请求头里一般有什么？ 5.MVC、MVP、MVVM区别，使用场景 6.用OC实现一个栈，push pop isEmpty方法，栈和队列的区别，使用场景 7.了解鸿蒙吗 二面： 1.了解提升研发效率的方法，跨平台框架？ 2.Flutter和原生交互方法 3.小程序的实现原理，SN的实现原理 3.设计图片下载框架，包括内存，缓存，解码等；缓存的技术指标是什么？(命中率) 在缓存即将达到最大容量时，同时有大量写入缓存的操作，怎么优化？ 4.下载限制并发数量，下载断点续传 http请求码是多少 5.同层渲染怎么实现 6.webView加载速度优化 7.线上卡顿监控，卡顿优化 8.线上内存监控 9.口述快速排序，快速排序用迭代实现 10.HTTPS的流程，客户端校验证书的过程，链式验证 三面： 1.监控 2.原生与H5交互，注入和post message怎么选型的？ 3.有没有关注过业务指标，技术手段提升业务指标的情况？收银台支付成功率？ 4.其他：年龄、看机会原因，有没有别的offer 参考答案1.内存管理，内存泄漏，卡顿监测方法，解决办法 2.App启动流程，优化方法，查看每个阶段耗时的方法 3.webView和原生交互，怎么提升webView加载速度？H5怎么加载本地的JS和图片资源？ 4.HTTP和HTTPS的区别，HTTPS怎么保证安全？GET和POST区别？请求头里一般有什么？ HTTP（HyperText Transfer Protocol）和HTTPS（HyperText Transfer Protocol Secure）是用于在网络上传输数据的两种协议。它们有以下主要区别： 安全性： HTTP：数据以纯文本形式传输，不加密。因此，数据在传输过程中容易被截获和篡改。 HTTPS：在HTTP的基础上增加了SSL/TLS加密层。数据在传输过程中会被加密，提供了数据的保密性和完整性，防止被窃听和篡改。 端口： HTTP：默认使用80端口。 HTTPS：默认使用443端口。 证书： HTTP：不需要证书。 HTTPS：需要SSL/TLS证书，用于加密通信和验证服务器身份。证书由受信任的证书颁发机构（CA）签发。 性能： HTTP：因为没有加密和解密的过程，速度相对较快。 HTTPS：由于需要进行加密和解密操作，性能会有所下降，但现代硬件和优化技术已经极大地减少了这种影响。 GET和POST区别 GET：主要用于获取数据，参数在URL中，适合传输较少、非敏感数据，幂等且可缓存。 POST：主要用于提交数据，参数在请求体中，适合传输大量、敏感数据，非幂等且通常不缓存。 以下是一些常见的HTTP请求头字段及其作用： 1. 通用请求头字段 Host：指定请求的目标主机和端口，例如：Host: www.example.com。这是HTTP/1.1中必须包含的头字段。 User-Agent：标识发出请求的客户端软件信息，例如浏览器类型和版本、操作系统等，例如：User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3。 Accept：指定客户端能够处理的内容类型，例如：Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8。 Accept-Language：指定客户端首选的语言和地区，例如：Accept-Language: en-US,en;q=0.5。 Accept-Encoding：指定客户端支持的内容编码类型，例如：Accept-Encoding: gzip, deflate, br。 Connection：控制连接的管理，例如：Connection: keep-alive或Connection: close。 2. 请求头字段（请求特有） Referer：指示请求的来源页面的URL，例如：Referer: https://www.example.com/previous-page。 Cookie：发送存储在客户端的Cookie数据，例如：Cookie: sessionId=abc123; theme=light。 Authorization：用于传递身份验证凭据，例如：Authorization: Bearer token123或Authorization: Basic base64credentials。 Content-Type：指定请求体的媒体类型，常用于POST和PUT请求，例如：Content-Type: application/json或Content-Type: application/x-www-form-urlencoded。 Content-Length：表示请求体的字节长度，例如：Content-Length: 348。 Origin：表明请求的来源，用于跨域请求，例如：Origin: https://www.example.com。 If-Modified-Since：用于条件请求，只在指定日期之后资源被修改时才返回，例如：If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT。 If-None-Match：用于条件请求，当ETag不匹配时才返回，例如：If-None-Match: &quot;abc123&quot;。 Range：请求部分资源内容，例如：Range: bytes=500-999。 3. 自定义请求头字段 X-Requested-With：通常用于标识Ajax请求，例如：X-Requested-With: XMLHttpRequest。 X-CSRF-Token：用于传递CSRF（跨站请求伪造）令牌，以防止CSRF攻击。 X-Forwarded-For：记录原始客户端IP地址，常用于代理服务器，例如：X-Forwarded-For: 203.0.113.195。 4. HTTP/2 特有头字段 :method：表示HTTP方法，例如：:method: GET。 :scheme：表示请求的协议（http或https），例如：:scheme: https。 :path：表示请求的路径和查询字符串，例如：:path: /index.html。 :authority：表示服务器的主机名和端口，类似于HTTP/1.1的Host头字段，例如：:authority: www.example.com。 示例请求头12345678910GET /index.html HTTP/1.1Host: www.example.comUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: en-US,en;q=0.5Accept-Encoding: gzip, deflate, brConnection: keep-aliveReferer: https://www.example.com/previous-pageCookie: sessionId=abc123; theme=lightAuthorization: Bearer token123 这些请求头字段在客户端和服务器之间传递时，提供了关于请求和客户端环境的丰富信息，使得服务器能够理解和处理请求，并返回适当的响应。 5.MVC、MVP、MVVM区别，使用场景 6.用OC实现一个栈，push pop isEmpty方法，栈和队列的区别，使用场景 7.了解鸿蒙吗 二面： 1.了解提升研发效率的方法，跨平台框架？ 2.Flutter和原生交互方法 3.小程序的实现原理，SN的实现原理 3.设计图片下载框架，包括内存，缓存，解码等；缓存的技术指标是什么？(命中率) 在缓存即将达到最大容量时，同时有大量写入缓存的操作，怎么优化？ 4.下载限制并发数量，下载断点续传 http请求码是多少 5.同层渲染怎么实现 小程序同层渲染原理剖析 小程序在同层渲染上的探索 6.webView加载速度优化 7.线上卡顿监控，卡顿优化 8.线上内存监控 iOS微信内存监控 9.口述快速排序，快速排序用迭代实现 10.HTTPS的流程，客户端校验证书的过程，链式验证 第一步是检查证书的链式验证。客户端会使用已信任的根证书（Root Certificate Authority）去验证服务器证书的有效性。根证书是权威机构颁发的，被广泛信任的证书，用于证明其它证书的合法性。客户端会检查服务器证书中的颁发者，然后递归地检查颁发者的证书，直到检查到根证书或者找不到信任的根证书为止。 第二步是检查证书的有效期。客户端会检查证书的有效起始日期和有效截止日期，确保证书在有效期内。如果证书过期，客户端将拒绝连接。 第三步是检查证书的公钥。客户端会验证服务器证书中的公钥和域名是否匹配。客户端会从证书中提取服务器的公钥，并与服务器进行握手协议，验证证书中的公钥是否与服务器的公钥匹配。如果不匹配，客户端将拒绝连接。 除了上述基本的校验步骤，客户端还可以进行更加严格的校验，以提高安全性。例如，客户端可以检查证书中是否包含指纹信息（Fingerprint），从而确保证书的完整性和一致性。客户端也可以检查证书中的扩展字段，查看是否存在其他安全相关的信息。 总结来说，客户端校验证书的过程包括链式验证、有效期验证和公钥匹配验证。通过这些验证步骤，客户端能够确保所连接的服务器是合法且可信赖的，从而保障通信的安全性。 三面： 1.监控 2.原生与H5交互，注入和post message怎么选型的？ 在移动开发中，原生与H5（HTML5）交互是一个常见的需求。为了实现这种交互，通常有两种主要的方法：注入（Injection）和 postMessage。各有优缺点，选择哪种方法取决于具体的应用场景和需求。下面对这两种方法进行详细比较和建议： 注入（Injection）优点： 灵活性高：可以直接在H5页面中注入原生代码，灵活性较高。 强大的控制力：原生代码可以直接操作H5页面的DOM和JavaScript，控制力强。 无需特定API支持：不需要依赖特定的API或者更新H5页面的代码。 缺点： 安全性问题：注入代码可能会带来安全风险，容易被恶意代码利用。 维护复杂：代码维护复杂，尤其是原生代码和H5页面频繁变动时。 浏览器兼容性：不同浏览器对注入代码的支持可能有所不同。 postMessage优点： 安全性高：通过消息传递的方式进行交互，安全性较高，不容易被恶意代码利用。 标准化：postMessage是HTML5标准的一部分，具有较好的跨浏览器兼容性。 易于调试和维护：消息传递方式使得代码逻辑更加清晰，易于调试和维护。 缺点： 性能影响：在高频率消息传递的情况下，可能会有性能影响。 依赖API：需要H5页面和原生代码都支持postMessage API。 有限的控制力：相比直接注入代码，控制力稍弱，只能通过消息进行交互。 如何选择？选择哪种方法取决于具体的应用场景和需求： 安全性优先：如果安全性是首要考虑因素，建议使用postMessage，因为这种方法更安全，不容易被恶意代码利用。 高频交互：如果需要高频率的交互，且对性能要求较高，可以考虑注入方式，但要特别注意代码的安全性和浏览器兼容性。 跨浏览器兼容：如果需要在多个浏览器中运行，并且希望代码易于维护和调试，postMessage是更好的选择。 快速开发：如果需要快速实现功能，且不考虑长远的维护和安全性问题，注入方式可能会更快捷。 结论综合来看，postMessage在大多数情况下是更优的选择，特别是在考虑安全性、标准化和易于维护的情况下。但在某些特定场景下，比如需要高频率的交互或者对H5页面进行强控制时，注入方式也不失为一个可选方案。最终的选择应根据具体的项目需求和开发环境来决定。 3.有没有关注过业务指标，技术手段提升业务指标的情况？收银台支付成功率？","link":"/度小满/"},{"title":"小米面试题及答案","text":"小米面试题 1.说说你了解的设计模式。说说你了解的设计原则。设计模式的六大原则1、开闭原则（Open Close Principle） 开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。 2、里氏代换原则（Liskov Substitution Principle） 里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。 3、依赖倒转原则（Dependence Inversion Principle） 这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。 4、接口隔离原则（Interface Segregation Principle） 这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。 5、迪米特法则，又称最少知道原则（Demeter Principle） 最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。 6、合成复用原则（Composite Reuse Principle） 合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。 设计模式装饰模式：在不改变原封装的前提下，为对象动态添加新功能的模式。在 Objective-C 中，它的实现形式为 Category 和 Delegation；在 Swift 中，它的实现形式为 Extension 和 Delegation。 观察者模式：通知、KVO 备忘录模式：保存对象当前的状态，并在日后可以恢复的模式。用 UserDefaults 来读写，同时配合栈可以存储一系列状态。它经常用于初始化、重启、App 前后台状态改变等场景。 工厂模式 单例模式 2.什么是队列？同步异步是什么？GCD与NSOperation的相同与不同，使用场景。GCD的队列可以分为2大类型并发队列（Concurrent Dispatch Queue） 可以让多个任务并发（同时）执行（自动开启多个线程同时执行任务） 并发功能只有在异步（dispatch_async）函数下才有效 串行队列（Serial Dispatch Queue） 让任务一个接着一个地执行（一个任务执行完毕后，再执行下一个任务） 同步和异步主要影响：能不能开启新的线程 同步：在当前线程中执行任务，不具备开启新线程的能力 异步：在新的线程中执行任务，具备开启新线程的能力 并发和串行主要影响：任务的执行方式 并发：多个任务并发（同时）执行 串行：一个任务执行完毕后，再执行下一个任务 并发队列 手动创建的串行队列 主队列 同步（sync） 没有开启新线程，串行执行任务 没有开启新线程，串行执行任务 没有开启新线程，串行执行任务 异步（async） 有开启新线程，并发执行任务 有开启新线程，串行执行任务 没有开启新线程，串行执行任务 使用sync函数往当前串行队列中添加任务，会卡住当前的串行队列（产生死锁） 3.Block，本质，指针引用，值引用，变量捕获（static和auto），__weak __block12345NSMutableArray *array = nil;void(^Block)(void) = ^{ array = [NSMutableArray array];};Block(); 有什么问题？局部变量是值捕获，不能在block内部修改。 12345NSMutableArray *array = [NSMutableArray array];void(^Block)(void) = ^{ [array addObject:\"1\"];};Block(); 有什么问题？没问题，可以添加元素 4.交叉链表找交点123456789101112function FindFirstCommonNode(pHead1, pHead2){ if (pHead1 == null || pHead2 == null) { return null; } let p1 = pHead1, p2 = pHead2; while (p1 != p2) { p1 = p1 == null ? pHead2 : p1.next; p2 = p2 == null ? pHead1 : p2.next; } return p1;} 5.性能优化，启动优化性能优化 cell复用，header、footer复用。 尽量把view设置不透明。 减少视图的层级。 尽量避免调整视图层次、添加和移除视图。 合理选择加载图片的方式，UIImage imageNamed: ImageAssets 用于多个地方重复使用，UIImage imageWithContentsOfFile 一般用在图片数据很大，一般不需要多次使用的情况。 图片大小最好和UIImageView的大小相同。 不要阻塞主线程，耗时操作放在子线程进行。 懒加载。 缓存，缓存图片SDWebImage，缓存行高，NSCache缓存。 复用高开销对象NSDateFormatter和NSCalendar。 减少离屏渲染，优化圆角、阴影。 使用正确的数据存储。 启动优化 将一些耗时操作延迟执行。比如SDK的初始化，界面的创建。 不能延迟执行的，尽量放到后台执行。比如数据读取，原始 JSON 数据转对象，日志发送。 减少动态库、合并动态库，定期清理不必要的动态库。 减少类、分类的数量，合并Category和功能类似的类。删除不必要的方法和类、分类。 将不必须在+load中做的事延时到+initialize中。 6.谈谈https 一个HTTPS请求实际上包含了两次HTTP传输： 1）客户端发起一个http请求，连接到服务器的443端口。 2）服务端把自己的信息以数字证书的形式返回给客户端（证书内容有密钥公钥，网站地址，证书颁发机构，失效日期等）。证书中有一个公钥来加密信息，私钥由服务器持有。 3）验证证书的合法性 客户端收到服务器的响应后会先验证证书的合法性（证书中包含的地址与正在访问的地址是否一致，证书是否过期）。 4）生成随机密码（RSA签名） 如果验证通过，或用户接受了不受信任的证书，浏览器就会生成一个随机的对称密钥（session key）并用公钥加密，让服务端用私钥解密，解密后就用这个对称密钥进行传输了，并且能够说明服务端确实是私钥的持有者。 5）生成对称加密算法 验证完服务端身份后，客户端生成一个对称加密的算法和对应密钥，以公钥加密之后发送给服务端。此时被黑客截获也没用，因为只有服务端的私钥才可以对其进行解密。之后客户端与服务端可以用这个对称加密算法来加密和解密通信内容了。 6）客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器。 7）服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。 8）然后服务器将加密后的密文发送给客户端。 9）客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成。 7.说说响应链能够响应触摸事件的例如UIView，UIButton，UIViewController，UIApplication，Appdelegate等都继承自UIResponder类，一个页面上通常会有许许多多个这种类型的对象，都可以对点击事件作出响应。为了避免冲突，这就需要有一个先后顺序，也就是响应的优先级。Hit-Testing的目的就是找到具有最高优先级的响应对象。寻找的具体流程如下： UIApplication首先将事件队列中的事件取出，传递给窗口对象。如果有多个窗口，则优先询问windows数组的最后一个窗口。 如果窗口不能响应事件，则将事件传递给倒数第二个窗口，以此类推。如果窗口能够响应事件，则再依次询问该窗口的子视图。 重复步骤2。 若视图的所有子视图均不是最佳响应者，则自身就是最合适的响应者。另外需要注意的是，一下几种状态的视图无法响应事件： 不允许交互的视图：userInteractionEnabled = NO 隐藏的视图：hidden = YES 透明度alpha&lt;0.01的视图 怎么样验证一下上面所说的Hit-Testing的顺序呢，看一下UIView的API，里面会有一个hitTest：withEvent：方法，这个方法的主要作用就是查询并返回事件在当前视图中的响应者，每个被询问到的视图对象都会调用这个方法来返回当前视图层的响应者。 如果当前视图无法响应事件，则返回nil。 如果当前视图可以响应事件，但子视图不能响应事件，则返回自身作为当前视图的响应者。 如果当前视图可以响应事件，同时有子视图可以响应事件，则返回该子视图作为当前视图的响应者。 8.你知道哪些锁？（自旋锁，互斥锁）使用场景都有哪些？os_unfair_lockOSSpinLockdispatch_semaphorepthread_mutexNSLockNSConditionpthread_mutex(recursive)NSRecursiveLockNSConditionLock@synchronized 线程同步","link":"/小米面试题/"},{"title":"淡蓝网","text":"淡蓝网 1.SDK体积优化，无用代码检测怎么做的？ 2.加载速度优化，怎么发现的多次刷新？ 3.高考项目 4.循环引用怎么解决？NSTimer 为什么用 weak 不能解决循环引用 5.Swift 中 weak 和 unowned 的区别？什么场景下用 unowned？或者说 unowned 有什么好处？ 6.什么场景下用分类？Category 能添加属性吗？为什么不能添加成员变量？苹果为什么这么设计？ 7.为什么要设计元类？ 8.SDK中有个类有私有成员变量，怎么改它的值？ 9.数组的方法被 hook 了，怎么让有些数组不生效，使用系统的默认方法 参考答案1.SDK体积优化，无用代码检测怎么做的？ 通过使用otool工具对编译产生的Mach-O文件，结合项目源码进行分析。 第一步： 找到项目中所有的protocol中的方法&lt;包括系统&lt;UITabaleViewDelegate&gt;的和项目的&gt; 第二步： 通过Mach-O，找到项目中所有被引用的方法 第三步： 通过Mach-O，找到项目中所有的方法 第四步： 遍历第三步查出的所有方法，如果当前方法不在代理方法集合，也不在引用方法集合中，那么就认为是没有用到的方法。 参考链接：简书-iOS 脚本查看项目未使用到的方法 2.加载速度优化，怎么发现的多次刷新 3.高考项目 4.循环引用怎么解决？NSTimer为什么用weak不能解决循环引用 解决循环引用的方法1. 使用 weak 修饰符在使用闭包时，可以使用weak或unowned关键字来解决循环引用问题。 1234__weak typeof(self) weakSelf = self;self.someBlock = ^{ [weakSelf doSomething];}; 在Swift中： 1234weak var weakSelf = selfself.someBlock = { [weak weakSelf] in weakSelf?.doSomething()} 2. 使用 delegate 和 weak 修饰符在使用委托模式时，可以将委托声明为weak。 1@property (nonatomic, weak) id&lt;MyDelegate&gt; delegate; 在Swift中： 1weak var delegate: MyDelegate? 3. 使用 __block 修饰符在某些情况下，可以使用__block修饰符来解决循环引用问题。 12345__block typeof(self) blockSelf = self;self.someBlock = ^{ [blockSelf doSomething]; blockSelf = nil; // 解除循环引用}; 为什么 NSTimer 使用 weak 不能解决循环引用NSTimer 是一个常见的导致循环引用的源头，因为它会强引用其目标对象。即使你在目标对象中使用weak修饰符，NSTimer仍然会强引用目标对象，导致循环引用。 使用 NSTimer 的正确方法 使用中介对象 你可以创建一个中介对象，这个对象不会强引用目标对象，从而打破循环引用。 12345678910111213141516171819202122232425@interface TimerProxy : NSObject@property (nonatomic, weak) id target;@property (nonatomic, assign) SEL selector;@end@implementation TimerProxy- (void)timerDidFire:(NSTimer *)timer { if (self.target) { [self.target performSelector:self.selector withObject:timer]; } else { [timer invalidate]; }}@end// 使用中介对象TimerProxy *proxy = [TimerProxy new];proxy.target = self;proxy.selector = @selector(timerDidFire:);NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:proxy selector:@selector(timerDidFire:) userInfo:nil repeats:YES]; 使用 GCD 定时器 GCD 提供了一种无需手动管理循环引用的定时器。 1234567891011dispatch_queue_t queue = dispatch_get_main_queue();self.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);dispatch_source_set_timer(self.timer, dispatch_time(DISPATCH_TIME_NOW, 0), 1.0 * NSEC_PER_SEC, (1ull * NSEC_PER_SEC) / 10);__weak typeof(self) weakSelf = self;dispatch_source_set_event_handler(self.timer, ^{ [weakSelf timerDidFire];});dispatch_resume(self.timer); 在Swift中： 1234567891011let queue = DispatchQueue.mainlet timer = DispatchSource.makeTimerSource(queue: queue)timer.schedule(deadline: .now(), repeating: 1.0)timer.setEventHandler { [weak self] in self?.timerDidFire()}timer.resume()self.timer = timer 5.swift中weak和unowned的区别？什么场景下用unowned？或者说unowned有什么好处？ 在Swift中，weak 和 unowned 是两种用于解决强引用循环（retain cycle）问题的引用类型修饰符。虽然它们都可以用来打破循环引用，但它们的行为和使用场景有所不同。 weak 和 unowned 的区别weak 可选类型：weak 修饰的引用会被自动设置为 nil 当其引用的对象被释放时。因此，weak 引用必须是可选类型（Optional）。 自动解除引用：使用 weak 修饰符可以防止强引用循环，因为当被引用对象被释放时，weak 引用会自动变成 nil。 用法 1234567891011121314151617class Person { var name: String weak var spouse: Person? init(name: String) { self.name = name }}var john: Person? = Person(name: \"John\")var jane: Person? = Person(name: \"Jane\")john?.spouse = janejane?.spouse = johnjohn = nil// At this point, jane?.spouse is automatically set to nil unowned 非可选类型：unowned 修饰的引用在其引用的对象被释放后不会自动变成 nil，并且它必须是非可选类型（Non-Optional）。 无自动解除引用：使用 unowned 修饰符不会自动变成 nil，如果你尝试访问一个已经被释放的对象，会导致运行时崩溃。 用法 1234567891011121314151617181920212223242526class Person { var name: String var car: Car? init(name: String) { self.name = name }}class Car { var model: String unowned var owner: Person init(model: String, owner: Person) { self.model = model self.owner = owner }}var john: Person? = Person(name: \"John\")var johnsCar: Car? = Car(model: \"Tesla\", owner: john!)john?.car = johnsCarjohn = nil// At this point, accessing johnsCar?.owner will cause a runtime crash because john has been deallocated 使用场景什么时候使用 weak 当引用的对象可能在其生命周期中变为 nil 时。 常见的场景包括委托（delegates）、UI元素的引用（例如：视图控制器对视图的引用），以及任何你预计会变为 nil 的引用。 什么时候使用 unowned 当引用的对象在其生命周期中不会变为 nil，并且你确定引用的对象会一直存在直到被引用对象的生命周期结束。 常见的场景包括：两个对象具有相同的生命周期，或一个对象的生命周期完全包含另一个对象的生命周期。 例如，闭包对 self 的引用可以使用 unowned 修饰符，因为闭包的生命周期通常与其持有者相同或更短。 unowned 的好处 性能：由于 unowned 引用不会自动设置为 nil，它的性能稍微优于 weak 引用，因为不需要额外的nil检查。 非可选类型：unowned 引用不需要解包，因为它是非可选类型，这可以简化代码。 然而，使用 unowned 引用时需要非常小心，因为如果引用的对象被释放后再访问该引用，会导致运行时崩溃。一般来说，除非你非常确定引用的对象在其生命周期中不会变为 nil，否则建议使用 weak 引用。 6.什么场景下用分类？Category能添加属性吗？为什么不能添加成员变量？苹果为什么这么设计？ 在 Objective-C 中，Category 是用于为现有类添加方法的一种机制，但它不能直接添加成员变量（实例变量）。不过，可以通过一些间接方式为 Category 添加属性。让我们深入探讨一下为什么 Category 不能添加成员变量、苹果为什么设计成这样，以及如何在 Category 中添加属性。 为什么 Category 不能添加成员变量Category 主要设计目的是为了扩展已有类的功能，而不是修改类的内部结构。添加成员变量会涉及到修改类的内存布局，这在运行时会带来很多复杂性和潜在的问题。 内存布局问题：Objective-C 的内存布局是在编译时确定的，而成员变量会影响对象的内存布局。如果允许在 Category 中添加成员变量，那么就意味着当一个新 Category 被加载时，需要重新计算和调整所有实例的内存布局，这在运行时是非常复杂和低效的。 二进制兼容性：允许 Category 添加成员变量会破坏二进制兼容性。假设一个类库在某个版本中添加了一个包含成员变量的 Category，而在早期版本中没有这个 Category，那么在不同版本之间切换时可能会导致崩溃或未定义行为。 动态加载：Objective-C 支持动态加载类和 Category。如果 Category 能够添加成员变量，那么动态加载一个新的 Category 时，需要重新分配和调整现有对象的内存，这在设计和实现上是非常困难的。 苹果为什么这么设计苹果设计 Category 的目的是为了提供一种灵活且轻量级的方式来扩展类的功能，而不改变类的基本结构。这样设计的主要原因包括： 简化实现：不允许 Category 添加成员变量使得内存管理和对象模型的实现更加简单和可靠。 动态特性：Objective-C 是一种动态语言，Category 提供了在运行时扩展类功能的能力，而无需重新编译类文件。这种灵活性是Objective-C的一个重要特性。 稳定性和兼容性：通过限制 Category 的能力，可以确保类的内存布局在整个应用程序生命周期内保持稳定，从而提高程序的稳定性和兼容性。 如何在 Category 中添加属性虽然 Category 不能直接添加成员变量，但可以通过关联对象（Associated Objects）来间接实现属性的添加。 1. 使用关联对象你可以使用 objc_setAssociatedObject 和 objc_getAssociatedObject 函数来为 Category 添加属性。 1234567891011121314151617#import &lt;objc/runtime.h&gt;@interface MyClass (CategoryName)@property (nonatomic, strong) id property;@end@implementation MyClass (CategoryName)- (void)setProperty:(id)value { objc_setAssociatedObject(self, @selector(property), value, OBJC_ASSOCIATION_RETAIN_NONATOMIC);}- (id)property { return objc_getAssociatedObject(self, @selector(property));}@end 在上面的代码中，我们使用了关联对象来为 Category 添加属性。objc_setAssociatedObject 函数将一个对象与一个键关联起来，而 objc_getAssociatedObject 函数则根据键获取关联的对象。 2. 关联对象策略objc_setAssociatedObject 的第四个参数是一个关联策略，常见的策略包括： OBJC_ASSOCIATION_ASSIGN：相当于 assign 属性。 OBJC_ASSOCIATION_RETAIN_NONATOMIC：相当于 strong 非原子属性。 OBJC_ASSOCIATION_COPY_NONATOMIC：相当于 copy 非原子属性。 OBJC_ASSOCIATION_RETAIN：相当于 strong 原子属性。 OBJC_ASSOCIATION_COPY：相当于 copy 原子属性。 结论虽然 Category 不能直接添加成员变量，但通过关联对象，我们可以间接地为 Category 添加属性。这种设计使得 Category 的实现更加简单和稳定，同时保留了扩展类功能的灵活性。苹果选择不允许 Category 添加成员变量，是为了简化内存管理、提高运行时性能和确保二进制兼容性。 7.为什么要设计元类？ 8.SDK中有个类有私有成员变量，怎么改它的值？ 9.数组的方法被hook了，怎么让有些数组不生效，使用系统的默认方法","link":"/淡蓝网/"},{"title":"猿辅导面试题","text":"猿辅导面试题 1.@[]; 加入 nil 会闪退吗会闪退，报错： 1-[__NSPlaceholderArray initWithObjects:count:]: attempt to insert nil object from objects[4] 2.array[i] 会不会走 objectAtIndex会走。 array[i] 如果数组越界，会崩溃报错： 1[__NSArrayI objectAtIndexedSubscript:]: index 6 beyond bounds [0 .. 4]' 3.信号量 3 个网络接口返回执行 4有些时候，我们需要阻塞发送请求的线程，比如在多个请求回调后统一操作的需求，而这些请求之间并没有顺序关系，且这些接口都会另开线程进行网络请求的。一般地，这种多线程完成后进行统一操作的需求都会使用队列组(dispatch_group_t)来完成，但是由于是异步请求，没等其异步回调之后，请求的线程就结束了，为此，就需要使用信号量来阻塞住发请求的线程。实现代码如下： 12345678dispatch_async(queue, 0), ^{ dispatch_semaphore_t sema = dispatch_semaphore_create(0); [网络请求:^{ //请求回调 dispatch_semaphore_signal(sema); }]; dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER);}); 这样，请求的线程就可以等到回调结束后再结束了，再配合队列组就能完成上述的需求。这种技巧可用于以下场景： 多个请求结束后统一操作 多个请求顺序执行 4.hook delelgate 方法参考链接：iOS hook delegate 5.交换方法传入参数 为什么需要先 addMethod12345678910111213141516171819+ (void)exchangeInstanceMethodWithSelfClass:(Class)selfClass originalSelector:(SEL)originalSelector swizzledSelector:(SEL)swizzledSelector { Method originalMethod = class_getInstanceMethod(selfClass, originalSelector); Method swizzledMethod = class_getInstanceMethod(selfClass, swizzledSelector); BOOL didAddMethod = class_addMethod(selfClass, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); if (didAddMethod) { class_replaceMethod(selfClass, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); } else { method_exchangeImplementations(originalMethod, swizzledMethod); }} 防止影响父类的方法。 init 方法并不是 Person 类本身的实例（对象）方法，而是父类 NSObject 的方法。由于 Person 本身没有该方法，所以 class_getInstanceMethod 获取到的方法是通过 Person 的 superclass 指针从 NSObject 类中获取到了 init 这个方法。 method_exchangeImplementations 操作将 NSObject 的 init 方法的实现与 Person 类的 yxc_init 方法的实现进行互换了，这时候调用 init 方法实际上是调用了 yxc_init 方法。 创建一个 Person 对象时，调用 init 方法，运行时会去查找 yxc_init 的实现，因为 yxc_init 方法是 Person 自身的方法，所以查找到了直接调用。（消息发送机制） 而创建一个 NSObject 对象时，调用 init 方法，运行时去查找 yxc_init 方法的时候，NSObject 是没有这个方法，这个方法存在于 Person 类中，所以查找完毕，还是找不到这个方法，就抛异常了。 正确的 hook 做法是，先将 init 方法添加到 Person 类中，如果这个类当前有这个方法（而不是父类），则不添加，直接 exchange，否则添加了 init 方法，然后再将 yxc_init 方法的实现设置成 init 方法的实现。 参考链接：iOS Runtime 黑魔法方法交换(Method swizzling) 6.关联对象有几种策略，如何实现 weak在关联对象释放的时候，调用objc_setAssociatedObject(object, key, nil, OBJC_ASSOCIATION_ASSIGN)这样就把宿主对象的该 key 的关联对象清除了，外部读这个 key 的关联对象就是 nil 1234567891011extern void objc_setWeakAssociatedObject(id _Nonnull object, const void * _Nonnull key, id _Nullable value);void objc_setWeakAssociatedObject(id _Nonnull object, const void * _Nonnull key, id _Nullable value) { if (value) { //__weak typeof(object) weakObj = object; [value hc_doSthWhenDeallocWithBlock:^(NSObject *__unsafe_unretained _Nonnull target) { objc_setAssociatedObject(object, key, nil, OBJC_ASSOCIATION_ASSIGN); // clear association }]; } objc_setAssociatedObject(object, key, value, OBJC_ASSOCIATION_ASSIGN); // call system imp} 参考链接：OC-AssociatedObject原理及weak关联对象的实现 7.响应者链 button 超出父视图一半能否响应点击事件超出父视图的部分不能响应，在父视图内的部分可以响应。 如何扩大按钮的点击范围？ 可以重写 button 的 pointInside: 方法 12345678- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event { // 当前btn的大小 CGRect btnBounds = self.bounds; // 扩大按钮的点击范围，改为负值 btnBounds = CGRectInset(btnBounds, -15, -15); // 若点击的点在新的bounds里，就返回YES return CGRectContainsPoint(btnBounds, point);} 8.离屏渲染，为什么会触发参考链接：知乎-关于iOS离屏渲染的深入研究 简书-iOS离屏渲染产生的原因 9.判断当前任务在哪个 queue 中dispatch_queue_get_label 参考链接：判断代码在哪个队列中运行 10.SDWebImage 内存缓存怎么实现的参考链接：iOS-SDWebImage缓存机制 11.json 转 model，Runtime 能否获取到自定义属性的类型class_copyPropertyList可以获取到属性列表 property_getName可以获取到属性名 property_getAttributes可以获取到成员类型 12.tableView 快速滑动 卡顿发生可能原因1.提前计算并缓存好高度，因为 heightForRow 最频繁的调用。 - (UITableViewCell)tableView:(UITableView)tableView cellForRowAtIndexPath:(NSIndexPath*)indexPath; 2.异步绘制，遇到复杂界面，性能瓶颈时，可能是突破口。 3.滑动时按需加载，这个在大量图片展示，网络加载时，很管用。（SDWebImage 已经实现异步加载）。 4.重用 cells。 5.如果 cell 内显示得内容来自 web，使用异步加载，缓存结果请求。当 cell 中的部分 View 是非常独立的，并且不便于重用的，而且“体积”非常小，在内存可控的前提下，我们完全可以将这些 view 缓存起来。当然也是缓存在模型中。 6.少用或不用透明图层，使用不透明视图。对于不透明的 View，设置 opaque 为 YES，这样在绘制该 View 时，就不需要考虑被 View 覆盖的其他内容（尽量设置 Cell 的 view 为 opaque，避免 GPU 对 Cell 下面的内容也进行绘制） 7.减少 subViews。分析 Cell 结构，尽可能的将 相同内容的抽取到一种样式 Cell 中，前面已经提到了 Cell 的重用机制，这样就能保证 UITbaleView 要显示多少内容，真正创建出的 Cell 可能只比屏幕显示的 Cell 多一点。虽然 Cell 的’体积’可能会大点，但是因为 Cell 的数量不会很多，完全可以接受的 8.少用 addView 给 cell 动态添加 view，可以初始化的时候就添加，然后通过 hide 控制是否显示。 13.括号算法LeetCode 题目链接：括号生成 14.CocoaPods 缓存存在哪里，pod install 执行~/Library/Caches/Cocoapods","link":"/猿辅导面试题/"},{"title":"滴滴出行面试题及答案","text":"滴滴出行面试题 1. 笔试题0.姓名？日期。1.C语言实现字符串反转：void reverse(char *str, int length) {}123456789101112131415void reverse(char *str, int length) { char *start, *end, t; start = str; end = &amp;str[length - 1]; while(start &lt; end) { t = *start; *start = *end; *end = t; start++; end--; } for (int i = 0; str[i]; i++) { printf(\"%c\",str[i]); }} 2.实现一个字符串数组去重函数。123456789101112var str_arr = [\"b\",\"c\",1,\"a\", 3,\"v\", \"2\",\"e\", \"6\",\"g\", \"9\", \"arr\",9, \"hello\",\",6\", \"9\", \"1\", 2, 6, \"b\", \"c\"];function unique(arr) { var map = {}, array = []; for (var i = 0; i &lt; arr.length; i++) { var key = arr[i] + typeof arr[i]; if (map[key] == null) { map[key] = true; array.push(arr[i]); } } return array;} 3.描述OC中对象的实现原理。12345@interface NSObject { Class isa;}@endtypedef struct objc_class *Class; NSObject对象内部存放了一个名叫isa的指针，指向了一个结构体struct objc_class 一个NSObject对象占用多少内存？ 1）系统分配了16字节给NSObject对象（通过malloc_size函数可以获得） 2）NSObject对象内部只使用了8个字节的空间，用来存放isa指针变量（64位系统下，可以通过class_getInstanceSize函数获得） 4.编写代码，实现 NSObject 中添加一个属性 p112345678910111213141516171819202122@interface NSObject (TestProperty)@property (nonatomic, copy) NSString *p1;@end #import &quot;NSObject+TestProperty.h&quot;#import &lt;objc/runtime.h&gt;@implementation NSObject (TestProperty)- (void)setP1:(NSString *)p1 { objc_setAssociatedObject(self, @selector(p1), p1, OBJC_ASSOCIATION_RETAIN_NONATOMIC);}- (NSString *)p1 { objc_getAssociatedObject(self, @selector(p1));}@end 5.KVO 的实现原理和注意事项。1) 利用RuntimeAPI动态生成一个子类，并且让instance对象的isa指向这个全新的子类2) 当修改instance对象的属性时，会调用Foundation的_NSSetXXXValueAndNotify函数 1234willChangeValueForKey:父类原来的setterdidChangeValueForKey:内部会触发监听器（Oberser）的监听方法( observeValueForKeyPath:ofObject:change:context:） 注意事项：需要调用set方法触发KVO 6.下面的代码有哪些问题？123456789101112131415@interface Demo : NSObject@property (nonatomic, assign) BOOL *p1;@property (nonatomic, strong) NSString *p2;@end@implementation Demo@dynamic p1;- (void)setP2:(NSString *)p2;{ self.p1 = YES; self.p2 = p2;}@end BOOL p1不应该带*。 self.p2 = p2; 调用set方法死循环。 p1没有set方法。 p2最好用copy修饰。 7.JS 和 Native 的通讯方式。方法一：拦截URL 方法二：注册OC与JS方法 12345678910111213141516171819202122232425262728- （void）webViewDidFinishLoad:(UIWebView *)webView { // 获取当前网页的标题 NSString *titleStr = [webView stringByEvaluatingJavaScriptFromString:@&quot;document.title&quot;]; NSLog(@&quot;%@&quot;,titleStr); // 还可以直接调用js定义的方法 // 比如getShareUrl()为js端定义好的方法，返回值为分享的url // 我们就可以通过调用这个方法在returnStr中拿到js返回的分享地址 NSString *returnStr = [webView stringByEvaluatingJavaScriptFromString:@&quot;getShareUrl()&quot;]; NSLog(@&quot;%@&quot;,returnStr); // 还可以为js端提供完整的原生方法供其调用（记得导入#import ） JSContext *context = [webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;]; // 可以定义供js调用的方法, testMethod为js调用的方法名 context[@&quot;testMethod&quot;] = ^() { dispatch_async(dispatch_get_main_queue(), ^{ UIAlertView *alert = [[UIAlertView alloc]initWithTitle:@&quot;&quot; message:@&quot;js调用方法&quot; delegate:nil cancelButtonTitle:@&quot;取消&quot; otherButtonTitles:nil, nil]; [alert show]; }); }; 方法三：桥接机制 OC和JS交互的桥接机制，主要包含3个类，JS端window.WebViewJavascriptBridge，OC端WebViewJavascriptBridge和WebViewJavascriptBridgeBase。 桥接类支持JS调用OC方法，OC调用JS方法。JS调用OC通过重定向url并取handlerName来调用，OC调用JS通过stringByEvaluatingJavaScriptFromString调用。 8.网络5层模型是哪5层？应用层、传输层、网络层、数据链路层、物理层 9.把t1表中 name 为 mike 的记录中 status 值改为11update t1 set status = 1 where name = mike 10.常用的 Linux 命令。cd 进入指定的目录 cd .. 返回上一级目录 ls 查看当前目录下的所有的目录与文件名 touch filename 表示创建一个文件 mkdir dirname 表示创建一个目录 rm filename 表示删除一个文件 rm -rf dirname 表示删除该目录及其所有的子级目录一起删掉 ctrl+c 强制终止，不会终止进程 sudo 以管理员身份运行上一个命令 :q 退出 :q! 强制退出 :wq 保存并退出 11.用过的包/库管理工具。CocoaPods 2. 一面1、说一下你觉得项目中遇到了什么印象深刻的问题，你是怎么解决的？2、大学里学了哪些课？信息管理与信息系统专业是哪个学院的？3、项目里的网络请求用到了网络5层模型的哪些，TCP/IP 属于哪一层？HTTP 呢？TCP/IP属于传输层 HTTP属于应用层 4、你觉得自己是什么级别的？优势和不足主要是哪方面？5、GCD 平时项目里怎么用的？dispatch_get_mainQueue：获取主线程 dispatch_sync：同步操作 dispatch_group：线程同步 dispatch_barrier：多读单写 dispatch_semaphore：加锁，控制并发数 dispatch_once：只执行一次 dispatch_after：延时执行 6、为什么操作 UI 需要在主线程？因为UIKit不是线程安全的。如果不在主线程中操作UI，可能会造成如下的情况：（1）两个线程同时设置同一个背景图片，那么很有可能因为当前图片被释放了两次而导致应用崩溃。（2）两个线程同时设置同一个UIView的背景颜色，那么很有可能渲染显示的是颜色A，而此时在UIView逻辑树上的背景颜色属性为B。（3）两个线程同时操作view的树形结构：在线程A中for循环遍历并操作当前View的所有subView，然后此时线程B中将某个subView直接删除，这就导致了错乱还可能导致应用崩溃。虽然，iOS4之后苹果将大部分绘图的方法和诸如 UIColor 和 UIFont 这样的类改写为了线程安全可用，但是仍然强烈建议将UI操作保证在主线程中执行。 7、哪些是你独立开发的项目？8、问了一下上家公司的情况9、之后有什么打算？10、上家薪资多少？你还有啥想问的吗？3. 二面1、自定义封装控件需要注意什么？有什么规范？ 头文件尽量不要过多引入其他的类,解耦合 如果使用了第三方框架, 不要在头文件引入改类 切记, 不要暴露第三方组件的任何属性,枚举等等 定义该类的常量,方便修改 尽量不要引入其他项目中的类,除了一些必要的分类,业务类尽量不要引入 Frame布局 使用分类 UIView+Helper 尽量不要暴露成员变量或者属性,除非有必要, 其余情况最好提供接口进行操作. 注意属性的可读。 封装的工具类 注意如果是分类可以实现的尽量迁移到分类中, 并且命名 最好以dd_ 开头, 例如-(void)dd_layoutWithDirection:(DDImageDirection)imageDirection ,之所以这样是因为,OC没有命名空间,后加载的分类可以覆盖掉前面的同名方法. 而且一旦和系统方法重名将造成巨大的bug 注意 驼峰命名原则,类,协议,代理属性，命名首字母大写,最好添加DD类前缀 2、说一下你了解的设计模式。设计模式的六大原则1、开闭原则（Open Close Principle） 开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。 2、里氏代换原则（Liskov Substitution Principle） 里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。 3、依赖倒转原则（Dependence Inversion Principle） 这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。 4、接口隔离原则（Interface Segregation Principle） 这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。 5、迪米特法则，又称最少知道原则（Demeter Principle） 最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。 6、合成复用原则（Composite Reuse Principle） 合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。 设计模式装饰模式、工厂模式、单例模式、观察者模式、备忘录模式。 3、数据库怎么优化？我说数据量大的话加索引提升查询效率。问其他优化呢？比如数据库大小有没有做过优化？（1）根据服务层面：配置mysql性能优化参数； （2）从系统层面增强mysql的性能：优化数据表结构、字段类型、字段索引、分表，分库、读写分离等等。 （3）从数据库层面增强性能：优化SQL语句，合理使用字段索引。 （4）从代码层面增强性能：使用缓存和NoSQL数据库方式存储，如MongoDB/Memcached/Redis来缓解高并发下数据库查询的压力。 （5）减少数据库操作次数，尽量使用数据库访问驱动的批处理方法。 （6）不常使用的数据迁移备份，避免每次都在海量数据中去检索。 （7）提升数据库服务器硬件配置，或者搭建数据库集群。 （8）编程手段防止SQL注入：使用JDBC PreparedStatement按位插入或查询；正则表达式过滤（非法字符串过滤）； 4、内存优化是怎么做的？什么情况会发生内存泄漏？ 减少内存泄漏。 降低内存使用峰值。 懒加载。 灵活运用图片和文件加载。 拉长文件处理机制，逐步处理文件。 5、App 启动时间优化？ 将一些耗时操作延迟执行。比如SDK的初始化，界面的创建。 不能延迟执行的，尽量放到后台执行。比如数据读取，原始 JSON 数据转对象，日志发送。 减少动态库、合并动态库，定期清理不必要的动态库。 减少类、分类的数量，合并Category和功能类似的类。删除不必要的方法和类、分类。 将不必须在+load中做的事延时到+initialize中。 6、视图做过哪些优化，我提了 TableView。那就以 TableView 说一下优化了哪些方面？ cell复用，header、footer复用。 尽量把view设置不透明。 减少视图的层级。 尽量避免调整视图层次、添加和移除视图。 合理选择加载图片的方式，UIImage imageNamed: ImageAssets 用于多个地方重复使用，UIImage imageWithContentsOfFile 一般用在图片数据很大，一般不需要多次使用的情况。 图片大小最好和UIImageView的大小相同。 不要阻塞主线程，耗时操作放在子线程进行。 懒加载。 缓存，缓存图片SDWebImage，缓存行高，NSCache缓存。 复用高开销对象NSDateFormatter和NSCalendar。 减少离屏渲染，优化圆角、阴影。 使用正确的数据存储。 7、AFNetworking 内部是怎么样的一个过程？8、你还有什么想问我的？","link":"/滴滴出行面试题及答案/"},{"title":"百川智能","text":"百川智能 一面： 1.SDK体积优化 2.webView白屏 3.线上闪退处理流程 4.Runtime、Runloop应用，结合项目；为什么开启runloop 5.MVC MVVM 项目里具体的用法 算法： 1.单链表中是否存在环？如果存在，返回环的起始节点。解释快慢指针原理。 2.一百盏灯排成一行,从左到右编号1-100,每盏灯都有一根开关,一开始全是灭的,另外有100小孩,第一个把1的倍数的开关拉一下,第二个把凡是2的倍数开关拉一下,这样下去到最后一盏灯,有哪些是亮的？（口述思路） 二面： 1.写一个工具方法：用 OC 或 Swift 实现，查找数组的第 k 个大的元素 要求能在项目里实际使用，可以用三方库。注意边界条件。 2.卡片动态化，怎么避免因为卡片样式等接需求 3.IM列表数据过大的问题 4.删除消息怎么保证多端一致性 5.怎么解决ViewModel过大的问题，MVVM和MVC的核心区别是双向绑定吗？ 6.为什么选择SSE 7.离线包 8.webView cookie 丢失问题 9.RN长列表性能问题 参考答案(GPT) 1.SDK体积优化 2.webView白屏 3.线上闪退处理流程 4.Runtime、Runloop应用，结合项目 算法： 1.单链表中是否存在环？如果存在，返回环的起始节点。解释快慢指针原理。 2.一百盏灯排成一行,从左到右编号1-100,每盏灯都有一根开关,一开始全是灭的,另外有100小孩,第一个把1的倍数的开关拉一下,第二个把凡是2的倍数开关拉一下,这样下去到最后一盏灯,有哪些是亮的？（口述思路） 这个问题可以通过分析开关操作的规律来解决。我们来详细探讨一下每盏灯的状态。 问题分析 一开始，每盏灯都是灭的。 每个小孩操作的是与他们编号相同的倍数的开关。例如，第一个小孩操作的是1、2、3、4、…、100号开关；第二个小孩操作的是2、4、6、8、…、100号开关，依此类推。 观察灯的状态每盏灯的状态取决于被多少个小孩操作。一个灯的状态会在操作次数（开关次数）为奇数时变为亮，为偶数时保持灭。 我们可以发现： 如果灯的编号是 ( n )，那么它会被所有 ( n ) 的因子的小孩操作。比如，灯编号为12的灯会被1、2、3、4、6、12号小孩操作。 因此，每盏灯的状态由它的因子数量决定。如果因子数量是奇数，则灯是亮的。如果因子数量是偶数，则灯是灭的。 因子数量的分析每个正整数 ( n ) 的因子数量通常是偶数，因为因子通常成对出现（比如 ( 1 ) 和 ( n ), ( 2 ) 和 ( n/2 ) 等）。然而，完全平方数（如1, 4, 9, 16, …）的因子数量是奇数，因为一个因子对（如 ( \\sqrt{n} )）会被重复计算一次。 结论 只有完全平方数的因子数量是奇数，因此只有那些灯编号是完全平方数的灯会在最后亮着。 列出完全平方数 ( 1^2 = 1 ) ( 2^2 = 4 ) ( 3^2 = 9 ) ( 4^2 = 16 ) ( 5^2 = 25 ) ( 6^2 = 36 ) ( 7^2 = 49 ) ( 8^2 = 64 ) ( 9^2 = 81 ) ( 10^2 = 100 ) 所以，最后亮着的灯的编号是：1, 4, 9, 16, 25, 36, 49, 64, 81, 100。 二面： 1.写一个工具方法：用 OC 或 Swift 实现，查找数组的第 k 个大的元素 要求能在项目里实际使用，可以用三方库。注意边界条件。 2.卡片动态化，怎么避免因为卡片样式等接需求 3.IM列表数据过大的问题 4.删除消息怎么保证多端一致性 5.怎么解决ViewModel过大的问题，MVVM和MVC的核心区别是双向绑定吗？ 6.为什么选择SSE 相较于其他流式数据传输方式，SSE 的优点包括： 简单实现：SSE 使用标准的 HTTP 协议，易于实现和调试，尤其是对于基本的实时推送需求。 自动重连：SSE 支持自动重连机制，连接丢失后会自动尝试重新建立连接，确保数据传输的可靠性。 单向通信：适用于只需要从服务器到客户端的单向数据流的场景，例如新闻推送或实时更新。 轻量级：SSE 不需要额外的握手或复杂的协议栈，相比 WebSocket，SSE 的实现和维护成本较低。 文本数据：SSE 以 UTF-8 编码的文本格式传输数据，解析起来较为简单。 这些优点使 SSE 在需要简单、可靠的实时数据推送时成为一个合适的选择。 流式数据可以通过多种方式进行传输，具体选择取决于应用场景、性能需求和技术栈。以下是一些常见的流式数据传输方法： 1. WebSocket 描述：WebSocket 是一种在单个 TCP 连接上进行全双工通信的协议。与 HTTP 不同，它允许在客户端和服务器之间进行双向实时数据交换。 适用场景：需要双向实时通信的应用，例如在线游戏、实时聊天、协作工具。 优点：低延迟、双向通信、持久连接。 2. Server-Sent Events (SSE) 描述：SSE 允许服务器通过单向的持久连接向客户端推送实时事件。客户端可以通过 EventSource API 接收这些事件。 适用场景：需要从服务器向客户端推送实时数据的应用，例如实时更新的新闻推送、监控系统。 优点：简单易用、自动重连、支持文本数据。 3. HTTP/2 描述：HTTP/2 是 HTTP 协议的升级版，支持多路复用（multiplexing），允许在单个 TCP 连接上并发传输多个请求和响应。 适用场景：需要高效和快速加载的网页应用、实时更新的内容。 优点：减少延迟、提高传输效率、支持流式数据传输。 4. gRPC 描述：gRPC 是 Google 开发的开源高性能 RPC 框架，支持双向流式通信。基于 HTTP/2，提供了高效的通信机制。 适用场景：微服务架构、需要高效传输和处理大规模数据的系统。 优点：强类型、安全、高性能、支持双向流。 5. MQTT (Message Queuing Telemetry Transport) 描述：MQTT 是一种轻量级的消息传输协议，设计用于低带宽、不稳定的网络环境。支持发布/订阅模型。 适用场景：物联网（IoT）设备通信、低带宽网络中的消息传输。 优点：轻量、可靠、适合低带宽和高延迟的环境。 6. Apache Kafka 描述：Apache Kafka 是一个分布式流媒体平台，用于构建实时数据流应用和数据管道。支持高吞吐量的数据传输。 适用场景：需要处理大量实时数据的应用、数据管道、日志聚合。 优点：高吞吐量、可扩展、持久性、高可靠性。 7. Redis Streams 描述：Redis Streams 是 Redis 的一种数据结构，用于处理流数据。支持持久化、高效的流数据存储和处理。 适用场景：需要高效处理流数据的应用，例如实时数据分析、日志处理。 优点：高性能、简单易用、支持持久化和数据恢复。 8. WebRTC 描述：WebRTC 是一种支持浏览器之间直接进行实时通信的技术，支持视频、音频和数据流。 适用场景：视频会议、实时数据传输、点对点通信。 优点：低延迟、点对点通信、支持多种数据类型。 9. Chunked Transfer Encoding 描述：这是 HTTP/1.1 中的一种传输编码方式，允许服务器分块传输数据，客户端可以在接收数据时开始处理。 适用场景：需要逐步传输大数据的场景。 优点：支持动态生成和传输数据，减少了延迟。 10. Data Streams (File Streams) 描述：通过文件流传输数据，通常用于大文件的逐步传输和处理。 适用场景：大文件传输、流式处理数据。 优点：支持大数据文件的逐步传输、处理。 选择合适的流式数据传输方式需要考虑具体的应用需求、数据量、实时性要求、网络条件等因素。每种技术都有其特定的优点和适用场景。 7.离线包 8.webView cookie 丢失问题 iOS WebView 中的 Cookie 丢失通常可以由以下几个原因引起： App 重新启动：WebView 的 Cookie 存储在内存中，当应用被终止或重启时，这些 Cookie 可能会丢失。 Cookies 设置：iOS 的 WebView 可能会受到应用的 Cookie 设置或隐私策略的影响，特别是在使用 WKWebView 时，它的 Cookie 存储可能与 UIWebView 不同。 共享 Cookie：WKWebView 和 UIWebView 使用不同的 Cookie 存储机制，它们之间的 Cookie 可能无法共享。 域名问题：确保设置和读取 Cookie 的域名一致，跨域请求可能导致 Cookie 丢失。 解决方案： 使用 WKWebView 的 WKWebsiteDataStore： 123let webView = WKWebView(frame: .zero, configuration: WKWebViewConfiguration())let dataStore = WKWebsiteDataStore.default()webView.configuration.websiteDataStore = dataStore 持久化 Cookie： 你可以手动持久化和恢复 Cookie。例如，通过 HTTPCookieStorage 保存 Cookie，然后在应用启动时恢复： 12345678910// Save cookiesif let cookies = HTTPCookieStorage.shared.cookies { UserDefaults.standard.set(cookies.map { NSKeyedArchiver.archivedData(withRootObject: \\$0) }, forKey: \"savedCookies\")}// Load cookiesif let cookieData = UserDefaults.standard.array(forKey: \"savedCookies\") as? [Data] { let cookies = cookieData.compactMap { NSKeyedUnarchiver.unarchiveObject(with: \\$0) as? HTTPCookie } cookies.forEach { HTTPCookieStorage.shared.setCookie(\\$0) }} 确保 WebView 配置正确：确保 WebView 使用的是适当的 WKWebViewConfiguration，并且 Cookie 设置没有被隐私设置或其他配置所干扰。 这些方法可以帮助管理和解决 iOS WebView 中的 Cookie 丢失问题。 https://www.jianshu.com/p/8636ccd3674b 9.RN长列表性能问题","link":"/百川智能/"},{"title":"百度知道面试题","text":"百度知道面试题 一面1.属性关键字，在 ARC、MRC下分别用什么关键字，copy 修饰 NSString，可变字符串用什么修饰？block 用什么修饰？能不能用 strong 修饰？assign 能修饰对象吗？unsafe_unretain 有什么作用？ 2.block，有几种 block，__weak __block，__block 修改局部变量的值原理，只把局部变量变成结构体就可以了吗？ 3.多线程都用过哪些？NSOperation 了解吗？GCD 怎么开一个线程 4.什么是死锁，举例说明为什么会死锁 5.内存都有哪些区域？哪些是在栈上，哪些是在堆上？局部变量存在哪里？ 6.+load 父类、子类调用顺序？分类的 +load 会调用吗？项目里有用到 +load 吗？initialize 7.Category 实现了本类的同名方法，有没有办法来调用本类的方法？ 8.单链表是否有环 9.两个链表是否相交（怎么判断是否相交？怎么找交点） 10.两个字符串的最长相同子串的长度 二面1.较难定位的 Crash 怎么定位？怎么判断是 OOM 导致的 Crash 还是其他导致的 Crach？ 2.Jenkins+Fastlane 实现 CI，自动化的流程除了打包还能做什么？ 3.Flutter 和原生开发你觉得有什么差异 4.HTTPDNS，使用和不使用有什么区别？有什么好处？ 5.通知是同步的还是异步的，异步的通知什么时候会发出去，通知的原理，通知如何存储，多次添加通知，多次移除通知会有问题吗？ 6.屏幕显示的流程，CPU/GPU，离屏渲染是什么？光栅化的过程 7.安装包大小优化做了哪些？段迁移了解吗？ 8.App 启动系统做了哪些事情，怎么优化启动速度 9.tableView 滑动流畅性优化 10.从点击屏幕到响应事件的流程 11.UIView 和 CALayer 的关系，为什么要这么设计 12.autoreleasePool 的原理，设计成双向链表有什么好处 13.最有成就感的项目，组件化的好处 14.如果 Code Review，你会关注哪些东西？ 15.相对其他团队成员的优势 16.分享会怎么做，如果听众有 PM/测试，会怎么分享 17.团队里有成员不是特别优秀，怎么把控进度 18.了解百度的技术职级吗？你觉得自己是T几？ 三面经理 项目中遇到的有挑战的问题 四面HR 五面1.通过什么途径学的包括 Vue 的其他知识？为什么会有前端的需求？ 2.IM 的气泡，点九图有没有使用类库，有没有兼容性问题，项目适配的最低系统版本是多少？ 3.IM 文本高度计算，图文混排怎么计算高度，高度计算有没有遇到什么问题 4.整个 IM 页面的布局，最复杂的 cell 布局 5.收到新消息的处理，怎么处理能够不滚动到页面底部 6.大量图片列表滑动到指定位置，怎么避免出现内存导致的问题，为什么没有落地 7.组件化，什么能拆成组件，你认为组件化做的足够好吗？更好的组件化怎么去做？ 8.你认为 iOS 和其他端有什么不一样，有什么经验可以共用？ 9.未来规划 参考答案一面1.属性关键字，在 ARC、MRC下分别用什么关键字，copy 修饰 NSString，可变字符串用什么修饰？block 用什么修饰？能不能用 strong 修饰？assign 能修饰对象吗？unsafe_unretain 有什么作用？ 2.block，有几种 block，__weak __block，__block 修改局部变量的值原理，只把局部变量变成结构体就可以了吗？ 3.多线程都用过哪些？NSOperation 了解吗？GCD 怎么开一个线程 4.什么是死锁，举例说明为什么会死锁 死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。 四个必要条件 互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。 请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。 不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。 环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。 举例： 123456- (void)viewDidLoad { [super viewDidLoad]; dispatch_sync(dispatch_get_main_queue(), ^{ NSLog(@\"1\"); });} dispatch_sync 同步，阻塞当前线程，即阻塞主线程。block 又在等主线程里的 viewDidLoad 执行完，从而形成了主线程等待主线程，造成死锁。 参考链接：百度百科-死锁 5.内存都有哪些区域？哪些是在栈上，哪些是在堆上？局部变量存在哪里？ 代码段 数据段 栈 堆 内核区 栈区：局部变量和实参 堆区：OC 中使用 new 方法创建的对象 6.+load 父类、子类调用顺序？分类的 +load 会调用吗？项目里有用到 +load 吗？initialize先调用父类，后调用子类，再调用分类。 +load 调用顺序 1.先调用类的 +load 按照编译先后顺序调用（先编译，先调用） 调用子类的 +load 之前会先调用父类的 +load 2.再调用分类的 +load 按照编译先后顺序调用（先编译，先调用） +initialize方法会在类第一次接收到消息时调用。+initialize 调用顺序： 先调用父类的+initialize，再调用子类的+initialize (先初始化父类，再初始化子类，每个类只会初始化1次) 7.Category 实现了本类的同名方法，有没有办法来调用本类的方法？Category 实现了本类的同名方法，会调用 Category 的同名方法。 8.单链表是否有环123456789101112131415function hasCycle( head ) { if (head == null) { return false; } let slow = head; let fast = head; while (fast.next &amp;&amp; fast.next.next) { slow = slow.next; fast = fast.next.next; if (slow == fast) { return true; } } return false;} 9.两个链表是否相交（怎么判断是否相交？怎么找交点）1234567891011121314151617function FindFirstCommonNode(pHead1, pHead2){ let mySet = new Set(); let p1 = pHead1; while (p1) { mySet.add(p1); p1 = p1.next; } let p2 = pHead2; while (p2) { if (mySet.has(p2)) { return p2; } p2 = p2.next; } return null;} 10.两个字符串的最长相同子串的长度题目链接：NC127 最长公共子串 123456789101112131415function LCS( str1 , str2 ) { if (str1.length &gt; str2.length) { [str1, str2] = [str2, str1]; } let res = \"\"; let len = 0; for (let i = 0; i &lt; str1.length; i++) { let temp = str1.slice(i-len,i+1); if (str2.indexOf(temp) !== -1) { res = temp; len++; } } return res;} 二面1.较难定位的 Crash 怎么定位？怎么判断是 OOM 导致的 Crash 还是其他导致的 Crach？ 2.Jenkins+Fastlane 实现 CI，自动化的流程除了打包还能做什么？ 3.Flutter 和原生开发你觉得有什么差异 4.HTTPDNS，使用和不使用有什么区别？有什么好处？ 5.通知是同步的还是异步的，异步的通知什么时候会发出去，通知的原理，通知如何存储，多次添加通知，多次移除通知会有问题吗？ 参考链接：iOS-通知中心原理 6.屏幕显示的流程，CPU/GPU，离屏渲染是什么？光栅化的过程 7.安装包大小优化做了哪些？段迁移了解吗？ 8.App 启动系统做了哪些事情，怎么优化启动速度 9.tableView 滑动流畅性优化 10.从点击屏幕到响应事件的流程 11.UIView 和 CALayer 的关系，为什么要这么设计 12.autoreleasePool 的原理，设计成双向链表有什么好处 13.最有成就感的项目，组件化的好处 14.如果 Code Review，你会关注哪些东西？ 15.相对其他团队成员的优势 16.分享会怎么做，如果听众有 PM/测试，会怎么分享 17.团队里有成员不是特别优秀，怎么把控进度 18.了解百度的技术职级吗？你觉得自己是T几？","link":"/百度知道面试题/"},{"title":"美团优选面试题及答案","text":"美团优选面试题 技术栈是怎么选择的？为什么选择Flutter，没有选择RN Flutter 与 React Native 的对比分析 1.链表环的入口结点（限制15分钟）算法1：遍历链表，使用Set去存一下 1234567891011function detectCycle( head ) { const visited = new Set(); while (head != null) { if (visited.has(head)) { return head; } visited.add(head); head = head.next; } return null;} 算法2：快慢指针 1234567891011121314151617function detectCycle( head ) { if (!head) return null; let slow = head, fast = head; while(fast.next &amp;&amp; fast.next.next) { fast = fast.next.next slow = slow.next if (slow == fast) { var a = head; while (slow != a) { a = a.next slow = slow.next } return a; } } return null;} 2.首页的轮播图，滑动主区域 timer会不会停止？Timer会停止。因为滑动时Runloop的mode由原来的DefaultMode切换到了UITrackingRunLoopMode。同一时间只能有一种mode。 解决方法其一是将timer加入到NSRunloopCommonModes中。其二是将timer放到另一个线程中，然后开启另一个线程的runloop，这样可以保证与主线程互不干扰，而现在主线程正在处理页面滑动。示例代码如下： 1234567// 方法1[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];// 方法2dispatch_async(dispatch_get_global_queue(0, 0), ^{timer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(repeat:) userInfo:nil repeats:true];[[NSRunLoop currentRunLoop] run];}); 3.滑动屏幕，从响应者的角度和手势的角度来分析系统做了什么事情从手指触摸屏幕，触摸事件的传递大概经历了3个阶段，系统响应阶段–&gt;SpringBoard.app处理阶段–&gt;前台App处理阶段，大致的流程如下图： 起始阶段 cpu处于睡眠阶段，等待事件发生 手指触摸屏幕 系统响应阶段 屏幕感应到触摸事件，并将感应到的事件传递给IOKit(用来操作硬件和驱动的框架) IOKit.framework封装整个触摸事件为IOHIDEvent对象，直接通过mach port(Mach属于硬件层，仅提供了诸如处理器调度、IPC进程通信等非常少量的基础服务。)转发给SpringBoard.app。 SpringBoard.app处理阶段 SpringBoard.app的主线程Runloop收到IOKit.framework转发来的消息苏醒，并触发对应mach port的Source1回调__IOHIDEventSystemClientQueueCallback()。 如果SpringBoard.app监测到有App在前台(记为xxx.app)，SpringBoard.app再通过mach port转发给xxx.app，如果SpringBoard.app监测到前台没有App运行，则SpringBoard.app进入App内部响应阶段，触发自身主线程runloop的Source0时间源的回调。 SpringBoard.app是一个系统进程，可以理解为桌面系统，可以统一管理和分发系统接收到的触摸事件。 App内部响应阶段 前台App主线程Runloop收到SpringBoard.app转发来的消息而苏醒，并触发对应mach port的Source1回调__IOHIDEventSystemClientQueueCallback()。 Source1回调内部，触发Source0回调__UIApplicationHandleEventQueue() Source0回调内部，封装IOHIDEvent为UIEvent。 Source0回调内部，调用UIApplication的sendEvent:方法，将UIEvent传给UIWindow，接下来就是寻找最佳响应者的过程，也就是命中测试hit-testing。 寻找到最佳响应者后，接下来就是事件在响应链中的传递和响应了。需要注意的是，事件除了可以被响应者处理之外，还有可能被手势识别器或者target-action捕捉并处理，这涉及到一个优先级的问题。如果触摸事件在响应链中没有找到能够响应该事件的对象，最终将被释放。 事件被处理或者释放之后，runloop如果没有其他事件进行处理，将会再次进入休眠状态。 寻找事件的最佳响应者(Hit-Testing)能够响应触摸事件的例如UIView，UIButton，UIViewController，UIApplication，Appdelegate等都继承自UIResponder类，一个页面上通常会有许许多多个这种类型的对象，都可以对点击事件作出响应。为了避免冲突，这就需要有一个先后顺序，也就是响应的优先级。Hit-Testing的目的就是找到具有最高优先级的响应对象。寻找的具体流程如下： UIApplication首先将事件队列中的事件取出，传递给窗口对象。如果有多个窗口，则优先询问windows数组的最后一个窗口。 如果窗口不能响应事件，则将事件传递给倒数第二个窗口，以此类推。如果窗口能够响应事件，则再依次询问该窗口的子视图。 重复步骤2。 若视图的所有子视图均不是最佳响应者，则自身就是最合适的响应者。另外需要注意的是，一下几种状态的视图无法响应事件： 不允许交互的视图：userInteractionEnabled = NO 隐藏的视图：hidden = YES 透明度alpha&lt;0.01的视图 怎么样验证一下上面所说的Hit-Testing的顺序呢，看一下UIView的API，里面会有一个hitTest：withEvent：方法，这个方法的主要作用就是查询并返回事件在当前视图中的响应者，每个被询问到的视图对象都会调用这个方法来返回当前视图层的响应者。 如果当前视图无法响应事件，则返回nil。 如果当前视图可以响应事件，但子视图不能响应事件，则返回自身作为当前视图的响应者。 如果当前视图可以响应事件，同时有子视图可以响应事件，则返回该子视图作为当前视图的响应者。 参考链接：iOS触摸事件处理 扩展阅读：UIButton在执行动画的时候,点击事件不响应的解决办法 4.网络请求回来后，回到主线程刷新UI，为什么有时候会延迟？主线程的RunLoop可能当时在处理的任务比较重，需要执行完后再执行刷新UI操作。 5.performSelector了解吗？performSelector:afterDelay:怎么确保执行的线程不被销毁。[self performSelector:@selector(test) withObject:nil afterDelay:.0]实际在runloop里面，是一个定时器，但是因为在子线程，runloop是默认没有开启的。 performSelector:afterDelay:之后开启runloop，即[[NSRunLoop currentRunLoop] run];。 port的生命周期结束，runloop也没了，那怎么保证runloop没销毁？ 在子线程调用方法前去开启Runloop。 6.谈谈autorelease和autoreleasepoolautorelease的基本用法 1) 会将对象放到一个自动释放池中 2) 当自动释放池被销毁时，会对池子里面的所有对象做一次release操作 3) 会返回对象本身 4) 调用完autorelease方法后，对象的计数器不变 autorelease的具体使用方法 生成并持有NSAutoreleasePool对象 调用已分配对象的autorelease实例方法 销毁NSAutoreleasePool对象 NSAutoreleasePool对象生存周期相当于C语言的局部变量作用域，对所有调用过autorelease的实例方法的对象，在销毁NSAutoreleasePool对象时，都将调用release实例方法，即实例对象调用release方法。 当对象调用了autorelease方法是实现实际大致可以理解为是调用的NSAutoreleasePool调用了类方法addObject 1234- (void)autorelease { [NSAutoreleasePool addObject: self];} AutoreleasePoolApp启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是_wrapRunLoopWithAutoreleasePoolHandler()。 第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。 第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush()释放旧的池并创建新池； Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。 7.student类在读书方法里加代码，不改变原方法可以使用 Runtime 或者子类。 iOS系统中有没有用类似的方法实现？KVO 8.KVO实现原理，KVO打印实例对象的class为什么能够做到还是原本类。1) 利用RuntimeAPI动态生成一个子类，并且让instance对象的isa指向这个全新的子类2) 当修改instance对象的属性时，会调用Foundation的_NSSetXXXValueAndNotify函数 1234willChangeValueForKey:父类原来的setterdidChangeValueForKey:内部会触发监听器（Oberser）的监听方法( observeValueForKeyPath:ofObject:change:context:） 注意事项：需要调用set方法触发KVO 实现了class方法，返回了父类。 9.http get和post区别Get是安全的、幂等的、可缓存的、Get参数一般拼接在url的query参数里，有长度限制。 Post是不安全的、非幂等的、不可缓存的，Post的参数一般放在请求体里，相对安全。 https的过程？ 一个HTTPS请求实际上包含了两次HTTP传输： 1）客户端发起一个http请求，连接到服务器的443端口。 2）服务端把自己的信息以数字证书的形式返回给客户端（证书内容有密钥公钥，网站地址，证书颁发机构，失效日期等）。证书中有一个公钥来加密信息，私钥由服务器持有。 3）验证证书的合法性 客户端收到服务器的响应后会先验证证书的合法性（证书中包含的地址与正在访问的地址是否一致，证书是否过期）。 4）生成随机密码（RSA签名） 如果验证通过，或用户接受了不受信任的证书，浏览器就会生成一个随机的对称密钥（session key）并用公钥加密，让服务端用私钥解密，解密后就用这个对称密钥进行传输了，并且能够说明服务端确实是私钥的持有者。 5）生成对称加密算法 验证完服务端身份后，客户端生成一个对称加密的算法和对应密钥，以公钥加密之后发送给服务端。此时被黑客截获也没用，因为只有服务端的私钥才可以对其进行解密。之后客户端与服务端可以用这个对称加密算法来加密和解密通信内容了。 6）客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器。 7）服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。 8）然后服务器将加密后的密文发送给客户端。 9）客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成。 https是绝对的安全吗？怎么保证安全性？不是，可以被抓包。 抓包的原理？Charles作用其实相当于拦截器，当客户端和服务器通信时，Charles其实会先接收到服务器的证书，但是它会自己生成一个证书发送给客户端(不管是Web端或App应用)，也就是说它不仅仅是拦截，甚至还可以修改。 由于Charles更改了证书，所以如果你是使用的Web浏览器，需要导入相应的Charles证书，否则校验不通过会给出安全警告，必须安装Charles的证书后才能进行正常访问。 1) Charles拦截客户端的请求。 2) 服务器向“客户端”（实际上是Charles）返回服务器的CA证书 3) Charles拦截服务器的响应，获取服务器证书公钥，然后自己制作一张证书，将服务器证书替换后发送给客户端。（这一步，Charles拿到了服务器证书的公钥） 4) 客户端接收到“服务器”（实际上是Charles）的证书后，生成一个对称密钥，用Charles的公钥加密，发送给“服务器”（Charles） 5) Charles拦截客户端的响应，用自己的私钥解密对称密钥，然后用服务器证书公钥加密，发送给服务器。（这一步，Charles拿到了对称密钥） 6) 服务器用自己的私钥解密对称密钥，向“客户端”（Charles）发送响应 7) Charles拦截服务器的响应，替换成自己的证书后发送给客户端 至此，连接建立，Charles拿到了服务器证书的公钥和客户端与服务器协商的对称密钥，之后就可以解密或者修改加密的报文了。 Charles作为“中间人代理”，拿到了服务器证书公钥和 HTTPS 连接的对称密钥，前提是客户端选择信任并安装Charles的CA证书，否则客户端就会“报警”并中止连接。这样看来，HTTPS还是很安全的。 怎么避免被抓包？判断是否有代理，如果有， 1）可以取消本次的网络请求。 2）可以取消掉代理，直连服务端。 校验证书、不使用http，使用更底层的协议。","link":"/美团优选面试题及答案/"},{"title":"豆瓣面试题","text":"豆瓣面试题 1.是在大学里学的 iOS 吗？怎么学的 iOS？2.判断2个单链表是否交叉,实现代码,如果有交叉找出交叉点。方法一：哈希表法 遍历链表 A 并将每个结点的地址/引用存储在哈希表中。然后检查链表 B 中的每一个结点 bi是否在哈希表中。若在，则 bi为相交结点。 12345678910111213141516var getIntersectionNode = function(headA, headB) { let mySet = new Set(); let curr = headA; while (curr != null) { mySet.add(curr); curr = curr.next; } curr = headB; while (curr != null) { if (mySet.has(curr)) { return curr; } curr = curr.next; } return null;}; 方法二：双指针法 1234567891011var getIntersectionNode = function(headA, headB) { if (headA == null || headB == null) { return null; } let pA = headA, pB = headB; while (pA != pB) { pA = pA == null ? headB : pA.next; pB = pB == null ? headA : pB.next; } return pA;}; 3.说一下 @property 属性修饰符，block 为什么用 copy ？weak 的实现原理？atomic 怎么保证安全？怎么解决读写安全？@property 什么都不写 基本数据类型默认修饰符是 atomic, readWrite, assign 对象类型默认修饰符是 atomic, readWrite, strong block 为什么用 copy？ 如果是全局静态 block 的话，它直到程序结束的时候，才会被被释放。但是我们实际操作中基本上不会使用到不访问外部变量的 block。 如果是保存在栈中的 block，它会随着函数调用结束被销毁。从而导致我们在执行一个包含 block 的函数之后，就无法再访问这个 block。因为（函数结束，函数栈就销毁了，存在函数里面的 block 也就没有了），我们再使用 block 时，就会产生空指针异常。 如果是堆中的 block，也就是 copy 修饰的 block。他的生命周期就是随着对象的销毁而结束的。只要对象不销毁，我们就可以调用的到在堆中的 block。 这就是为什么我们要用 copy 来修饰 block。因为不用 copy 修饰的访问外部变量的 block，只在他所在的函数被调用的那一瞬间可以使用。之后就消失了。 weak 的实现原理 参考链接：iOS 底层解析weak的实现原理 atomic 怎么保证安全？ 属性声明为atomic时，在该属性在调用getter和setter方法时，会加上同步锁，即在属性在调用getter和setter方法时，保证同一时刻只能有一个线程调用属性的读/写方法。保证了读和写的过程是可靠的。但并不能保证数据一定是可靠的。 怎么解决读写安全？ dispatch_barrier_async pthread_rwlock：读写锁 4.OSSPinLock 为什么不用了？系统维护了 5 个不同的线程优先级/QoS: background，utility，default，user-initiated，user-interactive。高优先级线程始终会在低优先级线程前执行，一个线程不会受到比它更低优先级线程的干扰。这种线程调度算法会产生潜在的优先级反转问题，从而破坏了 spin lock。 具体来说，如果一个低优先级的线程获得锁并访问共享资源，这时一个高优先级的线程也尝试获得这个锁，它会处于 spin lock 的忙等状态从而占用大量 CPU。此时低优先级线程无法与高优先级线程争夺 CPU 时间，从而导致任务迟迟完不成、无法释放 lock。这并不只是理论上的问题，libobjc 已经遇到了很多次这个问题了，于是苹果的工程师停用了 OSSpinLock。 参考链接：不再安全的 OSSpinLock 5.同时请求两张图片，之后合成一张图 dispatch_group 配合 dispatch_semaphore dispatch_group dispatch_enter dispatch_leave dispatch_barrier 还有其他的方式吗？只使用 dispatch_semphore 和 dispatch_async 怎么实现？ 6.Runloop 有哪些使用场景？ 控制线程生命周期，实现常驻线程。 TableView 延迟加载图片。滑动时不调用赋值图片的方法，等滑动完毕切换到 NSDefaultRunLoopMode 时才调用。 1[self.img performSelector:@selector(setImage:) withObject:image afterDelay:0 inModes:[NSDefaultRunLoopMode]]; 解决 NSTimer 在滑动时停止的问题。 监测 RunLoop 的状态监测应用卡顿。 7.子线程怎么销毁？换一种问法，常驻线程怎么销毁？NSPort 的生命周期怎么控制？12345678- (void)_stopThread { self.isRun = NO; // 停止当前线程的Runloop CFRunLoopStop(CFRunLoopGetCurrent()); self.innerThread = nil;} 参考链接：iOS RunLoop 常驻线程简化实现 8.说一下响应者链。有三个视图 A、B、C 依次被添加到 self.view 上，frame 相同，复写 C 的 pointInSide 方法缩小范围，点击 C 的边缘 C 会响应吗？C 不响应的话，B 会响应吗？点击 C 的边缘 C 不会响应，B 会响应。 9.组件是怎么拆分的？组件化是怎么传值的？组件的注册是写在哪里的？写在 +load 会不会有性能问题？怎么解决？参考链接：iOS组件化方案 10.了解 HTTPDNS 吗？询问的操作是谁去问？本层-&gt;上层-&gt;上上层 使用HTTP（HTTPS）协议绕过运营商的 Local DNS，避免域名劫持，也更准确地判断客户端地区和运营商，得到更精准的解析结果； HTTPDNS 能够直接得到客户端的出口网关 IP，从而更准确地判断客户端地区和运营商，得到更精准的解析结果； 参考链接：HTTPDNS 11.性能优化，tableView 怎么缓存行高？高度存在哪儿？key 是什么？横竖屏怎么缓存行高？一个页面大概率不会横屏，缓存横竖屏两份行高是不是有些浪费，怎么去处理行高？tableView 怎么控制缓存数量，比如最大1000条数据的缓存量。提前计算好cell的高度,缓存在相应的数据源模型中。cellHeight 12.加载大图，地图这种大图怎么加载优化？系统 API 的原理是什么？ 分片比例裁剪方式。参考苹果给出的 demo,利用 CGImageCreateWithImageInRect 截取原图对应位置的内容,再通过 CGContextDrawImage 渲染到指定位置; 利用 CATiledLayer 层级的API,自动进行绘制; 参考链接：iOS 大图显示解决办法 13.项目怎么分工的？你负责什么？有没有什么值得说的点？H5 与原生交互有什么经验分享吗？怎么给 webView 加载的页面发的网络请求统一加上 header？14.AFN 早期版本为什么要使用常驻线程？怎么统一设置 header？1[requestSerializer setValue:value forHTTPHeaderField:httpHeaderField]; 15.RN 和 Flutter 的底层实现有什么区别？在 Android 和 iOS 上，默认情况下 Flutter 和 React Native 都需要一个原生平台的 Activity / ViewController 支持，且在原生层面属于一个“单页面应用”，而它们之间最大的不同点其实在于 UI 构建 ： React Native ： React Native 是一套 UI 框架，默认情况下 React Native 会在 Activity 下加载 JS 文件，然后运行在 JavaScriptCore 中解析 Bundle 文件布局，最终堆叠出一系列的原生控件进行渲染。 简单来说就是 通过写 JS 代码配置页面布局，然后 React Native 最终会解析渲染成原生控件，如 &lt;View&gt; 标签对应 ViewGroup/UIView ，&lt;ScrollView&gt; 标签对应 ScrollView/UIScrollView ，&lt;Image&gt; 标签对应 ImageView/UIImageView 等。 Flutter ： 如果说 React Native 是为开发者做了平台兼容，那 Flutter 则更像是为开发者屏蔽平台的概念。 Flutter 中绝大部分的 Widget 都与平台无关， 开发者基于 Framework 开发 App ，而 Framework 运行在 Engine 之上，由 Engine 进行适配和跨平台支持。这个跨平台的支持过程，其实就是将 Flutter UI 中的 Widget “数据化” ，然后通过 Engine 上的 Skia 直接绘制到屏幕上 。 参考链接：Flutter 与 React Native 的对比分析 16.平时怎么学习 iOS？上家公司的离职原因，未来规划，有没有要问我的？","link":"/豆瓣面试题/"},{"title":"贝壳","text":"贝壳一面： 1.SDK体积优化，从多大优化到了多大，为什么减少Masony的使用会减少包大小 2.加载速度优化，两套网络请求的问题 3.上传视频需要注意什么？视频很大，分片，内存占用 4.自动释放池，什么时候会加 autorelease，一个方法里，alloc一个对象，这个对象加了autorelease吗？如果这个方法返回了这个对象呢？自动释放池能嵌套吗？ 5.循环引用，block什么时候循环引用，block用到了_xxx成员变量，会循环引用吗？成员变量会编译成什么 self -&gt; 6.NSTimer的循环引用，为什么？ 7.多线程：A/B/C并发，请求完成后执行其他任务 二面： 1.通用化技术提升迭代效率指的什么？卡片等是什么实现的 2.多线程：A -&gt; B C -&gt; D B依赖A、D依赖C，都完成后执行E 3.代理和block怎么选型？ 4.页面传值一对多怎么实现？对象加到数组里，这个对象的引用计数增加了吗？weak呢？ 5.SDWebImage原理，解码是在什么时候做的？一张图片加载到界面的过程，大图加载 6.设计：多个弹窗依次弹出，有优先级 三面： 1.iOS中遇到过的不易解决的问题，怎么解决的？ 2.A -&gt; B -&gt; C 用路由的方式反向传值，什么是路由？什么时候注册？参数是什么类型？ 3.autoreleasePool和Runloop的关系 4.mach-o了解吗？ 参考答案 一面： 1.SDK体积优化，从多大优化到了多大，为什么减少Masony的使用会减少包大小 2.加载速度优化，两套网络请求的问题 3.上传视频需要注意什么？视频很大，分片，内存占用 在iOS开发中，网络请求上传视频是一个常见的需求，尤其是当视频文件较大时，更需要注意一系列的技术细节和优化手段以确保上传过程的稳定性、效率和用户体验。以下是一些关键的注意事项和优化手段： 注意事项 文件大小检测： 在上传前，先检查视频文件的大小，避免上传过大的文件导致内存溢出或上传时间过长。 网络状态检测： 检测用户的网络状态（如Wi-Fi、4G/5G等），根据网络状况调整上传策略，如在网络较差时暂停上传或提示用户。 用户反馈： 提供清晰的上传进度反馈，让用户了解上传的当前状态和预计剩余时间。 权限检查： 确保应用已获取必要的权限，如访问相册或相机权限，以便读取视频文件。 优化手段 视频压缩： 在上传前对视频进行压缩，减小文件大小，从而减少上传时间和占用的网络带宽。可以使用如FFmpeg等库进行视频转码和压缩。 分片上传： 将大视频文件分割成多个较小的片段，并行上传这些片段。这样可以显著提高上传速度，并降低因网络问题导致上传失败的风险。当所有片段都上传完成后，服务器端可以将这些片段合并成完整的视频。 断点续传： 支持断点续传功能，即在网络中断或应用退出等情况下，能在下次上传时从上次中断的地方继续上传，而不是重新开始上传整个视频。 适当设置HTTP头部： 设置合适的Content-Type，并确保HTTP头部中的其他字段（如Content-Length）正确无误。对于分片上传，每个片段请求都应有对应的头部信息。 使用合适的网络库： 利用成熟的网络库（如AFNetworking、URLSession等）来简化网络请求的代码量，并利用这些库提供的优化功能来提高上传效率。 缓存策略： 对于已上传的视频或片段，可以在本地缓存其状态和信息，以便在网络恢复或应用重启时快速恢复上传状态。 后台上传： 利用iOS的后台任务功能，在应用进入后台时继续上传视频，不影响用户的其他操作。 错误处理和重试机制： 实现完善的错误处理逻辑，当上传失败时，根据错误类型进行重试或提示用户。可以设置合理的重试次数和重试间隔。 综上所述，iOS网络请求上传视频时需要注意多个方面，并通过一系列优化手段来提高上传的效率和稳定性。这些优化手段不仅有助于提升用户体验，还能降低因网络问题导致的数据丢失风险。 4.自动释放池，什么时候会加 autorelease，一个方法里，alloc一个对象，这个对象加了autorelease吗？如果这个方法返回了这个对象呢？自动释放池能嵌套吗？ 5.循环引用，block什么时候循环引用，block用到了_xxx成员变量，会循环引用吗？成员变量会编译成什么 self -&gt; 6.NSTimer的循环引用，为什么？ 7.多线程：A/B/C并发，请求完成后执行其他任务 二面： 1.通用化技术提升迭代效率指的什么？卡片等是什么实现的 2.多线程：A -&gt; B C -&gt; D B依赖A、D依赖C，都完成后执行E 3.代理和block怎么选型？ 4.页面传值一对多怎么实现？对象加到数组里，这个对象的引用计数增加了吗？weak呢？ 5.SDWebImage原理，解码是在什么时候做的？一张图片加载到界面的过程，大图加载 6.设计：多个弹窗依次弹出，有优先级 三面： 1.iOS中遇到过的不易解决的问题，怎么解决的？ 2.A -&gt; B -&gt; C 用路由的方式反向传值，什么是路由？什么时候注册？参数是什么类型？ 在iOS应用中通过路由机制进行页面导航和数据传递时，有时需要将数据从一个页面传递回到之前的页面。可以通过闭包（Block）来实现这种反向传值。下面是一个详细的示例，展示了如何通过路由机制进行反向传值。 示例：通过路由进行反向传值假设我们有三个页面：A -&gt; B -&gt; C，并希望在C页面完成某些操作后将数据传回A页面。 1. 定义路由管理器首先，我们需要一个路由管理器来管理导航和数据传递。我们将使用一个单例类Router来实现。 1234567891011121314// Router.h#import &lt;Foundation/Foundation.h&gt;#import &lt;UIKit/UIKit.h&gt;typedef void (^CompletionHandler)(id data);@interface Router : NSObject+ (instancetype)sharedInstance;- (void)registerPath:(NSString *)path forClass:(Class)className;- (void)openPath:(NSString *)path withParams:(NSDictionary *)params completionHandler:(CompletionHandler)completionHandler;@end 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// Router.m#import \"Router.h\"@interface Router ()@property (nonatomic, strong) NSMutableDictionary *routeMap;@end@implementation Router+ (instancetype)sharedInstance { static Router *instance; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ instance = [[Router alloc] init]; }); return instance;}- (instancetype)init { self = [super init]; if (self) { _routeMap = [NSMutableDictionary dictionary]; } return self;}- (void)registerPath:(NSString *)path forClass:(Class)className { self.routeMap[path] = className;}- (void)openPath:(NSString *)path withParams:(NSDictionary *)params completionHandler:(CompletionHandler)completionHandler { Class className = self.routeMap[path]; if (className) { UIViewController *viewController = [[className alloc] init]; if ([viewController isKindOfClass:[UIViewController class]]) { if (completionHandler) { [viewController setValue:completionHandler forKey:@\"completionHandler\"]; } [viewController setValuesForKeysWithDictionary:params]; [[UIApplication sharedApplication].keyWindow.rootViewController presentViewController:viewController animated:YES completion:nil]; } } else { NSLog(@\"No route found for path: %@\", path); }}@end 2. 定义页面C在C页面中定义一个回调Block，用于传递数据。 123456// CViewController.h#import &lt;UIKit/UIKit.h&gt;@interface CViewController : UIViewController@property (nonatomic, copy) void (^completionHandler)(id data);@end 在C页面完成操作时调用回调Block。 12345678910111213141516171819202122232425// CViewController.m#import \"CViewController.h\"@implementation CViewController- (void)viewDidLoad { [super viewDidLoad]; self.view.backgroundColor = [UIColor whiteColor]; UIButton *button = [UIButton buttonWithType:UIButtonTypeSystem]; button.frame = CGRectMake(100, 100, 100, 50); [button setTitle:@\"Send Data\" forState:UIControlStateNormal]; [button addTarget:self action:@selector(sendData) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview:button];}- (void)sendData { NSString *data = @\"Some data from C\"; if (self.completionHandler) { self.completionHandler(data); } [self dismissViewControllerAnimated:YES completion:nil];}@end 3. 注册路由在AppDelegate中注册路由。 123456789101112131415161718// AppDelegate.m#import \"AppDelegate.h\"#import \"Router.h\"#import \"AViewController.h\"#import \"BViewController.h\"#import \"CViewController.h\"- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { [[Router sharedInstance] registerPath:@\"a\" forClass:[AViewController class]]; [[Router sharedInstance] registerPath:@\"b\" forClass:[BViewController class]]; [[Router sharedInstance] registerPath:@\"c\" forClass:[CViewController class]]; self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds]; self.window.rootViewController = [[AViewController alloc] init]; [self.window makeKeyAndVisible]; return YES;} 4. 使用路由在A页面中导航到C页面并处理回调。 12345678910111213141516171819202122232425// AViewController.m#import \"AViewController.h\"#import \"Router.h\"@implementation AViewController- (void)viewDidLoad { [super viewDidLoad]; self.view.backgroundColor = [UIColor whiteColor]; UIButton *button = [UIButton buttonWithType:UIButtonTypeSystem]; button.frame = CGRectMake(100, 100, 100, 50); [button setTitle:@\"Go to C\" forState:UIControlStateNormal]; [button addTarget:self action:@selector(openCViewController) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview:button];}- (void)openCViewController { [[Router sharedInstance] openPath:@\"c\" withParams:@{} completionHandler:^(id data) { NSLog(@\"Received data: %@\", data); // 处理接收到的数据 }];}@end 总结通过以上步骤，你可以实现页面间的数据传递和反向传值。路由管理器负责管理页面的导航和数据传递，页面C通过回调Block将数据传回A页面。这种方法不仅简化了页面间的数据传递，还保持了代码的清晰和可维护性。 3.autoreleasePool和Runloop的关系 4.mach-o了解吗？","link":"/贝壳/"},{"title":"去哪儿网","text":"去哪儿网1.项目 降低三方 App 接入成本怎么做的？ 加载速度优化怎么做的？主要是从业务逻辑纬度处理的？ 异常监控怎么做的？ 动态库版式缩放怎么实现的？ 2.线上闪退捕获怎么做的？有没有捕获不到的异常，watchdog 能捕获吗？APM 性能监控 3.RN 是怎么实现的？跨端还了解哪些？Flutter是怎么实现的，为什么说 Flutter 的性能比 RN 好？ 4.H5 和原生通信有哪些方法？ 5.怎么提升 webView 的加载速度，使其接近原生？大的图片、JS 等端上下载后，怎么交给H5使用 6.小程序是怎么实现的？ 7.前端 JS 的异步是怎么实现的？ 8.项目亮点 参考答案(GPT) 1.项目 降低三方 App 接入成本怎么做的？ 加载速度优化怎么做的？主要是从业务逻辑纬度处理的？ 异常监控怎么做的？ 动态库版式缩放怎么实现的？ 2.线上闪退捕获怎么做的？有没有捕获不到的异常，watchdog能捕获吗？APM 性能监控移动端监控体系之技术原理剖析 iOS Crash 捕获及堆栈符号化思路剖析 知乎-iOS云音乐APM性能监控实践 3.RN 是怎么实现的？跨端还了解哪些？Flutter 是怎么实现的，为什么说 Flutter 的性能比 RN 好？React Native 通过 JavaScript 和原生代码之间的桥接，实现了跨平台的移动应用开发。其核心是通过 Bridge 在 JavaScript 和原生线程之间进行通信，使用 React 构建用户界面，并通过 Yoga 引擎处理布局。这样，开发者可以使用熟悉的 JavaScript 和 React 技术栈来构建高性能的移动应用，同时享受原生性能和体验。 Flutter 通过使用 Dart 语言、Skia 图形引擎和自定义的渲染引擎，实现了跨平台的高性能应用开发。其核心是完全自行绘制界面，不依赖于平台的原生控件，提供了一种一致的开发体验和用户体验。Flutter 的 Widget 系统、渲染树、状态管理和平台通道等机制，使其能够高效地构建复杂的跨平台应用。 Flutter 和 React Native（RN）是两种流行的跨平台移动应用开发框架，各有其优点和缺点。性能是评估这两种框架的一个重要方面。以下是从多个角度对 Flutter 和 React Native 性能的比较： 1. 启动时间 Flutter: Flutter 应用的启动时间通常较快，因为 Flutter 使用了 AOT（Ahead-of-Time）编译，将 Dart 代码编译成了原生 ARM 代码。在启动时，无需进行额外的解释或编译步骤。 React Native: React Native 应用的启动时间可能稍慢一些，因为它依赖于 JavaScriptCore（iOS）或 Hermes 引擎（Android）来解释和执行 JavaScript 代码。尽管 Hermes 引擎在某些情况下可以减少启动时间，但它仍然需要一些初始化步骤。 2. UI 渲染性能 Flutter: Flutter 使用 Skia 图形引擎直接绘制到屏幕上，这使得 Flutter 可以提供非常流畅的 UI 渲染性能。Flutter 的渲染是逐帧进行的，通常可以达到 60fps 或 120fps。 React Native: React Native 依赖于原生平台的控件和组件进行渲染，通过 Bridge 进行 JavaScript 和原生代码的通信。这种桥接机制可能会导致一定的性能瓶颈，特别是在处理复杂动画和大量 UI 更新时。 3. 动画性能 Flutter: Flutter 的动画性能通常非常出色，因为动画是在 Flutter 的渲染引擎中直接处理的，没有额外的通信开销。Flutter 提供了丰富的动画库和工具，使开发者可以轻松创建复杂和流畅的动画。 React Native: React Native 的动画性能在某些情况下可能不如 Flutter，因为动画需要通过 Bridge 进行通信。虽然 React Native 提供了 Animated API 和 Reanimated 库来优化动画性能，但在处理非常复杂的动画时，可能仍然会遇到性能问题。 4. 内存使用 Flutter: Flutter 的内存使用通常较为高效，但由于它将整个 UI 树都保持在内存中，内存占用可能会随着应用复杂度的增加而增加。 React Native: React Native 的内存使用也比较高效，不过由于 JavaScript 运行时和 Bridge 的存在，可能会引入额外的内存开销。 5. 开发体验 Flutter: Flutter 提供了热重载（Hot Reload）功能，使开发者可以快速看到代码修改的效果，极大地提高了开发效率。Flutter 的热重载通常速度非常快，体验流畅。 React Native: React Native 也提供了热重载和快速刷新（Fast Refresh）功能，不过在某些情况下，热重载的速度可能不如 Flutter 快。 6. 跨平台一致性 Flutter: 由于 Flutter 使用了自定义的绘图引擎，它在不同平台上的外观和行为非常一致，开发者可以更加精确地控制 UI 的细节。 React Native: React Native 使用的是平台原生控件，虽然这意味着它在不同平台上能提供更原生的体验，但也可能导致不同平台之间的外观和行为不一致。 总结 Flutter 在 UI 渲染性能、动画性能和跨平台一致性方面通常优于 React Native。其高效的渲染引擎和 AOT 编译使得 Flutter 应用的启动时间和运行性能都非常出色。 React Native 在使用原生控件和访问原生平台功能方面有优势，可以提供更原生的用户体验。不过，由于 JavaScript 和原生代码之间的桥接机制，可能会在某些场景下遇到性能瓶颈。 最终选择哪个框架，取决于具体项目的需求和开发团队的技术栈。如果需要非常高性能、流畅的动画和一致的跨平台体验，Flutter 可能是更好的选择。如果需要更原生的外观和感觉，或者开发团队已经熟悉 JavaScript 和 React 生态系统，React Native 可能更适合。 4.H5 和原生通信有哪些方法？1. 通过 URL SchemesURL Schemes 是一种通过特定 URL 格式触发原生代码的方法。 2. 通过 WKScriptMessageHandlerWKScriptMessageHandler 是 WKWebView 提供的用于接收来自 JavaScript 消息的处理器。 H5 代码1window.webkit.messageHandlers.myHandler.postMessage({key: 'value'}); iOS 代码在 WKWebView 的配置中添加一个脚本消息处理器： 123456789101112131415161718192021222324252627import WebKitclass ViewController: UIViewController, WKScriptMessageHandler { var webView: WKWebView! override func viewDidLoad() { super.viewDidLoad() let config = WKWebViewConfiguration() config.userContentController.add(self, name: \"myHandler\") webView = WKWebView(frame: self.view.frame, configuration: config) self.view.addSubview(webView) if let url = URL(string: \"https://yourwebsite.com\") { webView.load(URLRequest(url: url)) } } func userContentController(_ userContentController: WKUserContentController, didReceive message: WKScriptMessage) { if message.name == \"myHandler\" { if let body = message.body as? [String: Any] { print(\"Message from H5: \\(body)\") } } }} 3. 通过 evaluateJavaScriptiOS 可以通过 evaluateJavaScript 方法执行 H5 页面上的 JavaScript 代码。 iOS 代码1234567webView.evaluateJavaScript(\"javascriptFunctionName('argument')\") { (result, error) in if let error = error { print(\"JavaScript evaluation error: \\(error)\") } else { print(\"JavaScript evaluation result: \\(String(describing: result))\") }} 4. 通过 WebView 的 loadHTMLString 或 load 方法你可以通过 loadHTMLString 或 load 方法将 HTML 内容直接加载到 WebView 中，并在 HTML 中嵌入 JavaScript 代码与原生代码进行通信。 5.怎么提升 webView 的加载速度，使其接近原生？大的图片、js等端上下载后，怎么交给H5使用1. 预加载（Preloading） 提前加载 WebView：在用户访问页面之前，提前初始化和加载 WebView。这样用户点击时，内容已经部分或全部加载完毕。 使用缓存：利用缓存机制来存储常用资源，减少重复加载。 2. 优化资源 减少请求数量：合并 CSS、JavaScript 文件，减少 HTTP 请求次数。 压缩资源：使用 gzip 或 brotli 压缩 HTML、CSS 和 JavaScript 文件。 图片优化：压缩图片，使用适当的图片格式（如 WebP），并考虑使用延迟加载（lazy loading）。 3. 使用 WKWebView 选择 WKWebView：相比 UIWebView，WKWebView 提供了更好的性能和更低的内存占用。确保你的应用使用的是 WKWebView。 4. 加载策略 懒加载：对于不在视口内的内容，使用懒加载技术，只在需要时才加载这些资源。 异步加载：将 JavaScript 脚本放在页面底部或者使用 defer 和 async 属性异步加载脚本，避免阻塞页面渲染。 5. 优化代码 减少 DOM 操作：过多或复杂的 DOM 操作会降低渲染速度，优化前端代码，减少不必要的 DOM 操作。 避免重排（Reflow）和重绘（Repaint）：尽量减少和优化需要重排和重绘的操作。 6. 使用本地资源 本地化资源：将常用的 CSS 和 JavaScript 文件内嵌到应用中，避免从远程服务器加载。 Service Worker：虽然 iOS 对 Service Worker 的支持不如 Android，但可以利用它在支持的场景下缓存资源，提高加载速度。 7. 网络优化 CDN：使用内容分发网络（CDN）来加速资源加载。 HTTP/2：使用 HTTP/2 协议来降低延迟和提升加载速度。 8. 确保设备性能 内存优化：确保 WebView 不会消耗过多内存，避免在低内存设备上崩溃或变慢。 性能监控：定期监控应用的性能，并根据实际数据进行优化。 9. 使用 SPA (Single Page Application) 单页应用：如果你的应用逻辑允许，考虑将 Web 应用改为单页应用（SPA），减少页面跳转时间，并通过前端路由管理页面状态。 10. 其他优化 Lazy Load：对图片和其他资源使用懒加载技术。 减少动画和特效：过多的动画和特效会增加 CPU 和 GPU 的负担，尽量减少或优化这些效果。 通过综合以上方法，逐步优化 WebView 的加载速度，可以显著提升用户体验，使其接近原生应用的性能。 1. 预加载并注入资源在 WKWebView 初始化时，可以预先加载本地下载的资源，并通过 JavaScript 注入到网页中。 示例代码：1234567891011121314151617181920212223242526import WebKitclass ViewController: UIViewController, WKNavigationDelegate { var webView: WKWebView! override func viewDidLoad() { super.viewDidLoad() let webConfiguration = WKWebViewConfiguration() webView = WKWebView(frame: .zero, configuration: webConfiguration) webView.navigationDelegate = self view.addSubview(webView) // 加载本地 HTML 文件 if let localHTMLUrl = Bundle.main.url(forResource: \"index\", withExtension: \"html\") { webView.loadFileURL(localHTMLUrl, allowingReadAccessTo: localHTMLUrl.deletingLastPathComponent()) } // 注入本地 JavaScript 文件 if let localJSUrl = Bundle.main.url(forResource: \"script\", withExtension: \"js\"), let localJSContent = try? String(contentsOf: localJSUrl) { let userScript = WKUserScript(source: localJSContent, injectionTime: .atDocumentStart, forMainFrameOnly: true) webView.configuration.userContentController.addUserScript(userScript) } }} 2. 使用自定义 URL Scheme通过自定义 URL Scheme，将本地资源提供给 WebView。 示例代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import WebKitclass ViewController: UIViewController, WKNavigationDelegate { var webView: WKWebView! override func viewDidLoad() { super.viewDidLoad() let webConfiguration = WKWebViewConfiguration() webView = WKWebView(frame: .zero, configuration: webConfiguration) webView.navigationDelegate = self webView.uiDelegate = self view.addSubview(webView) if let localHTMLUrl = Bundle.main.url(forResource: \"index\", withExtension: \"html\") { webView.loadFileURL(localHTMLUrl, allowingReadAccessTo: localHTMLUrl.deletingLastPathComponent()) } let schemeHandler = LocalSchemeHandler() webConfiguration.setURLSchemeHandler(schemeHandler, forURLScheme: \"myapp\") if let url = URL(string: \"myapp://localResource/script.js\") { webView.load(URLRequest(url: url)) } }}class LocalSchemeHandler: NSObject, WKURLSchemeHandler { func webView(_ webView: WKWebView, start urlSchemeTask: WKURLSchemeTask) { if let url = urlSchemeTask.request.url, url.scheme == \"myapp\" { if url.path == \"/localResource/script.js\", let filePath = Bundle.main.path(forResource: \"script\", ofType: \"js\") { let data = try? Data(contentsOf: URL(fileURLWithPath: filePath)) let response = URLResponse(url: url, mimeType: \"application/javascript\", expectedContentLength: data?.count ?? 0, textEncodingName: nil) urlSchemeTask.didReceive(response) if let data = data { urlSchemeTask.didReceive(data) } urlSchemeTask.didFinish() } } } func webView(_ webView: WKWebView, stop urlSchemeTask: WKURLSchemeTask) { // Handle task stopping if needed }} 3. 使用 Base64 编码将本地资源转换成 Base64 编码，然后通过 JavaScript 将其注入到网页中。 示例代码：12345678910111213141516171819202122232425262728import WebKitclass ViewController: UIViewController { var webView: WKWebView! override func viewDidLoad() { super.viewDidLoad() webView = WKWebView(frame: self.view.frame) self.view.addSubview(webView) if let localHTMLUrl = Bundle.main.url(forResource: \"index\", withExtension: \"html\") { webView.loadFileURL(localHTMLUrl, allowingReadAccessTo: localHTMLUrl.deletingLastPathComponent()) } if let imagePath = Bundle.main.path(forResource: \"image\", ofType: \"png\"), let imageData = try? Data(contentsOf: URL(fileURLWithPath: imagePath)) { let base64String = imageData.base64EncodedString() let jsCode = \"\"\" var img = document.createElement('img'); img.src = 'data:image/png;base64,\\(base64String)'; document.body.appendChild(img); \"\"\" webView.evaluateJavaScript(jsCode, completionHandler: nil) } }} 4. 使用本地服务器在应用内启动一个本地服务器（如 GCDWebServer），然后通过 HTTP 请求获取本地资源。 示例代码：1234567891011121314151617181920212223242526import WebKitimport GCDWebServerclass ViewController: UIViewController { var webView: WKWebView! var webServer: GCDWebServer! override func viewDidLoad() { super.viewDidLoad() webServer = GCDWebServer() // 添加处理器来提供本地资源 webServer.addGETHandler(forBasePath: \"/\", directoryPath: Bundle.main.resourcePath!, indexFilename: nil, cacheAge: 3600, allowRangeRequests: true) // 启动本地服务器 webServer.start(withPort: 8080, bonjourName: \"GCD Web Server\") webView = WKWebView(frame: self.view.frame) self.view.addSubview(webView) if let url = URL(string: \"http://localhost:8080/index.html\") { webView.load(URLRequest(url: url)) } }} 通过上述方法，可以将本地下载的资源交给 H5 使用，以提升 WebView 的加载速度和用户体验。选择具体方案时，可以根据实际需求、项目复杂度和维护成本进行权衡。 6.小程序是怎么实现的？7.前端 JS 的异步是怎么实现的？JavaScript 的异步是通过事件循环（Event Loop）、回调函数、任务队列（Task Queue）和微任务队列（Microtask Queue）等机制共同实现的。下面我们详细讨论这些概念及其工作原理。 事件循环（Event Loop）JavaScript 运行时环境（如浏览器或 Node.js）包含一个事件循环，它是处理异步操作的核心。事件循环负责监控调用栈和任务队列，并根据情况将任务队列中的任务推入调用栈执行。 调用栈（Call Stack）调用栈用于追踪正在执行的函数，JavaScript 是单线程的，这意味着它一次只能执行一个任务。调用栈记录了函数的调用顺序，并在当前函数执行完毕后，依次返回上一级调用。 Web API浏览器提供了一些异步 API，如 setTimeout、setInterval、XMLHttpRequest、fetch 等。当调用这些 API 时，任务会被移交给浏览器处理，而不是立即在调用栈中执行。 任务队列（Task Queue）任务队列存储了已完成的异步操作对应的回调函数，这些回调函数等待事件循环将它们推入调用栈执行。任务队列包括宏任务队列（Macro Task Queue）和微任务队列（Microtask Queue）。 宏任务（Macro Task）宏任务包括 setTimeout、setInterval、I/O 操作等。这些任务会被添加到宏任务队列中，等待事件循环处理。 微任务（Microtask）微任务包括 Promise 的 .then 回调、MutationObserver 等。微任务会被添加到微任务队列中。微任务队列的优先级高于宏任务队列，这意味着在每次宏任务执行完毕后，事件循环会首先清空微任务队列。 工作流程 主线程执行同步代码：所有同步代码会被压入调用栈中并执行。 遇到异步操作：当遇到异步操作（如 setTimeout、fetch 等），相应的回调函数会被注册并移交给浏览器的 Web API 处理。 Web API 完成任务：一旦异步操作完成，回调函数会被放入相应的任务队列中（宏任务或微任务）。 事件循环检查调用栈：事件循环不断检查调用栈是否为空。 处理微任务：如果调用栈为空，事件循环会优先处理微任务队列中的任务。 处理宏任务：如果微任务队列为空，事件循环会处理宏任务队列中的任务。 示例代码1234567891011console.log('Start');setTimeout(() =&gt; { console.log('Timeout callback');}, 0);Promise.resolve().then(() =&gt; { console.log('Promise callback');});console.log('End'); 执行顺序解析 console.log('Start') 输出 “Start”。 setTimeout 注册一个回调函数，并将其移交给浏览器处理（宏任务）。 Promise.resolve().then 注册一个回调函数，并将其放入微任务队列。 console.log('End') 输出 “End”。 主线程执行完同步代码后，调用栈为空，事件循环首先处理微任务队列。 微任务队列中的 Promise 回调函数被执行，输出 “Promise callback”。 微任务队列清空后，事件循环处理宏任务队列中的 setTimeout 回调，输出 “Timeout callback”。 综上所述，JavaScript 的异步机制通过事件循环、调用栈、任务队列和 Web API 的协同工作，实现了异步操作，使得代码可以在等待长时间操作（如网络请求）时，不阻塞主线程的执行。 8.项目亮点","link":"/去哪儿网/"},{"title":"字节跳动","text":"字节跳动 1.项目选一点来说，技术指标？了解业务指标吗？ 2.KVO原理，应用场景 3.Runtime、应用，Runtime 交换方法需要注意什么？Runtime 的 hook 和 fish hook 有什么区别？ 4.Runloop、应用、Runloop 来监测卡顿有什么问题？ 5.UIView 和 CALaye r的区别，为什么这么设计？ 6.显式动画和隐式动画的区别 7.了解的设计原则和设计模式，结合项目 8.block 的本质 9.算法：查找字符串的无重复字符子串的最大长度 无重复字符的最长子串-力扣 参考答案1.项目选一点来说，技术指标？了解业务指标吗？2.KVO原理，应用场景 动态生成子类：当你观察某个对象的属性时，Objective-C Runtime会动态创建该对象的一个子类，并重写被观察属性的setter方法。 方法重写：在重写的setter方法中，KVO机制会插入一些代码，用于通知所有观察者该属性的变化。 isa指针指向：原始对象的isa指针会被修改，指向新创建的子类，以确保调用setter方法时实际调用的是重写后的方法。 通知机制：属性值变化时，KVO机制会自动通知所有注册的观察者，调用观察者的observeValueForKeyPath:ofObject:change:context:方法。 3.Runtime、应用，Runtime 交换方法需要注意什么？Runtime的 hook 和 fish hook 有什么区别？iOS Runtime Hook主要特点 Method Swizzling: 这是最常见的Runtime Hook技术，通过交换方法实现和自定义方法实现，从而改变类的行为。 动态性强: 由于Objective-C Runtime的动态特性，可以在运行时对类和方法进行操作。 灵活性高: 可以在不修改原始代码的情况下，对应用程序的行为进行修改。 适用范围广: 适用于Objective-C编写的类和方法。 使用场景 修改系统或第三方库的行为。 监控方法调用和参数。 在不破坏原有代码的基础上，添加额外的功能。 Fishhook概述Fishhook是由Facebook开源的一个库，主要用于在iOS应用中重绑定符号，从而实现对低层次的C函数进行hook。 主要特点 基于符号重绑定: Fishhook通过修改符号表来重新绑定函数指针，从而实现对函数的替换。 适用范围: 主要用于C语言层面的函数，如系统调用和标准库函数。 低层次: 适用于低层次的函数拦截，而不是面向对象的Method Swizzling。 开源库: Fishhook是一个开源库，可以方便地集成到项目中。 使用场景 替换系统函数实现，如malloc、free、open等。 监控和修改底层C函数的行为。 在动态加载的库中对特定函数进行hook。 总结 iOS Runtime Hook主要用于Objective-C的方法替换，通过Runtime机制实现，适用于面向对象的环境。 Fishhook主要用于C函数的符号重绑定，通过修改符号表实现，适用于底层C函数的拦截和替换。 4.Runloop、应用、Runloop 来监测卡顿有什么问题？使用 RunLoop 来监测卡顿是一个常见的方法，但它也有一些局限性和潜在的问题。以下是一些主要问题： 1. 精度问题RunLoop 的监测精度有限。RunLoop 的每一次循环都有其自身的周期，如果要监测短暂的卡顿（比如几毫秒），RunLoop 可能无法捕捉到。 2. 影响性能频繁监测 RunLoop 的状态可能会对应用性能产生影响。尤其在主线程上进行监测时，可能会增加额外的开销，从而影响应用的响应速度。 3. 误报问题使用 RunLoop 来检测卡顿时，可能会出现误报的情况。例如，后台任务、I/O 操作或者网络请求等可能导致 RunLoop 的阻塞，这些情况未必是真正的 UI 卡顿。 4. 无法检测异步任务RunLoop 主要监测的是同步任务的执行情况，对于异步任务（如 GCD 的 dispatch_async 或者 NSOperationQueue）的监测能力有限。这可能导致一些卡顿问题被遗漏。 5. 复杂的实现逻辑为了准确监测卡顿，可能需要实现复杂的逻辑来处理各种边界情况和特例。这不仅增加了代码的复杂性，也增加了维护的难度。 6. 应用场景有限RunLoop 监测方法主要应用于主线程的 UI 卡顿检测，对于多线程环境下的卡顿监测效果不佳。因此，如果应用中存在大量的多线程操作，单纯依赖 RunLoop 进行监测可能无法全面覆盖。 典型实现方法尽管存在上述问题，RunLoop 仍然是一个常用的卡顿监测工具。以下是一个简单的实现思路： 观察 RunLoop 的状态：通过监听 RunLoop 的 kCFRunLoopBeforeSources 和 kCFRunLoopAfterWaiting 等状态，记录 RunLoop 的执行时间。 计算时间差：在每次 RunLoop 状态变化时，计算当前时间与上一次状态变化的时间差。如果时间差超过某个阈值（比如 100 毫秒），则认为发生了卡顿。 记录或上报卡顿：将卡顿信息记录到日志中，或者上报到服务器进行分析。 1234567891011CFRunLoopObserverRef observer;CFRunLoopObserverContext context = {0, (__bridge void *)self, NULL, NULL, NULL};observer = CFRunLoopObserverCreate(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, &amp;runLoopObserverCallback, &amp;context);if (observer) { CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);} runLoopObserverCallback 中可以实现时间差计算和卡顿检测逻辑。 总结虽然使用 RunLoop 来监测卡顿存在一些问题，但它仍然是一个有用的工具，尤其是在主线程的 UI 卡顿检测方面。为了提高监测的准确性和覆盖面，可以结合其他监测方法，如定期采样、堆栈追踪等，来更全面地了解应用的性能状况。 5.UIView 和 CALayer 的区别，为什么这么设计？UIView 类型: UIView 是一个视图类，继承自 UIResponder。 功能 : 事件处理: UIView 负责处理用户交互事件，如触摸、手势等。 视图层次结构: UIView 管理视图层次结构，可以包含其他视图（子视图）并且可以被其他视图包含（父视图）。 布局和自动布局: UIView 支持自动布局（Auto Layout）和布局约束，并且可以响应布局变化。 动画: UIView 提供了动画接口，可以对视图进行动画处理。 渲染: UIView 本身并不直接进行渲染操作，而是通过其内部的 CALayer 来进行渲染。 CALayer 类型: CALayer 是 Core Animation 框架中的一个类，负责管理和渲染内容。 功能: 内容渲染: CALayer 负责渲染视图的内容，并且可以直接绘制图形、设置背景颜色、边框、阴影等。 动画: CALayer 提供了强大的动画功能，支持隐式动画（Implicit Animations）和显式动画（Explicit Animations）。 图形操作: CALayer 支持复杂的图形操作，如变换（旋转、缩放、平移）、遮罩（Masking）、滤镜（Filters）等。 不处理事件: CALayer 不处理用户交互事件，这是 UIView 的职责。 不参与自动布局: CALayer 不参与 UIView 的布局系统，它的布局需要手动设置。 关系 层次结构: 每个 UIView 都包含一个 CALayer 实例作为其 layer 属性，UIView 通过这个 CALayer 来进行内容的实际渲染。 委托关系: UIView 是 CALayer 的委托（delegate），CALayer 的一些操作（如绘制内容）可以委托给 UIView 来处理。 典型用法 UIView: 创建和管理界面元素。 响应用户交互。 布局和子视图管理。 CALayer: 执行复杂的动画和图形操作。 提供低级别的绘图和渲染支持。 作为 UIView 的底层实现，提升渲染性能。 在 iOS 开发中，UIView 和 CALayer 的设计遵循了一系列面向对象设计原则，这些原则确保了代码的灵活性、可维护性和性能。以下是一些关键的设计原则以及它们在 UIView 和 CALayer 中的体现： 1. 单一职责原则（Single Responsibility Principle, SRP）定义: 每个类应该只有一个引起变化的原因，即每个类应该只有一个职责。 体现: UIView 主要负责处理用户交互事件、管理视图层次结构和布局。 CALayer 专注于内容的渲染和动画。 通过将视图的管理和渲染职责分离，可以让每个类更加专注于自身的功能，简化了类的设计和职责。 2. 开放-封闭原则（Open/Closed Principle, OCP）定义: 软件实体（类、模块、函数等）应该可以扩展，但不可修改。 体现: UIView 通过其 layer 属性委托渲染任务给 CALayer。如果需要扩展渲染功能，可以通过自定义 CALayer 而不是修改 UIView。 CALayer 的功能可以通过子类化和委托模式来扩展，而不需要修改现有的类。 这种设计允许在不修改现有代码的情况下，轻松添加新功能。 3. 里氏替换原则（Liskov Substitution Principle, LSP）定义: 子类对象必须能够替换其父类对象，并且不会导致程序行为的改变。 体现: UIView 和 CALayer 都可以被子类化，子类可以替换父类的实例并正常工作。 UIView 的子类可以扩展用户交互和布局功能，而 CALayer 的子类可以扩展渲染和动画功能。 4. 依赖倒置原则（Dependency Inversion Principle, DIP）定义: 高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。 体现: UIView 并不直接依赖低层的渲染实现，而是通过 CALayer 进行抽象。 CALayer 提供了渲染的抽象接口，具体的渲染细节可以通过子类和委托模式来实现。 5. 接口隔离原则（Interface Segregation Principle, ISP）定义: 客户端不应该被强迫依赖它们不使用的方法；一个类对另一个类的依赖应该建立在最小接口上。 体现: UIView 和 CALayer 的接口设计相对独立，UIView 聚焦在用户交互和布局接口上，而 CALayer 聚焦在渲染和动画接口上。 UIView 的用户只需要关心用户交互和布局相关的方法，而不需要了解渲染和动画的细节。 6. 组合优于继承（Composition over Inheritance）定义: 应该优先使用组合而不是继承来达到代码复用和扩展的目的。 体现: UIView 通过组合 CALayer 来实现复杂的功能，而不是通过继承来扩展一个巨大的视图类。 这种设计允许在 UIView 和 CALayer 之间进行灵活的组合和配置，以适应不同的需求。 7. 性能和效率定义: 在设计中考虑性能和效率问题，确保应用程序运行高效。 体现: CALayer 直接与 Core Animation 交互，提供硬件加速的动画和渲染性能。 UIView 通过 CALayer 进行渲染，可以减少视图树的复杂度并提高渲染效率。 通过遵循这些设计原则，UIView 和 CALayer 实现了职责分离、代码复用、灵活扩展和高效渲染，形成了一个强大且易于维护的视图和动画系统。这种设计不仅提升了开发体验，还提高了应用程序的性能和稳定性。 6.显式动画和隐式动画的区别在 iOS 开发中，动画可以分为显式动画（Explicit Animations）和隐式动画（Implicit Animations）。这两种动画方式在实现、使用场景和控制粒度上有所不同。 隐式动画（Implicit Animations）隐式动画是由 Core Animation 框架自动处理的动画效果。它们不需要显式地创建动画对象，系统会自动为你生成动画效果。 特点: 自动触发: 隐式动画通常在更改 CALayer 的可动画属性时自动触发，如 position、opacity、backgroundColor 等。 简洁: 隐式动画不需要显式地声明动画对象，代码更简洁。 默认持续时间: 隐式动画有默认的动画持续时间，通常为 0.25 秒。 可定制: 可以通过事务（CATransaction）来定制隐式动画的属性，如持续时间、动画曲线等。 示例: 1234567891011121314151617181920212223import UIKitclass ViewController: UIViewController { var myLayer: CALayer! override func viewDidLoad() { super.viewDidLoad() myLayer = CALayer() myLayer.frame = CGRect(x: 50, y: 50, width: 100, height: 100) myLayer.backgroundColor = UIColor.blue.cgColor view.layer.addSublayer(myLayer) // 使用隐式动画更改属性 DispatchQueue.main.asyncAfter(deadline: .now() + 1) { CATransaction.begin() CATransaction.setAnimationDuration(2.0) self.myLayer.position = CGPoint(x: 200, y: 300) self.myLayer.backgroundColor = UIColor.red.cgColor CATransaction.commit() } }} 显式动画（Explicit Animations）显式动画是开发者明确创建并添加到图层上的动画对象。它们提供了更高的控制粒度，可以对动画的各个方面进行精细控制。 特点: 明确声明: 显式动画需要显式地创建动画对象，如 CABasicAnimation、CAKeyframeAnimation、CAAnimationGroup 等。 精细控制: 显式动画允许精细控制动画的各个方面，包括起始值、结束值、持续时间、重复次数、动画曲线等。 复合动画: 可以组合多个动画，形成复杂的动画效果。 更多类型: 提供了多种类型的动画，如基础动画、关键帧动画、路径动画、组动画等。 示例: 1234567891011121314151617181920212223242526272829303132333435import UIKitclass ViewController: UIViewController { var myLayer: CALayer! override func viewDidLoad() { super.viewDidLoad() myLayer = CALayer() myLayer.frame = CGRect(x: 50, y: 50, width: 100, height: 100) myLayer.backgroundColor = UIColor.blue.cgColor view.layer.addSublayer(myLayer) // 创建显式动画 DispatchQueue.main.asyncAfter(deadline: .now() + 1) { let positionAnimation = CABasicAnimation(keyPath: \"position\") positionAnimation.fromValue = self.myLayer.position positionAnimation.toValue = CGPoint(x: 200, y: 300) positionAnimation.duration = 2.0 let colorAnimation = CABasicAnimation(keyPath: \"backgroundColor\") colorAnimation.fromValue = UIColor.blue.cgColor colorAnimation.toValue = UIColor.red.cgColor colorAnimation.duration = 2.0 // 添加动画到图层 self.myLayer.add(positionAnimation, forKey: \"positionAnimation\") self.myLayer.add(colorAnimation, forKey: \"colorAnimation\") // 更新图层属性 self.myLayer.position = CGPoint(x: 200, y: 300) self.myLayer.backgroundColor = UIColor.red.cgColor } }} 总结 隐式动画: 自动触发，代码简洁。 适用于简单的动画效果。 可以通过事务（CATransaction）进行有限的定制。 显式动画: 需要显式地创建动画对象。 提供更高的控制粒度，适用于复杂的动画效果。 支持多种动画类型和复合动画。 选择使用隐式动画还是显式动画取决于具体的需求和场景。如果需要实现简单的动画效果，隐式动画通常足够且更简洁；如果需要复杂的、多步骤的动画效果，显式动画则提供了更强大的控制能力。 7.了解的设计原则和设计模式，结合项目设计原则单一职责：一个类只负责一件事，UIView和CALayer 开闭原则：对修改关闭，对扩展开放 Cagrgory 接口隔离原则：使用多个专门的协议，而不是一个庞大臃肿的协议，协议中的方法尽量少 UITableView 依赖倒置原则：抽象不应该依赖于具体实现，具体实现可以依赖于抽象 里氏替换原则：父类可以被子类无缝替换，且原有功能不受任何影响 KVO 迪米特法则：一个对象应当对其他对象尽可能少的了解，高内聚、低耦合 8.block的本质9.算法：查找字符串的无重复字符子串的最大长度无重复字符的最长子串-力扣 123456789101112131415161718192021/** * @param {string} s * @return {number} */var lengthOfLongestSubstring = function(s) { let len = s.length; let set = new Set(); let i = 0, j = 0; let maxLenth = 0; while (i &lt; len &amp;&amp; j &lt; len) { if (!set.has(s[j])) { set.add(s[j]); j++; maxLenth = Math.max(maxLenth, j - i); } else { set.delete(s[i]); i++; } } return maxLenth;};","link":"/字节跳动/"},{"title":"瓴岳科技","text":"瓴岳科技 1.SDK 体积优化 2.webView 加载速度优化，H5 怎么加载本地 JS/图片资源 3.线上监控，卡顿、内存 4.Runloop 有几个 mode？ 5.项目里有用到常驻线程吗？ 6.KVO 原理 7.IMP、selector、SEL 含义和区别 8.消息转发机制的优劣，和直接调用相比 9.点击界面上的一个按钮，发生了什么？ 10.SQLite3 和 Realm 的区别？ 11.Category 和 Extension 的区别 12.Block 的本质，结构体里有哪些东西？内存管理 13.为什么要在主线程刷新 UI 14.Swift 中 Result 类型 15.二叉树的翻转 226. 翻转二叉树 参考答案(GPT) 1.SDK体积优化优化iOS SDK体积对于提升应用性能、减少下载时间以及节省用户设备存储空间都非常重要。以下是一些有效的方法来优化iOS SDK的体积： 1. 移除不必要的架构 只保留所需的架构：在构建SDK时，移除不必要的架构，例如x86_64和i386（模拟器架构），只保留arm64（实际设备架构）。 1lipo -remove x86_64 YourSDK.framework/YourSDK -o YourSDK.framework/YourSDK 2. 减少资源文件 移除未使用的资源：移除未使用的图片、音频、视频等资源文件。 压缩资源文件：使用工具（如ImageOptim）压缩图片文件，使用合适的编码格式压缩音频和视频文件。 3. 使用符号表压缩 压缩符号表：通过strip工具压缩符号表以减少二进制文件的体积。 1strip -S YourSDK.framework/YourSDK 4. 代码优化 移除未使用代码：通过代码分析工具（如Xcode的静态分析功能）查找并移除未使用的代码。 模块化：将SDK拆分成多个模块，只在需要时引入特定模块。 5. 使用Swift Package Manager Swift Package Manager (SPM)：使用SPM来管理和分发SDK，可以显著减少SDK的体积，因为SPM只会下载和编译所需的代码。 6. 动态库 vs 静态库 选择合适的库类型：在某些情况下，使用动态库（.dylib或.framework）可以减少整体应用的体积，因为它们可以被多个应用共享。 7. 编译优化 优化编译设置：在Xcode中，确保在Release配置下选择优化选项（如-Oz）以减少代码体积。 1Build Settings -&gt; Optimization Level -&gt; Optimize for Size [-Oz] 8. 引用第三方库优化 移除未使用的第三方库：确保只包含那些在SDK中实际使用的第三方库。 使用轻量级的第三方库：选择功能相同但体积更小的第三方库。 9. 符号混淆 符号混淆：使用符号混淆工具（如llvm-obfuscator）混淆符号表以减少符号表大小和提高代码安全性。 通过以上方法，您可以显著减少iOS SDK的体积，从而提升用户体验和应用的整体性能。 2.webView加载速度优化，H5怎么加载本地JS/图片资源移动 H5 首屏秒开优化方案探讨 WebView性能、体验分析与优化 3.线上监控，卡顿、内存4.Runloop有几个mode？最常用的模式主要是以下几个： NSDefaultRunLoopMode / kCFRunLoopDefaultMode UITrackingRunLoopMode NSRunLoopCommonModes / kCFRunLoopCommonModes 5.项目里有用到常驻线程吗？6.KVO原理KVO 基本概念KVO 允许对象观察另一个对象的某个属性，当该属性发生变化时，观察者会收到通知。通常，KVO 的使用分为以下几个步骤： 注册观察者：使用 addObserver:forKeyPath:options:context: 方法注册观察者。 实现回调方法：实现 observeValueForKeyPath:ofObject:change:context: 方法来处理属性变化。 移除观察者：使用 removeObserver:forKeyPath: 方法移除观察者。 KVO 工作原理KVO 的实现主要依赖于 Objective-C 的运行时机制，具体步骤如下： 动态创建子类当你为某个对象的某个属性注册观察者时，Objective-C 运行时会动态创建该对象的一个子类（通常以 NSKVONotifying_ 为前缀），并将该对象的类指针（isa 指针）指向这个新创建的子类。 重写属性的 setter 方法在这个新创建的子类中，Objective-C 运行时会重写被观察属性的 setter 方法。例如，如果你观察的是 name 属性，KVO 会重写 setName: 方法。 通知观察者在重写的 setter 方法中，KVO 会插入一些钩子代码，在属性值变更前后调用 willChangeValueForKey: 和 didChangeValueForKey: 方法。这些方法用于通知观察者属性即将改变和已经改变。 调用观察者的回调方法didChangeValueForKey: 方法会触发 KVO 通知机制，最终调用观察者的 observeValueForKeyPath:ofObject:change:context: 方法。 注意事项 移除观察者：在对象释放之前，一定要移除所有的观察者，否则会导致崩溃。 线程安全：KVO 通知是同步的，意味着属性的 setter 方法会在观察者的回调方法完成之后才返回。确保观察者的回调方法是线程安全的非常重要。 KVO-compliant：确保属性遵循 KVO 协议，即通过 setter 方法（而不是直接修改实例变量）来改变属性的值。 自动和手动通知：默认情况下，KVO 是自动通知的。你也可以通过重写 automaticallyNotifiesObserversForKey: 方法来禁用自动通知，并手动调用 willChangeValueForKey: 和 didChangeValueForKey:。 7.IMP、selector、SEL含义和区别 SEL（selector） SEL 或 selector 是方法的唯一标识符。 在编译时，编译器会将方法名称映射为一个 SEL 类型的选择器。 选择器用于在运行时查找方法的实现。 IMP IMP 是一个函数指针，指向方法的实际实现。 当你发送消息给对象时，运行时系统会根据 SEL 找到对应的 IMP，然后调用它。 直接调用 IMP 可以略过消息传递机制，提高性能。 8.消息转发机制的优劣，和直接调用相比 性能 直接调用方法：最快，因为编译器在编译时已经确定了方法的实现。 消息传递机制：稍慢，因为需要在运行时查找方法的实现。 消息转发机制：最慢，因为涉及多个步骤来处理未知消息。 灵活性 直接调用方法：灵活性最低，因为方法实现是静态绑定的。 消息传递机制：灵活性较高，可以在运行时动态查找和调用方法。 消息转发机制：灵活性最高，可以在运行时动态处理未知消息，甚至可以将消息转发给其他对象。 使用场景 直接调用方法：适用于性能关键的代码，方法实现是确定的。 消息传递机制：适用于需要一些动态特性的代码。 消息转发机制：适用于需要高度动态性和灵活性的代码，例如代理模式、消息路由等。 9.点击界面上的一个按钮，发生了什么？响应者链（Responder Chain）响应者链是一个由 UIResponder 对象组成的链条，这些对象可以响应和处理事件。UIView, UIViewController, UIWindow, 以及 UIApplication 都是 UIResponder 的子类。 事件传递和响应者链 触摸事件的产生：当用户点击屏幕时，硬件会捕捉到这个触摸事件，并将其传递给 iOS 系统。 创建 UIEvent 对象：iOS 系统会将触摸数据封装成一个 UIEvent 对象。 事件传递给 UIWindow：系统会将这个 UIEvent 传递给应用的主 UIWindow。 找到第一响应者：UIWindow 会调用 hitTest:withEvent: 方法，从视图层次结构中找出最合适的视图来处理这个触摸事件。这个视图成为第一响应者。 事件传递给 UIView：触摸事件会被传递给找到的视图（通常是一个 UIButton），并调用其 touchesBegan:withEvent:, touchesMoved:withEvent:, touchesEnded:withEvent: 方法来处理具体的触摸事件。 手势识别器的优先级手势识别器（Gesture Recognizer）在 iOS 的事件处理机制中具有较高的优先级。具体来说，手势识别器会先接收到触摸事件，并尝试识别是否是自己关心的手势。如果手势识别器识别成功，那么它会处理该事件并阻止事件继续传递给响应者链。 具体的事件传递顺序 触摸事件产生：用户触摸屏幕，触摸事件被硬件捕获并传递给 iOS 系统。 创建 UIEvent 对象：iOS 系统将触摸数据封装成一个 UIEvent 对象。 事件传递给 UIWindow：系统将此 UIEvent 对象传递给应用的主 UIWindow。 手势识别器检测：UIWindow 会先将触摸事件传递给视图层次结构中相关视图的手势识别器。如果有手势识别器检测到手势并识别成功，那么该手势识别器会处理该事件，并阻止事件继续传递。 事件传递给响应者链：如果手势识别器没有处理该事件，那么事件将按照响应者链的机制传递。响应者链会从最合适的视图开始处理触摸事件，调用相关的 touchesBegan:withEvent:, touchesMoved:withEvent:, touchesEnded:withEvent: 方法。 10.SQLite3和Realm的区别？1. 数据库类型 SQLite3: SQLite 是一个轻量级的关系型数据库管理系统，遵循 SQL 标准。它使用 SQL 语言进行数据操作，支持复杂的查询和事务处理。 Realm: Realm 是一个面向对象的数据库，旨在简化数据存储和查询过程。它不使用 SQL，而是通过对象模型进行数据操作。 2. 数据模型 SQLite3: 使用关系型数据模型，数据存储在表中，表包含行和列。数据操作通过 SQL 查询语句完成。 Realm: 使用面向对象的数据模型，数据存储在对象中。你可以直接通过对象属性进行查询和操作，这使得代码更加直观和简洁。 3. 性能 SQLite3: 通常在处理非常复杂的查询或需要高度自定义的查询时性能较好。SQLite3 的性能可能会受到 SQL 查询复杂性的影响。 Realm: 由于其设计面向移动设备，通常在读写性能上表现优异，尤其是对于常见的、简单的查询操作。Realm 还提供了对多线程的支持，以提高并发性能。 4. 数据迁移 SQLite3: 数据库迁移通常需要手动编写 SQL 脚本来修改表结构，这可能会比较繁琐。 Realm: 提供了内置的数据迁移机制，可以通过代码来定义迁移步骤，这使得数据迁移过程更加方便和安全。 5. 易用性 SQLite3: 由于使用 SQL 语言，开发者需要了解 SQL 语法和关系型数据库的基本概念。数据模型的改变通常需要手动修改表结构。 Realm: 提供了面向对象的 API，使用起来更加直观。开发者不需要学习 SQL，只需操作对象模型即可。 6. 数据同步 SQLite3: 本身不提供数据同步功能。如果需要在不同设备间同步数据，通常需要额外的服务器支持。 Realm: 提供了 Realm Cloud 服务，可以实现数据的实时同步和离线访问，适合需要多设备数据同步的应用。 7. 文件大小和存储方式 SQLite3: 数据存储在单个文件中，文件大小会随着数据量的增加而增加。SQLite3 支持多种数据类型和存储格式。 Realm: 数据也存储在单个文件中，但由于其高效的存储格式和压缩机制，通常文件大小较小。Realm 对于对象模型的存储进行了优化，减少了数据的冗余。 8. 加密和安全性 SQLite3: 支持加密，但需要使用第三方库（如 SQLCipher）来实现。 Realm: 内置支持加密，可以方便地加密整个数据库文件，提高数据安全性。 9. 多平台支持 SQLite3: 支持几乎所有的平台，包括 iOS、Android、Windows、Linux 等。因为其广泛的支持和成熟度，SQLite 是一个非常可靠的选择。 Realm: 也支持多平台，包括 iOS、Android、React Native 等。Realm 提供的 API 在不同平台上保持一致性，便于跨平台开发。 总结 SQLite3: 适合需要复杂查询、事务处理和高度自定义的应用，尤其是那些开发者已经熟悉 SQL 语言的情况。 Realm: 适合需要高性能、简单易用和面向对象的数据存储解决方案，特别是移动应用开发。 11.Category和Extension的区别 特性 Category Extension 定义和用途 为现有类添加方法 在实现文件中添加私有方法和属性 实例变量 不能添加 可以添加 访问控制 方法是公开的 方法和属性是私有的 编译时机 动态加载，在运行时添加 编译时添加，类定义的一部分 使用场景 将类的方法划分到多个文件，为系统类添加方法 在实现文件中定义私有方法和属性，提高封装性 12.Block的本质，结构体里有哪些东西？内存管理Block 的本质在底层，Block 是一个封装了函数指针、捕获变量及其他相关信息的结构体。可以通过 Clang 提供的编译器选项 -rewrite-objc 将 Objective-C 代码转换为纯 C++ 代码，来查看 Block 的具体实现。 例如，以下是一个简单的 Block 声明和使用： 1234void (^simpleBlock)(void) = ^{ NSLog(@\"This is a simple block\");};simpleBlock(); 使用 -rewrite-objc 将其转换为 C++ 代码后，可以看到 Block 的底层实现。 Block 的结构体在底层，Block 是一个结构体，通常包含以下几个部分： isa 指针：指向 Block 的类对象，用于实现 Objective-C 的动态特性。 flags：标志位，指示 Block 的一些特性（如是否需要复制、是否包含捕获变量等）。 reserved：保留字段，通常用于内存对齐。 invoke 指针：指向实际执行 Block 代码的函数指针。 descriptor 指针：指向 Block 的描述信息，包括 Block 的大小、拷贝和释放函数等。 捕获变量：如果 Block 捕获了外部变量，这些变量会被存储在结构体中。 具体的结构体定义可能如下所示： 1234567891011121314struct __block_impl { void *isa; int flags; int reserved; void (*invoke)(void *, ...); struct __block_descriptor *descriptor;};struct __block_descriptor { unsigned long int reserved; unsigned long int size; void (*copy)(void *dst, void *src); void (*dispose)(void *src);}; Block 的内存管理Block 的内存管理涉及到以下几个方面： 栈上的 Block：默认情况下，Block 是在栈上分配的。这意味着它的生命周期是有限的，当超出其作用域时，Block 会被销毁。如果试图在作用域外使用该 Block，会导致崩溃。 堆上的 Block：为了让 Block 在作用域外仍然有效，可以将其复制到堆上。可以使用 Block_copy 函数或 ^ 运算符来实现这一点。在 ARC 环境下，直接赋值给 __strong 类型的变量时，Block 会自动复制到堆上。 捕获变量的内存管理：Block 可以捕获其作用域中的变量，包括自动变量（局部变量）和静态变量。捕获变量的内存管理取决于变量的类型： 对于自动变量，Block 会将其值拷贝到 Block 的结构体中。 对于对象类型的变量，Block 会对其进行 retain 操作（在 ARC 下），以确保 Block 的生命周期内变量仍然有效。 13.为什么要在主线程刷新UI在 iOS 和 macOS 开发中，所有的 UI 更新必须在主线程（也称为主队列）上执行。以下是为什么需要在主线程刷新 UI 的几个原因： 1. UIKit 和 AppKit 的线程安全性 单线程设计： UIKit（iOS 的 UI 框架）和 AppKit（macOS 的 UI 框架）是设计为非线程安全的。它们的大多数 API 都假定是在主线程上调用的。 这是因为 UI 操作通常涉及到大量复杂的内部状态管理和绘图操作，确保所有这些操作在一个单一线程上可以避免并发问题。 2. 数据一致性和线程同步 数据一致性： 如果多个线程同时操作 UI 组件，可能会导致不一致的 UI 状态。例如，一个线程正在修改视图的属性，而另一个线程正在试图渲染视图，这可能会导致崩溃或未定义行为。 线程同步： 多线程操作 UI 需要额外的同步机制来防止并发访问冲突。使用主线程可以简化这种同步需求，使代码更容易维护和理解。 3. 事件处理模型 事件循环： iOS 和 macOS 应用程序的主线程运行一个事件循环，处理用户交互、定时器、网络响应等各种事件。UI 更新也是事件循环的一部分。 通过将所有 UI 操作放在主线程上，确保了事件处理的顺序性和一致性。 4. 用户体验 平滑的 UI 动画和响应： 在主线程上更新 UI 可以确保动画的平滑性和用户交互的及时响应。如果在后台线程更新 UI，可能会导致动画卡顿或延迟响应，影响用户体验。 避免死锁： 主线程上的操作是顺序执行的，这降低了发生死锁的风险。如果尝试在后台线程进行复杂的 UI 操作，可能会导致线程间的资源争用和死锁。 总结在主线程刷新 UI 是为了确保 UIKit 和 AppKit 的线程安全性、保持数据一致性和简化线程同步、遵循事件处理模型以及提供更好的用户体验。通过理解和遵循这些原则，可以避免许多潜在的并发问题和性能瓶颈，从而构建更稳定和高效的应用程序。 14.Swift中Result类型在 Swift 中，Result 类型是一种用于表示操作结果的枚举，能够明确地表达成功和失败的情况。它的引入使得错误处理更加简洁和明确，特别是在异步操作和函数返回值中。 Result 类型的定义Result 类型是一个泛型枚举，有两个可能的值： .success(Value)：表示操作成功，并包含成功时的返回值。 .failure(Error)：表示操作失败，并包含失败时的错误。 以下是 Result 类型的定义： 1234enum Result&lt;Success, Failure: Error&gt; { case success(Success) case failure(Failure)} 使用 Result 类型定义一个返回 Result 类型的函数假设我们有一个函数，用于从服务器获取数据，该函数可以成功返回数据，也可能因为网络错误而失败： 12345678910111213141516171819202122enum NetworkError: Error { case badURL case requestFailed case unknown}func fetchData(from urlString: String, completion: (Result&lt;Data, NetworkError&gt;) -&gt; Void) { guard let url = URL(string: urlString) else { completion(.failure(.badURL)) return } URLSession.shared.dataTask(with: url) { data, response, error in if let _ = error { completion(.failure(.requestFailed)) } else if let data = data { completion(.success(data)) } else { completion(.failure(.unknown)) } }.resume()} 调用并处理 Result调用 fetchData 函数，并处理返回的 Result： 1234567891011121314151617fetchData(from: \"https://example.com\") { result in switch result { case .success(let data): // 处理成功情况 print(\"Data received: \\(data)\") case .failure(let error): // 处理失败情况 switch error { case .badURL: print(\"Bad URL\") case .requestFailed: print(\"Request failed\") case .unknown: print(\"Unknown error\") } }} Result 类型的便利方法Swift 提供了一些便利方法来处理 Result 类型，包括 map、flatMap、mapError 和 flatMapError。 map 方法map 方法可以将 Result 中的成功值转换为另一种类型： 12345let result: Result&lt;Int, NetworkError&gt; = .success(42)let stringResult = result.map { value in return \"The answer is \\(value)\"}// stringResult 是 Result&lt;String, NetworkError&gt;.success(\"The answer is 42\") flatMap 方法flatMap 方法用于将 Result 中的成功值转换为另一个 Result： 12345let result: Result&lt;Int, NetworkError&gt; = .success(42)let newResult = result.flatMap { value in return Result&lt;String, NetworkError&gt;.success(\"The answer is \\(value)\")}// newResult 是 Result&lt;String, NetworkError&gt;.success(\"The answer is 42\") mapError 方法mapError 方法用于将 Result 中的错误值转换为另一种错误类型： 12345let result: Result&lt;Int, NetworkError&gt; = .failure(.badURL)let newResult = result.mapError { error in return MyCustomError.networkError(error)}// newResult 是 Result&lt;Int, MyCustomError&gt;.failure(.networkError(.badURL)) flatMapError 方法flatMapError 方法用于将 Result 中的错误值转换为另一个 Result： 12345let result: Result&lt;Int, NetworkError&gt; = .failure(.badURL)let newResult = result.flatMapError { error in return Result&lt;Int, MyCustomError&gt;.failure(.networkError(error))}// newResult 是 Result&lt;Int, MyCustomError&gt;.failure(.networkError(.badURL)) 总结Result 类型在 Swift 中提供了一种优雅的方式来处理可能成功或失败的操作。通过明确地表达成功和失败的情况，Result 类型使得代码更加易读和可维护。借助 map、flatMap、mapError 和 flatMapError 等便利方法，可以更方便地处理 Result 类型的值。使用 Result 类型可以更好地管理错误处理，特别是在异步操作中。 15.二叉树的翻转226. 翻转二叉树 递归： 12345678910var invertTree = function(root) { if (root === null) { return null; } const left = invertTree(root.left); const right = invertTree(root.right); root.left = right; root.right = left; return root;}; 迭代： 1234567891011121314151617181920var invertTree = function(root) { if (root == null) { return null; } let stack = []; stack.push(root); while (stack.length) { let node = stack.pop(); if (node.left != null) { stack.push(node.left); } if (node.right != null) { stack.push(node.right); } let temp = node.left; node.left = node.right; node.right = temp; } return root;};","link":"/瓴岳科技/"},{"title":"米可世界","text":"米可世界1.长链的事件分发？例如收到礼物，直播间和个人中心模块都需要知道，数据可能很大，通知不合适 protocol buffer？ 2.动画用的什么？ 3.长连接 4.TCP和UDP的区别？ 5.HTTP 为什么要三次握手、四次挥手？ 6.HTTPS 的流程？确认加密算法是在哪一步？ 7.class 和 struct 区别 8.runtime，+load和+initialize方法的执行顺序 9.automic和nonatomic，automic是否是线程安全？ 10.Runloop，和对象释放的关系，Runloop在切换mode时会退出吗？ 11.SDK体积优化？脚本用的什么？静态分析发现了哪些问题？ 12.你觉得值得说的负责的项目 参考答案1.长链的事件分发？例如收到礼物，直播间和个人中心模块都需要知道，数据可能很大，通知不合适 长链的事件分发，特别是在处理像收到礼物这样的复杂事件时，需要考虑事件的多点通知、数据大小以及实时性等因素。以下是对这个问题的一些详细解答和建议： 一、事件分发机制概述事件分发机制主要指的是在系统中，当某个事件发生时，如何高效、准确地将该事件的信息传递给所有需要知道的模块或组件。在长链事件分发场景下，这种机制尤为重要，因为它需要确保多个模块（如直播间和个人中心模块）能够实时、准确地接收到事件信息。 二、长链事件分发的具体实现 事件定义与捕获 事件定义：首先，需要明确定义哪些事件需要被捕获并分发。在这个例子中，收到礼物是一个关键事件。 事件捕获：当用户在直播间送出礼物时，系统需要能够捕获到这个行为，并生成相应的事件信息。 事件信息的封装 由于数据可能很大，因此在封装事件信息时，需要考虑数据的压缩和精简。例如，可以使用Protobuf协议来序列化数据，以减少数据大小并提高效率。 同时，也可以考虑只封装关键信息，如礼物类型、数量、送礼者信息等，以减少数据传输量。 事件分发的设计与实现 分发策略：对于长链事件，可以采用多种分发策略，如发布订阅模式、消息队列等。这些策略可以确保事件信息能够可靠地传递给所有需要的模块。 异步处理：为了避免因事件处理而导致的系统阻塞，可以采用异步处理的方式。即当事件发生时，将事件信息放入消息队列中，由专门的消费者线程或进程进行异步处理。 并发控制：在并发环境下，需要确保事件分发的正确性和一致性。可以使用锁、事务等机制来控制并发访问和数据一致性。 模块间的通信 API调用：直播间和个人中心模块可以通过API调用来实现事件信息的接收和处理。这些API可以定义为RESTful接口或WebSocket等实时通信协议。 消息推送：对于需要实时性较高的场景，可以使用消息推送服务（如MQTT、WebSocket）来实时将事件信息推送给相关模块。 数据校验与错误处理 在事件分发过程中，需要对接收到的数据进行校验，以确保数据的完整性和正确性。 如果在分发过程中出现错误或异常情况，需要有相应的错误处理机制来记录日志、报警或进行重试等操作。 三、优化与改进 性能优化：通过优化事件捕获、封装、分发和处理的各个环节，来提高系统的整体性能。例如，使用高效的序列化协议、优化消息队列的处理逻辑等。 可扩展性设计：在设计事件分发机制时，需要考虑系统的可扩展性。例如，可以通过增加消费者线程或进程的数量、扩展消息队列的容量等方式来提高系统的处理能力。 安全性考虑：在事件分发过程中，需要确保数据的安全性和隐私保护。例如，使用加密技术来保护敏感数据的传输和存储安全。 综上所述，长链的事件分发是一个复杂的过程，需要综合考虑事件的定义与捕获、信息封装、分发策略、模块间通信、数据校验与错误处理等多个方面。通过合理的设计和优化，可以确保事件分发的准确性和实时性，同时提高系统的整体性能和可扩展性。 2.动画用的什么？ 3.长连接 4.TCP和UDP的区别？ TCP（传输控制协议）和UDP（用户数据报协议）是互联网协议族中两个重要的传输层协议。它们在多个方面存在显著差异，以下是对这些区别的详细解析： 一、连接性 TCP：TCP是一种面向连接的协议。在数据传输之前，发送方和接收方需要先进行三次握手，建立连接后才能开始传输数据。这种连接保证了数据的可靠性和顺序性。 UDP：UDP则是一种无连接的协议。发送方在发送数据时不需要提前与接收方建立连接，直接发送数据包。这种方式简化了通信过程，但牺牲了数据的可靠性和顺序性。 二、可靠性 TCP：TCP对数据的可靠性要求非常严格。它使用确认和重传机制来确保数据的完整性和正确性。如果接收方没有收到数据或数据损坏，发送方会重新发送数据，直到接收方确认收到为止。 UDP：UDP对数据的可靠性要求较低。它不提供确认、重传和流量控制机制。如果数据在传输过程中丢失或损坏，UDP不会进行重传，接收方可能会收到不完整的数据。 三、速度和效率 TCP：由于TCP需要建立连接和使用确认重传机制，因此其速度和效率相对较低。特别是在网络拥塞时，TCP的拥塞控制机制会限制发送速率，进一步降低传输速度。 UDP：UDP没有连接建立和确认重传的开销，也不受拥塞控制机制的限制。因此，其数据传输速度通常比TCP更快，尤其适用于对实时性要求较高的应用。 四、数据包大小 TCP：TCP将数据划分为较小的数据包（称为TCP段）进行传输。它没有固定的数据包大小限制，而是根据网络状况动态调整数据包大小。 UDP：UDP则允许发送方一次性将多个数据包打包成一个较大的数据报（称为UDP数据报）进行传输。数据报的大小通常由应用层决定，这使得UDP在传输大量数据时更为高效。 五、适用场景 TCP：适用于对数据可靠性要求较高的应用场景，如文件传输、电子邮件、网页浏览等。这些应用需要确保数据的完整性和正确性，因此选择TCP作为传输层协议更为合适。 UDP：适用于对数据实时性要求较高的应用场景，如音频和视频流传输、网络游戏、实时通信等。这些应用对数据的完整性和正确性要求相对较低，但对传输速度有较高要求，因此选择UDP作为传输层协议更为合适。 综上所述，TCP和UDP在连接性、可靠性、速度和效率、数据包大小以及适用场景等方面存在显著差异。在实际应用中，应根据具体需求选择合适的传输层协议以确保数据的安全、稳定和高效传输。 5.HTTP 为什么要三次握手、四次挥手？ HTTP之所以在TCP连接建立时需要三次握手，以及TCP连接断开时需要四次挥手，主要是为了确保数据传输的可靠性、确保连接的建立和断开均能够按照既定协议进行。以下是详细的解释： 三次握手目的： 确认双方的接收与发送能力：通过三次握手，客户端和服务器能够确认彼此的接收和发送功能都是正常的，从而确保数据能够双向、可靠地传输。 同步初始序列号：TCP连接中，每个传输的TCP段都会带有一个序列号，用于标识数据的顺序。三次握手过程中，双方会协商并同步各自的初始序列号，以便后续的数据传输能够按照正确的顺序进行。 防止失效的连接请求：三次握手可以防止由于网络延迟或信号丢失导致的失效连接请求被服务器误认为是新的连接请求，从而减少资源浪费和潜在的安全风险。 过程： 第一次握手：客户端发送一个带有SYN（同步）标志的数据包给服务器，表示自己希望建立连接，并附带一个初始序列号（ISN）。 第二次握手：服务器收到客户端的SYN包后，会回复一个带有SYN/ACK（同步/确认）标志的数据包给客户端，表示自己已经收到了客户端的连接请求，并且也附带了自己的初始序列号（ISN）以及确认号为客户端的序列号+1，以此确认客户端的发送能力。 第三次握手：客户端收到服务器的SYN/ACK包后，会发送一个带有ACK（确认）标志的数据包给服务器，表示自己已经收到了服务器的回复，确认号为服务器的序列号+1，从而完成连接的建立。 四次挥手目的： 确保数据完整传输：TCP连接是全双工的，即数据可以同时在两个方向上传输。四次挥手确保了双方都能在完成数据传输后再关闭连接，防止数据丢失。 释放连接资源：通过明确的断开连接过程，双方可以及时释放占用的资源，避免无效连接占用系统资源。 过程： 第一次挥手：客户端发送一个带有FIN（结束）标志的数据包给服务器，表示自己已经发送完所有数据，希望关闭连接。此时客户端进入FIN-WAIT-1状态。 第二次挥手：服务器收到客户端的FIN包后，会回复一个带有ACK标志的数据包给客户端，表示自己已经收到了客户端的关闭请求，确认号为客户端的序列号+1。此时服务器进入CLOSE-WAIT状态，等待自己这一方也发送完所有数据后再关闭连接。 第三次挥手：服务器发送一个带有FIN标志的数据包给客户端，表示自己也已经发送完所有数据，希望关闭连接。此时服务器进入LAST-ACK状态，等待客户端的确认。 第四次挥手：客户端收到服务器的FIN包后，回复一个带有ACK标志的数据包给服务器，表示自己已经收到了服务器的关闭请求，确认号为服务器的序列号+1。此时客户端进入TIME-WAIT状态，等待足够的时间以确保服务器收到自己的ACK包后顺利关闭连接。最后，客户端也从TIME-WAIT状态转换到CLOSED状态，完成连接的断开。 综上所述，HTTP的三次握手和四次挥手是为了确保数据传输的可靠性和连接的正确建立与断开而设计的机制。这些机制在TCP/IP协议栈中起着至关重要的作用，保证了网络通信的稳定性和高效性。 6.HTTPS 的流程？确认加密算法是在哪一步？ 7.class 和 struct 区别 1. 类型属性 class：是引用类型，意味着在堆上分配内存，栈中保存的是其引用（即指向堆上对象的指针）。这允许class对象可以被多个变量引用，且修改一个对象的属性可能会影响到其他引用该对象的变量。 struct：是值类型，它在栈上直接分配内存，存储的是其实际的值。因此，每次复制struct变量时，都会创建该变量值的副本，修改一个struct变量的值不会影响其他副本。 2. 成员访问权限 class：默认情况下，class中的成员（成员变量和成员函数）的访问权限是私有的（private），这意味着它们只能在class内部被访问。不过，可以显式地指定成员的访问权限，如public、protected或private。 struct：默认情况下，struct中的成员是公开的（public），这意味着它们可以在struct外部被访问。但同样地，也可以显式地指定成员的访问权限。 3. 构造函数和析构函数 class：可以定义构造函数来初始化对象的状态，也可以定义析构函数来清理资源。构造函数可以是隐式的或显式的，但析构函数总是显式的。 struct：虽然可以定义构造函数，但它们的构造函数有一些限制，如必须初始化所有成员变量。struct不支持定义析构函数。 4. 继承和多态 class：支持继承和多态。一个class可以继承另一个class的成员（包括方法和属性），并通过重写基类方法来支持多态。 struct：不支持继承（除了接口）和多态。在.NET等环境中，虽然struct可以实现接口，但它不能作为基类被其他类型继承 8.runtime，+load和+initialize方法的执行顺序 +load方法 调用时机： +load方法会在runtime加载类、分类时调用。具体来说，当应用程序启动时，Objective-C runtime会加载所有的类和分类实现，并在此时调用每个类和分类的+load方法。 需要注意的是，+load方法在程序运行过程中只会被调用一次，且其调用顺序遵循特定的规则。 调用顺序： 首先，调用类的+load方法，按照编译先后顺序调用（先编译的类，其+load方法会先被调用）。 调用子类的+load之前，会先调用其父类的+load方法。这是为了确保父类被正确加载和初始化后，子类再进行加载。 然后，调用分类的+load方法，也是按照编译先后顺序调用。但分类的+load方法会在所有类的+load方法之后调用。 调用方式： +load方法是根据方法地址直接调用的，不走objc_msgSend消息发送机制。这意味着+load方法的调用非常高效，但也需要注意不要在其中进行耗时的操作，以免影响程序启动速度。 +initialize方法 调用时机： +initialize方法会在类第一次接收到消息（即第一次使用该类时，如创建实例或调用类方法）时调用。每个类只会初始化一次。 调用顺序： 首先，调用父类的+initialize方法（如果子类没有实现自己的+initialize方法，则会调用父类的）。 然后，调用子类的+initialize方法。这确保了类的初始化过程是从基类开始，逐层向下进行的。 调用方式： 与+load方法不同，+initialize方法是通过objc_msgSend消息发送机制调用的。这意味着它的调用更加灵活，但也可能会受到消息传递机制的影响。 注意事项： 如果子类实现了自己的+initialize方法，那么父类的+initialize方法只有在子类没有调用[super initialize]时才会被跳过。但在实际开发中，通常不需要（也不建议）在子类的+initialize方法中显式调用[super initialize]，因为系统已经保证了这一过程的正确性。 9.automic和nonatomic，automic是否是线程安全？ 在Objective-C中，atomic和nonatomic是属性（property）声明时的两个关键字，它们用于定义属性的线程安全性。然而，关于atomic是否是线程安全的问题，需要更细致地理解这两个关键字的含义以及线程安全的概念。 atomic 定义：atomic属性表示属性的setter和getter方法是线程安全的。这通常是通过在访问属性时添加锁来实现的，以确保在任意给定时刻只有一个线程可以访问属性的值。 线程安全性：虽然atomic为setter和getter方法提供了基本的线程保护，但它并不保证整个对象的线程安全。具体来说，atomic只能确保在读取或写入属性值时的原子性，但如果操作涉及到多个步骤或需要访问对象的其他部分，那么atomic并不能提供足够的保护。 性能影响：由于atomic属性需要加锁，因此它们通常比nonatomic属性执行得更慢。在某些情况下，这种性能开销可能是不可接受的。 重要说明：需要注意的是，即使在iOS开发中，苹果官方也推荐使用nonatomic属性，除非有明确的理由需要线程安全（如使用原子操作来保证数据的一致性）。这是因为atomic属性虽然提供了一定的线程安全性，但它们的性能成本较高，并且在许多情况下，开发者可以通过其他方式（如使用锁或同步机制）来确保线程安全，而不必依赖atomic属性。 nonatomic 定义：nonatomic属性表示属性的setter和getter方法不是线程安全的。这意味着在多个线程同时访问同一属性时，可能会导致数据竞争和不确定的行为。 性能优势：由于nonatomic属性不需要加锁，因此它们通常比atomic属性执行得更快。 使用场景：nonatomic属性非常适合在不需要线程安全的情况下使用，例如在单线程环境中或当开发者可以通过其他方式（如加锁）来确保线程安全时。 结论因此，atomic属性虽然在一定程度上提供了线程安全，但它并不是完全线程安全的，并且性能成本较高。在iOS开发中，建议根据实际需要选择使用atomic或nonatomic属性，并在必要时通过其他同步机制来确保线程安全。 综上所述，atomic属性并不等同于线程安全，而只是为setter和getter方法提供了一定的保护。在复杂的多线程环境中，开发者需要结合其他同步机制来确保整个对象或应用的线程安全。 10.Runloop，和对象释放的关系，Runloop在切换mode时会退出吗？ 一、基本概念 Runloop： Runloop是一个事件处理循环，用于监听并处理输入事件（如触摸事件、定时器事件等）和系统事件（如内存警告）。 每个线程都可以有自己的Runloop，但默认情况下，除了主线程外，其他线程的Runloop不会自动启动。 自动释放池（AutoreleasePool）： 自动释放池是iOS中的一种内存自动回收机制，用于延迟释放加入到池中的对象。 当对象被添加到自动释放池中时，它并不会立即被释放，而是在自动释放池销毁时（通常是Runloop的休眠或结束时）发送release消息，从而释放对象。 二、Runloop与自动释放池的关系 自动释放池的创建与销毁： 在主线程中，每次Runloop启动时（如用户交互导致的事件循环开始），系统会自动创建一个新的自动释放池。 在Runloop休眠或结束前，旧的自动释放池会被销毁，同时创建新的自动释放池以准备下一轮的事件处理。 在子线程中，如果Runloop被手动启动，同样会在Runloop的循环中创建和销毁自动释放池。不过，如果子线程没有启动Runloop，则需要手动管理自动释放池（例如，在每个任务开始前创建，任务结束后销毁）。 对象释放的时机： 加入到自动释放池中的对象，其释放时机受Runloop控制。具体来说，当Runloop进入休眠状态前或结束运行时，会自动销毁当前的自动释放池，从而释放池中的所有对象。 这种机制有助于在事件处理过程中有效地管理内存，避免了因对象生命周期管理不当而导致的内存泄漏问题。 三、注意事项 在使用子线程时，如果需要处理大量数据或执行耗时操作，建议手动启动Runloop，并利用自动释放池来管理内存。这可以避免因长时间占用内存而导致的性能问题。 需要注意的是，虽然自动释放池可以简化内存管理任务，但在某些情况下（如循环引用）仍然需要开发者手动介入以释放对象。 综上所述，Runloop与自动释放池在iOS开发中紧密相关。Runloop通过控制自动释放池的创建与销毁来间接管理对象的释放时机，从而帮助开发者有效地管理内存资源。 Runloop在切换Mode时并不会直接退出，而是会先退出当前Mode的Runloop循环，并重新进入新的Mode下的Runloop循环。 11.SDK体积优化？脚本用的什么？静态分析发现了哪些问题？ Xcode静态分析能够发现的问题主要包括以下几个方面： 1. 逻辑缺陷 访问未初始化的变量：这是常见的逻辑错误之一，尝试访问一个未被赋予初始值的变量，可能导致不确定的结果。 空指针的解引用：解引用一个空指针（即指向空地址的指针）会导致程序崩溃。静态分析能够识别出这类潜在的解引用操作。 2. 内存管理缺陷 内存泄漏：分配的内存没有被及时释放，导致内存占用不断增加，最终可能影响程序的性能和稳定性。Xcode静态分析能够检测出这类内存管理错误。 对象所有权问题：对于使用ARC（自动引用计数）管理的对象，静态分析可以检查是否存在潜在的强引用循环等问题，这些问题可能导致对象无法被正确释放。 3. 无用存储缺陷 未使用的变量：定义了变量但在代码中从未使用过，这不仅浪费了内存资源，还可能是代码冗余或逻辑错误的表现。 4. API使用缺陷 不遵循库或框架的使用规则：在调用API时，如果未按照库或框架的规范进行操作（如传递了错误的参数类型、遗漏了必要的参数等），静态分析能够识别出这类问题。 5. 声明错误 类、方法或变量的声明错误：包括类型不匹配、拼写错误等，这些都可能导致编译错误或运行时错误。静态分析可以在不执行代码的情况下发现这些错误。 12.你觉得值得说的负责的项目","link":"/米可世界/"},{"title":"百融云创面试题","text":"百融云创面试题 1.腾讯会议共享屏幕在线编程 https://leetcode.cn/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/description/2.KVO 原理3.如何调用私有 API？三方库或系统未暴漏的方法4.怎么改一个类的只读属性5.消息机制6.Runloop 流程，用 Runloop 做过什么？卡顿检测，发生卡顿后怎么获取堆栈信息？堆栈信息的原理7.GCD 都用了哪些？网络请求 A 和 B 都回调后，请求 C，如何实现？除了 dispatch_group8.可变数组 NSMutableArray，在头部插入元素，iOS 系统做了什么优化9.Tagged Pointer10.NSString 存储在哪里，引用计数存储哪里？11.dealloc 流程12.避免哈希碰撞的几种方法？13.mach-o 了解吗？存储的方法信息可以无用代码检测？段迁移？14.脚本检测未使用代码原理15.render 渲染流程16.UIView 动画和 CAAnimation 动画有什么联系？17.项目亮点 参考答案1.腾讯会议共享屏幕在线编程 https://leetcode.cn/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/description/2.KVO 原理工作原理KVO 主要依赖于 Objective-C 的动态性和 Runtime 运行时机制。以下是 KVO 的几个核心步骤和原理： 1. 动态子类化当你第一次给某个对象添加观察者时，Objective-C Runtime 会动态地创建该对象的一个子类。这个子类会重写被观察属性的 setter 方法。 例如，如果你观察对象 person 的 name 属性： 1[person addObserver:self forKeyPath:@\"name\" options:NSKeyValueObservingOptionNew context:nil]; Runtime 会创建一个新的类，假设名为 NSKVONotifying_Person，这个类是 Person 类的子类。 2. 重写 setter 方法在新的子类中，Runtime 会重写被观察属性的 setter 方法。例如，对于 name 属性，其 setter 方法可能如下： 12345- (void)setName:(NSString *)name { [self willChangeValueForKey:@\"name\"]; [super setName:name]; [self didChangeValueForKey:@\"name\"];} willChangeValueForKey:：通知系统属性即将发生变化。 didChangeValueForKey:：通知系统属性已经发生变化。 这些方法会触发 KVO 通知机制，向所有观察者发送通知。 3. 注册观察者当你调用 addObserver:forKeyPath:options:context: 方法时，Runtime 会将观察者注册到一个内部的观察者列表中，这个列表通常是一个哈希表（Hash Table），键是被观察的属性，值是观察者对象。 4. 通知观察者当属性值发生变化时，重写的 setter 方法会调用 willChangeValueForKey: 和 didChangeValueForKey: 方法，这些方法会触发 KVO 通知机制，向注册的观察者发送通知。观察者会收到 observeValueForKeyPath:ofObject:change:context: 方法的回调。 3.如何调用私有 API？三方库或系统未暴漏的方法1. 使用 performSelector: 方法performSelector: 方法可以动态调用对象的方法，即使这些方法在编译时不可见。 1234SEL privateSelector = NSSelectorFromString(@\"privateMethod\");if ([object respondsToSelector:privateSelector]) { [object performSelector:privateSelector];} 2. 使用 Runtime 动态调用Objective-C 的 Runtime 库提供了一些函数，可以用来动态调用方法。 示例代码：调用私有方法12345678#import &lt;objc/runtime.h&gt;SEL privateSelector = NSSelectorFromString(@\"privateMethod\");if ([object respondsToSelector:privateSelector]) { IMP imp = [object methodForSelector:privateSelector]; void (*func)(id, SEL) = (void *)imp; func(object, privateSelector);} 示例代码：访问私有属性1234#import &lt;objc/runtime.h&gt;Ivar ivar = class_getInstanceVariable([object class], \"_privateProperty\");id privateValue = object_getIvar(object, ivar); 3. 使用 dlsym 函数如果你知道私有 API 的符号名称，可以使用 dlsym 函数来获取函数指针，并调用它。 12345678910#import &lt;dlfcn.h&gt;void *handle = dlopen(NULL, RTLD_LAZY);if (handle) { void (*privateFunction)(void) = dlsym(handle, \"privateFunctionName\"); if (privateFunction) { privateFunction(); } dlclose(handle);} 4.怎么改一个类的只读属性方法一：通过 KVC (Key-Value Coding)Key-Value Coding (KVC) 是一种间接访问对象属性的方法。即使属性是只读的，也可以通过 KVC 修改它的值。 示例： 1234567891011121314151617181920212223@interface MyClass : NSObject@property (nonatomic, strong, readonly) NSString *readonlyProperty;@end@implementation MyClass { NSString *_readonlyProperty;}- (instancetype)init { self = [super init]; if (self) { _readonlyProperty = @\"Initial Value\"; } return self;}@end// 修改只读属性MyClass *myObject = [[MyClass alloc] init];NSLog(@\"Before: %@\", myObject.readonlyProperty);[myObject setValue:@\"New Value\" forKey:@\"readonlyProperty\"];NSLog(@\"After: %@\", myObject.readonlyProperty); 方法二：使用运行时函数在 Objective-C 中，可以使用运行时函数来修改属性的值。 示例： 123456789101112131415161718192021222324252627#import &lt;objc/runtime.h&gt;@interface MyClass : NSObject@property (nonatomic, strong, readonly) NSString *readonlyProperty;@end@implementation MyClass { NSString *_readonlyProperty;}- (instancetype)init { self = [super init]; if (self) { _readonlyProperty = @\"Initial Value\"; } return self;}@end// 修改只读属性MyClass *myObject = [[MyClass alloc] init];NSLog(@\"Before: %@\", myObject.readonlyProperty);Ivar ivar = class_getInstanceVariable([MyClass class], \"_readonlyProperty\");object_setIvar(myObject, ivar, @\"New Value\");NSLog(@\"After: %@\", myObject.readonlyProperty); 方法三：子类化和重写 Getter 方法通过创建一个子类并重写只读属性的 getter 方法，可以控制属性的值。 示例： 123456789101112131415161718192021222324252627282930313233343536373839@interface MyClass : NSObject@property (nonatomic, strong, readonly) NSString *readonlyProperty;@end@implementation MyClass { NSString *_readonlyProperty;}- (instancetype)init { self = [super init]; if (self) { _readonlyProperty = @\"Initial Value\"; } return self;}@end@interface MyClassSubclass : MyClass@end@implementation MyClassSubclass { NSString *_customValue;}- (NSString *)readonlyProperty { return _customValue ? _customValue : [super readonlyProperty];}- (void)setCustomValue:(NSString *)value { _customValue = value;}@end// 修改只读属性MyClassSubclass *myObject = [[MyClassSubclass alloc] init];NSLog(@\"Before: %@\", myObject.readonlyProperty);[myObject setCustomValue:@\"New Value\"];NSLog(@\"After: %@\", myObject.readonlyProperty); 5.消息机制1. 基本概念 消息（Message）：在 Objective-C 中，方法调用被称为“发送消息”。发送消息的语法是 [receiver message]。 接收者（Receiver）：接收并处理消息的对象。 选择器（Selector）：表示方法名称的一个数据类型，类型为 SEL。选择器是方法的唯一标识符。 2. 消息发送流程当向一个对象发送消息时，Objective-C 的运行时系统会进行一系列步骤来查找并调用相应的方法。以下是消息发送的基本流程： 消息发送：当代码中调用 [object message] 时，编译器将其转换为 objc_msgSend 函数调用。 查找方法：objc_msgSend 函数会根据消息的选择器（SEL）在对象的类及其父类的方法列表中查找对应的方法实现。 调用方法：找到方法实现后，objc_msgSend 函数会调用该方法。如果没有找到方法实现，则会触发消息转发机制（Message Forwarding）。 3. objc_msgSend 函数objc_msgSend 是 Objective-C 运行时系统的核心函数之一，负责消息的分发。其原型如下： 1void objc_msgSend(id self, SEL _cmd, ...); self：消息的接收者。 _cmd：消息的选择器。 可变参数：方法的参数。 4. 消息转发机制当 objc_msgSend 无法在类的方法列表中找到与选择器匹配的方法时，会触发消息转发机制。消息转发机制包括以下几个步骤： 4.1 动态方法解析首先，运行时系统会尝试动态方法解析，通过调用类的 +resolveInstanceMethod: 或 +resolveClassMethod: 方法来添加方法实现。如果方法实现被动态添加，消息发送会重新开始。 1234567+ (BOOL)resolveInstanceMethod:(SEL)sel { if (sel == @selector(myMethod)) { class_addMethod([self class], sel, (IMP)myMethodIMP, \"v@:\"); return YES; } return [super resolveInstanceMethod:sel];} 4.2 快速转发如果动态方法解析未能添加方法实现，运行时系统会调用 -forwardingTargetForSelector: 方法。这个方法允许将消息转发给另一个对象。 123456- (id)forwardingTargetForSelector:(SEL)aSelector { if (aSelector == @selector(myMethod)) { return someOtherObject; } return [super forwardingTargetForSelector:aSelector];} 4.3 常规转发如果快速转发也未能处理消息，运行时系统会调用 -methodSignatureForSelector: 和 -forwardInvocation: 方法。首先，通过 -methodSignatureForSelector: 获取方法签名，然后通过 -forwardInvocation: 进行消息转发。 123456789101112131415- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector { if (aSelector == @selector(myMethod)) { return [NSMethodSignature signatureWithObjCTypes:\"v@:\"]; } return [super methodSignatureForSelector:aSelector];}- (void)forwardInvocation:(NSInvocation *)anInvocation { SEL sel = [anInvocation selector]; if ([someOtherObject respondsToSelector:sel]) { [anInvocation invokeWithTarget:someOtherObject]; } else { [super forwardInvocation:anInvocation]; }} 5. 消息缓存为了提高消息发送的性能，Objective-C 运行时系统使用方法缓存（Method Caching）。当一个方法第一次被调用时，其实现会被缓存起来，下次调用相同的方法时，可以直接从缓存中获取，而不需要重新查找。 6.Runloop 流程，用 Runloop 做过什么？卡顿检测，发生卡顿后怎么获取堆栈信息？堆栈信息的原理Runloop 基本概念RunLoop 是一个事件处理循环，用来调度和处理任务。它可以在没有任务时使线程进入休眠状态，从而节省资源；有任务时则立即唤醒线程处理任务。RunLoop 实质上是一个对象，这个对象管理着其需要处理的事件和消息，并提供一个入口函数来执行这个事件处理循环。 Runloop 的基本流程RunLoop 的基本流程可以概括为以下几个步骤： 进入循环：调用 CFRunLoopRun 或者 -[NSRunLoop run] 方法。 通知观察者：通知即将进入 RunLoop 事件处理循环。 检查 Timer：检查是否有定时器（Timer）需要处理。 处理输入源：处理输入源（Input Source），比如用户触摸事件，UI事件等。 通知观察者：通知即将进入休眠。 休眠：如果没有事件需要处理，线程进入休眠状态，等待事件发生。 唤醒：收到外部事件（如 Timer 到时间、输入源事件）唤醒线程。 通知观察者：通知即将处理事件。 处理事件：处理 Timer 或输入源事件。 通知观察者：通知事件已处理完成。 重复或退出：重复上述步骤，或根据特定条件退出循环。 RunLoop 在 iOS 中的应用1. 保持线程活跃RunLoop 的一个典型应用是保持线程活跃。默认情况下，子线程在任务完成后会立即退出。通过 RunLoop，可以让子线程在没有任务时处于休眠状态，但不会退出，等待新的任务到来。 示例代码： 12345678910111213- (void)startThread { NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(threadEntryPoint) object:nil]; [thread start];}- (void)threadEntryPoint { @autoreleasepool { [[NSThread currentThread] setName:@\"MyThread\"]; NSRunLoop *runLoop = [NSRunLoop currentRunLoop]; [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode]; [runLoop run]; // 进入 RunLoop }} 2. 处理定时任务RunLoop 可以用来处理定时任务，比如定时器。通过将 NSTimer 添加到 RunLoop，可以在指定的时间间隔触发任务。 示例代码： 12345678- (void)scheduleTimer { NSTimer *timer = [NSTimer timerWithTimeInterval:1.0 target:self selector:@selector(timerFired:) userInfo:nil repeats:YES]; [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];}- (void)timerFired:(NSTimer *)timer { NSLog(@\"Timer fired!\");} 3. 处理网络请求在处理网络请求时，可以使用 RunLoop 来保持线程活跃，等待网络请求完成。NSURLConnection 和 NSURLSession 都使用 RunLoop 来处理网络事件。 4. 处理输入源事件RunLoop 可以用来处理输入源事件，比如用户触摸事件、UI事件等。 7.GCD 都用了哪些？网络请求 A 和 B 都回调后，请求 C，如何实现？除了 dispatch_groupGrand Central Dispatch (GCD) 是苹果公司推出的一种用于并发编程的技术，旨在优化多核设备上的代码执行。GCD 提供了一种简单易用的 API 来管理并发任务，并且能够自动利用系统资源进行优化。以下是一些常见的 GCD 使用场景： 1. 异步任务GCD 的一个主要用途就是在后台执行耗时任务，从而避免阻塞主线程，提高应用的响应速度。 示例代码： 123456789dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ // 执行耗时任务 NSData *data = [self fetchDataFromServer]; // 回到主线程更新 UI dispatch_async(dispatch_get_main_queue(), ^{ [self updateUIWithData:data]; });}); 2. 并行任务GCD 可以轻松地创建并行任务，从而充分利用多核处理器的计算能力。 示例代码： 12345678910dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);dispatch_async(queue, ^{ [self performTask1];});dispatch_async(queue, ^{ [self performTask2];});dispatch_async(queue, ^{ [self performTask3];}); 3. 同步任务尽管异步任务更常见，有时也需要同步任务来确保任务按顺序执行。 示例代码： 123dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ [self performSynchronousTask];}); 4. 延迟执行GCD 提供了简洁的 API 来延迟执行任务。 示例代码： 1234dispatch_time_t delay = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5.0 * NSEC_PER_SEC));dispatch_after(delay, dispatch_get_main_queue(), ^{ [self performDelayedTask];}); 5. 一次性代码有时我们需要确保某段代码只执行一次，这时候可以使用 dispatch_once。 示例代码： 1234static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^{ [self initializeOnce];}); 6. 调度组调度组可以用来监控一组任务的完成状态，通常用于需要等待多项任务全部完成后才能继续下一步操作的场景。 示例代码： 12345678910111213141516dispatch_group_t group = dispatch_group_create();dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);dispatch_group_async(group, queue, ^{ [self performTask1];});dispatch_group_async(group, queue, ^{ [self performTask2];});dispatch_group_async(group, queue, ^{ [self performTask3];});dispatch_group_notify(group, dispatch_get_main_queue(), ^{ [self allTasksCompleted];}); 7. 信号量信号量可以用来控制并发访问资源的数量，适用于需要限制并发任务数量的场景。 示例代码： 1234567891011121314dispatch_semaphore_t semaphore = dispatch_semaphore_create(2); // 允许同时执行两个并发任务for (int i = 0; i &lt; 5; i++) { dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); // 执行任务 NSLog(@\"Task %d started\", i); sleep(2); // 模拟耗时任务 NSLog(@\"Task %d completed\", i); dispatch_semaphore_signal(semaphore); });} 8. Barrier BlockBarrier Block 用于在并发队列中插入一个障碍，确保在障碍前提交的所有任务执行完成后，才执行障碍后的任务。 示例代码： 12345678910111213141516dispatch_queue_t queue = dispatch_queue_create(\"com.example.myqueue\", DISPATCH_QUEUE_CONCURRENT);dispatch_async(queue, ^{ [self performReadTask1];});dispatch_async(queue, ^{ [self performReadTask2];});dispatch_barrier_async(queue, ^{ [self performWriteTask];});dispatch_async(queue, ^{ [self performReadTask3];}); 9. Dispatch SourceDispatch Source 是一种非常强大的工具，可以用来处理各种系统事件，如文件变化、定时器、信号等。 示例代码（定时器）： 123456dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue());dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, 1.0 * NSEC_PER_SEC, 0.1 * NSEC_PER_SEC);dispatch_source_set_event_handler(timer, ^{ NSLog(@\"Timer fired\");});dispatch_resume(timer); 10. Dispatch Work Item使用 dispatch_block_t 创建可取消的工作项。 示例代码： 12345678910dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);dispatch_block_t workItem = dispatch_block_create(0, ^{ // 执行任务 NSLog(@\"Work item executed\");});dispatch_async(queue, workItem);// 取消工作项dispatch_block_cancel(workItem); 在 iOS 开发中，有时候需要等待多个网络请求完成后再进行进一步操作，比如发起新的网络请求。为了实现这种需求，可以使用多种方法，包括 GCD（Grand Central Dispatch）、NSOperationQueue 和第三方库如 PromiseKit 或 Combine。 方法一：使用 GCD (Grand Central Dispatch)GCD 提供了一种简单的方法来同步多个异步任务。可以使用 dispatch_group 来实现等待多个任务完成后执行下一步操作。 12345678910111213141516171819202122dispatch_group_t group = dispatch_group_create();// 开始请求Adispatch_group_enter(group);[self performRequestAWithCompletion:^(id response, NSError *error) { // 处理请求A的响应 dispatch_group_leave(group);}];// 开始请求Bdispatch_group_enter(group);[self performRequestBWithCompletion:^(id response, NSError *error) { // 处理请求B的响应 dispatch_group_leave(group);}];// 当请求A和请求B都完成后，执行请求Cdispatch_group_notify(group, dispatch_get_main_queue(), ^{ [self performRequestCWithCompletion:^(id response, NSError *error) { // 处理请求C的响应 }];}); 方法二：使用 NSOperationQueueNSOperationQueue 提供了一种更为面向对象的方法来管理异步任务的依赖关系。 1234567891011121314151617181920212223242526272829NSOperationQueue *queue = [[NSOperationQueue alloc] init];queue.maxConcurrentOperationCount = 2; // 设置最大并发数NSBlockOperation *operationA = [NSBlockOperation blockOperationWithBlock:^{ [self performRequestAWithCompletion:^(id response, NSError *error) { // 处理请求A的响应 }];}];NSBlockOperation *operationB = [NSBlockOperation blockOperationWithBlock:^{ [self performRequestBWithCompletion:^(id response, NSError *error) { // 处理请求B的响应 }];}];NSBlockOperation *operationC = [NSBlockOperation blockOperationWithBlock:^{ [self performRequestCWithCompletion:^(id response, NSError *error) { // 处理请求C的响应 }];}];// 设置依赖关系[operationC addDependency:operationA];[operationC addDependency:operationB];// 将操作添加到队列[queue addOperation:operationA];[queue addOperation:operationB];[queue addOperation:operationC]; 方法三：使用第三方库 PromiseKitPromiseKit 提供了一种现代的、链式的方式来处理异步操作。 首先，确保你已经安装了 PromiseKit。 1pod &apos;PromiseKit&apos;, &apos;~&gt; 6.0&apos; 然后，你可以使用类似以下的代码来实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#import &lt;PromiseKit/PromiseKit.h&gt;- (AnyPromise *)performRequestA { return [AnyPromise promiseWithResolverBlock:^(PMKResolver resolve) { [self performRequestAWithCompletion:^(id response, NSError *error) { if (error) { resolve(error); } else { resolve(response); } }]; }];}- (AnyPromise *)performRequestB { return [AnyPromise promiseWithResolverBlock:^(PMKResolver resolve) { [self performRequestBWithCompletion:^(id response, NSError *error) { if (error) { resolve(error); } else { resolve(response); } }]; }];}- (AnyPromise *)performRequestC { return [AnyPromise promiseWithResolverBlock:^(PMKResolver resolve) { [self performRequestCWithCompletion:^(id response, NSError *error) { if (error) { resolve(error); } else { resolve(response); } }]; }];}- (void)makeRequests { [When(@[[self performRequestA], [self performRequestB]]) then:^id(id results) { return [self performRequestC]; }].catch(^(NSError *error) { // 处理错误 });} 方法四：使用 Combine（适用于 iOS 13 及以上）如果你在使用 iOS 13 及以上版本，可以使用 Combine 框架来处理异步任务。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import Combinefunc performRequestA() -&gt; Future&lt;Data, Error&gt; { return Future { promise in // 模拟网络请求A self.performRequestA { (data, error) in if let error = error { promise(.failure(error)) } else { promise(.success(data)) } } }}func performRequestB() -&gt; Future&lt;Data, Error&gt; { return Future { promise in // 模拟网络请求B self.performRequestB { (data, error) in if let error = error { promise(.failure(error)) } else { promise(.success(data)) } } }}func performRequestC() -&gt; Future&lt;Data, Error&gt; { return Future { promise in // 模拟网络请求C self.performRequestC { (data, error) in if let error = error { promise(.failure(error)) } else { promise(.success(data)) } } }}let cancellable = Publishers.Zip(performRequestA(), performRequestB()) .flatMap { _ in return performRequestC() } .sink(receiveCompletion: { completion in switch completion { case .failure(let error): print(\"Error: \\(error)\") case .finished: print(\"All requests finished successfully\") } }, receiveValue: { data in print(\"Received data: \\(data)\") }) 总结 GCD: 适用于需要轻量级并发管理的场景。 NSOperationQueue: 提供了更为面向对象的并发管理方式，适用于复杂任务依赖关系的场景。 PromiseKit: 提供了一种现代的链式异步处理方式，代码更为简洁。 Combine: 适用于 iOS 13 及以上版本，提供了响应式编程的方式来处理异步任务。 选择哪种方法取决于你的项目需求和个人偏好。希望这些示例能够帮助你实现网络请求 A 和 B 都回调后再请求 C 的需求。 8.可变数组 NSMutableArray，在头部插入元素，iOS 系统做了什么优化在 iOS 系统中，NSMutableArray 是一个动态数组，它在插入和删除元素时会进行一些优化，但具体的优化细节是由底层实现决定的，这些实现细节通常是私有的，Apple 并未公开详细的内部实现。不过，我们可以推测和总结一些常见的优化策略，这些策略可能会在 NSMutableArray 中使用。 1. 内存预分配和扩展NSMutableArray 会预先分配内存来容纳多个元素，以减少频繁的内存分配操作。当数组需要扩展容量时，它可能会一次性分配比当前需求更多的内存空间，以备将来使用。这种策略可以减少内存分配和释放的频率，提高性能。 2. 元素移动优化在数组头部插入元素时，所有现有元素都需要向后移动一个位置。为了减少内存拷贝的开销，系统可能会使用高效的内存拷贝函数（如 memmove）来移动元素。memmove 函数在处理重叠内存区域时比 memcpy 更安全和高效。 3. 数据结构优化尽管 NSMutableArray 主要使用动态数组来实现，但底层可能会结合使用其他数据结构（如链表）来优化特定操作的性能。例如，为了优化头部插入操作，系统可能会在特定情况下使用双向链表或者其他更适合插入操作的结构。 4. 缓存局部性NSMutableArray 可能会利用缓存局部性来提高性能。通过将相邻的元素存储在接近的内存地址上，可以提高缓存命中率，从而提高内存访问速度。 5. 并发处理优化虽然 NSMutableArray 本身不是线程安全的，但在一些多线程环境中，系统可能会使用锁、原子操作或者其他并发控制机制来优化并发访问的性能。 总的来说，虽然我们无法确切知道 NSMutableArray 的内部优化细节，但可以推测它会采用一些常见的优化策略来提升性能。了解这些优化策略有助于我们在开发过程中做出更好的性能优化决策。 9.Tagged PointerTagged Pointer 的基本原理Tagged Pointer 的基本原理是利用指针的高位位元来存储数据，而不是使用这些位元来存储内存地址。具体来说： 在 64 位系统中，指针有 64 位，其中通常只有低 48 位用于存储内存地址，高 16 位未被使用。 Tagged Pointer 技术利用这些未使用的高位位元来存储数据。 如何识别 Tagged Pointer在 Objective-C 中，Tagged Pointer 使用最高位（最高位为 1）来标识是否是 Tagged Pointer。例如： 0x8000000000000000：最高位为 1，表示这是一个 Tagged Pointer。 0x0000000000000000：最高位为 0，表示这是一个普通的指针。 Tagged Pointer 的数据存储Tagged Pointer 可以存储多种类型的数据，包括： 小整数：直接在指针中存储整数值。 小浮点数：直接在指针中存储浮点数值。 小字符串：直接在指针中存储字符串数据。 10.NSString 存储在哪里，引用计数存储哪里？1. 常量字符串常量字符串是指在代码中直接使用的字符串字面量，例如： 1NSString *str = @\"Hello, World!\"; 这些字符串字面量通常会被存储在程序的只读数据段（Read-Only Data Segment）中。这意味着它们在编译时已经确定，并且在程序运行时不会被修改。它们的内存分配通常是由编译器在编译时完成的。 2. 动态字符串动态字符串是指在程序运行时生成或拼接的字符串，例如： 12NSString *str1 = [NSString stringWithFormat:@\"Hello, %@\", @\"World\"];NSString *str2 = [str1 mutableCopy]; 这些字符串是在程序运行时动态分配内存的。它们通常存储在堆（Heap）中，并由 NSString 和 NSMutableString 的内部实现来管理。 3. 内存管理在 Objective-C 中，内存管理主要通过引用计数（Reference Counting）来完成。NSString 对象也遵循这一规则： ARC（Automatic Reference Counting）: 在使用 ARC 的情况下，编译器会自动插入内存管理代码，负责增加和减少引用计数。 手动内存管理（MRC）: 在不使用 ARC 的情况下，开发者需要手动管理内存，通过 retain、release 和 autorelease 方法来管理引用计数。 4. 内部实现NSString 是一个抽象类，其具体实现有多个子类，这些子类优化了不同类型的字符串存储和操作。常见的子类包括： __NSCFConstantString: 用于存储常量字符串。 __NSCFString: 一般用于动态创建的不可变字符串。 NSMutableString: 用于可变字符串。 在实际运行时，NSString 对象的具体存储位置和方式可能会因为优化而有所不同。例如，短字符串可能会被存储在栈上，以提高性能。 5. 字符串缓存为了提高性能，NSString 类可能会使用一些内部缓存机制。例如，常量字符串可能会被缓存，以避免重复分配内存。这种优化在底层是由 Core Foundation 框架实现的。 6. Foundation 框架与 Core FoundationNSString 是 Foundation 框架的一部分，但其底层实现依赖于 Core Foundation 中的 CFString。CFString 提供了字符串操作的底层实现，而 NSString 则是在其基础上提供了面向对象的接口。 总结 常量字符串: 存储在程序的只读数据段中。 动态字符串: 在程序运行时存储在堆中。 内存管理: 通过引用计数管理，无论是 ARC 还是 MRC。 内部实现: 由多个子类优化不同类型的字符串，底层依赖于 Core Foundation 的 CFString。 11.dealloc 流程12.避免哈希碰撞的几种方法？1. 更好的哈希函数选择一个更好的哈希函数可以极大地减少哈希碰撞的可能性。一个好的哈希函数应具有以下特性： 均匀性：能够将输入数据均匀地分布到哈希表的各个位置。 确定性：相同的输入总是产生相同的哈希值。 高效性：计算哈希值的时间复杂度应尽可能低。 常见的哈希函数包括： MD5 SHA-1 SHA-256 在某些特定场景下，自定义的哈希函数也可能是一个有效的选择。 2. 增大哈希表的大小通过增大哈希表的大小，可以减少哈希碰撞的概率。哈希表的大小通常是一个素数，这样可以更均匀地分布哈希值。 3. 链地址法（Separate Chaining）链地址法是处理哈希碰撞的一种常见方法。每个哈希表的槽（bucket）都包含一个链表（或其他数据结构），用于存储具有相同哈希值的多个元素。 4. 开放定址法（Open Addressing）开放定址法通过在发生碰撞时寻找下一个空闲槽来存储元素。常见的开放定址法包括线性探测、二次探测和双重散列。 线性探测线性探测在发生碰撞时，按固定步长（通常为 1）依次探测下一个槽，直到找到空闲槽为止。 二次探测二次探测在发生碰撞时，按二次方序列探测下一个槽。 1index = (index + i^2) % self.size 双重散列双重散列使用两个不同的哈希函数来计算探测序列。 1index = (hash1(key) + i * hash2(key)) % self.size 5. 再哈希法（Rehashing）再哈希法在发生碰撞时，使用另一个哈希函数重新计算哈希值，直到找到空闲槽为止。 6. 动态调整哈希表大小在哈希表负载因子（Load Factor）达到一定阈值时，动态调整哈希表的大小。负载因子是已存储元素数量与哈希表大小的比值。当负载因子过高时，增大哈希表的大小并重新哈希所有元素。 13.mach-o 了解吗？存储的方法信息可以无用代码检测？段迁移？Mach-O（Mach Object 文件格式）是 macOS 和 iOS 操作系统上使用的一种文件格式，用于可执行文件、目标代码、动态库、内核转储等。Mach-O 格式提供了一种灵活且强大的方式来描述程序的结构，支持多种架构（如 x86_64、arm64）和多种类型的文件（如可执行文件、动态库）。以下是关于 Mach-O 文件格式的详细介绍： Mach-O 文件的基本结构Mach-O 文件由多个部分组成，每个部分都有特定的用途和结构。主要部分包括： Header（头部）：包含文件的基本信息，如文件类型、CPU 架构、加载命令数量等。 Load Commands（加载命令）：描述文件的各个部分如何加载到内存中。这些命令包括段的描述、动态库的引用、符号表的位置等。 Segments（段）：包含实际的代码和数据。每个段包含多个 section（节），每个节存储特定类型的数据，如代码节、数据节、符号表等。 Sections（节）：段的子部分，存储不同类型的数据，如可执行代码、只读数据、可写数据等。 详细结构1. Header（头部）头部是 Mach-O 文件的开始部分，包含文件的基本信息。头部的结构定义如下： 123456789struct mach_header { uint32_t magic; // 魔数，标识文件格式 cpu_type_t cputype; // CPU 类型 cpu_subtype_t cpusubtype;// CPU 子类型 uint32_t filetype; // 文件类型（如可执行文件、动态库） uint32_t ncmds; // 加载命令的数量 uint32_t sizeofcmds; // 所有加载命令的总大小 uint32_t flags; // 标志位}; 2. Load Commands（加载命令）加载命令描述文件的各个部分如何加载到内存中。常见的加载命令包括： LC_SEGMENT：描述一个段。 LC_SYMTAB：描述符号表的位置。 LC_DYSYMTAB：描述动态符号表的位置。 LC_LOAD_DYLIB：描述需要加载的动态库。 每个加载命令的基本结构如下： 1234struct load_command { uint32_t cmd; // 加载命令的类型 uint32_t cmdsize; // 加载命令的大小}; 3. Segments（段）段是 Mach-O 文件中的主要数据部分，每个段包含多个节。常见的段包括： __TEXT：包含可执行代码和只读数据。 __DATA：包含可写数据。 __LINKEDIT：包含符号表和其他链接信息。 段的基本结构如下： 12345678910111213struct segment_command { uint32_t cmd; // LC_SEGMENT uint32_t cmdsize; // 加载命令的大小 char segname[16]; // 段的名称 uint32_t vmaddr; // 段在虚拟内存中的地址 uint32_t vmsize; // 段的大小 uint32_t fileoff; // 段在文件中的偏移 uint32_t filesize; // 段在文件中的大小 vm_prot_t maxprot; // 段的最大保护 vm_prot_t initprot; // 段的初始保护 uint32_t nsects; // 段中节的数量 uint32_t flags; // 段的标志}; 4. Sections（节）节是段的子部分，存储具体类型的数据。每个节的基本结构如下： 12345678910111213struct section { char sectname[16]; // 节的名称 char segname[16]; // 段的名称 uint32_t addr; // 节在虚拟内存中的地址 uint32_t size; // 节的大小 uint32_t offset; // 节在文件中的偏移 uint32_t align; // 节的对齐 uint32_t reloff; // 重定位表的偏移 uint32_t nreloc; // 重定位表的数量 uint32_t flags; // 节的标志 uint32_t reserved1; // 保留字段 uint32_t reserved2; // 保留字段}; Mach-O 文件类型Mach-O 文件有多种类型，主要包括： MH_EXECUTE：可执行文件。 MH_DYLIB：动态库。 MH_BUNDLE：可加载的代码包。 MH_OBJECT：目标文件。 MH_DYLINKER：动态链接器。 使用工具查看 Mach-O 文件macOS 提供了一些工具来查看和分析 Mach-O 文件： otool ：用于显示 Mach-O 文件的头部、段、节、符号表等信息。 123otool -hV MyApp.app/MyApp # 显示头部信息otool -L MyApp.app/MyApp # 显示动态库依赖otool -tV MyApp.app/MyApp # 显示反汇编代码 nm ：用于显示 Mach-O 文件中的符号表。 1nm MyApp.app/MyApp dyldinfo ：用于显示动态链接相关信息。 1dyldinfo -all MyApp.app/MyApp 总结Mach-O 是 macOS 和 iOS 上使用的一种复杂而灵活的文件格式，用于描述可执行文件、动态库等。它通过头部、加载命令、段和节组织数据，支持多种文件类型和 CPU 架构。理解 Mach-O 文件格式有助于进行底层调试、性能优化和安全分析。macOS 提供了一些工具，如 otool 和 nm，可以用来查看和分析 Mach-O 文件的结构和内容。 14.脚本检测未使用代码原理15.Render 渲染流程iOS 渲染流程是一个复杂且高效的过程，它负责将应用的界面呈现到屏幕上。理解这个流程有助于优化应用的性能和用户体验。以下是 iOS 渲染流程的概要： 1. 应用层（Application Layer）应用层是 iOS 应用的最上层，包括应用的逻辑、UI 视图控制器（UIViewController）、视图（UIView）等。开发者主要在这一层进行开发。 2. Core AnimationCore Animation 是 iOS 渲染的核心技术，它负责管理和执行所有的动画和视图层次结构（Layer Tree）。Core Animation 使用双缓冲技术来确保动画的流畅性。主要包括以下几个组成部分： Layer Tree: 由 CALayer 对象组成的层次结构，每个 UIView 对应一个 CALayer。 Display Tree: 由 Core Animation 生成的用于实际显示内容的树。 Render Tree: 用于渲染的最终树，由 Core Animation 发送给渲染服务器（Render Server）。 3. 渲染服务器（Render Server）渲染服务器是一个独立的进程，负责接收来自 Core Animation 的 Render Tree，并将其转换为 GPU 可以理解的指令。渲染服务器会将这些指令发送给 GPU 进行实际的渲染。 4. GPU 渲染GPU（图形处理单元）接收到渲染指令后，会执行以下操作： 顶点着色（Vertex Shading）: 处理顶点数据，包括位置、颜色、纹理等信息。 图元组装（Primitive Assembly）: 将顶点连接成图元（如三角形）。 光栅化（Rasterization）: 将图元转换为片元（Pixel）。 片元着色（Fragment Shading）: 计算每个片元的颜色和其他属性。 帧缓存操作（Frame Buffer Operations）: 将最终的片元数据写入帧缓存（Frame Buffer）。 5. 显示层（Display Layer）最终的帧缓存数据会被传递到显示层，由显示层将其显示在屏幕上。iOS 使用 VSync（垂直同步）信号来协调显示更新，以确保屏幕刷新和渲染同步，避免画面撕裂。 渲染流程的详细步骤 视图更新（View Update）: 应用程序修改视图或图层属性（如位置、大小、颜色等）。 UIView 的属性变化会触发 CALayer 的相应变化。 布局和显示（Layout and Display）: UIView 布局系统会重新计算视图的布局。 CALayer 会根据视图的变化更新自己的属性。 Core Animation 动画处理（Core Animation Animation Handling）: Core Animation 会将动画应用到相关的 CALayer 上。 根据动画时间轴生成 Display Tree。 Render Tree 生成（Render Tree Generation）: Core Animation 从 Display Tree 生成 Render Tree。 Render Tree 包含了所有需要渲染的信息。 Render Server 渲染（Render Server Rendering）: Core Animation 将 Render Tree 发送给渲染服务器。 渲染服务器将 Render Tree 转换为 GPU 指令。 GPU 渲染（GPU Rendering）: GPU 执行顶点着色、图元组装、光栅化、片元着色和帧缓存操作。 渲染结果存储在帧缓存中。 显示更新（Display Update）: 帧缓存内容通过显示层显示在屏幕上。 VSync 信号确保显示更新和屏幕刷新同步。 性能优化理解 iOS 渲染流程有助于优化应用性能，以下是一些常见的优化策略： 减少布局计算和视图层次结构的复杂度。 使用合适的图层类型（如 CAShapeLayer、CATextLayer）。 避免频繁的视图更新和动画。 使用异步绘制技术（如 drawRect: 方法）。 避免不必要的离屏渲染（Offscreen Rendering）。 通过这些优化策略，可以减少 CPU 和 GPU 的负担，提高应用的流畅性和响应速度。 16.UIView 动画和 CAAnimation 动画有什么联系？虽然 UIView 动画和 CAAnimation 动画在使用上有区别，但它们的底层机制是有联系的。UIView 动画实际上是对 CAAnimation 的封装和简化。当你使用 UIView 动画时，UIKit 会在内部创建相应的 CAAnimation 对象，并将其添加到视图的 CALayer 上。 示例：123UIView.animate(withDuration: 1.0, animations: { myView.alpha = 0.0}) 上面的代码等价于： 123456let animation = CABasicAnimation(keyPath: \"opacity\")animation.fromValue = 1.0animation.toValue = 0.0animation.duration = 1.0myView.layer.add(animation, forKey: \"opacityAnimation\")myView.layer.opacity = 0.0 结论UIView 动画是对 CAAnimation 的封装，提供了更高层次的接口，使得简单动画的实现更加便捷，而 CAAnimation 提供了更强大的功能和更精细的控制，适合复杂的动画需求。在实际开发中，可以根据具体的动画需求选择合适的动画方式。 17.项目亮点","link":"/百融云创面试题/"}],"tags":[{"name":"面试","slug":"面试","link":"/tags/面试/"},{"name":"算法","slug":"算法","link":"/tags/算法/"},{"name":"二叉树","slug":"二叉树","link":"/tags/二叉树/"},{"name":"天眼查","slug":"天眼查","link":"/tags/天眼查/"},{"name":"转转","slug":"转转","link":"/tags/转转/"},{"name":"美团","slug":"美团","link":"/tags/美团/"},{"name":"ofo","slug":"ofo","link":"/tags/ofo/"},{"name":"小黄车","slug":"小黄车","link":"/tags/小黄车/"},{"name":"一点资讯","slug":"一点资讯","link":"/tags/一点资讯/"},{"name":"技术点","slug":"技术点","link":"/tags/技术点/"},{"name":"乐为金融","slug":"乐为金融","link":"/tags/乐为金融/"},{"name":"58","slug":"58","link":"/tags/58/"},{"name":"人人车","slug":"人人车","link":"/tags/人人车/"},{"name":"全民短视频","slug":"全民短视频","link":"/tags/全民短视频/"},{"name":"十点读书","slug":"十点读书","link":"/tags/十点读书/"},{"name":"墨迹天气","slug":"墨迹天气","link":"/tags/墨迹天气/"},{"name":"元石","slug":"元石","link":"/tags/元石/"},{"name":"京东","slug":"京东","link":"/tags/京东/"},{"name":"太一云","slug":"太一云","link":"/tags/太一云/"},{"name":"区块链","slug":"区块链","link":"/tags/区块链/"},{"name":"好未来","slug":"好未来","link":"/tags/好未来/"},{"name":"平安","slug":"平安","link":"/tags/平安/"},{"name":"开果","slug":"开果","link":"/tags/开果/"},{"name":"面试题","slug":"面试题","link":"/tags/面试题/"},{"name":"必要商城","slug":"必要商城","link":"/tags/必要商城/"},{"name":"微店","slug":"微店","link":"/tags/微店/"},{"name":"快狗打车","slug":"快狗打车","link":"/tags/快狗打车/"},{"name":"恒天财富","slug":"恒天财富","link":"/tags/恒天财富/"},{"name":"新浪","slug":"新浪","link":"/tags/新浪/"},{"name":"乐居","slug":"乐居","link":"/tags/乐居/"},{"name":"普华商学院","slug":"普华商学院","link":"/tags/普华商学院/"},{"name":"朗播网","slug":"朗播网","link":"/tags/朗播网/"},{"name":"搜狐","slug":"搜狐","link":"/tags/搜狐/"},{"name":"狐友","slug":"狐友","link":"/tags/狐友/"},{"name":"核桃编程","slug":"核桃编程","link":"/tags/核桃编程/"},{"name":"汽车之家","slug":"汽车之家","link":"/tags/汽车之家/"},{"name":"棵朵","slug":"棵朵","link":"/tags/棵朵/"},{"name":"滴滴","slug":"滴滴","link":"/tags/滴滴/"},{"name":"笔试题","slug":"笔试题","link":"/tags/笔试题/"},{"name":"登云美业","slug":"登云美业","link":"/tags/登云美业/"},{"name":"百易图","slug":"百易图","link":"/tags/百易图/"},{"name":"百度","slug":"百度","link":"/tags/百度/"},{"name":"美团优选","slug":"美团优选","link":"/tags/美团优选/"},{"name":"腰果公考","slug":"腰果公考","link":"/tags/腰果公考/"},{"name":"自如","slug":"自如","link":"/tags/自如/"},{"name":"苏宁","slug":"苏宁","link":"/tags/苏宁/"},{"name":"货拉拉","slug":"货拉拉","link":"/tags/货拉拉/"},{"name":"链表","slug":"链表","link":"/tags/链表/"},{"name":"达达","slug":"达达","link":"/tags/达达/"},{"name":"京东到家","slug":"京东到家","link":"/tags/京东到家/"},{"name":"高思教育","slug":"高思教育","link":"/tags/高思教育/"},{"name":"闲徕互娱","slug":"闲徕互娱","link":"/tags/闲徕互娱/"},{"name":"首汽租车","slug":"首汽租车","link":"/tags/首汽租车/"},{"name":"首汽","slug":"首汽","link":"/tags/首汽/"},{"name":"京东搜索","slug":"京东搜索","link":"/tags/京东搜索/"},{"name":"底层原理","slug":"底层原理","link":"/tags/底层原理/"},{"name":"OC语法","slug":"OC语法","link":"/tags/OC语法/"},{"name":"字节跳动","slug":"字节跳动","link":"/tags/字节跳动/"},{"name":"度小满","slug":"度小满","link":"/tags/度小满/"},{"name":"小米","slug":"小米","link":"/tags/小米/"},{"name":"淡蓝网","slug":"淡蓝网","link":"/tags/淡蓝网/"},{"name":"猿辅导","slug":"猿辅导","link":"/tags/猿辅导/"},{"name":"百川智能","slug":"百川智能","link":"/tags/百川智能/"},{"name":"百度知道","slug":"百度知道","link":"/tags/百度知道/"},{"name":"豆瓣","slug":"豆瓣","link":"/tags/豆瓣/"},{"name":"贝壳","slug":"贝壳","link":"/tags/贝壳/"},{"name":"去哪儿网","slug":"去哪儿网","link":"/tags/去哪儿网/"},{"name":"瓴岳科技","slug":"瓴岳科技","link":"/tags/瓴岳科技/"},{"name":"米可世界","slug":"米可世界","link":"/tags/米可世界/"},{"name":"百融云创","slug":"百融云创","link":"/tags/百融云创/"}],"categories":[{"name":"面试题","slug":"面试题","link":"/categories/面试题/"},{"name":"底层原理","slug":"底层原理","link":"/categories/底层原理/"}]}